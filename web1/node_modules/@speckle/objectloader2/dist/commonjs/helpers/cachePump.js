"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CachePump = void 0;
const shared_1 = require("@speckle/shared");
const batchingQueue_js_1 = __importDefault(require("./batchingQueue.js"));
class CachePump {
    #writeQueue;
    #database;
    #logger;
    #deferments;
    #gathered;
    #options;
    constructor(database, gathered, deferments, options) {
        this.#database = database;
        this.#gathered = gathered;
        this.#deferments = deferments;
        this.#options = options;
        this.#logger = options.logger || (() => { });
    }
    add(item) {
        if (!this.#writeQueue) {
            this.#writeQueue = new batchingQueue_js_1.default({
                batchSize: this.#options.maxCacheWriteSize,
                maxWaitTime: this.#options.maxCacheBatchWriteWait,
                processFunction: (batch) => this.#database.cacheSaveBatch({ batch })
            });
        }
        this.#writeQueue.add(item.baseId, item);
    }
    async disposeAsync() {
        await this.#writeQueue?.disposeAsync();
    }
    async pumpItems(params) {
        const { ids, foundItems, notFoundItems } = params;
        const maxCacheReadSize = this.#options.maxCacheReadSize;
        for (let i = 0; i < ids.length;) {
            if (this.#writeQueue?.isDisposed())
                break;
            if ((this.#writeQueue?.count() ?? 0) > this.#options.maxWriteQueueSize) {
                this.#logger('pausing reads (# in write queue: ' + this.#writeQueue?.count() + ')');
                await new Promise((resolve) => setTimeout(resolve, shared_1.TIME.second)); // Pause for 1 second, protects against out of memory
                continue;
            }
            const batch = ids.slice(i, i + maxCacheReadSize);
            const cachedData = await this.#database.getAll(batch);
            for (let i = 0; i < cachedData.length; i++) {
                if (cachedData[i]) {
                    foundItems.add(cachedData[i]);
                }
                else {
                    notFoundItems.add(batch[i]);
                }
            }
            i += maxCacheReadSize;
        }
    }
    async *gather(ids, downloader) {
        const total = ids.length;
        const pumpPromise = this.pumpItems({
            ids,
            foundItems: this.#gathered,
            notFoundItems: downloader
        });
        let count = 0;
        for await (const item of this.#gathered.consume()) {
            this.#deferments.undefer(item);
            yield item;
            count++;
            if (count >= total) {
                this.#gathered.dispose();
            }
        }
        await pumpPromise;
    }
}
exports.CachePump = CachePump;
//# sourceMappingURL=cachePump.js.map