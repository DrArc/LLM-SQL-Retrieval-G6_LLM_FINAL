"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class BatchedPool {
    #queue = [];
    #concurrencyAndSizes;
    #processFunction;
    #baseInterval;
    #processingLoop;
    #disposed = false;
    constructor(params) {
        this.#concurrencyAndSizes = params.concurrencyAndSizes;
        this.#baseInterval = Math.min(params.maxWaitTime ?? 200, 200); // Initial batch time (ms)
        this.#processFunction = params.processFunction;
        this.#processingLoop = this.#loop();
    }
    add(item) {
        this.#queue.push(item);
    }
    getBatch(batchSize) {
        return this.#queue.splice(0, Math.min(batchSize, this.#queue.length));
    }
    async #runWorker(batchSize) {
        while (!this.#disposed || this.#queue.length > 0) {
            if (this.#queue.length > 0) {
                const batch = this.getBatch(batchSize);
                await this.#processFunction(batch);
            }
            await this.#delay(this.#baseInterval);
        }
    }
    async disposeAsync() {
        this.#disposed = true;
        await this.#processingLoop;
    }
    async #loop() {
        // Initialize workers
        const workers = Array.from(this.#concurrencyAndSizes, (batchSize) => this.#runWorker(batchSize));
        await Promise.all(workers);
    }
    #delay(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
    }
}
exports.default = BatchedPool;
//# sourceMappingURL=batchedPool.js.map