"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CacheReader = void 0;
const batchingQueue_js_1 = __importDefault(require("./batchingQueue.js"));
class CacheReader {
    #database;
    #defermentManager;
    #logger;
    #options;
    #readQueue;
    constructor(database, defermentManager, options) {
        this.#database = database;
        this.#defermentManager = defermentManager;
        this.#options = options;
        this.#logger = options.logger || (() => { });
    }
    async getObject(params) {
        if (!this.#defermentManager.isDeferred(params.id)) {
            this.#getItem(params.id);
        }
        return await this.#defermentManager.defer({ id: params.id });
    }
    #getItem(id) {
        if (!this.#readQueue) {
            this.#readQueue = new batchingQueue_js_1.default({
                batchSize: this.#options.maxCacheReadSize,
                maxWaitTime: this.#options.maxCacheBatchReadWait,
                processFunction: this.#processBatch
            });
        }
        if (!this.#readQueue.get(id)) {
            this.#readQueue.add(id, id);
        }
    }
    async getAll(keys) {
        return this.#database.getAll(keys);
    }
    #processBatch = async (batch) => {
        const items = await this.#database.getAll(batch);
        for (let i = 0; i < items.length; i++) {
            if (items[i]) {
                this.#defermentManager.undefer(items[i]);
            }
            else {
                //this is okay!
                //this.#logger(`Item ${batch[i]} not found in cache`)
            }
        }
    };
    async disposeAsync() {
        await this.#readQueue?.disposeAsync();
    }
}
exports.CacheReader = CacheReader;
//# sourceMappingURL=cacheReader.js.map