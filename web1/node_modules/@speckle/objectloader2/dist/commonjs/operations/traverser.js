"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const types_js_1 = require("../types/types.js");
class Traverser {
    #loader;
    #options;
    #totalChildrenCount = 0;
    #traversedReferencesCount = 0;
    constructor(loader, options) {
        this.#options = options || {};
        this.#loader = loader;
    }
    async traverse(onProgress) {
        let firstObjectPromise = undefined;
        for await (const obj of this.#loader.getObjectIterator()) {
            if (!firstObjectPromise) {
                firstObjectPromise = this.traverseBase(obj, onProgress);
            }
        }
        if (firstObjectPromise) {
            return await firstObjectPromise;
        }
        else {
            throw new Error('No objects found');
        }
    }
    async traverseArray(array, onProgress) {
        for (let i = 0; i < 10; i++) {
            const prop = array[i];
            if ((0, types_js_1.isScalar)(prop))
                continue;
            if ((0, types_js_1.isBase)(prop)) {
                array[i] = await this.traverseBase(prop, onProgress);
            }
            else if ((0, types_js_1.isReference)(prop)) {
                array[i] = await this.traverseBase(await this.#loader.getObject({ id: prop.referencedId }), onProgress);
            }
        }
    }
    async traverseBase(base, onProgress) {
        for (const ignoredProp of this.#options.excludeProps || []) {
            delete base[ignoredProp];
        }
        if (base.__closure) {
            const ids = Object.keys(base.__closure);
            const promises = [];
            for (const id of ids) {
                promises.push(this.traverseBase(await this.#loader.getObject({ id }), onProgress));
            }
            await Promise.all(promises);
        }
        delete base['__closure'];
        // De-chunk
        if (base.speckle_type?.includes('DataChunk')) {
            const chunk = base;
            if (chunk.data) {
                await this.traverseArray(chunk.data, onProgress);
            }
        }
        //other props
        for (const prop in base) {
            if (prop === '__closure')
                continue;
            if (prop === 'referenceId')
                continue;
            if (prop === 'speckle_type')
                continue;
            if (prop === 'data')
                continue;
            const baseProp = base[prop];
            if ((0, types_js_1.isScalar)(baseProp))
                continue;
            if ((0, types_js_1.isBase)(baseProp)) {
                await this.traverseBase(baseProp, onProgress);
            }
            else if ((0, types_js_1.isReference)(baseProp)) {
                await this.traverseBase(await this.#loader.getObject({ id: baseProp.referencedId }), onProgress);
            }
            else if (Array.isArray(baseProp)) {
                await this.traverseArray(baseProp, onProgress);
            }
        }
        if (onProgress) {
            onProgress({
                stage: 'construction',
                current: ++this.#traversedReferencesCount > this.#totalChildrenCount
                    ? this.#totalChildrenCount
                    : this.#traversedReferencesCount,
                total: this.#totalChildrenCount
            });
        }
        return base;
    }
}
exports.default = Traverser;
//# sourceMappingURL=traverser.js.map