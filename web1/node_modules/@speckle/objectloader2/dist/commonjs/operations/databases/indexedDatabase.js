"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const shared_1 = require("@speckle/shared");
const dexie_1 = require("dexie");
class ObjectStore extends dexie_1.Dexie {
    static #databaseName = 'speckle-cache';
    objects; // Table type: <entity, primaryKey>
    constructor(options) {
        super(ObjectStore.#databaseName, options);
        this.version(1).stores({
            objects: 'baseId, item' // baseId is primary key
        });
    }
}
class IndexedDatabase {
    #options;
    #logger;
    #cacheDB;
    #writeQueue;
    // #count: number = 0
    constructor(options) {
        this.#options = options;
        this.#logger = options.logger || (() => { });
    }
    async getAll(keys) {
        await this.#setupCacheDb();
        let items = [];
        //   this.#count++
        //  const startTime = performance.now()
        // this.#logger('Start read ' + x + ' ' + batch.length)
        //faster than BulkGet with dexie
        await this.#cacheDB.transaction('r', this.#cacheDB.objects, async () => {
            const gets = keys.map((key) => this.#cacheDB.objects.get(key));
            const cachedData = await Promise.all(gets);
            items = cachedData;
        });
        // const endTime = performance.now()
        // const duration = endTime - startTime
        //this.#logger('Saved batch ' + x + ' ' + batch.length + ' ' + duration / TIME_MS.second)
        return items;
    }
    async #openDatabase() {
        const db = new ObjectStore({
            indexedDB: this.#options.indexedDB ?? globalThis.indexedDB,
            IDBKeyRange: this.#options.keyRange ?? IDBKeyRange,
            chromeTransactionDurability: 'relaxed'
        });
        await db.open();
        return db;
    }
    async #setupCacheDb() {
        if (this.#cacheDB !== undefined) {
            return;
        }
        // Initialize
        await this.#safariFix();
        this.#cacheDB = await this.#openDatabase();
    }
    //this is for testing only - in the real world we will not use this
    async add(item) {
        await this.#setupCacheDb();
        await this.#cacheDB.transaction('rw', this.#cacheDB.objects, async () => {
            return await this.#cacheDB?.objects.add(item);
        });
    }
    async getItem(params) {
        const { id } = params;
        await this.#setupCacheDb();
        //might not be in the real DB yet, so check the write queue first
        if (this.#writeQueue) {
            const item = this.#writeQueue.get(id);
            if (item) {
                return item;
            }
        }
        return this.#cacheDB.transaction('r', this.#cacheDB.objects, async () => {
            return await this.#cacheDB?.objects.get(id);
        });
    }
    async cacheSaveBatch(params) {
        await this.#setupCacheDb();
        const { batch } = params;
        //const x = this.#count
        //this.#count++
        // const startTime = performance.now()
        //  this.#logger('Start save ' + x + ' ' + batch.length)
        await this.#cacheDB.objects.bulkPut(batch);
        // const endTime = performance.now()
        // const duration = endTime - startTime
        //this.#logger('Saved batch ' + x + ' ' + batch.length + ' ' + duration / TIME_MS.second)
    }
    /**
     * Fixes a Safari bug where IndexedDB requests get lost and never resolve - invoke before you use IndexedDB
     * @link Credits and more info: https://github.com/jakearchibald/safari-14-idb-fix
     */
    async #safariFix() {
        // No point putting other browsers or older versions of Safari through this mess.
        if (!(0, shared_1.isSafari)() || !this.#options.indexedDB?.databases)
            return Promise.resolve();
        let intervalId;
        return new Promise((resolve) => {
            const tryIdb = () => this.#options.indexedDB?.databases().finally(resolve);
            intervalId = setInterval(() => {
                void tryIdb();
            }, 100);
            void tryIdb();
        }).finally(() => clearInterval(intervalId));
    }
    async disposeAsync() {
        this.#cacheDB?.close();
        this.#cacheDB = undefined;
        await this.#writeQueue?.disposeAsync();
        this.#writeQueue = undefined;
    }
}
exports.default = IndexedDatabase;
//# sourceMappingURL=indexedDatabase.js.map