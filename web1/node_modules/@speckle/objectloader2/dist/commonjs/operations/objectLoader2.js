"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ObjectLoader2 = void 0;
const asyncGeneratorQueue_js_1 = __importDefault(require("../helpers/asyncGeneratorQueue.js"));
const defermentManager_js_1 = require("../helpers/defermentManager.js");
const cacheReader_js_1 = require("../helpers/cacheReader.js");
const cachePump_js_1 = require("../helpers/cachePump.js");
const aggregateQueue_js_1 = __importDefault(require("../helpers/aggregateQueue.js"));
const objectLoader2Factory_js_1 = require("./objectLoader2Factory.js");
class ObjectLoader2 {
    #rootId;
    #logger;
    #database;
    #downloader;
    #pump;
    #cache;
    #deferments;
    #gathered;
    #root = undefined;
    constructor(options) {
        this.#rootId = options.rootId;
        this.#logger = options.logger || console.log;
        const cacheOptions = {
            logger: this.#logger,
            maxCacheReadSize: 10_000,
            maxCacheWriteSize: 10_000,
            maxWriteQueueSize: 40_000,
            maxCacheBatchWriteWait: 3_000,
            maxCacheBatchReadWait: 3_000
        };
        this.#gathered = new asyncGeneratorQueue_js_1.default();
        this.#database = options.database;
        this.#deferments = new defermentManager_js_1.DefermentManager({
            maxSizeInMb: 2_000, // 2 GBs
            ttlms: 5_000, // 5 seconds
            logger: this.#logger
        });
        this.#cache = new cacheReader_js_1.CacheReader(this.#database, this.#deferments, cacheOptions);
        this.#pump = new cachePump_js_1.CachePump(this.#database, this.#gathered, this.#deferments, cacheOptions);
        this.#downloader = options.downloader;
    }
    async disposeAsync() {
        await Promise.all([this.#downloader.disposeAsync(), this.#cache.disposeAsync()]);
        this.#deferments.dispose();
    }
    async getRootObject() {
        if (!this.#root) {
            this.#root = await this.#database.getItem({ id: this.#rootId });
            if (!this.#root) {
                this.#root = await this.#downloader.downloadSingle();
            }
        }
        return this.#root;
    }
    async getObject(params) {
        return await this.#cache.getObject({ id: params.id });
    }
    async getTotalObjectCount() {
        const rootObj = await this.getRootObject();
        const totalChildrenCount = Object.keys(rootObj?.base.__closure || {}).length;
        return totalChildrenCount + 1; //count the root
    }
    async *getObjectIterator() {
        const rootItem = await this.getRootObject();
        if (rootItem === undefined) {
            this.#logger('No root object found!');
            return;
        }
        //only for root
        this.#pump.add(rootItem);
        yield rootItem.base;
        if (!rootItem.base.__closure)
            return;
        const children = Object.keys(rootItem.base.__closure);
        const total = children.length;
        this.#downloader.initializePool({
            results: new aggregateQueue_js_1.default(this.#gathered, this.#pump),
            total
        });
        for await (const item of this.#pump.gather(children, this.#downloader)) {
            yield item.base;
        }
    }
    static createFromObjects(objects) {
        return objectLoader2Factory_js_1.ObjectLoader2Factory.createFromObjects(objects);
    }
    static createFromJSON(json) {
        return objectLoader2Factory_js_1.ObjectLoader2Factory.createFromJSON(json);
    }
}
exports.ObjectLoader2 = ObjectLoader2;
//# sourceMappingURL=objectLoader2.js.map