var QA=Object.defineProperty;var X0=s=>{throw TypeError(s)};var XA=(s,e,t)=>e in s?QA(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t;var JA=(s,e)=>()=>(e||s((e={exports:{}}).exports,e),e.exports);var Mn=(s,e,t)=>XA(s,typeof e!="symbol"?e+"":e,t),om=(s,e,t)=>e.has(s)||X0("Cannot "+t);var Ge=(s,e,t)=>(om(s,e,"read from private field"),t?t.call(s):e.get(s)),Lt=(s,e,t)=>e.has(s)?X0("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(s):e.set(s,t),Ut=(s,e,t,n)=>(om(s,e,"write to private field"),n?n.call(s,t):e.set(s,t),t),ri=(s,e,t)=>(om(s,e,"access private method"),t);var Bz=JA((Ws,qs)=>{(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))n(i);new MutationObserver(i=>{for(const r of i)if(r.type==="childList")for(const a of r.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&n(a)}).observe(document,{childList:!0,subtree:!0});function t(i){const r={};return i.integrity&&(r.integrity=i.integrity),i.referrerPolicy&&(r.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?r.credentials="include":i.crossOrigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function n(i){if(i.ep)return;i.ep=!0;const r=t(i);fetch(i.href,r)}})();/**
 * @license
 * Copyright 2010-2022 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const Cv="140",KA=0,J0=1,YA=2,AS=1,ZA=2,_l=3,gr=0,er=1,Qt=2,TS=1,ui=0,Jl=1,K0=2,Y0=3,Z0=4,Cp=5,rs=100,$A=101,ES=102,$0=103,Fg=104,Cf=200,Ao=201,eT=202,tT=203,MS=204,CS=205,Rv=206,nT=207,RS=208,iT=209,rT=210,sT=0,aT=1,oT=2,Ug=3,lT=4,cT=5,uT=6,hT=7,Rp=0,dT=1,fT=2,js=0,pT=1,mT=2,gT=3,IS=4,vT=5,PS=300,mc=301,gc=302,kg=303,_g=304,Ip=306,Ho=1e3,fr=1001,Vg=1002,wn=1003,ey=1004,ty=1005,cn=1006,yT=1007,wh=1008,Js=1009,DS=1010,LS=1011,vc=1012,BS=1013,gu=1014,Oi=1015,Zi=1016,OS=1017,NS=1018,Fo=1020,zS=1021,FS=1022,qi=1023,US=1024,kS=1025,za=1026,Wo=1027,Iv=1028,_S=1029,VS=1030,GS=1031,HS=1033,Kl=33776,Yl=33777,Zl=33778,$l=33779,Rf=35840,If=35841,Pf=35842,Df=35843,WS=36196,Lf=37492,Bf=37496,Of=37808,Nf=37809,zf=37810,Ff=37811,Uf=37812,kf=37813,_f=37814,Vf=37815,Gf=37816,Hf=37817,Wf=37818,qf=37819,jf=37820,Qf=37821,Xf=36492,xT=2200,wT=2201,ST=2202,Jf=2300,Kf=2301,lm=2302,Vl=2400,Gl=2401,Yf=2402,Pv=2500,qS=2501,bT=0,Ir=3e3,Wt=3001,jS=3200,Ko=3201,Cc=0,AT=1,Us="srgb",To="srgb-linear",cm=7680,ec=7681,TT=514,Dv=519,Pu=35044,Pr=35048,ny="300 es",Zf=1035;class Yo{addEventListener(e,t){this._listeners===void 0&&(this._listeners={});const n=this._listeners;n[e]===void 0&&(n[e]=[]),n[e].indexOf(t)===-1&&n[e].push(t)}hasEventListener(e,t){if(this._listeners===void 0)return!1;const n=this._listeners;return n[e]!==void 0&&n[e].indexOf(t)!==-1}removeEventListener(e,t){if(this._listeners===void 0)return;const i=this._listeners[e];if(i!==void 0){const r=i.indexOf(t);r!==-1&&i.splice(r,1)}}dispatchEvent(e){if(this._listeners===void 0)return;const n=this._listeners[e.type];if(n!==void 0){e.target=this;const i=n.slice(0);for(let r=0,a=i.length;r<a;r++)i[r].call(this,e);e.target=null}}}const Ri=[];for(let s=0;s<256;s++)Ri[s]=(s<16?"0":"")+s.toString(16);let iy=1234567;const vu=Math.PI/180,Du=180/Math.PI;function Qr(){const s=Math.random()*4294967295|0,e=Math.random()*4294967295|0,t=Math.random()*4294967295|0,n=Math.random()*4294967295|0;return(Ri[s&255]+Ri[s>>8&255]+Ri[s>>16&255]+Ri[s>>24&255]+"-"+Ri[e&255]+Ri[e>>8&255]+"-"+Ri[e>>16&15|64]+Ri[e>>24&255]+"-"+Ri[t&63|128]+Ri[t>>8&255]+"-"+Ri[t>>16&255]+Ri[t>>24&255]+Ri[n&255]+Ri[n>>8&255]+Ri[n>>16&255]+Ri[n>>24&255]).toLowerCase()}function oi(s,e,t){return Math.max(e,Math.min(t,s))}function Lv(s,e){return(s%e+e)%e}function ET(s,e,t,n,i){return n+(s-e)*(i-n)/(t-e)}function MT(s,e,t){return s!==e?(t-s)/(e-s):0}function yu(s,e,t){return(1-t)*s+t*e}function CT(s,e,t,n){return yu(s,e,1-Math.exp(-t*n))}function RT(s,e=1){return e-Math.abs(Lv(s,e*2)-e)}function IT(s,e,t){return s<=e?0:s>=t?1:(s=(s-e)/(t-e),s*s*(3-2*s))}function PT(s,e,t){return s<=e?0:s>=t?1:(s=(s-e)/(t-e),s*s*s*(s*(s*6-15)+10))}function DT(s,e){return s+Math.floor(Math.random()*(e-s+1))}function LT(s,e){return s+Math.random()*(e-s)}function BT(s){return s*(.5-Math.random())}function OT(s){s!==void 0&&(iy=s);let e=iy+=1831565813;return e=Math.imul(e^e>>>15,e|1),e^=e+Math.imul(e^e>>>7,e|61),((e^e>>>14)>>>0)/4294967296}function NT(s){return s*vu}function zT(s){return s*Du}function Gg(s){return(s&s-1)===0&&s!==0}function FT(s){return Math.pow(2,Math.ceil(Math.log(s)/Math.LN2))}function $f(s){return Math.pow(2,Math.floor(Math.log(s)/Math.LN2))}function UT(s,e,t,n,i){const r=Math.cos,a=Math.sin,o=r(t/2),l=a(t/2),c=r((e+n)/2),u=a((e+n)/2),h=r((e-n)/2),d=a((e-n)/2),f=r((n-e)/2),v=a((n-e)/2);switch(i){case"XYX":s.set(o*u,l*h,l*d,o*c);break;case"YZY":s.set(l*d,o*u,l*h,o*c);break;case"ZXZ":s.set(l*h,l*d,o*u,o*c);break;case"XZX":s.set(o*u,l*v,l*f,o*c);break;case"YXY":s.set(l*f,o*u,l*v,o*c);break;case"ZYZ":s.set(l*v,l*f,o*u,o*c);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+i)}}function kT(s,e){switch(e.constructor){case Float32Array:return s;case Uint16Array:return s/65535;case Uint8Array:return s/255;case Int16Array:return Math.max(s/32767,-1);case Int8Array:return Math.max(s/127,-1);default:throw new Error("Invalid component type.")}}function _T(s,e){switch(e.constructor){case Float32Array:return s;case Uint16Array:return Math.round(s*65535);case Uint8Array:return Math.round(s*255);case Int16Array:return Math.round(s*32767);case Int8Array:return Math.round(s*127);default:throw new Error("Invalid component type.")}}var ci=Object.freeze({__proto__:null,DEG2RAD:vu,RAD2DEG:Du,generateUUID:Qr,clamp:oi,euclideanModulo:Lv,mapLinear:ET,inverseLerp:MT,lerp:yu,damp:CT,pingpong:RT,smoothstep:IT,smootherstep:PT,randInt:DT,randFloat:LT,randFloatSpread:BT,seededRandom:OT,degToRad:NT,radToDeg:zT,isPowerOfTwo:Gg,ceilPowerOfTwo:FT,floorPowerOfTwo:$f,setQuaternionFromProperEuler:UT,normalize:_T,denormalize:kT});class Me{constructor(e=0,t=0){this.x=e,this.y=t}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,t){return this.x=e,this.y=t,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this)}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this)}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const t=this.x,n=this.y,i=e.elements;return this.x=i[0]*t+i[3]*n+i[6],this.y=i[1]*t+i[4]*n+i[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,n=this.y-e.y;return t*t+n*n}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e}fromBufferAttribute(e,t,n){return n!==void 0&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this}rotateAround(e,t){const n=Math.cos(t),i=Math.sin(t),r=this.x-e.x,a=this.y-e.y;return this.x=r*n-a*i+e.x,this.y=r*i+a*n+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}Me.prototype.isVector2=!0;class Hn{constructor(){this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(e,t,n,i,r,a,o,l,c){const u=this.elements;return u[0]=e,u[1]=i,u[2]=o,u[3]=t,u[4]=r,u[5]=l,u[6]=n,u[7]=a,u[8]=c,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(e){const t=this.elements,n=e.elements;return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],this}extractBasis(e,t,n){return e.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const n=e.elements,i=t.elements,r=this.elements,a=n[0],o=n[3],l=n[6],c=n[1],u=n[4],h=n[7],d=n[2],f=n[5],v=n[8],g=i[0],m=i[3],x=i[6],w=i[1],S=i[4],b=i[7],E=i[2],C=i[5],P=i[8];return r[0]=a*g+o*w+l*E,r[3]=a*m+o*S+l*C,r[6]=a*x+o*b+l*P,r[1]=c*g+u*w+h*E,r[4]=c*m+u*S+h*C,r[7]=c*x+u*b+h*P,r[2]=d*g+f*w+v*E,r[5]=d*m+f*S+v*C,r[8]=d*x+f*b+v*P,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=e,t[4]*=e,t[7]*=e,t[2]*=e,t[5]*=e,t[8]*=e,this}determinant(){const e=this.elements,t=e[0],n=e[1],i=e[2],r=e[3],a=e[4],o=e[5],l=e[6],c=e[7],u=e[8];return t*a*u-t*o*c-n*r*u+n*o*l+i*r*c-i*a*l}invert(){const e=this.elements,t=e[0],n=e[1],i=e[2],r=e[3],a=e[4],o=e[5],l=e[6],c=e[7],u=e[8],h=u*a-o*c,d=o*l-u*r,f=c*r-a*l,v=t*h+n*d+i*f;if(v===0)return this.set(0,0,0,0,0,0,0,0,0);const g=1/v;return e[0]=h*g,e[1]=(i*c-u*n)*g,e[2]=(o*n-i*a)*g,e[3]=d*g,e[4]=(u*t-i*l)*g,e[5]=(i*r-o*t)*g,e[6]=f*g,e[7]=(n*l-c*t)*g,e[8]=(a*t-n*r)*g,this}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).invert().transpose()}transposeIntoArray(e){const t=this.elements;return e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8],this}setUvTransform(e,t,n,i,r,a,o){const l=Math.cos(r),c=Math.sin(r);return this.set(n*l,n*c,-n*(l*a+c*o)+a+e,-i*c,i*l,-i*(-c*a+l*o)+o+t,0,0,1),this}scale(e,t){const n=this.elements;return n[0]*=e,n[3]*=e,n[6]*=e,n[1]*=t,n[4]*=t,n[7]*=t,this}rotate(e){const t=Math.cos(e),n=Math.sin(e),i=this.elements,r=i[0],a=i[3],o=i[6],l=i[1],c=i[4],u=i[7];return i[0]=t*r+n*l,i[3]=t*a+n*c,i[6]=t*o+n*u,i[1]=-n*r+t*l,i[4]=-n*a+t*c,i[7]=-n*o+t*u,this}translate(e,t){const n=this.elements;return n[0]+=e*n[2],n[3]+=e*n[5],n[6]+=e*n[8],n[1]+=t*n[2],n[4]+=t*n[5],n[7]+=t*n[8],this}equals(e){const t=this.elements,n=e.elements;for(let i=0;i<9;i++)if(t[i]!==n[i])return!1;return!0}fromArray(e,t=0){for(let n=0;n<9;n++)this.elements[n]=e[n+t];return this}toArray(e=[],t=0){const n=this.elements;return e[t]=n[0],e[t+1]=n[1],e[t+2]=n[2],e[t+3]=n[3],e[t+4]=n[4],e[t+5]=n[5],e[t+6]=n[6],e[t+7]=n[7],e[t+8]=n[8],e}clone(){return new this.constructor().fromArray(this.elements)}}Hn.prototype.isMatrix3=!0;function QS(s){for(let e=s.length-1;e>=0;--e)if(s[e]>65535)return!0;return!1}function Lu(s){return document.createElementNS("http://www.w3.org/1999/xhtml",s)}function Uo(s){return s<.04045?s*.0773993808:Math.pow(s*.9478672986+.0521327014,2.4)}function gf(s){return s<.0031308?s*12.92:1.055*Math.pow(s,.41666)-.055}const um={[Us]:{[To]:Uo},[To]:{[Us]:gf}},Nr={legacyMode:!0,get workingColorSpace(){return To},set workingColorSpace(s){console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")},convert:function(s,e,t){if(this.legacyMode||e===t||!e||!t)return s;if(um[e]&&um[e][t]!==void 0){const n=um[e][t];return s.r=n(s.r),s.g=n(s.g),s.b=n(s.b),s}throw new Error("Unsupported color space conversion.")},fromWorkingColorSpace:function(s,e){return this.convert(s,this.workingColorSpace,e)},toWorkingColorSpace:function(s,e){return this.convert(s,e,this.workingColorSpace)}},XS={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},pi={r:0,g:0,b:0},zr={h:0,s:0,l:0},Kh={h:0,s:0,l:0};function hm(s,e,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?s+(e-s)*6*t:t<1/2?e:t<2/3?s+(e-s)*6*(2/3-t):s}function Yh(s,e){return e.r=s.r,e.g=s.g,e.b=s.b,e}class ot{constructor(e,t,n){return t===void 0&&n===void 0?this.set(e):this.setRGB(e,t,n)}set(e){return e&&e.isColor?this.copy(e):typeof e=="number"?this.setHex(e):typeof e=="string"&&this.setStyle(e),this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e,t=Us){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(e&255)/255,Nr.toWorkingColorSpace(this,t),this}setRGB(e,t,n,i=To){return this.r=e,this.g=t,this.b=n,Nr.toWorkingColorSpace(this,i),this}setHSL(e,t,n,i=To){if(e=Lv(e,1),t=oi(t,0,1),n=oi(n,0,1),t===0)this.r=this.g=this.b=n;else{const r=n<=.5?n*(1+t):n+t-n*t,a=2*n-r;this.r=hm(a,r,e+1/3),this.g=hm(a,r,e),this.b=hm(a,r,e-1/3)}return Nr.toWorkingColorSpace(this,i),this}setStyle(e,t=Us){function n(r){r!==void 0&&parseFloat(r)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let i;if(i=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)){let r;const a=i[1],o=i[2];switch(a){case"rgb":case"rgba":if(r=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return this.r=Math.min(255,parseInt(r[1],10))/255,this.g=Math.min(255,parseInt(r[2],10))/255,this.b=Math.min(255,parseInt(r[3],10))/255,Nr.toWorkingColorSpace(this,t),n(r[4]),this;if(r=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return this.r=Math.min(100,parseInt(r[1],10))/100,this.g=Math.min(100,parseInt(r[2],10))/100,this.b=Math.min(100,parseInt(r[3],10))/100,Nr.toWorkingColorSpace(this,t),n(r[4]),this;break;case"hsl":case"hsla":if(r=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)){const l=parseFloat(r[1])/360,c=parseInt(r[2],10)/100,u=parseInt(r[3],10)/100;return n(r[4]),this.setHSL(l,c,u,t)}break}}else if(i=/^\#([A-Fa-f\d]+)$/.exec(e)){const r=i[1],a=r.length;if(a===3)return this.r=parseInt(r.charAt(0)+r.charAt(0),16)/255,this.g=parseInt(r.charAt(1)+r.charAt(1),16)/255,this.b=parseInt(r.charAt(2)+r.charAt(2),16)/255,Nr.toWorkingColorSpace(this,t),this;if(a===6)return this.r=parseInt(r.charAt(0)+r.charAt(1),16)/255,this.g=parseInt(r.charAt(2)+r.charAt(3),16)/255,this.b=parseInt(r.charAt(4)+r.charAt(5),16)/255,Nr.toWorkingColorSpace(this,t),this}return e&&e.length>0?this.setColorName(e,t):this}setColorName(e,t=Us){const n=XS[e.toLowerCase()];return n!==void 0?this.setHex(n,t):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copySRGBToLinear(e){return this.r=Uo(e.r),this.g=Uo(e.g),this.b=Uo(e.b),this}copyLinearToSRGB(e){return this.r=gf(e.r),this.g=gf(e.g),this.b=gf(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(e=Us){return Nr.fromWorkingColorSpace(Yh(this,pi),e),oi(pi.r*255,0,255)<<16^oi(pi.g*255,0,255)<<8^oi(pi.b*255,0,255)<<0}getHexString(e=Us){return("000000"+this.getHex(e).toString(16)).slice(-6)}getHSL(e,t=To){Nr.fromWorkingColorSpace(Yh(this,pi),t);const n=pi.r,i=pi.g,r=pi.b,a=Math.max(n,i,r),o=Math.min(n,i,r);let l,c;const u=(o+a)/2;if(o===a)l=0,c=0;else{const h=a-o;switch(c=u<=.5?h/(a+o):h/(2-a-o),a){case n:l=(i-r)/h+(i<r?6:0);break;case i:l=(r-n)/h+2;break;case r:l=(n-i)/h+4;break}l/=6}return e.h=l,e.s=c,e.l=u,e}getRGB(e,t=To){return Nr.fromWorkingColorSpace(Yh(this,pi),t),e.r=pi.r,e.g=pi.g,e.b=pi.b,e}getStyle(e=Us){return Nr.fromWorkingColorSpace(Yh(this,pi),e),e!==Us?`color(${e} ${pi.r} ${pi.g} ${pi.b})`:`rgb(${pi.r*255|0},${pi.g*255|0},${pi.b*255|0})`}offsetHSL(e,t,n){return this.getHSL(zr),zr.h+=e,zr.s+=t,zr.l+=n,this.setHSL(zr.h,zr.s,zr.l),this}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this}lerpColors(e,t,n){return this.r=e.r+(t.r-e.r)*n,this.g=e.g+(t.g-e.g)*n,this.b=e.b+(t.b-e.b)*n,this}lerpHSL(e,t){this.getHSL(zr),e.getHSL(Kh);const n=yu(zr.h,Kh.h,t),i=yu(zr.s,Kh.s,t),r=yu(zr.l,Kh.l,t);return this.setHSL(n,i,r),this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,t=0){return this.r=e[t],this.g=e[t+1],this.b=e[t+2],this}toArray(e=[],t=0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e}fromBufferAttribute(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),e.normalized===!0&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}ot.NAMES=XS;ot.prototype.isColor=!0;ot.prototype.r=1;ot.prototype.g=1;ot.prototype.b=1;let cl;class Zo{static getDataURL(e){if(/^data:/i.test(e.src)||typeof HTMLCanvasElement>"u")return e.src;let t;if(e instanceof HTMLCanvasElement)t=e;else{cl===void 0&&(cl=Lu("canvas")),cl.width=e.width,cl.height=e.height;const n=cl.getContext("2d");e instanceof ImageData?n.putImageData(e,0,0):n.drawImage(e,0,0,e.width,e.height),t=cl}return t.width>2048||t.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",e),t.toDataURL("image/jpeg",.6)):t.toDataURL("image/png")}static sRGBToLinear(e){if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&e instanceof ImageBitmap){const t=Lu("canvas");t.width=e.width,t.height=e.height;const n=t.getContext("2d");n.drawImage(e,0,0,e.width,e.height);const i=n.getImageData(0,0,e.width,e.height),r=i.data;for(let a=0;a<r.length;a++)r[a]=Uo(r[a]/255)*255;return n.putImageData(i,0,0),t}else if(e.data){const t=e.data.slice(0);for(let n=0;n<t.length;n++)t instanceof Uint8Array||t instanceof Uint8ClampedArray?t[n]=Math.floor(Uo(t[n]/255)*255):t[n]=Uo(t[n]);return{data:t,width:e.width,height:e.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),e}}class Bv{constructor(e=null){this.uuid=Qr(),this.data=e,this.version=0}set needsUpdate(e){e===!0&&this.version++}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.images[this.uuid]!==void 0)return e.images[this.uuid];const n={uuid:this.uuid,url:""},i=this.data;if(i!==null){let r;if(Array.isArray(i)){r=[];for(let a=0,o=i.length;a<o;a++)i[a].isDataTexture?r.push(dm(i[a].image)):r.push(dm(i[a]))}else r=dm(i);n.url=r}return t||(e.images[this.uuid]=n),n}}function dm(s){return typeof HTMLImageElement<"u"&&s instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&s instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&s instanceof ImageBitmap?Zo.getDataURL(s):s.data?{data:Array.prototype.slice.call(s.data),width:s.width,height:s.height,type:s.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}Bv.prototype.isSource=!0;let VT=0;class hi extends Yo{constructor(e=hi.DEFAULT_IMAGE,t=hi.DEFAULT_MAPPING,n=fr,i=fr,r=cn,a=wh,o=qi,l=Js,c=1,u=Ir){super(),Object.defineProperty(this,"id",{value:VT++}),this.uuid=Qr(),this.name="",this.source=new Bv(e),this.mipmaps=[],this.mapping=t,this.wrapS=n,this.wrapT=i,this.magFilter=r,this.minFilter=a,this.anisotropy=c,this.format=o,this.internalFormat=null,this.type=l,this.offset=new Me(0,0),this.repeat=new Me(1,1),this.center=new Me(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new Hn,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=u,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.needsPMREMUpdate=!1}get image(){return this.source.data}set image(e){this.source.data=e}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(e){return this.name=e.name,this.source=e.source,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.encoding=e.encoding,this.userData=JSON.parse(JSON.stringify(e.userData)),this.needsUpdate=!0,this}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.textures[this.uuid]!==void 0)return e.textures[this.uuid];const n={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(e).uuid,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return JSON.stringify(this.userData)!=="{}"&&(n.userData=this.userData),t||(e.textures[this.uuid]=n),n}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(e){if(this.mapping!==PS)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case Ho:e.x=e.x-Math.floor(e.x);break;case fr:e.x=e.x<0?0:1;break;case Vg:Math.abs(Math.floor(e.x)%2)===1?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x);break}if(e.y<0||e.y>1)switch(this.wrapT){case Ho:e.y=e.y-Math.floor(e.y);break;case fr:e.y=e.y<0?0:1;break;case Vg:Math.abs(Math.floor(e.y)%2)===1?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y);break}return this.flipY&&(e.y=1-e.y),e}set needsUpdate(e){e===!0&&(this.version++,this.source.needsUpdate=!0)}}hi.DEFAULT_IMAGE=null;hi.DEFAULT_MAPPING=PS;hi.prototype.isTexture=!0;class Ft{constructor(e=0,t=0,n=0,i=1){this.x=e,this.y=t,this.z=n,this.w=i}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,t,n,i){return this.x=e,this.y=t,this.z=n,this.w=i,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w!==void 0?e.w:1,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this)}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this.w=e.w+t.w,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this.w+=e.w*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this)}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this.w=e.w-t.w,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){const t=this.x,n=this.y,i=this.z,r=this.w,a=e.elements;return this.x=a[0]*t+a[4]*n+a[8]*i+a[12]*r,this.y=a[1]*t+a[5]*n+a[9]*i+a[13]*r,this.z=a[2]*t+a[6]*n+a[10]*i+a[14]*r,this.w=a[3]*t+a[7]*n+a[11]*i+a[15]*r,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);const t=Math.sqrt(1-e.w*e.w);return t<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/t,this.y=e.y/t,this.z=e.z/t),this}setAxisAngleFromRotationMatrix(e){let t,n,i,r;const l=e.elements,c=l[0],u=l[4],h=l[8],d=l[1],f=l[5],v=l[9],g=l[2],m=l[6],x=l[10];if(Math.abs(u-d)<.01&&Math.abs(h-g)<.01&&Math.abs(v-m)<.01){if(Math.abs(u+d)<.1&&Math.abs(h+g)<.1&&Math.abs(v+m)<.1&&Math.abs(c+f+x-3)<.1)return this.set(1,0,0,0),this;t=Math.PI;const S=(c+1)/2,b=(f+1)/2,E=(x+1)/2,C=(u+d)/4,P=(h+g)/4,M=(v+m)/4;return S>b&&S>E?S<.01?(n=0,i=.707106781,r=.707106781):(n=Math.sqrt(S),i=C/n,r=P/n):b>E?b<.01?(n=.707106781,i=0,r=.707106781):(i=Math.sqrt(b),n=C/i,r=M/i):E<.01?(n=.707106781,i=.707106781,r=0):(r=Math.sqrt(E),n=P/r,i=M/r),this.set(n,i,r,t),this}let w=Math.sqrt((m-v)*(m-v)+(h-g)*(h-g)+(d-u)*(d-u));return Math.abs(w)<.001&&(w=1),this.x=(m-v)/w,this.y=(h-g)/w,this.z=(d-u)/w,this.w=Math.acos((c+f+x-1)/2),this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this.w=Math.max(e.w,Math.min(t.w,this.w)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this.w=Math.max(e,Math.min(t,this.w)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this.w+=(e.w-this.w)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this.z=e.z+(t.z-e.z)*n,this.w=e.w+(t.w-e.w)*n,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this.w=e[t+3],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e[t+3]=this.w,e}fromBufferAttribute(e,t,n){return n!==void 0&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this.w=e.getW(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}Ft.prototype.isVector4=!0;class Yn extends Yo{constructor(e,t,n={}){super(),this.width=e,this.height=t,this.depth=1,this.scissor=new Ft(0,0,e,t),this.scissorTest=!1,this.viewport=new Ft(0,0,e,t);const i={width:e,height:t,depth:1};this.texture=new hi(i,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),this.texture.isRenderTargetTexture=!0,this.texture.flipY=!1,this.texture.generateMipmaps=n.generateMipmaps!==void 0?n.generateMipmaps:!1,this.texture.internalFormat=n.internalFormat!==void 0?n.internalFormat:null,this.texture.minFilter=n.minFilter!==void 0?n.minFilter:cn,this.depthBuffer=n.depthBuffer!==void 0?n.depthBuffer:!0,this.stencilBuffer=n.stencilBuffer!==void 0?n.stencilBuffer:!1,this.depthTexture=n.depthTexture!==void 0?n.depthTexture:null,this.samples=n.samples!==void 0?n.samples:0}setSize(e,t,n=1){(this.width!==e||this.height!==t||this.depth!==n)&&(this.width=e,this.height=t,this.depth=n,this.texture.image.width=e,this.texture.image.height=t,this.texture.image.depth=n,this.dispose()),this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)}clone(){return new this.constructor().copy(this)}copy(e){this.width=e.width,this.height=e.height,this.depth=e.depth,this.viewport.copy(e.viewport),this.texture=e.texture.clone(),this.texture.isRenderTargetTexture=!0;const t=Object.assign({},e.texture.image);return this.texture.source=new Bv(t),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,e.depthTexture!==null&&(this.depthTexture=e.depthTexture.clone()),this.samples=e.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}Yn.prototype.isWebGLRenderTarget=!0;class Pp extends hi{constructor(e=null,t=1,n=1,i=1){super(null),this.image={data:e,width:t,height:n,depth:i},this.magFilter=wn,this.minFilter=wn,this.wrapR=fr,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}Pp.prototype.isDataArrayTexture=!0;class GT extends Yn{constructor(e,t,n){super(e,t),this.depth=n,this.texture=new Pp(null,e,t,n),this.texture.isRenderTargetTexture=!0}}GT.prototype.isWebGLArrayRenderTarget=!0;class Ov extends hi{constructor(e=null,t=1,n=1,i=1){super(null),this.image={data:e,width:t,height:n,depth:i},this.magFilter=wn,this.minFilter=wn,this.wrapR=fr,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}Ov.prototype.isData3DTexture=!0;class HT extends Yn{constructor(e,t,n){super(e,t),this.depth=n,this.texture=new Ov(null,e,t,n),this.texture.isRenderTargetTexture=!0}}HT.prototype.isWebGL3DRenderTarget=!0;class Nv extends Yn{constructor(e,t,n,i={}){super(e,t,i);const r=this.texture;this.texture=[];for(let a=0;a<n;a++)this.texture[a]=r.clone(),this.texture[a].isRenderTargetTexture=!0}setSize(e,t,n=1){if(this.width!==e||this.height!==t||this.depth!==n){this.width=e,this.height=t,this.depth=n;for(let i=0,r=this.texture.length;i<r;i++)this.texture[i].image.width=e,this.texture[i].image.height=t,this.texture[i].image.depth=n;this.dispose()}return this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t),this}copy(e){this.dispose(),this.width=e.width,this.height=e.height,this.depth=e.depth,this.viewport.set(0,0,this.width,this.height),this.scissor.set(0,0,this.width,this.height),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,e.depthTexture!==null&&(this.depthTexture=e.depthTexture.clone()),this.texture.length=0;for(let t=0,n=e.texture.length;t<n;t++)this.texture[t]=e.texture[t].clone(),this.texture[t].isRenderTargetTexture=!0;return this}}Nv.prototype.isWebGLMultipleRenderTargets=!0;class An{constructor(e=0,t=0,n=0,i=1){this._x=e,this._y=t,this._z=n,this._w=i}static slerp(e,t,n,i){return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),n.slerpQuaternions(e,t,i)}static slerpFlat(e,t,n,i,r,a,o){let l=n[i+0],c=n[i+1],u=n[i+2],h=n[i+3];const d=r[a+0],f=r[a+1],v=r[a+2],g=r[a+3];if(o===0){e[t+0]=l,e[t+1]=c,e[t+2]=u,e[t+3]=h;return}if(o===1){e[t+0]=d,e[t+1]=f,e[t+2]=v,e[t+3]=g;return}if(h!==g||l!==d||c!==f||u!==v){let m=1-o;const x=l*d+c*f+u*v+h*g,w=x>=0?1:-1,S=1-x*x;if(S>Number.EPSILON){const E=Math.sqrt(S),C=Math.atan2(E,x*w);m=Math.sin(m*C)/E,o=Math.sin(o*C)/E}const b=o*w;if(l=l*m+d*b,c=c*m+f*b,u=u*m+v*b,h=h*m+g*b,m===1-o){const E=1/Math.sqrt(l*l+c*c+u*u+h*h);l*=E,c*=E,u*=E,h*=E}}e[t]=l,e[t+1]=c,e[t+2]=u,e[t+3]=h}static multiplyQuaternionsFlat(e,t,n,i,r,a){const o=n[i],l=n[i+1],c=n[i+2],u=n[i+3],h=r[a],d=r[a+1],f=r[a+2],v=r[a+3];return e[t]=o*v+u*h+l*f-c*d,e[t+1]=l*v+u*d+c*h-o*f,e[t+2]=c*v+u*f+o*d-l*h,e[t+3]=u*v-o*h-l*d-c*f,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,t,n,i){return this._x=e,this._y=t,this._z=n,this._w=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,t){if(!(e&&e.isEuler))throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const n=e._x,i=e._y,r=e._z,a=e._order,o=Math.cos,l=Math.sin,c=o(n/2),u=o(i/2),h=o(r/2),d=l(n/2),f=l(i/2),v=l(r/2);switch(a){case"XYZ":this._x=d*u*h+c*f*v,this._y=c*f*h-d*u*v,this._z=c*u*v+d*f*h,this._w=c*u*h-d*f*v;break;case"YXZ":this._x=d*u*h+c*f*v,this._y=c*f*h-d*u*v,this._z=c*u*v-d*f*h,this._w=c*u*h+d*f*v;break;case"ZXY":this._x=d*u*h-c*f*v,this._y=c*f*h+d*u*v,this._z=c*u*v+d*f*h,this._w=c*u*h-d*f*v;break;case"ZYX":this._x=d*u*h-c*f*v,this._y=c*f*h+d*u*v,this._z=c*u*v-d*f*h,this._w=c*u*h+d*f*v;break;case"YZX":this._x=d*u*h+c*f*v,this._y=c*f*h+d*u*v,this._z=c*u*v-d*f*h,this._w=c*u*h-d*f*v;break;case"XZY":this._x=d*u*h-c*f*v,this._y=c*f*h-d*u*v,this._z=c*u*v+d*f*h,this._w=c*u*h+d*f*v;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+a)}return t!==!1&&this._onChangeCallback(),this}setFromAxisAngle(e,t){const n=t/2,i=Math.sin(n);return this._x=e.x*i,this._y=e.y*i,this._z=e.z*i,this._w=Math.cos(n),this._onChangeCallback(),this}setFromRotationMatrix(e){const t=e.elements,n=t[0],i=t[4],r=t[8],a=t[1],o=t[5],l=t[9],c=t[2],u=t[6],h=t[10],d=n+o+h;if(d>0){const f=.5/Math.sqrt(d+1);this._w=.25/f,this._x=(u-l)*f,this._y=(r-c)*f,this._z=(a-i)*f}else if(n>o&&n>h){const f=2*Math.sqrt(1+n-o-h);this._w=(u-l)/f,this._x=.25*f,this._y=(i+a)/f,this._z=(r+c)/f}else if(o>h){const f=2*Math.sqrt(1+o-n-h);this._w=(r-c)/f,this._x=(i+a)/f,this._y=.25*f,this._z=(l+u)/f}else{const f=2*Math.sqrt(1+h-n-o);this._w=(a-i)/f,this._x=(r+c)/f,this._y=(l+u)/f,this._z=.25*f}return this._onChangeCallback(),this}setFromUnitVectors(e,t){let n=e.dot(t)+1;return n<Number.EPSILON?(n=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=n):(this._x=0,this._y=-e.z,this._z=e.y,this._w=n)):(this._x=e.y*t.z-e.z*t.y,this._y=e.z*t.x-e.x*t.z,this._z=e.x*t.y-e.y*t.x,this._w=n),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(oi(this.dot(e),-1,1)))}rotateTowards(e,t){const n=this.angleTo(e);if(n===0)return this;const i=Math.min(1,t/n);return this.slerp(e,i),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return e===0?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e,t){return t!==void 0?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(e,t)):this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,t){const n=e._x,i=e._y,r=e._z,a=e._w,o=t._x,l=t._y,c=t._z,u=t._w;return this._x=n*u+a*o+i*c-r*l,this._y=i*u+a*l+r*o-n*c,this._z=r*u+a*c+n*l-i*o,this._w=a*u-n*o-i*l-r*c,this._onChangeCallback(),this}slerp(e,t){if(t===0)return this;if(t===1)return this.copy(e);const n=this._x,i=this._y,r=this._z,a=this._w;let o=a*e._w+n*e._x+i*e._y+r*e._z;if(o<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,o=-o):this.copy(e),o>=1)return this._w=a,this._x=n,this._y=i,this._z=r,this;const l=1-o*o;if(l<=Number.EPSILON){const f=1-t;return this._w=f*a+t*this._w,this._x=f*n+t*this._x,this._y=f*i+t*this._y,this._z=f*r+t*this._z,this.normalize(),this._onChangeCallback(),this}const c=Math.sqrt(l),u=Math.atan2(c,o),h=Math.sin((1-t)*u)/c,d=Math.sin(t*u)/c;return this._w=a*h+this._w*d,this._x=n*h+this._x*d,this._y=i*h+this._y*d,this._z=r*h+this._z*d,this._onChangeCallback(),this}slerpQuaternions(e,t,n){return this.copy(e).slerp(t,n)}random(){const e=Math.random(),t=Math.sqrt(1-e),n=Math.sqrt(e),i=2*Math.PI*Math.random(),r=2*Math.PI*Math.random();return this.set(t*Math.cos(i),n*Math.sin(r),n*Math.cos(r),t*Math.sin(i))}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,t=0){return this._x=e[t],this._y=e[t+1],this._z=e[t+2],this._w=e[t+3],this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,e}fromBufferAttribute(e,t){return this._x=e.getX(t),this._y=e.getY(t),this._z=e.getZ(t),this._w=e.getW(t),this}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}An.prototype.isQuaternion=!0;class T{constructor(e=0,t=0,n=0){this.x=e,this.y=t,this.z=n}set(e,t,n){return n===void 0&&(n=this.z),this.x=e,this.y=t,this.z=n,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this)}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this)}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}multiply(e,t){return t!==void 0?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(e,t)):(this.x*=e.x,this.y*=e.y,this.z*=e.z,this)}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}applyEuler(e){return e&&e.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(ry.setFromEuler(e))}applyAxisAngle(e,t){return this.applyQuaternion(ry.setFromAxisAngle(e,t))}applyMatrix3(e){const t=this.x,n=this.y,i=this.z,r=e.elements;return this.x=r[0]*t+r[3]*n+r[6]*i,this.y=r[1]*t+r[4]*n+r[7]*i,this.z=r[2]*t+r[5]*n+r[8]*i,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const t=this.x,n=this.y,i=this.z,r=e.elements,a=1/(r[3]*t+r[7]*n+r[11]*i+r[15]);return this.x=(r[0]*t+r[4]*n+r[8]*i+r[12])*a,this.y=(r[1]*t+r[5]*n+r[9]*i+r[13])*a,this.z=(r[2]*t+r[6]*n+r[10]*i+r[14])*a,this}applyQuaternion(e){const t=this.x,n=this.y,i=this.z,r=e.x,a=e.y,o=e.z,l=e.w,c=l*t+a*i-o*n,u=l*n+o*t-r*i,h=l*i+r*n-a*t,d=-r*t-a*n-o*i;return this.x=c*l+d*-r+u*-o-h*-a,this.y=u*l+d*-a+h*-r-c*-o,this.z=h*l+d*-o+c*-a-u*-r,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const t=this.x,n=this.y,i=this.z,r=e.elements;return this.x=r[0]*t+r[4]*n+r[8]*i,this.y=r[1]*t+r[5]*n+r[9]*i,this.z=r[2]*t+r[6]*n+r[10]*i,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this.z=e.z+(t.z-e.z)*n,this}cross(e,t){return t!==void 0?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(e,t)):this.crossVectors(this,e)}crossVectors(e,t){const n=e.x,i=e.y,r=e.z,a=t.x,o=t.y,l=t.z;return this.x=i*l-r*o,this.y=r*a-n*l,this.z=n*o-i*a,this}projectOnVector(e){const t=e.lengthSq();if(t===0)return this.set(0,0,0);const n=e.dot(this)/t;return this.copy(e).multiplyScalar(n)}projectOnPlane(e){return fm.copy(this).projectOnVector(e),this.sub(fm)}reflect(e){return this.sub(fm.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const n=this.dot(e)/t;return Math.acos(oi(n,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,n=this.y-e.y,i=this.z-e.z;return t*t+n*n+i*i}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,t,n){const i=Math.sin(t)*e;return this.x=i*Math.sin(n),this.y=Math.cos(t)*e,this.z=i*Math.cos(n),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,t,n){return this.x=e*Math.sin(t),this.y=n,this.z=e*Math.cos(t),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(e){const t=this.setFromMatrixColumn(e,0).length(),n=this.setFromMatrixColumn(e,1).length(),i=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=n,this.z=i,this}setFromMatrixColumn(e,t){return this.fromArray(e.elements,t*4)}setFromMatrix3Column(e,t){return this.fromArray(e.elements,t*3)}setFromEuler(e){return this.x=e._x,this.y=e._y,this.z=e._z,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e}fromBufferAttribute(e,t,n){return n!==void 0&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const e=(Math.random()-.5)*2,t=Math.random()*Math.PI*2,n=Math.sqrt(1-e**2);return this.x=n*Math.cos(t),this.y=n*Math.sin(t),this.z=e,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}T.prototype.isVector3=!0;const fm=new T,ry=new An;class Tt{constructor(e=new T(1/0,1/0,1/0),t=new T(-1/0,-1/0,-1/0)){this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromArray(e){let t=1/0,n=1/0,i=1/0,r=-1/0,a=-1/0,o=-1/0;for(let l=0,c=e.length;l<c;l+=3){const u=e[l],h=e[l+1],d=e[l+2];u<t&&(t=u),h<n&&(n=h),d<i&&(i=d),u>r&&(r=u),h>a&&(a=h),d>o&&(o=d)}return this.min.set(t,n,i),this.max.set(r,a,o),this}setFromBufferAttribute(e){let t=1/0,n=1/0,i=1/0,r=-1/0,a=-1/0,o=-1/0;for(let l=0,c=e.count;l<c;l++){const u=e.getX(l),h=e.getY(l),d=e.getZ(l);u<t&&(t=u),h<n&&(n=h),d<i&&(i=d),u>r&&(r=u),h>a&&(a=h),d>o&&(o=d)}return this.min.set(t,n,i),this.max.set(r,a,o),this}setFromPoints(e){this.makeEmpty();for(let t=0,n=e.length;t<n;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const n=co.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(n),this.max.copy(e).add(n),this}setFromObject(e,t=!1){return this.makeEmpty(),this.expandByObject(e,t)}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e,t=!1){e.updateWorldMatrix(!1,!1);const n=e.geometry;if(n!==void 0)if(t&&n.attributes!=null&&n.attributes.position!==void 0){const r=n.attributes.position;for(let a=0,o=r.count;a<o;a++)co.fromBufferAttribute(r,a).applyMatrix4(e.matrixWorld),this.expandByPoint(co)}else n.boundingBox===null&&n.computeBoundingBox(),pm.copy(n.boundingBox),pm.applyMatrix4(e.matrixWorld),this.union(pm);const i=e.children;for(let r=0,a=i.length;r<a;r++)this.expandByObject(i[r],t);return this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y||e.z<this.min.z||e.z>this.max.z)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y||e.max.z<this.min.z||e.min.z>this.max.z)}intersectsSphere(e){return this.clampPoint(e.center,co),co.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let t,n;return e.normal.x>0?(t=e.normal.x*this.min.x,n=e.normal.x*this.max.x):(t=e.normal.x*this.max.x,n=e.normal.x*this.min.x),e.normal.y>0?(t+=e.normal.y*this.min.y,n+=e.normal.y*this.max.y):(t+=e.normal.y*this.max.y,n+=e.normal.y*this.min.y),e.normal.z>0?(t+=e.normal.z*this.min.z,n+=e.normal.z*this.max.z):(t+=e.normal.z*this.max.z,n+=e.normal.z*this.min.z),t<=-e.constant&&n>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;this.getCenter(Kc),Zh.subVectors(this.max,Kc),ul.subVectors(e.a,Kc),hl.subVectors(e.b,Kc),dl.subVectors(e.c,Kc),da.subVectors(hl,ul),fa.subVectors(dl,hl),uo.subVectors(ul,dl);let t=[0,-da.z,da.y,0,-fa.z,fa.y,0,-uo.z,uo.y,da.z,0,-da.x,fa.z,0,-fa.x,uo.z,0,-uo.x,-da.y,da.x,0,-fa.y,fa.x,0,-uo.y,uo.x,0];return!mm(t,ul,hl,dl,Zh)||(t=[1,0,0,0,1,0,0,0,1],!mm(t,ul,hl,dl,Zh))?!1:($h.crossVectors(da,fa),t=[$h.x,$h.y,$h.z],mm(t,ul,hl,dl,Zh))}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return co.copy(e).clamp(this.min,this.max).sub(e).length()}getBoundingSphere(e){return this.getCenter(e.center),e.radius=this.getSize(co).length()*.5,e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()?this:(bs[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),bs[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),bs[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),bs[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),bs[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),bs[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),bs[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),bs[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(bs),this)}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}Tt.prototype.isBox3=!0;const bs=[new T,new T,new T,new T,new T,new T,new T,new T],co=new T,pm=new Tt,ul=new T,hl=new T,dl=new T,da=new T,fa=new T,uo=new T,Kc=new T,Zh=new T,$h=new T,ho=new T;function mm(s,e,t,n,i){for(let r=0,a=s.length-3;r<=a;r+=3){ho.fromArray(s,r);const o=i.x*Math.abs(ho.x)+i.y*Math.abs(ho.y)+i.z*Math.abs(ho.z),l=e.dot(ho),c=t.dot(ho),u=n.dot(ho);if(Math.max(-Math.max(l,c,u),Math.min(l,c,u))>o)return!1}return!0}const WT=new Tt,sy=new T,ed=new T,gm=new T;class Zn{constructor(e=new T,t=-1){this.center=e,this.radius=t}set(e,t){return this.center.copy(e),this.radius=t,this}setFromPoints(e,t){const n=this.center;t!==void 0?n.copy(t):WT.setFromPoints(e).getCenter(n);let i=0;for(let r=0,a=e.length;r<a;r++)i=Math.max(i,n.distanceToSquared(e[r]));return this.radius=Math.sqrt(i),this}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){const t=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=t*t}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,t){const n=this.center.distanceToSquared(e);return t.copy(e),n>this.radius*this.radius&&(t.sub(this.center).normalize(),t.multiplyScalar(this.radius).add(this.center)),t}getBoundingBox(e){return this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}expandByPoint(e){gm.subVectors(e,this.center);const t=gm.lengthSq();if(t>this.radius*this.radius){const n=Math.sqrt(t),i=(n-this.radius)*.5;this.center.add(gm.multiplyScalar(i/n)),this.radius+=i}return this}union(e){return this.center.equals(e.center)===!0?ed.set(0,0,1).multiplyScalar(e.radius):ed.subVectors(e.center,this.center).normalize().multiplyScalar(e.radius),this.expandByPoint(sy.copy(e.center).add(ed)),this.expandByPoint(sy.copy(e.center).sub(ed)),this}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}clone(){return new this.constructor().copy(this)}}const As=new T,vm=new T,td=new T,pa=new T,ym=new T,nd=new T,xm=new T;class Ti{constructor(e=new T,t=new T(0,0,-1)){this.origin=e,this.direction=t}set(e,t){return this.origin.copy(e),this.direction.copy(t),this}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,t){return t.copy(this.direction).multiplyScalar(e).add(this.origin)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,As)),this}closestPointToPoint(e,t){t.subVectors(e,this.origin);const n=t.dot(this.direction);return n<0?t.copy(this.origin):t.copy(this.direction).multiplyScalar(n).add(this.origin)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){const t=As.subVectors(e,this.origin).dot(this.direction);return t<0?this.origin.distanceToSquared(e):(As.copy(this.direction).multiplyScalar(t).add(this.origin),As.distanceToSquared(e))}distanceSqToSegment(e,t,n,i){vm.copy(e).add(t).multiplyScalar(.5),td.copy(t).sub(e).normalize(),pa.copy(this.origin).sub(vm);const r=e.distanceTo(t)*.5,a=-this.direction.dot(td),o=pa.dot(this.direction),l=-pa.dot(td),c=pa.lengthSq(),u=Math.abs(1-a*a);let h,d,f,v;if(u>0)if(h=a*l-o,d=a*o-l,v=r*u,h>=0)if(d>=-v)if(d<=v){const g=1/u;h*=g,d*=g,f=h*(h+a*d+2*o)+d*(a*h+d+2*l)+c}else d=r,h=Math.max(0,-(a*d+o)),f=-h*h+d*(d+2*l)+c;else d=-r,h=Math.max(0,-(a*d+o)),f=-h*h+d*(d+2*l)+c;else d<=-v?(h=Math.max(0,-(-a*r+o)),d=h>0?-r:Math.min(Math.max(-r,-l),r),f=-h*h+d*(d+2*l)+c):d<=v?(h=0,d=Math.min(Math.max(-r,-l),r),f=d*(d+2*l)+c):(h=Math.max(0,-(a*r+o)),d=h>0?r:Math.min(Math.max(-r,-l),r),f=-h*h+d*(d+2*l)+c);else d=a>0?-r:r,h=Math.max(0,-(a*d+o)),f=-h*h+d*(d+2*l)+c;return n&&n.copy(this.direction).multiplyScalar(h).add(this.origin),i&&i.copy(td).multiplyScalar(d).add(vm),f}intersectSphere(e,t){As.subVectors(e.center,this.origin);const n=As.dot(this.direction),i=As.dot(As)-n*n,r=e.radius*e.radius;if(i>r)return null;const a=Math.sqrt(r-i),o=n-a,l=n+a;return o<0&&l<0?null:o<0?this.at(l,t):this.at(o,t)}intersectsSphere(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){const t=e.normal.dot(this.direction);if(t===0)return e.distanceToPoint(this.origin)===0?0:null;const n=-(this.origin.dot(e.normal)+e.constant)/t;return n>=0?n:null}intersectPlane(e,t){const n=this.distanceToPlane(e);return n===null?null:this.at(n,t)}intersectsPlane(e){const t=e.distanceToPoint(this.origin);return t===0||e.normal.dot(this.direction)*t<0}intersectBox(e,t){let n,i,r,a,o,l;const c=1/this.direction.x,u=1/this.direction.y,h=1/this.direction.z,d=this.origin;return c>=0?(n=(e.min.x-d.x)*c,i=(e.max.x-d.x)*c):(n=(e.max.x-d.x)*c,i=(e.min.x-d.x)*c),u>=0?(r=(e.min.y-d.y)*u,a=(e.max.y-d.y)*u):(r=(e.max.y-d.y)*u,a=(e.min.y-d.y)*u),n>a||r>i||((r>n||n!==n)&&(n=r),(a<i||i!==i)&&(i=a),h>=0?(o=(e.min.z-d.z)*h,l=(e.max.z-d.z)*h):(o=(e.max.z-d.z)*h,l=(e.min.z-d.z)*h),n>l||o>i)||((o>n||n!==n)&&(n=o),(l<i||i!==i)&&(i=l),i<0)?null:this.at(n>=0?n:i,t)}intersectsBox(e){return this.intersectBox(e,As)!==null}intersectTriangle(e,t,n,i,r){ym.subVectors(t,e),nd.subVectors(n,e),xm.crossVectors(ym,nd);let a=this.direction.dot(xm),o;if(a>0){if(i)return null;o=1}else if(a<0)o=-1,a=-a;else return null;pa.subVectors(this.origin,e);const l=o*this.direction.dot(nd.crossVectors(pa,nd));if(l<0)return null;const c=o*this.direction.dot(ym.cross(pa));if(c<0||l+c>a)return null;const u=-o*pa.dot(xm);return u<0?null:this.at(u/a,r)}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class Ne{constructor(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(e,t,n,i,r,a,o,l,c,u,h,d,f,v,g,m){const x=this.elements;return x[0]=e,x[4]=t,x[8]=n,x[12]=i,x[1]=r,x[5]=a,x[9]=o,x[13]=l,x[2]=c,x[6]=u,x[10]=h,x[14]=d,x[3]=f,x[7]=v,x[11]=g,x[15]=m,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new Ne().fromArray(this.elements)}copy(e){const t=this.elements,n=e.elements;return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=n[11],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15],this}copyPosition(e){const t=this.elements,n=e.elements;return t[12]=n[12],t[13]=n[13],t[14]=n[14],this}setFromMatrix3(e){const t=e.elements;return this.set(t[0],t[3],t[6],0,t[1],t[4],t[7],0,t[2],t[5],t[8],0,0,0,0,1),this}extractBasis(e,t,n){return e.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),n.setFromMatrixColumn(this,2),this}makeBasis(e,t,n){return this.set(e.x,t.x,n.x,0,e.y,t.y,n.y,0,e.z,t.z,n.z,0,0,0,0,1),this}extractRotation(e){const t=this.elements,n=e.elements,i=1/fl.setFromMatrixColumn(e,0).length(),r=1/fl.setFromMatrixColumn(e,1).length(),a=1/fl.setFromMatrixColumn(e,2).length();return t[0]=n[0]*i,t[1]=n[1]*i,t[2]=n[2]*i,t[3]=0,t[4]=n[4]*r,t[5]=n[5]*r,t[6]=n[6]*r,t[7]=0,t[8]=n[8]*a,t[9]=n[9]*a,t[10]=n[10]*a,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromEuler(e){e&&e.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const t=this.elements,n=e.x,i=e.y,r=e.z,a=Math.cos(n),o=Math.sin(n),l=Math.cos(i),c=Math.sin(i),u=Math.cos(r),h=Math.sin(r);if(e.order==="XYZ"){const d=a*u,f=a*h,v=o*u,g=o*h;t[0]=l*u,t[4]=-l*h,t[8]=c,t[1]=f+v*c,t[5]=d-g*c,t[9]=-o*l,t[2]=g-d*c,t[6]=v+f*c,t[10]=a*l}else if(e.order==="YXZ"){const d=l*u,f=l*h,v=c*u,g=c*h;t[0]=d+g*o,t[4]=v*o-f,t[8]=a*c,t[1]=a*h,t[5]=a*u,t[9]=-o,t[2]=f*o-v,t[6]=g+d*o,t[10]=a*l}else if(e.order==="ZXY"){const d=l*u,f=l*h,v=c*u,g=c*h;t[0]=d-g*o,t[4]=-a*h,t[8]=v+f*o,t[1]=f+v*o,t[5]=a*u,t[9]=g-d*o,t[2]=-a*c,t[6]=o,t[10]=a*l}else if(e.order==="ZYX"){const d=a*u,f=a*h,v=o*u,g=o*h;t[0]=l*u,t[4]=v*c-f,t[8]=d*c+g,t[1]=l*h,t[5]=g*c+d,t[9]=f*c-v,t[2]=-c,t[6]=o*l,t[10]=a*l}else if(e.order==="YZX"){const d=a*l,f=a*c,v=o*l,g=o*c;t[0]=l*u,t[4]=g-d*h,t[8]=v*h+f,t[1]=h,t[5]=a*u,t[9]=-o*u,t[2]=-c*u,t[6]=f*h+v,t[10]=d-g*h}else if(e.order==="XZY"){const d=a*l,f=a*c,v=o*l,g=o*c;t[0]=l*u,t[4]=-h,t[8]=c*u,t[1]=d*h+g,t[5]=a*u,t[9]=f*h-v,t[2]=v*h-f,t[6]=o*u,t[10]=g*h+d}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromQuaternion(e){return this.compose(qT,e,jT)}lookAt(e,t,n){const i=this.elements;return cr.subVectors(e,t),cr.lengthSq()===0&&(cr.z=1),cr.normalize(),ma.crossVectors(n,cr),ma.lengthSq()===0&&(Math.abs(n.z)===1?cr.x+=1e-4:cr.z+=1e-4,cr.normalize(),ma.crossVectors(n,cr)),ma.normalize(),id.crossVectors(cr,ma),i[0]=ma.x,i[4]=id.x,i[8]=cr.x,i[1]=ma.y,i[5]=id.y,i[9]=cr.y,i[2]=ma.z,i[6]=id.z,i[10]=cr.z,this}multiply(e,t){return t!==void 0?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(e,t)):this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const n=e.elements,i=t.elements,r=this.elements,a=n[0],o=n[4],l=n[8],c=n[12],u=n[1],h=n[5],d=n[9],f=n[13],v=n[2],g=n[6],m=n[10],x=n[14],w=n[3],S=n[7],b=n[11],E=n[15],C=i[0],P=i[4],M=i[8],L=i[12],z=i[1],V=i[5],U=i[9],j=i[13],F=i[2],K=i[6],J=i[10],se=i[14],le=i[3],q=i[7],te=i[11],H=i[15];return r[0]=a*C+o*z+l*F+c*le,r[4]=a*P+o*V+l*K+c*q,r[8]=a*M+o*U+l*J+c*te,r[12]=a*L+o*j+l*se+c*H,r[1]=u*C+h*z+d*F+f*le,r[5]=u*P+h*V+d*K+f*q,r[9]=u*M+h*U+d*J+f*te,r[13]=u*L+h*j+d*se+f*H,r[2]=v*C+g*z+m*F+x*le,r[6]=v*P+g*V+m*K+x*q,r[10]=v*M+g*U+m*J+x*te,r[14]=v*L+g*j+m*se+x*H,r[3]=w*C+S*z+b*F+E*le,r[7]=w*P+S*V+b*K+E*q,r[11]=w*M+S*U+b*J+E*te,r[15]=w*L+S*j+b*se+E*H,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[4]*=e,t[8]*=e,t[12]*=e,t[1]*=e,t[5]*=e,t[9]*=e,t[13]*=e,t[2]*=e,t[6]*=e,t[10]*=e,t[14]*=e,t[3]*=e,t[7]*=e,t[11]*=e,t[15]*=e,this}determinant(){const e=this.elements,t=e[0],n=e[4],i=e[8],r=e[12],a=e[1],o=e[5],l=e[9],c=e[13],u=e[2],h=e[6],d=e[10],f=e[14],v=e[3],g=e[7],m=e[11],x=e[15];return v*(+r*l*h-i*c*h-r*o*d+n*c*d+i*o*f-n*l*f)+g*(+t*l*f-t*c*d+r*a*d-i*a*f+i*c*u-r*l*u)+m*(+t*c*h-t*o*f-r*a*h+n*a*f+r*o*u-n*c*u)+x*(-i*o*u-t*l*h+t*o*d+i*a*h-n*a*d+n*l*u)}transpose(){const e=this.elements;let t;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}setPosition(e,t,n){const i=this.elements;return e.isVector3?(i[12]=e.x,i[13]=e.y,i[14]=e.z):(i[12]=e,i[13]=t,i[14]=n),this}invert(){const e=this.elements,t=e[0],n=e[1],i=e[2],r=e[3],a=e[4],o=e[5],l=e[6],c=e[7],u=e[8],h=e[9],d=e[10],f=e[11],v=e[12],g=e[13],m=e[14],x=e[15],w=h*m*c-g*d*c+g*l*f-o*m*f-h*l*x+o*d*x,S=v*d*c-u*m*c-v*l*f+a*m*f+u*l*x-a*d*x,b=u*g*c-v*h*c+v*o*f-a*g*f-u*o*x+a*h*x,E=v*h*l-u*g*l-v*o*d+a*g*d+u*o*m-a*h*m,C=t*w+n*S+i*b+r*E;if(C===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const P=1/C;return e[0]=w*P,e[1]=(g*d*r-h*m*r-g*i*f+n*m*f+h*i*x-n*d*x)*P,e[2]=(o*m*r-g*l*r+g*i*c-n*m*c-o*i*x+n*l*x)*P,e[3]=(h*l*r-o*d*r-h*i*c+n*d*c+o*i*f-n*l*f)*P,e[4]=S*P,e[5]=(u*m*r-v*d*r+v*i*f-t*m*f-u*i*x+t*d*x)*P,e[6]=(v*l*r-a*m*r-v*i*c+t*m*c+a*i*x-t*l*x)*P,e[7]=(a*d*r-u*l*r+u*i*c-t*d*c-a*i*f+t*l*f)*P,e[8]=b*P,e[9]=(v*h*r-u*g*r-v*n*f+t*g*f+u*n*x-t*h*x)*P,e[10]=(a*g*r-v*o*r+v*n*c-t*g*c-a*n*x+t*o*x)*P,e[11]=(u*o*r-a*h*r-u*n*c+t*h*c+a*n*f-t*o*f)*P,e[12]=E*P,e[13]=(u*g*i-v*h*i+v*n*d-t*g*d-u*n*m+t*h*m)*P,e[14]=(v*o*i-a*g*i-v*n*l+t*g*l+a*n*m-t*o*m)*P,e[15]=(a*h*i-u*o*i+u*n*l-t*h*l-a*n*d+t*o*d)*P,this}scale(e){const t=this.elements,n=e.x,i=e.y,r=e.z;return t[0]*=n,t[4]*=i,t[8]*=r,t[1]*=n,t[5]*=i,t[9]*=r,t[2]*=n,t[6]*=i,t[10]*=r,t[3]*=n,t[7]*=i,t[11]*=r,this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],n=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],i=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,n,i))}makeTranslation(e,t,n){return this.set(1,0,0,e,0,1,0,t,0,0,1,n,0,0,0,1),this}makeRotationX(e){const t=Math.cos(e),n=Math.sin(e);return this.set(1,0,0,0,0,t,-n,0,0,n,t,0,0,0,0,1),this}makeRotationY(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,0,n,0,0,1,0,0,-n,0,t,0,0,0,0,1),this}makeRotationZ(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,-n,0,0,n,t,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,t){const n=Math.cos(t),i=Math.sin(t),r=1-n,a=e.x,o=e.y,l=e.z,c=r*a,u=r*o;return this.set(c*a+n,c*o-i*l,c*l+i*o,0,c*o+i*l,u*o+n,u*l-i*a,0,c*l-i*o,u*l+i*a,r*l*l+n,0,0,0,0,1),this}makeScale(e,t,n){return this.set(e,0,0,0,0,t,0,0,0,0,n,0,0,0,0,1),this}makeShear(e,t,n,i,r,a){return this.set(1,n,r,0,e,1,a,0,t,i,1,0,0,0,0,1),this}compose(e,t,n){const i=this.elements,r=t._x,a=t._y,o=t._z,l=t._w,c=r+r,u=a+a,h=o+o,d=r*c,f=r*u,v=r*h,g=a*u,m=a*h,x=o*h,w=l*c,S=l*u,b=l*h,E=n.x,C=n.y,P=n.z;return i[0]=(1-(g+x))*E,i[1]=(f+b)*E,i[2]=(v-S)*E,i[3]=0,i[4]=(f-b)*C,i[5]=(1-(d+x))*C,i[6]=(m+w)*C,i[7]=0,i[8]=(v+S)*P,i[9]=(m-w)*P,i[10]=(1-(d+g))*P,i[11]=0,i[12]=e.x,i[13]=e.y,i[14]=e.z,i[15]=1,this}decompose(e,t,n){const i=this.elements;let r=fl.set(i[0],i[1],i[2]).length();const a=fl.set(i[4],i[5],i[6]).length(),o=fl.set(i[8],i[9],i[10]).length();this.determinant()<0&&(r=-r),e.x=i[12],e.y=i[13],e.z=i[14],Fr.copy(this);const c=1/r,u=1/a,h=1/o;return Fr.elements[0]*=c,Fr.elements[1]*=c,Fr.elements[2]*=c,Fr.elements[4]*=u,Fr.elements[5]*=u,Fr.elements[6]*=u,Fr.elements[8]*=h,Fr.elements[9]*=h,Fr.elements[10]*=h,t.setFromRotationMatrix(Fr),n.x=r,n.y=a,n.z=o,this}makePerspective(e,t,n,i,r,a){a===void 0&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const o=this.elements,l=2*r/(t-e),c=2*r/(n-i),u=(t+e)/(t-e),h=(n+i)/(n-i),d=-(a+r)/(a-r),f=-2*a*r/(a-r);return o[0]=l,o[4]=0,o[8]=u,o[12]=0,o[1]=0,o[5]=c,o[9]=h,o[13]=0,o[2]=0,o[6]=0,o[10]=d,o[14]=f,o[3]=0,o[7]=0,o[11]=-1,o[15]=0,this}makeOrthographic(e,t,n,i,r,a){const o=this.elements,l=1/(t-e),c=1/(n-i),u=1/(a-r),h=(t+e)*l,d=(n+i)*c,f=(a+r)*u;return o[0]=2*l,o[4]=0,o[8]=0,o[12]=-h,o[1]=0,o[5]=2*c,o[9]=0,o[13]=-d,o[2]=0,o[6]=0,o[10]=-2*u,o[14]=-f,o[3]=0,o[7]=0,o[11]=0,o[15]=1,this}equals(e){const t=this.elements,n=e.elements;for(let i=0;i<16;i++)if(t[i]!==n[i])return!1;return!0}fromArray(e,t=0){for(let n=0;n<16;n++)this.elements[n]=e[n+t];return this}toArray(e=[],t=0){const n=this.elements;return e[t]=n[0],e[t+1]=n[1],e[t+2]=n[2],e[t+3]=n[3],e[t+4]=n[4],e[t+5]=n[5],e[t+6]=n[6],e[t+7]=n[7],e[t+8]=n[8],e[t+9]=n[9],e[t+10]=n[10],e[t+11]=n[11],e[t+12]=n[12],e[t+13]=n[13],e[t+14]=n[14],e[t+15]=n[15],e}}Ne.prototype.isMatrix4=!0;const fl=new T,Fr=new Ne,qT=new T(0,0,0),jT=new T(1,1,1),ma=new T,id=new T,cr=new T,ay=new Ne,oy=new An;class vr{constructor(e=0,t=0,n=0,i=vr.DefaultOrder){this._x=e,this._y=t,this._z=n,this._order=i}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,t,n,i=this._order){return this._x=e,this._y=t,this._z=n,this._order=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,t=this._order,n=!0){const i=e.elements,r=i[0],a=i[4],o=i[8],l=i[1],c=i[5],u=i[9],h=i[2],d=i[6],f=i[10];switch(t){case"XYZ":this._y=Math.asin(oi(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(-u,f),this._z=Math.atan2(-a,r)):(this._x=Math.atan2(d,c),this._z=0);break;case"YXZ":this._x=Math.asin(-oi(u,-1,1)),Math.abs(u)<.9999999?(this._y=Math.atan2(o,f),this._z=Math.atan2(l,c)):(this._y=Math.atan2(-h,r),this._z=0);break;case"ZXY":this._x=Math.asin(oi(d,-1,1)),Math.abs(d)<.9999999?(this._y=Math.atan2(-h,f),this._z=Math.atan2(-a,c)):(this._y=0,this._z=Math.atan2(l,r));break;case"ZYX":this._y=Math.asin(-oi(h,-1,1)),Math.abs(h)<.9999999?(this._x=Math.atan2(d,f),this._z=Math.atan2(l,r)):(this._x=0,this._z=Math.atan2(-a,c));break;case"YZX":this._z=Math.asin(oi(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-u,c),this._y=Math.atan2(-h,r)):(this._x=0,this._y=Math.atan2(o,f));break;case"XZY":this._z=Math.asin(-oi(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(d,c),this._y=Math.atan2(o,r)):(this._x=Math.atan2(-u,f),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,n===!0&&this._onChangeCallback(),this}setFromQuaternion(e,t,n){return ay.makeRotationFromQuaternion(e),this.setFromRotationMatrix(ay,t,n)}setFromVector3(e,t=this._order){return this.set(e.x,e.y,e.z,t)}reorder(e){return oy.setFromEuler(this),this.setFromQuaternion(oy,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],e[3]!==void 0&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._order,e}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}vr.prototype.isEuler=!0;vr.DefaultOrder="XYZ";vr.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];class zv{constructor(){this.mask=1}set(e){this.mask=(1<<e|0)>>>0}enable(e){this.mask|=1<<e|0}enableAll(){this.mask=-1}toggle(e){this.mask^=1<<e|0}disable(e){this.mask&=~(1<<e|0)}disableAll(){this.mask=0}test(e){return(this.mask&e.mask)!==0}isEnabled(e){return(this.mask&(1<<e|0))!==0}}let QT=0;const ly=new T,pl=new An,Ts=new Ne,rd=new T,Yc=new T,XT=new T,JT=new An,cy=new T(1,0,0),uy=new T(0,1,0),hy=new T(0,0,1),KT={type:"added"},dy={type:"removed"};class fn extends Yo{constructor(){super(),Object.defineProperty(this,"id",{value:QT++}),this.uuid=Qr(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=fn.DefaultUp.clone();const e=new T,t=new vr,n=new An,i=new T(1,1,1);function r(){n.setFromEuler(t,!1)}function a(){t.setFromQuaternion(n,void 0,!1)}t._onChange(r),n._onChange(a),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:i},modelViewMatrix:{value:new Ne},normalMatrix:{value:new Hn}}),this.matrix=new Ne,this.matrixWorld=new Ne,this.matrixAutoUpdate=fn.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new zv,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(e){return this.quaternion.premultiply(e),this}setRotationFromAxisAngle(e,t){this.quaternion.setFromAxisAngle(e,t)}setRotationFromEuler(e){this.quaternion.setFromEuler(e,!0)}setRotationFromMatrix(e){this.quaternion.setFromRotationMatrix(e)}setRotationFromQuaternion(e){this.quaternion.copy(e)}rotateOnAxis(e,t){return pl.setFromAxisAngle(e,t),this.quaternion.multiply(pl),this}rotateOnWorldAxis(e,t){return pl.setFromAxisAngle(e,t),this.quaternion.premultiply(pl),this}rotateX(e){return this.rotateOnAxis(cy,e)}rotateY(e){return this.rotateOnAxis(uy,e)}rotateZ(e){return this.rotateOnAxis(hy,e)}translateOnAxis(e,t){return ly.copy(e).applyQuaternion(this.quaternion),this.position.add(ly.multiplyScalar(t)),this}translateX(e){return this.translateOnAxis(cy,e)}translateY(e){return this.translateOnAxis(uy,e)}translateZ(e){return this.translateOnAxis(hy,e)}localToWorld(e){return e.applyMatrix4(this.matrixWorld)}worldToLocal(e){return e.applyMatrix4(Ts.copy(this.matrixWorld).invert())}lookAt(e,t,n){e.isVector3?rd.copy(e):rd.set(e,t,n);const i=this.parent;this.updateWorldMatrix(!0,!1),Yc.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?Ts.lookAt(Yc,rd,this.up):Ts.lookAt(rd,Yc,this.up),this.quaternion.setFromRotationMatrix(Ts),i&&(Ts.extractRotation(i.matrixWorld),pl.setFromRotationMatrix(Ts),this.quaternion.premultiply(pl.invert()))}add(e){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return e===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(e.parent!==null&&e.parent.remove(e),e.parent=this,this.children.push(e),e.dispatchEvent(KT)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",e),this)}remove(e){if(arguments.length>1){for(let n=0;n<arguments.length;n++)this.remove(arguments[n]);return this}const t=this.children.indexOf(e);return t!==-1&&(e.parent=null,this.children.splice(t,1),e.dispatchEvent(dy)),this}removeFromParent(){const e=this.parent;return e!==null&&e.remove(this),this}clear(){for(let e=0;e<this.children.length;e++){const t=this.children[e];t.parent=null,t.dispatchEvent(dy)}return this.children.length=0,this}attach(e){return this.updateWorldMatrix(!0,!1),Ts.copy(this.matrixWorld).invert(),e.parent!==null&&(e.parent.updateWorldMatrix(!0,!1),Ts.multiply(e.parent.matrixWorld)),e.applyMatrix4(Ts),this.add(e),e.updateWorldMatrix(!1,!0),this}getObjectById(e){return this.getObjectByProperty("id",e)}getObjectByName(e){return this.getObjectByProperty("name",e)}getObjectByProperty(e,t){if(this[e]===t)return this;for(let n=0,i=this.children.length;n<i;n++){const a=this.children[n].getObjectByProperty(e,t);if(a!==void 0)return a}}getWorldPosition(e){return this.updateWorldMatrix(!0,!1),e.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Yc,e,XT),e}getWorldScale(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Yc,JT,e),e}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(t[8],t[9],t[10]).normalize()}raycast(){}traverse(e){e(this);const t=this.children;for(let n=0,i=t.length;n<i;n++)t[n].traverse(e)}traverseVisible(e){if(this.visible===!1)return;e(this);const t=this.children;for(let n=0,i=t.length;n<i;n++)t[n].traverseVisible(e)}traverseAncestors(e){const t=this.parent;t!==null&&(e(t),t.traverseAncestors(e))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,e=!0);const t=this.children;for(let n=0,i=t.length;n<i;n++)t[n].updateMatrixWorld(e)}updateWorldMatrix(e,t){const n=this.parent;if(e===!0&&n!==null&&n.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),t===!0){const i=this.children;for(let r=0,a=i.length;r<a;r++)i[r].updateWorldMatrix(!1,!0)}}toJSON(e){const t=e===void 0||typeof e=="string",n={};t&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},n.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const i={};i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),this.castShadow===!0&&(i.castShadow=!0),this.receiveShadow===!0&&(i.receiveShadow=!0),this.visible===!1&&(i.visible=!1),this.frustumCulled===!1&&(i.frustumCulled=!1),this.renderOrder!==0&&(i.renderOrder=this.renderOrder),JSON.stringify(this.userData)!=="{}"&&(i.userData=this.userData),i.layers=this.layers.mask,i.matrix=this.matrix.toArray(),this.matrixAutoUpdate===!1&&(i.matrixAutoUpdate=!1),this.isInstancedMesh&&(i.type="InstancedMesh",i.count=this.count,i.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(i.instanceColor=this.instanceColor.toJSON()));function r(o,l){return o[l.uuid]===void 0&&(o[l.uuid]=l.toJSON(e)),l.uuid}if(this.isScene)this.background&&(this.background.isColor?i.background=this.background.toJSON():this.background.isTexture&&(i.background=this.background.toJSON(e).uuid)),this.environment&&this.environment.isTexture&&(i.environment=this.environment.toJSON(e).uuid);else if(this.isMesh||this.isLine||this.isPoints){i.geometry=r(e.geometries,this.geometry);const o=this.geometry.parameters;if(o!==void 0&&o.shapes!==void 0){const l=o.shapes;if(Array.isArray(l))for(let c=0,u=l.length;c<u;c++){const h=l[c];r(e.shapes,h)}else r(e.shapes,l)}}if(this.isSkinnedMesh&&(i.bindMode=this.bindMode,i.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(r(e.skeletons,this.skeleton),i.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const o=[];for(let l=0,c=this.material.length;l<c;l++)o.push(r(e.materials,this.material[l]));i.material=o}else i.material=r(e.materials,this.material);if(this.children.length>0){i.children=[];for(let o=0;o<this.children.length;o++)i.children.push(this.children[o].toJSON(e).object)}if(this.animations.length>0){i.animations=[];for(let o=0;o<this.animations.length;o++){const l=this.animations[o];i.animations.push(r(e.animations,l))}}if(t){const o=a(e.geometries),l=a(e.materials),c=a(e.textures),u=a(e.images),h=a(e.shapes),d=a(e.skeletons),f=a(e.animations),v=a(e.nodes);o.length>0&&(n.geometries=o),l.length>0&&(n.materials=l),c.length>0&&(n.textures=c),u.length>0&&(n.images=u),h.length>0&&(n.shapes=h),d.length>0&&(n.skeletons=d),f.length>0&&(n.animations=f),v.length>0&&(n.nodes=v)}return n.object=i,n;function a(o){const l=[];for(const c in o){const u=o[c];delete u.metadata,l.push(u)}return l}}clone(e){return new this.constructor().copy(this,e)}copy(e,t=!0){if(this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.userData=JSON.parse(JSON.stringify(e.userData)),t===!0)for(let n=0;n<e.children.length;n++){const i=e.children[n];this.add(i.clone())}return this}}fn.DefaultUp=new T(0,1,0);fn.DefaultMatrixAutoUpdate=!0;fn.prototype.isObject3D=!0;const Ur=new T,Es=new T,wm=new T,Ms=new T,ml=new T,gl=new T,fy=new T,Sm=new T,bm=new T,Am=new T;class Cn{constructor(e=new T,t=new T,n=new T){this.a=e,this.b=t,this.c=n}static getNormal(e,t,n,i){i.subVectors(n,t),Ur.subVectors(e,t),i.cross(Ur);const r=i.lengthSq();return r>0?i.multiplyScalar(1/Math.sqrt(r)):i.set(0,0,0)}static getBarycoord(e,t,n,i,r){Ur.subVectors(i,t),Es.subVectors(n,t),wm.subVectors(e,t);const a=Ur.dot(Ur),o=Ur.dot(Es),l=Ur.dot(wm),c=Es.dot(Es),u=Es.dot(wm),h=a*c-o*o;if(h===0)return r.set(-2,-1,-1);const d=1/h,f=(c*l-o*u)*d,v=(a*u-o*l)*d;return r.set(1-f-v,v,f)}static containsPoint(e,t,n,i){return this.getBarycoord(e,t,n,i,Ms),Ms.x>=0&&Ms.y>=0&&Ms.x+Ms.y<=1}static getUV(e,t,n,i,r,a,o,l){return this.getBarycoord(e,t,n,i,Ms),l.set(0,0),l.addScaledVector(r,Ms.x),l.addScaledVector(a,Ms.y),l.addScaledVector(o,Ms.z),l}static isFrontFacing(e,t,n,i){return Ur.subVectors(n,t),Es.subVectors(e,t),Ur.cross(Es).dot(i)<0}set(e,t,n){return this.a.copy(e),this.b.copy(t),this.c.copy(n),this}setFromPointsAndIndices(e,t,n,i){return this.a.copy(e[t]),this.b.copy(e[n]),this.c.copy(e[i]),this}setFromAttributeAndIndices(e,t,n,i){return this.a.fromBufferAttribute(e,t),this.b.fromBufferAttribute(e,n),this.c.fromBufferAttribute(e,i),this}clone(){return new this.constructor().copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return Ur.subVectors(this.c,this.b),Es.subVectors(this.a,this.b),Ur.cross(Es).length()*.5}getMidpoint(e){return e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return Cn.getNormal(this.a,this.b,this.c,e)}getPlane(e){return e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,t){return Cn.getBarycoord(e,this.a,this.b,this.c,t)}getUV(e,t,n,i,r){return Cn.getUV(e,this.a,this.b,this.c,t,n,i,r)}containsPoint(e){return Cn.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return Cn.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,t){const n=this.a,i=this.b,r=this.c;let a,o;ml.subVectors(i,n),gl.subVectors(r,n),Sm.subVectors(e,n);const l=ml.dot(Sm),c=gl.dot(Sm);if(l<=0&&c<=0)return t.copy(n);bm.subVectors(e,i);const u=ml.dot(bm),h=gl.dot(bm);if(u>=0&&h<=u)return t.copy(i);const d=l*h-u*c;if(d<=0&&l>=0&&u<=0)return a=l/(l-u),t.copy(n).addScaledVector(ml,a);Am.subVectors(e,r);const f=ml.dot(Am),v=gl.dot(Am);if(v>=0&&f<=v)return t.copy(r);const g=f*c-l*v;if(g<=0&&c>=0&&v<=0)return o=c/(c-v),t.copy(n).addScaledVector(gl,o);const m=u*v-f*h;if(m<=0&&h-u>=0&&f-v>=0)return fy.subVectors(r,i),o=(h-u)/(h-u+(f-v)),t.copy(i).addScaledVector(fy,o);const x=1/(m+g+d);return a=g*x,o=d*x,t.copy(n).addScaledVector(ml,a).addScaledVector(gl,o)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}}let YT=0;class di extends Yo{constructor(){super(),Object.defineProperty(this,"id",{value:YT++}),this.uuid=Qr(),this.name="",this.type="Material",this.blending=Jl,this.side=gr,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=MS,this.blendDst=CS,this.blendEquation=rs,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=Ug,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=Dv,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=cm,this.stencilZFail=cm,this.stencilZPass=cm,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(e){this._alphaTest>0!=e>0&&this.version++,this._alphaTest=e}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(e){if(e!==void 0)for(const t in e){const n=e[t];if(n===void 0){console.warn("THREE.Material: '"+t+"' parameter is undefined.");continue}if(t==="shading"){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=n===TS;continue}const i=this[t];if(i===void 0){console.warn("THREE."+this.type+": '"+t+"' is not a property of this material.");continue}i&&i.isColor?i.set(n):i&&i.isVector3&&n&&n.isVector3?i.copy(n):this[t]=n}}toJSON(e){const t=e===void 0||typeof e=="string";t&&(e={textures:{},images:{}});const n={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};n.uuid=this.uuid,n.type=this.type,this.name!==""&&(n.name=this.name),this.color&&this.color.isColor&&(n.color=this.color.getHex()),this.roughness!==void 0&&(n.roughness=this.roughness),this.metalness!==void 0&&(n.metalness=this.metalness),this.sheen!==void 0&&(n.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(n.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(n.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(n.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(n.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(n.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(n.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(n.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(n.shininess=this.shininess),this.clearcoat!==void 0&&(n.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(n.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(n.clearcoatMap=this.clearcoatMap.toJSON(e).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(n.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(n.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid,n.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.map&&this.map.isTexture&&(n.map=this.map.toJSON(e).uuid),this.matcap&&this.matcap.isTexture&&(n.matcap=this.matcap.toJSON(e).uuid),this.alphaMap&&this.alphaMap.isTexture&&(n.alphaMap=this.alphaMap.toJSON(e).uuid),this.lightMap&&this.lightMap.isTexture&&(n.lightMap=this.lightMap.toJSON(e).uuid,n.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(n.aoMap=this.aoMap.toJSON(e).uuid,n.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(n.bumpMap=this.bumpMap.toJSON(e).uuid,n.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(n.normalMap=this.normalMap.toJSON(e).uuid,n.normalMapType=this.normalMapType,n.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(n.displacementMap=this.displacementMap.toJSON(e).uuid,n.displacementScale=this.displacementScale,n.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(n.roughnessMap=this.roughnessMap.toJSON(e).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(n.metalnessMap=this.metalnessMap.toJSON(e).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(n.emissiveMap=this.emissiveMap.toJSON(e).uuid),this.specularMap&&this.specularMap.isTexture&&(n.specularMap=this.specularMap.toJSON(e).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(n.specularIntensityMap=this.specularIntensityMap.toJSON(e).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(n.specularColorMap=this.specularColorMap.toJSON(e).uuid),this.envMap&&this.envMap.isTexture&&(n.envMap=this.envMap.toJSON(e).uuid,this.combine!==void 0&&(n.combine=this.combine)),this.envMapIntensity!==void 0&&(n.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(n.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(n.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(n.gradientMap=this.gradientMap.toJSON(e).uuid),this.transmission!==void 0&&(n.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(n.transmissionMap=this.transmissionMap.toJSON(e).uuid),this.thickness!==void 0&&(n.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(n.thicknessMap=this.thicknessMap.toJSON(e).uuid),this.attenuationDistance!==void 0&&(n.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(n.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(n.size=this.size),this.shadowSide!==null&&(n.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(n.sizeAttenuation=this.sizeAttenuation),this.blending!==Jl&&(n.blending=this.blending),this.side!==gr&&(n.side=this.side),this.vertexColors&&(n.vertexColors=!0),this.opacity<1&&(n.opacity=this.opacity),this.transparent===!0&&(n.transparent=this.transparent),n.depthFunc=this.depthFunc,n.depthTest=this.depthTest,n.depthWrite=this.depthWrite,n.colorWrite=this.colorWrite,n.stencilWrite=this.stencilWrite,n.stencilWriteMask=this.stencilWriteMask,n.stencilFunc=this.stencilFunc,n.stencilRef=this.stencilRef,n.stencilFuncMask=this.stencilFuncMask,n.stencilFail=this.stencilFail,n.stencilZFail=this.stencilZFail,n.stencilZPass=this.stencilZPass,this.rotation!==void 0&&this.rotation!==0&&(n.rotation=this.rotation),this.polygonOffset===!0&&(n.polygonOffset=!0),this.polygonOffsetFactor!==0&&(n.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(n.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(n.linewidth=this.linewidth),this.dashSize!==void 0&&(n.dashSize=this.dashSize),this.gapSize!==void 0&&(n.gapSize=this.gapSize),this.scale!==void 0&&(n.scale=this.scale),this.dithering===!0&&(n.dithering=!0),this.alphaTest>0&&(n.alphaTest=this.alphaTest),this.alphaToCoverage===!0&&(n.alphaToCoverage=this.alphaToCoverage),this.premultipliedAlpha===!0&&(n.premultipliedAlpha=this.premultipliedAlpha),this.wireframe===!0&&(n.wireframe=this.wireframe),this.wireframeLinewidth>1&&(n.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(n.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(n.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(n.flatShading=this.flatShading),this.visible===!1&&(n.visible=!1),this.toneMapped===!1&&(n.toneMapped=!1),this.fog===!1&&(n.fog=!1),JSON.stringify(this.userData)!=="{}"&&(n.userData=this.userData);function i(r){const a=[];for(const o in r){const l=r[o];delete l.metadata,a.push(l)}return a}if(t){const r=i(e.textures),a=i(e.images);r.length>0&&(n.textures=r),a.length>0&&(n.images=a)}return n}clone(){return new this.constructor().copy(this)}copy(e){this.name=e.name,this.blending=e.blending,this.side=e.side,this.vertexColors=e.vertexColors,this.opacity=e.opacity,this.transparent=e.transparent,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.depthFunc=e.depthFunc,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.stencilWriteMask=e.stencilWriteMask,this.stencilFunc=e.stencilFunc,this.stencilRef=e.stencilRef,this.stencilFuncMask=e.stencilFuncMask,this.stencilFail=e.stencilFail,this.stencilZFail=e.stencilZFail,this.stencilZPass=e.stencilZPass,this.stencilWrite=e.stencilWrite;const t=e.clippingPlanes;let n=null;if(t!==null){const i=t.length;n=new Array(i);for(let r=0;r!==i;++r)n[r]=t[r].clone()}return this.clippingPlanes=n,this.clipIntersection=e.clipIntersection,this.clipShadows=e.clipShadows,this.shadowSide=e.shadowSide,this.colorWrite=e.colorWrite,this.precision=e.precision,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.dithering=e.dithering,this.alphaTest=e.alphaTest,this.alphaToCoverage=e.alphaToCoverage,this.premultipliedAlpha=e.premultipliedAlpha,this.visible=e.visible,this.toneMapped=e.toneMapped,this.userData=JSON.parse(JSON.stringify(e.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(e){e===!0&&this.version++}}di.prototype.isMaterial=!0;di.fromType=function(){return null};class Ja extends di{constructor(e){super(),this.type="MeshBasicMaterial",this.color=new ot(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Rp,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}Ja.prototype.isMeshBasicMaterial=!0;const si=new T,sd=new Me;class Sn{constructor(e,t,n){if(Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="",this.array=e,this.itemSize=t,this.count=e!==void 0?e.length/t:0,this.normalized=n===!0,this.usage=Pu,this.updateRange={offset:0,count:-1},this.version=0}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}copy(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this}copyAt(e,t,n){e*=this.itemSize,n*=t.itemSize;for(let i=0,r=this.itemSize;i<r;i++)this.array[e+i]=t.array[n+i];return this}copyArray(e){return this.array.set(e),this}copyColorsArray(e){const t=this.array;let n=0;for(let i=0,r=e.length;i<r;i++){let a=e[i];a===void 0&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",i),a=new ot),t[n++]=a.r,t[n++]=a.g,t[n++]=a.b}return this}copyVector2sArray(e){const t=this.array;let n=0;for(let i=0,r=e.length;i<r;i++){let a=e[i];a===void 0&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",i),a=new Me),t[n++]=a.x,t[n++]=a.y}return this}copyVector3sArray(e){const t=this.array;let n=0;for(let i=0,r=e.length;i<r;i++){let a=e[i];a===void 0&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",i),a=new T),t[n++]=a.x,t[n++]=a.y,t[n++]=a.z}return this}copyVector4sArray(e){const t=this.array;let n=0;for(let i=0,r=e.length;i<r;i++){let a=e[i];a===void 0&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",i),a=new Ft),t[n++]=a.x,t[n++]=a.y,t[n++]=a.z,t[n++]=a.w}return this}applyMatrix3(e){if(this.itemSize===2)for(let t=0,n=this.count;t<n;t++)sd.fromBufferAttribute(this,t),sd.applyMatrix3(e),this.setXY(t,sd.x,sd.y);else if(this.itemSize===3)for(let t=0,n=this.count;t<n;t++)si.fromBufferAttribute(this,t),si.applyMatrix3(e),this.setXYZ(t,si.x,si.y,si.z);return this}applyMatrix4(e){for(let t=0,n=this.count;t<n;t++)si.fromBufferAttribute(this,t),si.applyMatrix4(e),this.setXYZ(t,si.x,si.y,si.z);return this}applyNormalMatrix(e){for(let t=0,n=this.count;t<n;t++)si.fromBufferAttribute(this,t),si.applyNormalMatrix(e),this.setXYZ(t,si.x,si.y,si.z);return this}transformDirection(e){for(let t=0,n=this.count;t<n;t++)si.fromBufferAttribute(this,t),si.transformDirection(e),this.setXYZ(t,si.x,si.y,si.z);return this}set(e,t=0){return this.array.set(e,t),this}getX(e){return this.array[e*this.itemSize]}setX(e,t){return this.array[e*this.itemSize]=t,this}getY(e){return this.array[e*this.itemSize+1]}setY(e,t){return this.array[e*this.itemSize+1]=t,this}getZ(e){return this.array[e*this.itemSize+2]}setZ(e,t){return this.array[e*this.itemSize+2]=t,this}getW(e){return this.array[e*this.itemSize+3]}setW(e,t){return this.array[e*this.itemSize+3]=t,this}setXY(e,t,n){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=n,this}setXYZ(e,t,n,i){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=n,this.array[e+2]=i,this}setXYZW(e,t,n,i,r){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=n,this.array[e+2]=i,this.array[e+3]=r,this}onUpload(e){return this.onUploadCallback=e,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const e={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized};return this.name!==""&&(e.name=this.name),this.usage!==Pu&&(e.usage=this.usage),(this.updateRange.offset!==0||this.updateRange.count!==-1)&&(e.updateRange=this.updateRange),e}}Sn.prototype.isBufferAttribute=!0;class qo extends Sn{constructor(e,t,n){super(new Uint16Array(e),t,n)}}class jo extends Sn{constructor(e,t,n){super(new Uint32Array(e),t,n)}}class ZT extends Sn{constructor(e,t,n){super(new Uint16Array(e),t,n)}}ZT.prototype.isFloat16BufferAttribute=!0;class Vt extends Sn{constructor(e,t,n){super(new Float32Array(e),t,n)}}let $T=0;const wr=new Ne,Tm=new fn,vl=new T,ur=new Tt,Zc=new Tt,bi=new T;class Xt extends Yo{constructor(){super(),Object.defineProperty(this,"id",{value:$T++}),this.uuid=Qr(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(e){return Array.isArray(e)?this.index=new(QS(e)?jo:qo)(e,1):this.index=e,this}getAttribute(e){return this.attributes[e]}setAttribute(e,t){return this.attributes[e]=t,this}deleteAttribute(e){return delete this.attributes[e],this}hasAttribute(e){return this.attributes[e]!==void 0}addGroup(e,t,n=0){this.groups.push({start:e,count:t,materialIndex:n})}clearGroups(){this.groups=[]}setDrawRange(e,t){this.drawRange.start=e,this.drawRange.count=t}applyMatrix4(e){const t=this.attributes.position;t!==void 0&&(t.applyMatrix4(e),t.needsUpdate=!0);const n=this.attributes.normal;if(n!==void 0){const r=new Hn().getNormalMatrix(e);n.applyNormalMatrix(r),n.needsUpdate=!0}const i=this.attributes.tangent;return i!==void 0&&(i.transformDirection(e),i.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(e){return wr.makeRotationFromQuaternion(e),this.applyMatrix4(wr),this}rotateX(e){return wr.makeRotationX(e),this.applyMatrix4(wr),this}rotateY(e){return wr.makeRotationY(e),this.applyMatrix4(wr),this}rotateZ(e){return wr.makeRotationZ(e),this.applyMatrix4(wr),this}translate(e,t,n){return wr.makeTranslation(e,t,n),this.applyMatrix4(wr),this}scale(e,t,n){return wr.makeScale(e,t,n),this.applyMatrix4(wr),this}lookAt(e){return Tm.lookAt(e),Tm.updateMatrix(),this.applyMatrix4(Tm.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(vl).negate(),this.translate(vl.x,vl.y,vl.z),this}setFromPoints(e){const t=[];for(let n=0,i=e.length;n<i;n++){const r=e[n];t.push(r.x,r.y,r.z||0)}return this.setAttribute("position",new Vt(t,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Tt);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingBox.set(new T(-1/0,-1/0,-1/0),new T(1/0,1/0,1/0));return}if(e!==void 0){if(this.boundingBox.setFromBufferAttribute(e),t)for(let n=0,i=t.length;n<i;n++){const r=t[n];ur.setFromBufferAttribute(r),this.morphTargetsRelative?(bi.addVectors(this.boundingBox.min,ur.min),this.boundingBox.expandByPoint(bi),bi.addVectors(this.boundingBox.max,ur.max),this.boundingBox.expandByPoint(bi)):(this.boundingBox.expandByPoint(ur.min),this.boundingBox.expandByPoint(ur.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Zn);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingSphere.set(new T,1/0);return}if(e){const n=this.boundingSphere.center;if(ur.setFromBufferAttribute(e),t)for(let r=0,a=t.length;r<a;r++){const o=t[r];Zc.setFromBufferAttribute(o),this.morphTargetsRelative?(bi.addVectors(ur.min,Zc.min),ur.expandByPoint(bi),bi.addVectors(ur.max,Zc.max),ur.expandByPoint(bi)):(ur.expandByPoint(Zc.min),ur.expandByPoint(Zc.max))}ur.getCenter(n);let i=0;for(let r=0,a=e.count;r<a;r++)bi.fromBufferAttribute(e,r),i=Math.max(i,n.distanceToSquared(bi));if(t)for(let r=0,a=t.length;r<a;r++){const o=t[r],l=this.morphTargetsRelative;for(let c=0,u=o.count;c<u;c++)bi.fromBufferAttribute(o,c),l&&(vl.fromBufferAttribute(e,c),bi.add(vl)),i=Math.max(i,n.distanceToSquared(bi))}this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const e=this.index,t=this.attributes;if(e===null||t.position===void 0||t.normal===void 0||t.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const n=e.array,i=t.position.array,r=t.normal.array,a=t.uv.array,o=i.length/3;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new Sn(new Float32Array(4*o),4));const l=this.getAttribute("tangent").array,c=[],u=[];for(let z=0;z<o;z++)c[z]=new T,u[z]=new T;const h=new T,d=new T,f=new T,v=new Me,g=new Me,m=new Me,x=new T,w=new T;function S(z,V,U){h.fromArray(i,z*3),d.fromArray(i,V*3),f.fromArray(i,U*3),v.fromArray(a,z*2),g.fromArray(a,V*2),m.fromArray(a,U*2),d.sub(h),f.sub(h),g.sub(v),m.sub(v);const j=1/(g.x*m.y-m.x*g.y);isFinite(j)&&(x.copy(d).multiplyScalar(m.y).addScaledVector(f,-g.y).multiplyScalar(j),w.copy(f).multiplyScalar(g.x).addScaledVector(d,-m.x).multiplyScalar(j),c[z].add(x),c[V].add(x),c[U].add(x),u[z].add(w),u[V].add(w),u[U].add(w))}let b=this.groups;b.length===0&&(b=[{start:0,count:n.length}]);for(let z=0,V=b.length;z<V;++z){const U=b[z],j=U.start,F=U.count;for(let K=j,J=j+F;K<J;K+=3)S(n[K+0],n[K+1],n[K+2])}const E=new T,C=new T,P=new T,M=new T;function L(z){P.fromArray(r,z*3),M.copy(P);const V=c[z];E.copy(V),E.sub(P.multiplyScalar(P.dot(V))).normalize(),C.crossVectors(M,V);const j=C.dot(u[z])<0?-1:1;l[z*4]=E.x,l[z*4+1]=E.y,l[z*4+2]=E.z,l[z*4+3]=j}for(let z=0,V=b.length;z<V;++z){const U=b[z],j=U.start,F=U.count;for(let K=j,J=j+F;K<J;K+=3)L(n[K+0]),L(n[K+1]),L(n[K+2])}}computeVertexNormals(){const e=this.index,t=this.getAttribute("position");if(t!==void 0){let n=this.getAttribute("normal");if(n===void 0)n=new Sn(new Float32Array(t.count*3),3),this.setAttribute("normal",n);else for(let d=0,f=n.count;d<f;d++)n.setXYZ(d,0,0,0);const i=new T,r=new T,a=new T,o=new T,l=new T,c=new T,u=new T,h=new T;if(e)for(let d=0,f=e.count;d<f;d+=3){const v=e.getX(d+0),g=e.getX(d+1),m=e.getX(d+2);i.fromBufferAttribute(t,v),r.fromBufferAttribute(t,g),a.fromBufferAttribute(t,m),u.subVectors(a,r),h.subVectors(i,r),u.cross(h),o.fromBufferAttribute(n,v),l.fromBufferAttribute(n,g),c.fromBufferAttribute(n,m),o.add(u),l.add(u),c.add(u),n.setXYZ(v,o.x,o.y,o.z),n.setXYZ(g,l.x,l.y,l.z),n.setXYZ(m,c.x,c.y,c.z)}else for(let d=0,f=t.count;d<f;d+=3)i.fromBufferAttribute(t,d+0),r.fromBufferAttribute(t,d+1),a.fromBufferAttribute(t,d+2),u.subVectors(a,r),h.subVectors(i,r),u.cross(h),n.setXYZ(d+0,u.x,u.y,u.z),n.setXYZ(d+1,u.x,u.y,u.z),n.setXYZ(d+2,u.x,u.y,u.z);this.normalizeNormals(),n.needsUpdate=!0}}merge(e,t){if(!(e&&e.isBufferGeometry)){console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",e);return}t===void 0&&(t=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const n=this.attributes;for(const i in n){if(e.attributes[i]===void 0)continue;const a=n[i].array,o=e.attributes[i],l=o.array,c=o.itemSize*t,u=Math.min(l.length,a.length-c);for(let h=0,d=c;h<u;h++,d++)a[d]=l[h]}return this}normalizeNormals(){const e=this.attributes.normal;for(let t=0,n=e.count;t<n;t++)bi.fromBufferAttribute(e,t),bi.normalize(),e.setXYZ(t,bi.x,bi.y,bi.z)}toNonIndexed(){function e(o,l){const c=o.array,u=o.itemSize,h=o.normalized,d=new c.constructor(l.length*u);let f=0,v=0;for(let g=0,m=l.length;g<m;g++){o.isInterleavedBufferAttribute?f=l[g]*o.data.stride+o.offset:f=l[g]*u;for(let x=0;x<u;x++)d[v++]=c[f++]}return new Sn(d,u,h)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const t=new Xt,n=this.index.array,i=this.attributes;for(const o in i){const l=i[o],c=e(l,n);t.setAttribute(o,c)}const r=this.morphAttributes;for(const o in r){const l=[],c=r[o];for(let u=0,h=c.length;u<h;u++){const d=c[u],f=e(d,n);l.push(f)}t.morphAttributes[o]=l}t.morphTargetsRelative=this.morphTargetsRelative;const a=this.groups;for(let o=0,l=a.length;o<l;o++){const c=a[o];t.addGroup(c.start,c.count,c.materialIndex)}return t}toJSON(){const e={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,this.name!==""&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),this.parameters!==void 0){const l=this.parameters;for(const c in l)l[c]!==void 0&&(e[c]=l[c]);return e}e.data={attributes:{}};const t=this.index;t!==null&&(e.data.index={type:t.array.constructor.name,array:Array.prototype.slice.call(t.array)});const n=this.attributes;for(const l in n){const c=n[l];e.data.attributes[l]=c.toJSON(e.data)}const i={};let r=!1;for(const l in this.morphAttributes){const c=this.morphAttributes[l],u=[];for(let h=0,d=c.length;h<d;h++){const f=c[h];u.push(f.toJSON(e.data))}u.length>0&&(i[l]=u,r=!0)}r&&(e.data.morphAttributes=i,e.data.morphTargetsRelative=this.morphTargetsRelative);const a=this.groups;a.length>0&&(e.data.groups=JSON.parse(JSON.stringify(a)));const o=this.boundingSphere;return o!==null&&(e.data.boundingSphere={center:o.center.toArray(),radius:o.radius}),e}clone(){return new this.constructor().copy(this)}copy(e){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const t={};this.name=e.name;const n=e.index;n!==null&&this.setIndex(n.clone(t));const i=e.attributes;for(const c in i){const u=i[c];this.setAttribute(c,u.clone(t))}const r=e.morphAttributes;for(const c in r){const u=[],h=r[c];for(let d=0,f=h.length;d<f;d++)u.push(h[d].clone(t));this.morphAttributes[c]=u}this.morphTargetsRelative=e.morphTargetsRelative;const a=e.groups;for(let c=0,u=a.length;c<u;c++){const h=a[c];this.addGroup(h.start,h.count,h.materialIndex)}const o=e.boundingBox;o!==null&&(this.boundingBox=o.clone());const l=e.boundingSphere;return l!==null&&(this.boundingSphere=l.clone()),this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,this.userData=e.userData,e.parameters!==void 0&&(this.parameters=Object.assign({},e.parameters)),this}dispose(){this.dispatchEvent({type:"dispose"})}}Xt.prototype.isBufferGeometry=!0;const py=new Ne,yl=new Ti,Em=new Zn,ga=new T,va=new T,ya=new T,Mm=new T,Cm=new T,Rm=new T,ad=new T,od=new T,ld=new T,cd=new Me,ud=new Me,hd=new Me,Im=new T,dd=new T;class gn extends fn{constructor(e=new Xt,t=new Ja){super(),this.type="Mesh",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e){return super.copy(e),e.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),e.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=e.material,this.geometry=e.geometry,this}updateMorphTargets(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes,n=Object.keys(t);if(n.length>0){const i=t[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,a=i.length;r<a;r++){const o=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=r}}}}else{const t=e.morphTargets;t!==void 0&&t.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}raycast(e,t){const n=this.geometry,i=this.material,r=this.matrixWorld;if(i===void 0||(n.boundingSphere===null&&n.computeBoundingSphere(),Em.copy(n.boundingSphere),Em.applyMatrix4(r),e.ray.intersectsSphere(Em)===!1)||(py.copy(r).invert(),yl.copy(e.ray).applyMatrix4(py),n.boundingBox!==null&&yl.intersectsBox(n.boundingBox)===!1))return;let a;if(n.isBufferGeometry){const o=n.index,l=n.attributes.position,c=n.morphAttributes.position,u=n.morphTargetsRelative,h=n.attributes.uv,d=n.attributes.uv2,f=n.groups,v=n.drawRange;if(o!==null)if(Array.isArray(i))for(let g=0,m=f.length;g<m;g++){const x=f[g],w=i[x.materialIndex],S=Math.max(x.start,v.start),b=Math.min(o.count,Math.min(x.start+x.count,v.start+v.count));for(let E=S,C=b;E<C;E+=3){const P=o.getX(E),M=o.getX(E+1),L=o.getX(E+2);a=fd(this,w,e,yl,l,c,u,h,d,P,M,L),a&&(a.faceIndex=Math.floor(E/3),a.face.materialIndex=x.materialIndex,t.push(a))}}else{const g=Math.max(0,v.start),m=Math.min(o.count,v.start+v.count);for(let x=g,w=m;x<w;x+=3){const S=o.getX(x),b=o.getX(x+1),E=o.getX(x+2);a=fd(this,i,e,yl,l,c,u,h,d,S,b,E),a&&(a.faceIndex=Math.floor(x/3),t.push(a))}}else if(l!==void 0)if(Array.isArray(i))for(let g=0,m=f.length;g<m;g++){const x=f[g],w=i[x.materialIndex],S=Math.max(x.start,v.start),b=Math.min(l.count,Math.min(x.start+x.count,v.start+v.count));for(let E=S,C=b;E<C;E+=3){const P=E,M=E+1,L=E+2;a=fd(this,w,e,yl,l,c,u,h,d,P,M,L),a&&(a.faceIndex=Math.floor(E/3),a.face.materialIndex=x.materialIndex,t.push(a))}}else{const g=Math.max(0,v.start),m=Math.min(l.count,v.start+v.count);for(let x=g,w=m;x<w;x+=3){const S=x,b=x+1,E=x+2;a=fd(this,i,e,yl,l,c,u,h,d,S,b,E),a&&(a.faceIndex=Math.floor(x/3),t.push(a))}}}else n.isGeometry&&console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}gn.prototype.isMesh=!0;function eE(s,e,t,n,i,r,a,o){let l;if(e.side===er?l=n.intersectTriangle(a,r,i,!0,o):l=n.intersectTriangle(i,r,a,e.side!==Qt,o),l===null)return null;dd.copy(o),dd.applyMatrix4(s.matrixWorld);const c=t.ray.origin.distanceTo(dd);return c<t.near||c>t.far?null:{distance:c,point:dd.clone(),object:s}}function fd(s,e,t,n,i,r,a,o,l,c,u,h){ga.fromBufferAttribute(i,c),va.fromBufferAttribute(i,u),ya.fromBufferAttribute(i,h);const d=s.morphTargetInfluences;if(r&&d){ad.set(0,0,0),od.set(0,0,0),ld.set(0,0,0);for(let v=0,g=r.length;v<g;v++){const m=d[v],x=r[v];m!==0&&(Mm.fromBufferAttribute(x,c),Cm.fromBufferAttribute(x,u),Rm.fromBufferAttribute(x,h),a?(ad.addScaledVector(Mm,m),od.addScaledVector(Cm,m),ld.addScaledVector(Rm,m)):(ad.addScaledVector(Mm.sub(ga),m),od.addScaledVector(Cm.sub(va),m),ld.addScaledVector(Rm.sub(ya),m)))}ga.add(ad),va.add(od),ya.add(ld)}s.isSkinnedMesh&&(s.boneTransform(c,ga),s.boneTransform(u,va),s.boneTransform(h,ya));const f=eE(s,e,t,n,ga,va,ya,Im);if(f){o&&(cd.fromBufferAttribute(o,c),ud.fromBufferAttribute(o,u),hd.fromBufferAttribute(o,h),f.uv=Cn.getUV(Im,ga,va,ya,cd,ud,hd,new Me)),l&&(cd.fromBufferAttribute(l,c),ud.fromBufferAttribute(l,u),hd.fromBufferAttribute(l,h),f.uv2=Cn.getUV(Im,ga,va,ya,cd,ud,hd,new Me));const v={a:c,b:u,c:h,normal:new T,materialIndex:0};Cn.getNormal(ga,va,ya,v.normal),f.face=v}return f}class Sh extends Xt{constructor(e=1,t=1,n=1,i=1,r=1,a=1){super(),this.type="BoxGeometry",this.parameters={width:e,height:t,depth:n,widthSegments:i,heightSegments:r,depthSegments:a};const o=this;i=Math.floor(i),r=Math.floor(r),a=Math.floor(a);const l=[],c=[],u=[],h=[];let d=0,f=0;v("z","y","x",-1,-1,n,t,e,a,r,0),v("z","y","x",1,-1,n,t,-e,a,r,1),v("x","z","y",1,1,e,n,t,i,a,2),v("x","z","y",1,-1,e,n,-t,i,a,3),v("x","y","z",1,-1,e,t,n,i,r,4),v("x","y","z",-1,-1,e,t,-n,i,r,5),this.setIndex(l),this.setAttribute("position",new Vt(c,3)),this.setAttribute("normal",new Vt(u,3)),this.setAttribute("uv",new Vt(h,2));function v(g,m,x,w,S,b,E,C,P,M,L){const z=b/P,V=E/M,U=b/2,j=E/2,F=C/2,K=P+1,J=M+1;let se=0,le=0;const q=new T;for(let te=0;te<J;te++){const H=te*V-j;for(let $=0;$<K;$++){const ce=$*z-U;q[g]=ce*w,q[m]=H*S,q[x]=F,c.push(q.x,q.y,q.z),q[g]=0,q[m]=0,q[x]=C>0?1:-1,u.push(q.x,q.y,q.z),h.push($/P),h.push(1-te/M),se+=1}}for(let te=0;te<M;te++)for(let H=0;H<P;H++){const $=d+H+K*te,ce=d+H+K*(te+1),xe=d+(H+1)+K*(te+1),pe=d+(H+1)+K*te;l.push($,ce,pe),l.push(ce,xe,pe),le+=6}o.addGroup(f,le,L),f+=le,d+=se}}static fromJSON(e){return new Sh(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)}}function yc(s){const e={};for(const t in s){e[t]={};for(const n in s[t]){const i=s[t][n];i&&(i.isColor||i.isMatrix3||i.isMatrix4||i.isVector2||i.isVector3||i.isVector4||i.isTexture||i.isQuaternion)?e[t][n]=i.clone():Array.isArray(i)?e[t][n]=i.slice():e[t][n]=i}}return e}function Gi(s){const e={};for(let t=0;t<s.length;t++){const n=yc(s[t]);for(const i in n)e[i]=n[i]}return e}const Ga={clone:yc,merge:Gi};var tE=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,nE=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class $n extends di{constructor(e){super(),this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader=tE,this.fragmentShader=nE,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,e!==void 0&&(e.attributes!==void 0&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(e))}copy(e){return super.copy(e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=yc(e.uniforms),this.defines=Object.assign({},e.defines),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.fog=e.fog,this.lights=e.lights,this.clipping=e.clipping,this.extensions=Object.assign({},e.extensions),this.glslVersion=e.glslVersion,this}toJSON(e){const t=super.toJSON(e);t.glslVersion=this.glslVersion,t.uniforms={};for(const i in this.uniforms){const a=this.uniforms[i].value;a&&a.isTexture?t.uniforms[i]={type:"t",value:a.toJSON(e).uuid}:a&&a.isColor?t.uniforms[i]={type:"c",value:a.getHex()}:a&&a.isVector2?t.uniforms[i]={type:"v2",value:a.toArray()}:a&&a.isVector3?t.uniforms[i]={type:"v3",value:a.toArray()}:a&&a.isVector4?t.uniforms[i]={type:"v4",value:a.toArray()}:a&&a.isMatrix3?t.uniforms[i]={type:"m3",value:a.toArray()}:a&&a.isMatrix4?t.uniforms[i]={type:"m4",value:a.toArray()}:t.uniforms[i]={value:a}}Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader;const n={};for(const i in this.extensions)this.extensions[i]===!0&&(n[i]=!0);return Object.keys(n).length>0&&(t.extensions=n),t}}$n.prototype.isShaderMaterial=!0;class Dp extends fn{constructor(){super(),this.type="Camera",this.matrixWorldInverse=new Ne,this.projectionMatrix=new Ne,this.projectionMatrixInverse=new Ne}copy(e,t){return super.copy(e,t),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(-t[8],-t[9],-t[10]).normalize()}updateMatrixWorld(e){super.updateMatrixWorld(e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(e,t){super.updateWorldMatrix(e,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}Dp.prototype.isCamera=!0;class li extends Dp{constructor(e=50,t=1,n=.1,i=2e3){super(),this.type="PerspectiveCamera",this.fov=e,this.zoom=1,this.near=n,this.far=i,this.focus=10,this.aspect=t,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=e.view===null?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this}setFocalLength(e){const t=.5*this.getFilmHeight()/e;this.fov=Du*2*Math.atan(t),this.updateProjectionMatrix()}getFocalLength(){const e=Math.tan(vu*.5*this.fov);return .5*this.getFilmHeight()/e}getEffectiveFOV(){return Du*2*Math.atan(Math.tan(vu*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(e,t,n,i,r,a){this.aspect=e/t,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=n,this.view.offsetY=i,this.view.width=r,this.view.height=a,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=this.near;let t=e*Math.tan(vu*.5*this.fov)/this.zoom,n=2*t,i=this.aspect*n,r=-.5*i;const a=this.view;if(this.view!==null&&this.view.enabled){const l=a.fullWidth,c=a.fullHeight;r+=a.offsetX*i/l,t-=a.offsetY*n/c,i*=a.width/l,n*=a.height/c}const o=this.filmOffset;o!==0&&(r+=e*o/this.getFilmWidth()),this.projectionMatrix.makePerspective(r,r+i,t,t-n,e,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.fov=this.fov,t.object.zoom=this.zoom,t.object.near=this.near,t.object.far=this.far,t.object.focus=this.focus,t.object.aspect=this.aspect,this.view!==null&&(t.object.view=Object.assign({},this.view)),t.object.filmGauge=this.filmGauge,t.object.filmOffset=this.filmOffset,t}}li.prototype.isPerspectiveCamera=!0;const xl=90,wl=1;class Fv extends fn{constructor(e,t,n){if(super(),this.type="CubeCamera",n.isWebGLCubeRenderTarget!==!0){console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");return}this.renderTarget=n;const i=new li(xl,wl,e,t);i.layers=this.layers,i.up.set(0,-1,0),i.lookAt(new T(1,0,0)),this.add(i);const r=new li(xl,wl,e,t);r.layers=this.layers,r.up.set(0,-1,0),r.lookAt(new T(-1,0,0)),this.add(r);const a=new li(xl,wl,e,t);a.layers=this.layers,a.up.set(0,0,1),a.lookAt(new T(0,1,0)),this.add(a);const o=new li(xl,wl,e,t);o.layers=this.layers,o.up.set(0,0,-1),o.lookAt(new T(0,-1,0)),this.add(o);const l=new li(xl,wl,e,t);l.layers=this.layers,l.up.set(0,-1,0),l.lookAt(new T(0,0,1)),this.add(l);const c=new li(xl,wl,e,t);c.layers=this.layers,c.up.set(0,-1,0),c.lookAt(new T(0,0,-1)),this.add(c)}update(e,t){this.parent===null&&this.updateMatrixWorld();const n=this.renderTarget,[i,r,a,o,l,c]=this.children,u=e.getRenderTarget(),h=e.toneMapping,d=e.xr.enabled;e.toneMapping=js,e.xr.enabled=!1;const f=n.texture.generateMipmaps;n.texture.generateMipmaps=!1,e.setRenderTarget(n,0),e.render(t,i),e.setRenderTarget(n,1),e.render(t,r),e.setRenderTarget(n,2),e.render(t,a),e.setRenderTarget(n,3),e.render(t,o),e.setRenderTarget(n,4),e.render(t,l),n.texture.generateMipmaps=f,e.setRenderTarget(n,5),e.render(t,c),e.setRenderTarget(u),e.toneMapping=h,e.xr.enabled=d,n.texture.needsPMREMUpdate=!0}}class Lp extends hi{constructor(e,t,n,i,r,a,o,l,c,u){e=e!==void 0?e:[],t=t!==void 0?t:mc,super(e,t,n,i,r,a,o,l,c,u),this.flipY=!1}get images(){return this.image}set images(e){this.image=e}}Lp.prototype.isCubeTexture=!0;class Uv extends Yn{constructor(e,t={}){super(e,e,t);const n={width:e,height:e,depth:1},i=[n,n,n,n,n,n];this.texture=new Lp(i,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.encoding),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=t.generateMipmaps!==void 0?t.generateMipmaps:!1,this.texture.minFilter=t.minFilter!==void 0?t.minFilter:cn}fromEquirectangularTexture(e,t){this.texture.type=t.type,this.texture.encoding=t.encoding,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;const n={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},i=new Sh(5,5,5),r=new $n({name:"CubemapFromEquirect",uniforms:yc(n.uniforms),vertexShader:n.vertexShader,fragmentShader:n.fragmentShader,side:er,blending:ui});r.uniforms.tEquirect.value=t;const a=new gn(i,r),o=t.minFilter;return t.minFilter===wh&&(t.minFilter=cn),new Fv(1,10,this).update(e,a),t.minFilter=o,a.geometry.dispose(),a.material.dispose(),this}clear(e,t,n,i){const r=e.getRenderTarget();for(let a=0;a<6;a++)e.setRenderTarget(this,a),e.clear(t,n,i);e.setRenderTarget(r)}}Uv.prototype.isWebGLCubeRenderTarget=!0;const Pm=new T,iE=new T,rE=new Hn;class vi{constructor(e=new T(1,0,0),t=0){this.normal=e,this.constant=t}set(e,t){return this.normal.copy(e),this.constant=t,this}setComponents(e,t,n,i){return this.normal.set(e,t,n),this.constant=i,this}setFromNormalAndCoplanarPoint(e,t){return this.normal.copy(e),this.constant=-t.dot(this.normal),this}setFromCoplanarPoints(e,t,n){const i=Pm.subVectors(n,t).cross(iE.subVectors(e,t)).normalize();return this.setFromNormalAndCoplanarPoint(i,e),this}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){const e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,t){return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)}intersectLine(e,t){const n=e.delta(Pm),i=this.normal.dot(n);if(i===0)return this.distanceToPoint(e.start)===0?t.copy(e.start):null;const r=-(e.start.dot(this.normal)+this.constant)/i;return r<0||r>1?null:t.copy(n).multiplyScalar(r).add(e.start)}intersectsLine(e){const t=this.distanceToPoint(e.start),n=this.distanceToPoint(e.end);return t<0&&n>0||n<0&&t>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,t){const n=t||rE.getNormalMatrix(e),i=this.coplanarPoint(Pm).applyMatrix4(e),r=this.normal.applyMatrix3(n).normalize();return this.constant=-i.dot(r),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}clone(){return new this.constructor().copy(this)}}vi.prototype.isPlane=!0;const Sl=new Zn,pd=new T;class bh{constructor(e=new vi,t=new vi,n=new vi,i=new vi,r=new vi,a=new vi){this.planes=[e,t,n,i,r,a]}set(e,t,n,i,r,a){const o=this.planes;return o[0].copy(e),o[1].copy(t),o[2].copy(n),o[3].copy(i),o[4].copy(r),o[5].copy(a),this}copy(e){const t=this.planes;for(let n=0;n<6;n++)t[n].copy(e.planes[n]);return this}setFromProjectionMatrix(e){const t=this.planes,n=e.elements,i=n[0],r=n[1],a=n[2],o=n[3],l=n[4],c=n[5],u=n[6],h=n[7],d=n[8],f=n[9],v=n[10],g=n[11],m=n[12],x=n[13],w=n[14],S=n[15];return t[0].setComponents(o-i,h-l,g-d,S-m).normalize(),t[1].setComponents(o+i,h+l,g+d,S+m).normalize(),t[2].setComponents(o+r,h+c,g+f,S+x).normalize(),t[3].setComponents(o-r,h-c,g-f,S-x).normalize(),t[4].setComponents(o-a,h-u,g-v,S-w).normalize(),t[5].setComponents(o+a,h+u,g+v,S+w).normalize(),this}intersectsObject(e){const t=e.geometry;return t.boundingSphere===null&&t.computeBoundingSphere(),Sl.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),this.intersectsSphere(Sl)}intersectsSprite(e){return Sl.center.set(0,0,0),Sl.radius=.7071067811865476,Sl.applyMatrix4(e.matrixWorld),this.intersectsSphere(Sl)}intersectsSphere(e){const t=this.planes,n=e.center,i=-e.radius;for(let r=0;r<6;r++)if(t[r].distanceToPoint(n)<i)return!1;return!0}intersectsBox(e){const t=this.planes;for(let n=0;n<6;n++){const i=t[n];if(pd.x=i.normal.x>0?e.max.x:e.min.x,pd.y=i.normal.y>0?e.max.y:e.min.y,pd.z=i.normal.z>0?e.max.z:e.min.z,i.distanceToPoint(pd)<0)return!1}return!0}containsPoint(e){const t=this.planes;for(let n=0;n<6;n++)if(t[n].distanceToPoint(e)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}function JS(){let s=null,e=!1,t=null,n=null;function i(r,a){t(r,a),n=s.requestAnimationFrame(i)}return{start:function(){e!==!0&&t!==null&&(n=s.requestAnimationFrame(i),e=!0)},stop:function(){s.cancelAnimationFrame(n),e=!1},setAnimationLoop:function(r){t=r},setContext:function(r){s=r}}}function sE(s,e){const t=e.isWebGL2,n=new WeakMap;function i(c,u){const h=c.array,d=c.usage,f=s.createBuffer();s.bindBuffer(u,f),s.bufferData(u,h,d),c.onUploadCallback();let v;if(h instanceof Float32Array)v=5126;else if(h instanceof Uint16Array)if(c.isFloat16BufferAttribute)if(t)v=5131;else throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");else v=5123;else if(h instanceof Int16Array)v=5122;else if(h instanceof Uint32Array)v=5125;else if(h instanceof Int32Array)v=5124;else if(h instanceof Int8Array)v=5120;else if(h instanceof Uint8Array)v=5121;else if(h instanceof Uint8ClampedArray)v=5121;else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+h);return{buffer:f,type:v,bytesPerElement:h.BYTES_PER_ELEMENT,version:c.version}}function r(c,u,h){const d=u.array,f=u.updateRange;s.bindBuffer(h,c),f.count===-1?s.bufferSubData(h,0,d):(t?s.bufferSubData(h,f.offset*d.BYTES_PER_ELEMENT,d,f.offset,f.count):s.bufferSubData(h,f.offset*d.BYTES_PER_ELEMENT,d.subarray(f.offset,f.offset+f.count)),f.count=-1)}function a(c){return c.isInterleavedBufferAttribute&&(c=c.data),n.get(c)}function o(c){c.isInterleavedBufferAttribute&&(c=c.data);const u=n.get(c);u&&(s.deleteBuffer(u.buffer),n.delete(c))}function l(c,u){if(c.isGLBufferAttribute){const d=n.get(c);(!d||d.version<c.version)&&n.set(c,{buffer:c.buffer,type:c.type,bytesPerElement:c.elementSize,version:c.version});return}c.isInterleavedBufferAttribute&&(c=c.data);const h=n.get(c);h===void 0?n.set(c,i(c,u)):h.version<c.version&&(r(h.buffer,c,u),h.version=c.version)}return{get:a,remove:o,update:l}}class Ks extends Xt{constructor(e=1,t=1,n=1,i=1){super(),this.type="PlaneGeometry",this.parameters={width:e,height:t,widthSegments:n,heightSegments:i};const r=e/2,a=t/2,o=Math.floor(n),l=Math.floor(i),c=o+1,u=l+1,h=e/o,d=t/l,f=[],v=[],g=[],m=[];for(let x=0;x<u;x++){const w=x*d-a;for(let S=0;S<c;S++){const b=S*h-r;v.push(b,-w,0),g.push(0,0,1),m.push(S/o),m.push(1-x/l)}}for(let x=0;x<l;x++)for(let w=0;w<o;w++){const S=w+c*x,b=w+c*(x+1),E=w+1+c*(x+1),C=w+1+c*x;f.push(S,b,C),f.push(b,E,C)}this.setIndex(f),this.setAttribute("position",new Vt(v,3)),this.setAttribute("normal",new Vt(g,3)),this.setAttribute("uv",new Vt(m,2))}static fromJSON(e){return new Ks(e.width,e.height,e.widthSegments,e.heightSegments)}}var aE=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,oE=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,lE=`#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,cE=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,uE=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,hE=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,dE="vec3 transformed = vec3( position );",fE=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,pE=`vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`,mE=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,gE=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,vE=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,yE=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,xE=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,wE=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,SE=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,bE=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,AE=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,TE=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,EE=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,ME=`vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,CE=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,RE=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,IE=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,PE=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,DE="gl_FragColor = linearToOutputTexel( gl_FragColor );",LE=`vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,BE=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,OE=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,NE=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,zE=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,FE=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,UE=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,kE=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,_E=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,VE=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,GE=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`,HE=`#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,WE=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,qE=`vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointLightInfo( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotLightInfo( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );
		#endif
	}
	#pragma unroll_loop_end
#endif`,jE=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,QE=`#if defined( USE_ENVMAP )
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`,XE=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,JE=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`,KE=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,YE=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`,ZE=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`,$E=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	vec3 FssEss = specularColor * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,eM=`
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,tM=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,nM=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,iM=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,rM=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,sM=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,aM=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,oM=`#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,lM=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,cM=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,uM=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,hM=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,dM=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,fM=`#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,pM=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,mM=`#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,gM=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,vM=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,yM=`#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,xM=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,wM=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,SM=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,bM=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`,AM=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,TM=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`,EM=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,MM=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,CM=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,RM=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,IM=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,PM=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,DM=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,LM=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,BM=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,OM=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,NM=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,zM=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`,FM=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,UM=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,kM=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`,_M=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,VM=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,GM=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,HM=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,WM=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,qM=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,jM=`#ifdef USE_TRANSMISSION
	float transmissionAlpha = 1.0;
	float transmissionFactor = transmission;
	float thicknessFactor = thickness;
	#ifdef USE_TRANSMISSIONMAP
		transmissionFactor *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		thicknessFactor *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,
		attenuationColor, attenuationDistance );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );
	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );
#endif`,QM=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef texture2DLodEXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( attenuationDistance == 0.0 ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`,XM=`#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,JM=`#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,KM=`#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,YM=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,ZM=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,$M=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,eC=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;const tC=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,nC=`uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	gl_FragColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		gl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );
	#endif
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,iC=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,rC=`#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,sC=`#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,aC=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,oC=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,lC=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,cC=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,uC=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,hC=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,dC=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,fC=`#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,pC=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,mC=`#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,gC=`uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,vC=`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,yC=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,xC=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,wC=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,SC=`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,bC=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,AC=`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,TC=`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,EC=`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,MC=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,CC=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,RC=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,IC=`#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,PC=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,DC=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,LC=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,tn={alphamap_fragment:aE,alphamap_pars_fragment:oE,alphatest_fragment:lE,alphatest_pars_fragment:cE,aomap_fragment:uE,aomap_pars_fragment:hE,begin_vertex:dE,beginnormal_vertex:fE,bsdfs:pE,bumpmap_pars_fragment:mE,clipping_planes_fragment:gE,clipping_planes_pars_fragment:vE,clipping_planes_pars_vertex:yE,clipping_planes_vertex:xE,color_fragment:wE,color_pars_fragment:SE,color_pars_vertex:bE,color_vertex:AE,common:TE,cube_uv_reflection_fragment:EE,defaultnormal_vertex:ME,displacementmap_pars_vertex:CE,displacementmap_vertex:RE,emissivemap_fragment:IE,emissivemap_pars_fragment:PE,encodings_fragment:DE,encodings_pars_fragment:LE,envmap_fragment:BE,envmap_common_pars_fragment:OE,envmap_pars_fragment:NE,envmap_pars_vertex:zE,envmap_physical_pars_fragment:QE,envmap_vertex:FE,fog_vertex:UE,fog_pars_vertex:kE,fog_fragment:_E,fog_pars_fragment:VE,gradientmap_pars_fragment:GE,lightmap_fragment:HE,lightmap_pars_fragment:WE,lights_lambert_vertex:qE,lights_pars_begin:jE,lights_toon_fragment:XE,lights_toon_pars_fragment:JE,lights_phong_fragment:KE,lights_phong_pars_fragment:YE,lights_physical_fragment:ZE,lights_physical_pars_fragment:$E,lights_fragment_begin:eM,lights_fragment_maps:tM,lights_fragment_end:nM,logdepthbuf_fragment:iM,logdepthbuf_pars_fragment:rM,logdepthbuf_pars_vertex:sM,logdepthbuf_vertex:aM,map_fragment:oM,map_pars_fragment:lM,map_particle_fragment:cM,map_particle_pars_fragment:uM,metalnessmap_fragment:hM,metalnessmap_pars_fragment:dM,morphcolor_vertex:fM,morphnormal_vertex:pM,morphtarget_pars_vertex:mM,morphtarget_vertex:gM,normal_fragment_begin:vM,normal_fragment_maps:yM,normal_pars_fragment:xM,normal_pars_vertex:wM,normal_vertex:SM,normalmap_pars_fragment:bM,clearcoat_normal_fragment_begin:AM,clearcoat_normal_fragment_maps:TM,clearcoat_pars_fragment:EM,output_fragment:MM,packing:CM,premultiplied_alpha_fragment:RM,project_vertex:IM,dithering_fragment:PM,dithering_pars_fragment:DM,roughnessmap_fragment:LM,roughnessmap_pars_fragment:BM,shadowmap_pars_fragment:OM,shadowmap_pars_vertex:NM,shadowmap_vertex:zM,shadowmask_pars_fragment:FM,skinbase_vertex:UM,skinning_pars_vertex:kM,skinning_vertex:_M,skinnormal_vertex:VM,specularmap_fragment:GM,specularmap_pars_fragment:HM,tonemapping_fragment:WM,tonemapping_pars_fragment:qM,transmission_fragment:jM,transmission_pars_fragment:QM,uv_pars_fragment:XM,uv_pars_vertex:JM,uv_vertex:KM,uv2_pars_fragment:YM,uv2_pars_vertex:ZM,uv2_vertex:$M,worldpos_vertex:eC,background_vert:tC,background_frag:nC,cube_vert:iC,cube_frag:rC,depth_vert:sC,depth_frag:aC,distanceRGBA_vert:oC,distanceRGBA_frag:lC,equirect_vert:cC,equirect_frag:uC,linedashed_vert:hC,linedashed_frag:dC,meshbasic_vert:fC,meshbasic_frag:pC,meshlambert_vert:mC,meshlambert_frag:gC,meshmatcap_vert:vC,meshmatcap_frag:yC,meshnormal_vert:xC,meshnormal_frag:wC,meshphong_vert:SC,meshphong_frag:bC,meshphysical_vert:AC,meshphysical_frag:TC,meshtoon_vert:EC,meshtoon_frag:MC,points_vert:CC,points_frag:RC,shadow_vert:IC,shadow_frag:PC,sprite_vert:DC,sprite_frag:LC},xt={common:{diffuse:{value:new ot(16777215)},opacity:{value:1},map:{value:null},uvTransform:{value:new Hn},uv2Transform:{value:new Hn},alphaMap:{value:null},alphaTest:{value:0}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new Me(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new ot(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new ot(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new Hn}},sprite:{diffuse:{value:new ot(16777215)},opacity:{value:1},center:{value:new Me(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new Hn}}},Xn={basic:{uniforms:Gi([xt.common,xt.specularmap,xt.envmap,xt.aomap,xt.lightmap,xt.fog]),vertexShader:tn.meshbasic_vert,fragmentShader:tn.meshbasic_frag},lambert:{uniforms:Gi([xt.common,xt.specularmap,xt.envmap,xt.aomap,xt.lightmap,xt.emissivemap,xt.fog,xt.lights,{emissive:{value:new ot(0)}}]),vertexShader:tn.meshlambert_vert,fragmentShader:tn.meshlambert_frag},phong:{uniforms:Gi([xt.common,xt.specularmap,xt.envmap,xt.aomap,xt.lightmap,xt.emissivemap,xt.bumpmap,xt.normalmap,xt.displacementmap,xt.fog,xt.lights,{emissive:{value:new ot(0)},specular:{value:new ot(1118481)},shininess:{value:30}}]),vertexShader:tn.meshphong_vert,fragmentShader:tn.meshphong_frag},standard:{uniforms:Gi([xt.common,xt.envmap,xt.aomap,xt.lightmap,xt.emissivemap,xt.bumpmap,xt.normalmap,xt.displacementmap,xt.roughnessmap,xt.metalnessmap,xt.fog,xt.lights,{emissive:{value:new ot(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:tn.meshphysical_vert,fragmentShader:tn.meshphysical_frag},toon:{uniforms:Gi([xt.common,xt.aomap,xt.lightmap,xt.emissivemap,xt.bumpmap,xt.normalmap,xt.displacementmap,xt.gradientmap,xt.fog,xt.lights,{emissive:{value:new ot(0)}}]),vertexShader:tn.meshtoon_vert,fragmentShader:tn.meshtoon_frag},matcap:{uniforms:Gi([xt.common,xt.bumpmap,xt.normalmap,xt.displacementmap,xt.fog,{matcap:{value:null}}]),vertexShader:tn.meshmatcap_vert,fragmentShader:tn.meshmatcap_frag},points:{uniforms:Gi([xt.points,xt.fog]),vertexShader:tn.points_vert,fragmentShader:tn.points_frag},dashed:{uniforms:Gi([xt.common,xt.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:tn.linedashed_vert,fragmentShader:tn.linedashed_frag},depth:{uniforms:Gi([xt.common,xt.displacementmap]),vertexShader:tn.depth_vert,fragmentShader:tn.depth_frag},normal:{uniforms:Gi([xt.common,xt.bumpmap,xt.normalmap,xt.displacementmap,{opacity:{value:1}}]),vertexShader:tn.meshnormal_vert,fragmentShader:tn.meshnormal_frag},sprite:{uniforms:Gi([xt.sprite,xt.fog]),vertexShader:tn.sprite_vert,fragmentShader:tn.sprite_frag},background:{uniforms:{uvTransform:{value:new Hn},t2D:{value:null}},vertexShader:tn.background_vert,fragmentShader:tn.background_frag},cube:{uniforms:Gi([xt.envmap,{opacity:{value:1}}]),vertexShader:tn.cube_vert,fragmentShader:tn.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:tn.equirect_vert,fragmentShader:tn.equirect_frag},distanceRGBA:{uniforms:Gi([xt.common,xt.displacementmap,{referencePosition:{value:new T},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:tn.distanceRGBA_vert,fragmentShader:tn.distanceRGBA_frag},shadow:{uniforms:Gi([xt.lights,xt.fog,{color:{value:new ot(0)},opacity:{value:1}}]),vertexShader:tn.shadow_vert,fragmentShader:tn.shadow_frag}};Xn.physical={uniforms:Gi([Xn.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new Me(1,1)},clearcoatNormalMap:{value:null},sheen:{value:0},sheenColor:{value:new ot(0)},sheenColorMap:{value:null},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},transmission:{value:0},transmissionMap:{value:null},transmissionSamplerSize:{value:new Me},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:0},attenuationColor:{value:new ot(0)},specularIntensity:{value:1},specularIntensityMap:{value:null},specularColor:{value:new ot(1,1,1)},specularColorMap:{value:null}}]),vertexShader:tn.meshphysical_vert,fragmentShader:tn.meshphysical_frag};function BC(s,e,t,n,i,r){const a=new ot(0);let o=i===!0?0:1,l,c,u=null,h=0,d=null;function f(g,m){let x=!1,w=m.isScene===!0?m.background:null;w&&w.isTexture&&(w=e.get(w));const S=s.xr,b=S.getSession&&S.getSession();b&&b.environmentBlendMode==="additive"&&(w=null),w===null?v(a,o):w&&w.isColor&&(v(w,1),x=!0),(s.autoClear||x)&&s.clear(s.autoClearColor,s.autoClearDepth,s.autoClearStencil),w&&(w.isCubeTexture||w.mapping===Ip)?(c===void 0&&(c=new gn(new Sh(1,1,1),new $n({name:"BackgroundCubeMaterial",uniforms:yc(Xn.cube.uniforms),vertexShader:Xn.cube.vertexShader,fragmentShader:Xn.cube.fragmentShader,side:er,depthTest:!1,depthWrite:!1,fog:!1})),c.geometry.deleteAttribute("normal"),c.geometry.deleteAttribute("uv"),c.onBeforeRender=function(E,C,P){this.matrixWorld.copyPosition(P.matrixWorld)},Object.defineProperty(c.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),n.update(c)),c.material.uniforms.envMap.value=w,c.material.uniforms.flipEnvMap.value=w.isCubeTexture&&w.isRenderTargetTexture===!1?-1:1,(u!==w||h!==w.version||d!==s.toneMapping)&&(c.material.needsUpdate=!0,u=w,h=w.version,d=s.toneMapping),c.layers.enableAll(),g.unshift(c,c.geometry,c.material,0,0,null)):w&&w.isTexture&&(l===void 0&&(l=new gn(new Ks(2,2),new $n({name:"BackgroundMaterial",uniforms:yc(Xn.background.uniforms),vertexShader:Xn.background.vertexShader,fragmentShader:Xn.background.fragmentShader,side:gr,depthTest:!1,depthWrite:!1,fog:!1})),l.geometry.deleteAttribute("normal"),Object.defineProperty(l.material,"map",{get:function(){return this.uniforms.t2D.value}}),n.update(l)),l.material.uniforms.t2D.value=w,w.matrixAutoUpdate===!0&&w.updateMatrix(),l.material.uniforms.uvTransform.value.copy(w.matrix),(u!==w||h!==w.version||d!==s.toneMapping)&&(l.material.needsUpdate=!0,u=w,h=w.version,d=s.toneMapping),l.layers.enableAll(),g.unshift(l,l.geometry,l.material,0,0,null))}function v(g,m){t.buffers.color.setClear(g.r,g.g,g.b,m,r)}return{getClearColor:function(){return a},setClearColor:function(g,m=1){a.set(g),o=m,v(a,o)},getClearAlpha:function(){return o},setClearAlpha:function(g){o=g,v(a,o)},render:f}}function OC(s,e,t,n){const i=s.getParameter(34921),r=n.isWebGL2?null:e.get("OES_vertex_array_object"),a=n.isWebGL2||r!==null,o={},l=m(null);let c=l,u=!1;function h(F,K,J,se,le){let q=!1;if(a){const te=g(se,J,K);c!==te&&(c=te,f(c.object)),q=x(F,se,J,le),q&&w(F,se,J,le)}else{const te=K.wireframe===!0;(c.geometry!==se.id||c.program!==J.id||c.wireframe!==te)&&(c.geometry=se.id,c.program=J.id,c.wireframe=te,q=!0)}le!==null&&t.update(le,34963),(q||u)&&(u=!1,M(F,K,J,se),le!==null&&s.bindBuffer(34963,t.get(le).buffer))}function d(){return n.isWebGL2?s.createVertexArray():r.createVertexArrayOES()}function f(F){return n.isWebGL2?s.bindVertexArray(F):r.bindVertexArrayOES(F)}function v(F){return n.isWebGL2?s.deleteVertexArray(F):r.deleteVertexArrayOES(F)}function g(F,K,J){const se=J.wireframe===!0;let le=o[F.id];le===void 0&&(le={},o[F.id]=le);let q=le[K.id];q===void 0&&(q={},le[K.id]=q);let te=q[se];return te===void 0&&(te=m(d()),q[se]=te),te}function m(F){const K=[],J=[],se=[];for(let le=0;le<i;le++)K[le]=0,J[le]=0,se[le]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:K,enabledAttributes:J,attributeDivisors:se,object:F,attributes:{},index:null}}function x(F,K,J,se){const le=c.attributes,q=K.attributes;let te=0;const H=J.getAttributes();for(const $ in H)if(H[$].location>=0){const xe=le[$];let pe=q[$];if(pe===void 0&&($==="instanceMatrix"&&F.instanceMatrix&&(pe=F.instanceMatrix),$==="instanceColor"&&F.instanceColor&&(pe=F.instanceColor)),xe===void 0||xe.attribute!==pe||pe&&xe.data!==pe.data)return!0;te++}return c.attributesNum!==te||c.index!==se}function w(F,K,J,se){const le={},q=K.attributes;let te=0;const H=J.getAttributes();for(const $ in H)if(H[$].location>=0){let xe=q[$];xe===void 0&&($==="instanceMatrix"&&F.instanceMatrix&&(xe=F.instanceMatrix),$==="instanceColor"&&F.instanceColor&&(xe=F.instanceColor));const pe={};pe.attribute=xe,xe&&xe.data&&(pe.data=xe.data),le[$]=pe,te++}c.attributes=le,c.attributesNum=te,c.index=se}function S(){const F=c.newAttributes;for(let K=0,J=F.length;K<J;K++)F[K]=0}function b(F){E(F,0)}function E(F,K){const J=c.newAttributes,se=c.enabledAttributes,le=c.attributeDivisors;J[F]=1,se[F]===0&&(s.enableVertexAttribArray(F),se[F]=1),le[F]!==K&&((n.isWebGL2?s:e.get("ANGLE_instanced_arrays"))[n.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](F,K),le[F]=K)}function C(){const F=c.newAttributes,K=c.enabledAttributes;for(let J=0,se=K.length;J<se;J++)K[J]!==F[J]&&(s.disableVertexAttribArray(J),K[J]=0)}function P(F,K,J,se,le,q){n.isWebGL2===!0&&(J===5124||J===5125)?s.vertexAttribIPointer(F,K,J,le,q):s.vertexAttribPointer(F,K,J,se,le,q)}function M(F,K,J,se){if(n.isWebGL2===!1&&(F.isInstancedMesh||se.isInstancedBufferGeometry)&&e.get("ANGLE_instanced_arrays")===null)return;S();const le=se.attributes,q=J.getAttributes(),te=K.defaultAttributeValues;for(const H in q){const $=q[H];if($.location>=0){let ce=le[H];if(ce===void 0&&(H==="instanceMatrix"&&F.instanceMatrix&&(ce=F.instanceMatrix),H==="instanceColor"&&F.instanceColor&&(ce=F.instanceColor)),ce!==void 0){const xe=ce.normalized,pe=ce.itemSize,Y=t.get(ce);if(Y===void 0)continue;const Ie=Y.buffer,re=Y.type,oe=Y.bytesPerElement;if(ce.isInterleavedBufferAttribute){const ye=ce.data,ke=ye.stride,X=ce.offset;if(ye.isInstancedInterleavedBuffer){for(let Se=0;Se<$.locationSize;Se++)E($.location+Se,ye.meshPerAttribute);F.isInstancedMesh!==!0&&se._maxInstanceCount===void 0&&(se._maxInstanceCount=ye.meshPerAttribute*ye.count)}else for(let Se=0;Se<$.locationSize;Se++)b($.location+Se);s.bindBuffer(34962,Ie);for(let Se=0;Se<$.locationSize;Se++)P($.location+Se,pe/$.locationSize,re,xe,ke*oe,(X+pe/$.locationSize*Se)*oe)}else{if(ce.isInstancedBufferAttribute){for(let ye=0;ye<$.locationSize;ye++)E($.location+ye,ce.meshPerAttribute);F.isInstancedMesh!==!0&&se._maxInstanceCount===void 0&&(se._maxInstanceCount=ce.meshPerAttribute*ce.count)}else for(let ye=0;ye<$.locationSize;ye++)b($.location+ye);s.bindBuffer(34962,Ie);for(let ye=0;ye<$.locationSize;ye++)P($.location+ye,pe/$.locationSize,re,xe,pe*oe,pe/$.locationSize*ye*oe)}}else if(te!==void 0){const xe=te[H];if(xe!==void 0)switch(xe.length){case 2:s.vertexAttrib2fv($.location,xe);break;case 3:s.vertexAttrib3fv($.location,xe);break;case 4:s.vertexAttrib4fv($.location,xe);break;default:s.vertexAttrib1fv($.location,xe)}}}}C()}function L(){U();for(const F in o){const K=o[F];for(const J in K){const se=K[J];for(const le in se)v(se[le].object),delete se[le];delete K[J]}delete o[F]}}function z(F){if(o[F.id]===void 0)return;const K=o[F.id];for(const J in K){const se=K[J];for(const le in se)v(se[le].object),delete se[le];delete K[J]}delete o[F.id]}function V(F){for(const K in o){const J=o[K];if(J[F.id]===void 0)continue;const se=J[F.id];for(const le in se)v(se[le].object),delete se[le];delete J[F.id]}}function U(){j(),u=!0,c!==l&&(c=l,f(c.object))}function j(){l.geometry=null,l.program=null,l.wireframe=!1}return{setup:h,reset:U,resetDefaultState:j,dispose:L,releaseStatesOfGeometry:z,releaseStatesOfProgram:V,initAttributes:S,enableAttribute:b,disableUnusedAttributes:C}}function NC(s,e,t,n){const i=n.isWebGL2;let r;function a(c){r=c}function o(c,u){s.drawArrays(r,c,u),t.update(u,r,1)}function l(c,u,h){if(h===0)return;let d,f;if(i)d=s,f="drawArraysInstanced";else if(d=e.get("ANGLE_instanced_arrays"),f="drawArraysInstancedANGLE",d===null){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}d[f](r,c,u,h),t.update(u,r,h)}this.setMode=a,this.render=o,this.renderInstances=l}function zC(s,e,t){let n;function i(){if(n!==void 0)return n;if(e.has("EXT_texture_filter_anisotropic")===!0){const P=e.get("EXT_texture_filter_anisotropic");n=s.getParameter(P.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else n=0;return n}function r(P){if(P==="highp"){if(s.getShaderPrecisionFormat(35633,36338).precision>0&&s.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";P="mediump"}return P==="mediump"&&s.getShaderPrecisionFormat(35633,36337).precision>0&&s.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const a=typeof WebGL2RenderingContext<"u"&&s instanceof WebGL2RenderingContext||typeof WebGL2ComputeRenderingContext<"u"&&s instanceof WebGL2ComputeRenderingContext;let o=t.precision!==void 0?t.precision:"highp";const l=r(o);l!==o&&(console.warn("THREE.WebGLRenderer:",o,"not supported, using",l,"instead."),o=l);const c=a||e.has("WEBGL_draw_buffers"),u=t.logarithmicDepthBuffer===!0,h=s.getParameter(34930),d=s.getParameter(35660),f=s.getParameter(3379),v=s.getParameter(34076),g=s.getParameter(34921),m=s.getParameter(36347),x=s.getParameter(36348),w=s.getParameter(36349),S=d>0,b=a||e.has("OES_texture_float"),E=S&&b,C=a?s.getParameter(36183):0;return{isWebGL2:a,drawBuffers:c,getMaxAnisotropy:i,getMaxPrecision:r,precision:o,logarithmicDepthBuffer:u,maxTextures:h,maxVertexTextures:d,maxTextureSize:f,maxCubemapSize:v,maxAttributes:g,maxVertexUniforms:m,maxVaryings:x,maxFragmentUniforms:w,vertexTextures:S,floatFragmentTextures:b,floatVertexTextures:E,maxSamples:C}}function FC(s){const e=this;let t=null,n=0,i=!1,r=!1;const a=new vi,o=new Hn,l={value:null,needsUpdate:!1};this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(h,d,f){const v=h.length!==0||d||n!==0||i;return i=d,t=u(h,f,0),n=h.length,v},this.beginShadows=function(){r=!0,u(null)},this.endShadows=function(){r=!1,c()},this.setState=function(h,d,f){const v=h.clippingPlanes,g=h.clipIntersection,m=h.clipShadows,x=s.get(h);if(!i||v===null||v.length===0||r&&!m)r?u(null):c();else{const w=r?0:n,S=w*4;let b=x.clippingState||null;l.value=b,b=u(v,d,S,f);for(let E=0;E!==S;++E)b[E]=t[E];x.clippingState=b,this.numIntersection=g?this.numPlanes:0,this.numPlanes+=w}};function c(){l.value!==t&&(l.value=t,l.needsUpdate=n>0),e.numPlanes=n,e.numIntersection=0}function u(h,d,f,v){const g=h!==null?h.length:0;let m=null;if(g!==0){if(m=l.value,v!==!0||m===null){const x=f+g*4,w=d.matrixWorldInverse;o.getNormalMatrix(w),(m===null||m.length<x)&&(m=new Float32Array(x));for(let S=0,b=f;S!==g;++S,b+=4)a.copy(h[S]).applyMatrix4(w,o),a.normal.toArray(m,b),m[b+3]=a.constant}l.value=m,l.needsUpdate=!0}return e.numPlanes=g,e.numIntersection=0,m}}function UC(s){let e=new WeakMap;function t(a,o){return o===kg?a.mapping=mc:o===_g&&(a.mapping=gc),a}function n(a){if(a&&a.isTexture&&a.isRenderTargetTexture===!1){const o=a.mapping;if(o===kg||o===_g)if(e.has(a)){const l=e.get(a).texture;return t(l,a.mapping)}else{const l=a.image;if(l&&l.height>0){const c=new Uv(l.height/2);return c.fromEquirectangularTexture(s,a),e.set(a,c),a.addEventListener("dispose",i),t(c.texture,a.mapping)}else return null}}return a}function i(a){const o=a.target;o.removeEventListener("dispose",i);const l=e.get(o);l!==void 0&&(e.delete(o),l.dispose())}function r(){e=new WeakMap}return{get:n,dispose:r}}class Xr extends Dp{constructor(e=-1,t=1,n=1,i=-1,r=.1,a=2e3){super(),this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=e,this.right=t,this.top=n,this.bottom=i,this.near=r,this.far=a,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=e.view===null?null:Object.assign({},e.view),this}setViewOffset(e,t,n,i,r,a){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=n,this.view.offsetY=i,this.view.width=r,this.view.height=a,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=(this.right-this.left)/(2*this.zoom),t=(this.top-this.bottom)/(2*this.zoom),n=(this.right+this.left)/2,i=(this.top+this.bottom)/2;let r=n-e,a=n+e,o=i+t,l=i-t;if(this.view!==null&&this.view.enabled){const c=(this.right-this.left)/this.view.fullWidth/this.zoom,u=(this.top-this.bottom)/this.view.fullHeight/this.zoom;r+=c*this.view.offsetX,a=r+c*this.view.width,o-=u*this.view.offsetY,l=o-u*this.view.height}this.projectionMatrix.makeOrthographic(r,a,o,l,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.zoom=this.zoom,t.object.left=this.left,t.object.right=this.right,t.object.top=this.top,t.object.bottom=this.bottom,t.object.near=this.near,t.object.far=this.far,this.view!==null&&(t.object.view=Object.assign({},this.view)),t}}Xr.prototype.isOrthographicCamera=!0;const Hl=4,my=[.125,.215,.35,.446,.526,.582],bo=20,Dm=new Xr,gy=new ot;let Lm=null;const So=(1+Math.sqrt(5))/2,bl=1/So,vy=[new T(1,1,1),new T(-1,1,1),new T(1,1,-1),new T(-1,1,-1),new T(0,So,bl),new T(0,So,-bl),new T(bl,0,So),new T(-bl,0,So),new T(So,bl,0),new T(-So,bl,0)];class Hg{constructor(e){this._renderer=e,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(e,t=0,n=.1,i=100){Lm=this._renderer.getRenderTarget(),this._setSize(256);const r=this._allocateTargets();return r.depthBuffer=!0,this._sceneToCubeUV(e,n,i,r),t>0&&this._blur(r,0,0,t),this._applyPMREM(r),this._cleanup(r),r}fromEquirectangular(e,t=null){return this._fromTexture(e,t)}fromCubemap(e,t=null){return this._fromTexture(e,t)}compileCubemapShader(){this._cubemapMaterial===null&&(this._cubemapMaterial=wy(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){this._equirectMaterial===null&&(this._equirectMaterial=xy(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),this._cubemapMaterial!==null&&this._cubemapMaterial.dispose(),this._equirectMaterial!==null&&this._equirectMaterial.dispose()}_setSize(e){this._lodMax=Math.floor(Math.log2(e)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){this._blurMaterial!==null&&this._blurMaterial.dispose(),this._pingPongRenderTarget!==null&&this._pingPongRenderTarget.dispose();for(let e=0;e<this._lodPlanes.length;e++)this._lodPlanes[e].dispose()}_cleanup(e){this._renderer.setRenderTarget(Lm),e.scissorTest=!1,md(e,0,0,e.width,e.height)}_fromTexture(e,t){e.mapping===mc||e.mapping===gc?this._setSize(e.image.length===0?16:e.image[0].width||e.image[0].image.width):this._setSize(e.image.width/4),Lm=this._renderer.getRenderTarget();const n=t||this._allocateTargets();return this._textureToCubeUV(e,n),this._applyPMREM(n),this._cleanup(n),n}_allocateTargets(){const e=3*Math.max(this._cubeSize,112),t=4*this._cubeSize,n={magFilter:cn,minFilter:cn,generateMipmaps:!1,type:Zi,format:qi,encoding:Ir,depthBuffer:!1},i=yy(e,t,n);if(this._pingPongRenderTarget===null||this._pingPongRenderTarget.width!==e){this._pingPongRenderTarget!==null&&this._dispose(),this._pingPongRenderTarget=yy(e,t,n);const{_lodMax:r}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=kC(r)),this._blurMaterial=_C(r,e,t)}return i}_compileMaterial(e){const t=new gn(this._lodPlanes[0],e);this._renderer.compile(t,Dm)}_sceneToCubeUV(e,t,n,i){const o=new li(90,1,t,n),l=[1,-1,1,1,1,1],c=[1,1,1,-1,-1,-1],u=this._renderer,h=u.autoClear,d=u.toneMapping;u.getClearColor(gy),u.toneMapping=js,u.autoClear=!1;const f=new Ja({name:"PMREM.Background",side:er,depthWrite:!1,depthTest:!1}),v=new gn(new Sh,f);let g=!1;const m=e.background;m?m.isColor&&(f.color.copy(m),e.background=null,g=!0):(f.color.copy(gy),g=!0);for(let x=0;x<6;x++){const w=x%3;w===0?(o.up.set(0,l[x],0),o.lookAt(c[x],0,0)):w===1?(o.up.set(0,0,l[x]),o.lookAt(0,c[x],0)):(o.up.set(0,l[x],0),o.lookAt(0,0,c[x]));const S=this._cubeSize;md(i,w*S,x>2?S:0,S,S),u.setRenderTarget(i),g&&u.render(v,o),u.render(e,o)}v.geometry.dispose(),v.material.dispose(),u.toneMapping=d,u.autoClear=h,e.background=m}_textureToCubeUV(e,t){const n=this._renderer,i=e.mapping===mc||e.mapping===gc;i?(this._cubemapMaterial===null&&(this._cubemapMaterial=wy()),this._cubemapMaterial.uniforms.flipEnvMap.value=e.isRenderTargetTexture===!1?-1:1):this._equirectMaterial===null&&(this._equirectMaterial=xy());const r=i?this._cubemapMaterial:this._equirectMaterial,a=new gn(this._lodPlanes[0],r),o=r.uniforms;o.envMap.value=e;const l=this._cubeSize;md(t,0,0,3*l,2*l),n.setRenderTarget(t),n.render(a,Dm)}_applyPMREM(e){const t=this._renderer,n=t.autoClear;t.autoClear=!1;for(let i=1;i<this._lodPlanes.length;i++){const r=Math.sqrt(this._sigmas[i]*this._sigmas[i]-this._sigmas[i-1]*this._sigmas[i-1]),a=vy[(i-1)%vy.length];this._blur(e,i-1,i,r,a)}t.autoClear=n}_blur(e,t,n,i,r){const a=this._pingPongRenderTarget;this._halfBlur(e,a,t,n,i,"latitudinal",r),this._halfBlur(a,e,n,n,i,"longitudinal",r)}_halfBlur(e,t,n,i,r,a,o){const l=this._renderer,c=this._blurMaterial;a!=="latitudinal"&&a!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const u=3,h=new gn(this._lodPlanes[i],c),d=c.uniforms,f=this._sizeLods[n]-1,v=isFinite(r)?Math.PI/(2*f):2*Math.PI/(2*bo-1),g=r/v,m=isFinite(r)?1+Math.floor(u*g):bo;m>bo&&console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${m} samples when the maximum is set to ${bo}`);const x=[];let w=0;for(let P=0;P<bo;++P){const M=P/g,L=Math.exp(-M*M/2);x.push(L),P===0?w+=L:P<m&&(w+=2*L)}for(let P=0;P<x.length;P++)x[P]=x[P]/w;d.envMap.value=e.texture,d.samples.value=m,d.weights.value=x,d.latitudinal.value=a==="latitudinal",o&&(d.poleAxis.value=o);const{_lodMax:S}=this;d.dTheta.value=v,d.mipInt.value=S-n;const b=this._sizeLods[i],E=3*b*(i>S-Hl?i-S+Hl:0),C=4*(this._cubeSize-b);md(t,E,C,3*b,2*b),l.setRenderTarget(t),l.render(h,Dm)}}function kC(s){const e=[],t=[],n=[];let i=s;const r=s-Hl+1+my.length;for(let a=0;a<r;a++){const o=Math.pow(2,i);t.push(o);let l=1/o;a>s-Hl?l=my[a-s+Hl-1]:a===0&&(l=0),n.push(l);const c=1/(o-2),u=-c,h=1+c,d=[u,u,h,u,h,h,u,u,h,h,u,h],f=6,v=6,g=3,m=2,x=1,w=new Float32Array(g*v*f),S=new Float32Array(m*v*f),b=new Float32Array(x*v*f);for(let C=0;C<f;C++){const P=C%3*2/3-1,M=C>2?0:-1,L=[P,M,0,P+2/3,M,0,P+2/3,M+1,0,P,M,0,P+2/3,M+1,0,P,M+1,0];w.set(L,g*v*C),S.set(d,m*v*C);const z=[C,C,C,C,C,C];b.set(z,x*v*C)}const E=new Xt;E.setAttribute("position",new Sn(w,g)),E.setAttribute("uv",new Sn(S,m)),E.setAttribute("faceIndex",new Sn(b,x)),e.push(E),i>Hl&&i--}return{lodPlanes:e,sizeLods:t,sigmas:n}}function yy(s,e,t){const n=new Yn(s,e,t);return n.texture.mapping=Ip,n.texture.name="PMREM.cubeUv",n.scissorTest=!0,n}function md(s,e,t,n,i){s.viewport.set(e,t,n,i),s.scissor.set(e,t,n,i)}function _C(s,e,t){const n=new Float32Array(bo),i=new T(0,1,0);return new $n({name:"SphericalGaussianBlur",defines:{n:bo,CUBEUV_TEXEL_WIDTH:1/e,CUBEUV_TEXEL_HEIGHT:1/t,CUBEUV_MAX_MIP:`${s}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:n},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:i}},vertexShader:kv(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,blending:ui,depthTest:!1,depthWrite:!1})}function xy(){return new $n({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:kv(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,blending:ui,depthTest:!1,depthWrite:!1})}function wy(){return new $n({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:kv(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,blending:ui,depthTest:!1,depthWrite:!1})}function kv(){return`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function VC(s){let e=new WeakMap,t=null;function n(o){if(o&&o.isTexture){const l=o.mapping,c=l===kg||l===_g,u=l===mc||l===gc;if(c||u)if(o.isRenderTargetTexture&&o.needsPMREMUpdate===!0){o.needsPMREMUpdate=!1;let h=e.get(o);return t===null&&(t=new Hg(s)),h=c?t.fromEquirectangular(o,h):t.fromCubemap(o,h),e.set(o,h),h.texture}else{if(e.has(o))return e.get(o).texture;{const h=o.image;if(c&&h&&h.height>0||u&&h&&i(h)){t===null&&(t=new Hg(s));const d=c?t.fromEquirectangular(o):t.fromCubemap(o);return e.set(o,d),o.addEventListener("dispose",r),d.texture}else return null}}}return o}function i(o){let l=0;const c=6;for(let u=0;u<c;u++)o[u]!==void 0&&l++;return l===c}function r(o){const l=o.target;l.removeEventListener("dispose",r);const c=e.get(l);c!==void 0&&(e.delete(l),c.dispose())}function a(){e=new WeakMap,t!==null&&(t.dispose(),t=null)}return{get:n,dispose:a}}function GC(s){const e={};function t(n){if(e[n]!==void 0)return e[n];let i;switch(n){case"WEBGL_depth_texture":i=s.getExtension("WEBGL_depth_texture")||s.getExtension("MOZ_WEBGL_depth_texture")||s.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":i=s.getExtension("EXT_texture_filter_anisotropic")||s.getExtension("MOZ_EXT_texture_filter_anisotropic")||s.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":i=s.getExtension("WEBGL_compressed_texture_s3tc")||s.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||s.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":i=s.getExtension("WEBGL_compressed_texture_pvrtc")||s.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:i=s.getExtension(n)}return e[n]=i,i}return{has:function(n){return t(n)!==null},init:function(n){n.isWebGL2?t("EXT_color_buffer_float"):(t("WEBGL_depth_texture"),t("OES_texture_float"),t("OES_texture_half_float"),t("OES_texture_half_float_linear"),t("OES_standard_derivatives"),t("OES_element_index_uint"),t("OES_vertex_array_object"),t("ANGLE_instanced_arrays")),t("OES_texture_float_linear"),t("EXT_color_buffer_half_float"),t("WEBGL_multisampled_render_to_texture")},get:function(n){const i=t(n);return i===null&&console.warn("THREE.WebGLRenderer: "+n+" extension not supported."),i}}}function HC(s,e,t,n){const i={},r=new WeakMap;function a(h){const d=h.target;d.index!==null&&e.remove(d.index);for(const v in d.attributes)e.remove(d.attributes[v]);d.removeEventListener("dispose",a),delete i[d.id];const f=r.get(d);f&&(e.remove(f),r.delete(d)),n.releaseStatesOfGeometry(d),d.isInstancedBufferGeometry===!0&&delete d._maxInstanceCount,t.memory.geometries--}function o(h,d){return i[d.id]===!0||(d.addEventListener("dispose",a),i[d.id]=!0,t.memory.geometries++),d}function l(h){const d=h.attributes;for(const v in d)e.update(d[v],34962);const f=h.morphAttributes;for(const v in f){const g=f[v];for(let m=0,x=g.length;m<x;m++)e.update(g[m],34962)}}function c(h){const d=[],f=h.index,v=h.attributes.position;let g=0;if(f!==null){const w=f.array;g=f.version;for(let S=0,b=w.length;S<b;S+=3){const E=w[S+0],C=w[S+1],P=w[S+2];d.push(E,C,C,P,P,E)}}else{const w=v.array;g=v.version;for(let S=0,b=w.length/3-1;S<b;S+=3){const E=S+0,C=S+1,P=S+2;d.push(E,C,C,P,P,E)}}const m=new(QS(d)?jo:qo)(d,1);m.version=g;const x=r.get(h);x&&e.remove(x),r.set(h,m)}function u(h){const d=r.get(h);if(d){const f=h.index;f!==null&&d.version<f.version&&c(h)}else c(h);return r.get(h)}return{get:o,update:l,getWireframeAttribute:u}}function WC(s,e,t,n){const i=n.isWebGL2;let r;function a(d){r=d}let o,l;function c(d){o=d.type,l=d.bytesPerElement}function u(d,f){s.drawElements(r,f,o,d*l),t.update(f,r,1)}function h(d,f,v){if(v===0)return;let g,m;if(i)g=s,m="drawElementsInstanced";else if(g=e.get("ANGLE_instanced_arrays"),m="drawElementsInstancedANGLE",g===null){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}g[m](r,f,o,d*l,v),t.update(f,r,v)}this.setMode=a,this.setIndex=c,this.render=u,this.renderInstances=h}function qC(s){const e={geometries:0,textures:0},t={frame:0,calls:0,triangles:0,points:0,lines:0};function n(r,a,o){switch(t.calls++,a){case 4:t.triangles+=o*(r/3);break;case 1:t.lines+=o*(r/2);break;case 3:t.lines+=o*(r-1);break;case 2:t.lines+=o*r;break;case 0:t.points+=o*r;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",a);break}}function i(){t.frame++,t.calls=0,t.triangles=0,t.points=0,t.lines=0}return{memory:e,render:t,programs:null,autoReset:!0,reset:i,update:n}}function jC(s,e){return s[0]-e[0]}function QC(s,e){return Math.abs(e[1])-Math.abs(s[1])}function Bm(s,e){let t=1;const n=e.isInterleavedBufferAttribute?e.data.array:e.array;n instanceof Int8Array?t=127:n instanceof Int16Array?t=32767:n instanceof Int32Array?t=2147483647:console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ",n),s.divideScalar(t)}function XC(s,e,t){const n={},i=new Float32Array(8),r=new WeakMap,a=new Ft,o=[];for(let c=0;c<8;c++)o[c]=[c,0];function l(c,u,h,d){const f=c.morphTargetInfluences;if(e.isWebGL2===!0){const g=u.morphAttributes.position||u.morphAttributes.normal||u.morphAttributes.color,m=g!==void 0?g.length:0;let x=r.get(u);if(x===void 0||x.count!==m){let J=function(){F.dispose(),r.delete(u),u.removeEventListener("dispose",J)};var v=J;x!==void 0&&x.texture.dispose();const b=u.morphAttributes.position!==void 0,E=u.morphAttributes.normal!==void 0,C=u.morphAttributes.color!==void 0,P=u.morphAttributes.position||[],M=u.morphAttributes.normal||[],L=u.morphAttributes.color||[];let z=0;b===!0&&(z=1),E===!0&&(z=2),C===!0&&(z=3);let V=u.attributes.position.count*z,U=1;V>e.maxTextureSize&&(U=Math.ceil(V/e.maxTextureSize),V=e.maxTextureSize);const j=new Float32Array(V*U*4*m),F=new Pp(j,V,U,m);F.type=Oi,F.needsUpdate=!0;const K=z*4;for(let se=0;se<m;se++){const le=P[se],q=M[se],te=L[se],H=V*U*4*se;for(let $=0;$<le.count;$++){const ce=$*K;b===!0&&(a.fromBufferAttribute(le,$),le.normalized===!0&&Bm(a,le),j[H+ce+0]=a.x,j[H+ce+1]=a.y,j[H+ce+2]=a.z,j[H+ce+3]=0),E===!0&&(a.fromBufferAttribute(q,$),q.normalized===!0&&Bm(a,q),j[H+ce+4]=a.x,j[H+ce+5]=a.y,j[H+ce+6]=a.z,j[H+ce+7]=0),C===!0&&(a.fromBufferAttribute(te,$),te.normalized===!0&&Bm(a,te),j[H+ce+8]=a.x,j[H+ce+9]=a.y,j[H+ce+10]=a.z,j[H+ce+11]=te.itemSize===4?a.w:1)}}x={count:m,texture:F,size:new Me(V,U)},r.set(u,x),u.addEventListener("dispose",J)}let w=0;for(let b=0;b<f.length;b++)w+=f[b];const S=u.morphTargetsRelative?1:1-w;d.getUniforms().setValue(s,"morphTargetBaseInfluence",S),d.getUniforms().setValue(s,"morphTargetInfluences",f),d.getUniforms().setValue(s,"morphTargetsTexture",x.texture,t),d.getUniforms().setValue(s,"morphTargetsTextureSize",x.size)}else{const g=f===void 0?0:f.length;let m=n[u.id];if(m===void 0||m.length!==g){m=[];for(let E=0;E<g;E++)m[E]=[E,0];n[u.id]=m}for(let E=0;E<g;E++){const C=m[E];C[0]=E,C[1]=f[E]}m.sort(QC);for(let E=0;E<8;E++)E<g&&m[E][1]?(o[E][0]=m[E][0],o[E][1]=m[E][1]):(o[E][0]=Number.MAX_SAFE_INTEGER,o[E][1]=0);o.sort(jC);const x=u.morphAttributes.position,w=u.morphAttributes.normal;let S=0;for(let E=0;E<8;E++){const C=o[E],P=C[0],M=C[1];P!==Number.MAX_SAFE_INTEGER&&M?(x&&u.getAttribute("morphTarget"+E)!==x[P]&&u.setAttribute("morphTarget"+E,x[P]),w&&u.getAttribute("morphNormal"+E)!==w[P]&&u.setAttribute("morphNormal"+E,w[P]),i[E]=M,S+=M):(x&&u.hasAttribute("morphTarget"+E)===!0&&u.deleteAttribute("morphTarget"+E),w&&u.hasAttribute("morphNormal"+E)===!0&&u.deleteAttribute("morphNormal"+E),i[E]=0)}const b=u.morphTargetsRelative?1:1-S;d.getUniforms().setValue(s,"morphTargetBaseInfluence",b),d.getUniforms().setValue(s,"morphTargetInfluences",i)}}return{update:l}}function JC(s,e,t,n){let i=new WeakMap;function r(l){const c=n.render.frame,u=l.geometry,h=e.get(l,u);return i.get(h)!==c&&(e.update(h),i.set(h,c)),l.isInstancedMesh&&(l.hasEventListener("dispose",o)===!1&&l.addEventListener("dispose",o),t.update(l.instanceMatrix,34962),l.instanceColor!==null&&t.update(l.instanceColor,34962)),h}function a(){i=new WeakMap}function o(l){const c=l.target;c.removeEventListener("dispose",o),t.remove(c.instanceMatrix),c.instanceColor!==null&&t.remove(c.instanceColor)}return{update:r,dispose:a}}const KS=new hi,YS=new Pp,ZS=new Ov,$S=new Lp,Sy=[],by=[],Ay=new Float32Array(16),Ty=new Float32Array(9),Ey=new Float32Array(4);function Rc(s,e,t){const n=s[0];if(n<=0||n>0)return s;const i=e*t;let r=Sy[i];if(r===void 0&&(r=new Float32Array(i),Sy[i]=r),e!==0){n.toArray(r,0);for(let a=1,o=0;a!==e;++a)o+=t,s[a].toArray(r,o)}return r}function tr(s,e){if(s.length!==e.length)return!1;for(let t=0,n=s.length;t<n;t++)if(s[t]!==e[t])return!1;return!0}function nr(s,e){for(let t=0,n=e.length;t<n;t++)s[t]=e[t]}function Bp(s,e){let t=by[e];t===void 0&&(t=new Int32Array(e),by[e]=t);for(let n=0;n!==e;++n)t[n]=s.allocateTextureUnit();return t}function KC(s,e){const t=this.cache;t[0]!==e&&(s.uniform1f(this.addr,e),t[0]=e)}function YC(s,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(s.uniform2f(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(tr(t,e))return;s.uniform2fv(this.addr,e),nr(t,e)}}function ZC(s,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(s.uniform3f(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else if(e.r!==void 0)(t[0]!==e.r||t[1]!==e.g||t[2]!==e.b)&&(s.uniform3f(this.addr,e.r,e.g,e.b),t[0]=e.r,t[1]=e.g,t[2]=e.b);else{if(tr(t,e))return;s.uniform3fv(this.addr,e),nr(t,e)}}function $C(s,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(s.uniform4f(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(tr(t,e))return;s.uniform4fv(this.addr,e),nr(t,e)}}function eR(s,e){const t=this.cache,n=e.elements;if(n===void 0){if(tr(t,e))return;s.uniformMatrix2fv(this.addr,!1,e),nr(t,e)}else{if(tr(t,n))return;Ey.set(n),s.uniformMatrix2fv(this.addr,!1,Ey),nr(t,n)}}function tR(s,e){const t=this.cache,n=e.elements;if(n===void 0){if(tr(t,e))return;s.uniformMatrix3fv(this.addr,!1,e),nr(t,e)}else{if(tr(t,n))return;Ty.set(n),s.uniformMatrix3fv(this.addr,!1,Ty),nr(t,n)}}function nR(s,e){const t=this.cache,n=e.elements;if(n===void 0){if(tr(t,e))return;s.uniformMatrix4fv(this.addr,!1,e),nr(t,e)}else{if(tr(t,n))return;Ay.set(n),s.uniformMatrix4fv(this.addr,!1,Ay),nr(t,n)}}function iR(s,e){const t=this.cache;t[0]!==e&&(s.uniform1i(this.addr,e),t[0]=e)}function rR(s,e){const t=this.cache;tr(t,e)||(s.uniform2iv(this.addr,e),nr(t,e))}function sR(s,e){const t=this.cache;tr(t,e)||(s.uniform3iv(this.addr,e),nr(t,e))}function aR(s,e){const t=this.cache;tr(t,e)||(s.uniform4iv(this.addr,e),nr(t,e))}function oR(s,e){const t=this.cache;t[0]!==e&&(s.uniform1ui(this.addr,e),t[0]=e)}function lR(s,e){const t=this.cache;tr(t,e)||(s.uniform2uiv(this.addr,e),nr(t,e))}function cR(s,e){const t=this.cache;tr(t,e)||(s.uniform3uiv(this.addr,e),nr(t,e))}function uR(s,e){const t=this.cache;tr(t,e)||(s.uniform4uiv(this.addr,e),nr(t,e))}function hR(s,e,t){const n=this.cache,i=t.allocateTextureUnit();n[0]!==i&&(s.uniform1i(this.addr,i),n[0]=i),t.setTexture2D(e||KS,i)}function dR(s,e,t){const n=this.cache,i=t.allocateTextureUnit();n[0]!==i&&(s.uniform1i(this.addr,i),n[0]=i),t.setTexture3D(e||ZS,i)}function fR(s,e,t){const n=this.cache,i=t.allocateTextureUnit();n[0]!==i&&(s.uniform1i(this.addr,i),n[0]=i),t.setTextureCube(e||$S,i)}function pR(s,e,t){const n=this.cache,i=t.allocateTextureUnit();n[0]!==i&&(s.uniform1i(this.addr,i),n[0]=i),t.setTexture2DArray(e||YS,i)}function mR(s){switch(s){case 5126:return KC;case 35664:return YC;case 35665:return ZC;case 35666:return $C;case 35674:return eR;case 35675:return tR;case 35676:return nR;case 5124:case 35670:return iR;case 35667:case 35671:return rR;case 35668:case 35672:return sR;case 35669:case 35673:return aR;case 5125:return oR;case 36294:return lR;case 36295:return cR;case 36296:return uR;case 35678:case 36198:case 36298:case 36306:case 35682:return hR;case 35679:case 36299:case 36307:return dR;case 35680:case 36300:case 36308:case 36293:return fR;case 36289:case 36303:case 36311:case 36292:return pR}}function gR(s,e){s.uniform1fv(this.addr,e)}function vR(s,e){const t=Rc(e,this.size,2);s.uniform2fv(this.addr,t)}function yR(s,e){const t=Rc(e,this.size,3);s.uniform3fv(this.addr,t)}function xR(s,e){const t=Rc(e,this.size,4);s.uniform4fv(this.addr,t)}function wR(s,e){const t=Rc(e,this.size,4);s.uniformMatrix2fv(this.addr,!1,t)}function SR(s,e){const t=Rc(e,this.size,9);s.uniformMatrix3fv(this.addr,!1,t)}function bR(s,e){const t=Rc(e,this.size,16);s.uniformMatrix4fv(this.addr,!1,t)}function AR(s,e){s.uniform1iv(this.addr,e)}function TR(s,e){s.uniform2iv(this.addr,e)}function ER(s,e){s.uniform3iv(this.addr,e)}function MR(s,e){s.uniform4iv(this.addr,e)}function CR(s,e){s.uniform1uiv(this.addr,e)}function RR(s,e){s.uniform2uiv(this.addr,e)}function IR(s,e){s.uniform3uiv(this.addr,e)}function PR(s,e){s.uniform4uiv(this.addr,e)}function DR(s,e,t){const n=e.length,i=Bp(t,n);s.uniform1iv(this.addr,i);for(let r=0;r!==n;++r)t.setTexture2D(e[r]||KS,i[r])}function LR(s,e,t){const n=e.length,i=Bp(t,n);s.uniform1iv(this.addr,i);for(let r=0;r!==n;++r)t.setTexture3D(e[r]||ZS,i[r])}function BR(s,e,t){const n=e.length,i=Bp(t,n);s.uniform1iv(this.addr,i);for(let r=0;r!==n;++r)t.setTextureCube(e[r]||$S,i[r])}function OR(s,e,t){const n=e.length,i=Bp(t,n);s.uniform1iv(this.addr,i);for(let r=0;r!==n;++r)t.setTexture2DArray(e[r]||YS,i[r])}function NR(s){switch(s){case 5126:return gR;case 35664:return vR;case 35665:return yR;case 35666:return xR;case 35674:return wR;case 35675:return SR;case 35676:return bR;case 5124:case 35670:return AR;case 35667:case 35671:return TR;case 35668:case 35672:return ER;case 35669:case 35673:return MR;case 5125:return CR;case 36294:return RR;case 36295:return IR;case 36296:return PR;case 35678:case 36198:case 36298:case 36306:case 35682:return DR;case 35679:case 36299:case 36307:return LR;case 35680:case 36300:case 36308:case 36293:return BR;case 36289:case 36303:case 36311:case 36292:return OR}}function zR(s,e,t){this.id=s,this.addr=t,this.cache=[],this.setValue=mR(e.type)}function FR(s,e,t){this.id=s,this.addr=t,this.cache=[],this.size=e.size,this.setValue=NR(e.type)}function eb(s){this.id=s,this.seq=[],this.map={}}eb.prototype.setValue=function(s,e,t){const n=this.seq;for(let i=0,r=n.length;i!==r;++i){const a=n[i];a.setValue(s,e[a.id],t)}};const Om=/(\w+)(\])?(\[|\.)?/g;function My(s,e){s.seq.push(e),s.map[e.id]=e}function UR(s,e,t){const n=s.name,i=n.length;for(Om.lastIndex=0;;){const r=Om.exec(n),a=Om.lastIndex;let o=r[1];const l=r[2]==="]",c=r[3];if(l&&(o=o|0),c===void 0||c==="["&&a+2===i){My(t,c===void 0?new zR(o,s,e):new FR(o,s,e));break}else{let h=t.map[o];h===void 0&&(h=new eb(o),My(t,h)),t=h}}}function Fa(s,e){this.seq=[],this.map={};const t=s.getProgramParameter(e,35718);for(let n=0;n<t;++n){const i=s.getActiveUniform(e,n),r=s.getUniformLocation(e,i.name);UR(i,r,this)}}Fa.prototype.setValue=function(s,e,t,n){const i=this.map[e];i!==void 0&&i.setValue(s,t,n)};Fa.prototype.setOptional=function(s,e,t){const n=e[t];n!==void 0&&this.setValue(s,t,n)};Fa.upload=function(s,e,t,n){for(let i=0,r=e.length;i!==r;++i){const a=e[i],o=t[a.id];o.needsUpdate!==!1&&a.setValue(s,o.value,n)}};Fa.seqWithValue=function(s,e){const t=[];for(let n=0,i=s.length;n!==i;++n){const r=s[n];r.id in e&&t.push(r)}return t};function Cy(s,e,t){const n=s.createShader(e);return s.shaderSource(n,t),s.compileShader(n),n}let kR=0;function _R(s,e){const t=s.split(`
`),n=[],i=Math.max(e-6,0),r=Math.min(e+6,t.length);for(let a=i;a<r;a++)n.push(a+1+": "+t[a]);return n.join(`
`)}function VR(s){switch(s){case Ir:return["Linear","( value )"];case Wt:return["sRGB","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",s),["Linear","( value )"]}}function Ry(s,e,t){const n=s.getShaderParameter(e,35713),i=s.getShaderInfoLog(e).trim();if(n&&i==="")return"";const r=/ERROR: 0:(\d+)/.exec(i);if(r){const a=parseInt(r[0]);return t.toUpperCase()+`

`+i+`

`+_R(s.getShaderSource(e),a)}else return i}function GR(s,e){const t=VR(e);return"vec4 "+s+"( vec4 value ) { return LinearTo"+t[0]+t[1]+"; }"}function HR(s,e){let t;switch(e){case pT:t="Linear";break;case mT:t="Reinhard";break;case gT:t="OptimizedCineon";break;case IS:t="ACESFilmic";break;case vT:t="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),t="Linear"}return"vec3 "+s+"( vec3 color ) { return "+t+"ToneMapping( color ); }"}function WR(s){return[s.extensionDerivatives||s.envMapCubeUVHeight||s.bumpMap||s.tangentSpaceNormalMap||s.clearcoatNormalMap||s.flatShading||s.shaderID==="physical"?"#extension GL_OES_standard_derivatives : enable":"",(s.extensionFragDepth||s.logarithmicDepthBuffer)&&s.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",s.extensionDrawBuffers&&s.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(s.extensionShaderTextureLOD||s.envMap||s.transmission)&&s.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(hu).join(`
`)}function qR(s){const e=[];for(const t in s){const n=s[t];n!==!1&&e.push("#define "+t+" "+n)}return e.join(`
`)}function jR(s,e){const t={},n=s.getProgramParameter(e,35721);for(let i=0;i<n;i++){const r=s.getActiveAttrib(e,i),a=r.name;let o=1;r.type===35674&&(o=2),r.type===35675&&(o=3),r.type===35676&&(o=4),t[a]={type:r.type,location:s.getAttribLocation(e,a),locationSize:o}}return t}function hu(s){return s!==""}function Iy(s,e){return s.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function Py(s,e){return s.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const QR=/^[ \t]*#include +<([\w\d./]+)>/gm;function Wg(s){return s.replace(QR,XR)}function XR(s,e){const t=tn[e];if(t===void 0)throw new Error("Can not resolve #include <"+e+">");return Wg(t)}const JR=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,KR=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function Dy(s){return s.replace(KR,tb).replace(JR,YR)}function YR(s,e,t,n){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),tb(s,e,t,n)}function tb(s,e,t,n){let i="";for(let r=parseInt(e);r<parseInt(t);r++)i+=n.replace(/\[\s*i\s*\]/g,"[ "+r+" ]").replace(/UNROLLED_LOOP_INDEX/g,r);return i}function Ly(s){let e="precision "+s.precision+` float;
precision `+s.precision+" int;";return s.precision==="highp"?e+=`
#define HIGH_PRECISION`:s.precision==="mediump"?e+=`
#define MEDIUM_PRECISION`:s.precision==="lowp"&&(e+=`
#define LOW_PRECISION`),e}function ZR(s){let e="SHADOWMAP_TYPE_BASIC";return s.shadowMapType===AS?e="SHADOWMAP_TYPE_PCF":s.shadowMapType===ZA?e="SHADOWMAP_TYPE_PCF_SOFT":s.shadowMapType===_l&&(e="SHADOWMAP_TYPE_VSM"),e}function $R(s){let e="ENVMAP_TYPE_CUBE";if(s.envMap)switch(s.envMapMode){case mc:case gc:e="ENVMAP_TYPE_CUBE";break;case Ip:e="ENVMAP_TYPE_CUBE_UV";break}return e}function e3(s){let e="ENVMAP_MODE_REFLECTION";if(s.envMap)switch(s.envMapMode){case gc:e="ENVMAP_MODE_REFRACTION";break}return e}function t3(s){let e="ENVMAP_BLENDING_NONE";if(s.envMap)switch(s.combine){case Rp:e="ENVMAP_BLENDING_MULTIPLY";break;case dT:e="ENVMAP_BLENDING_MIX";break;case fT:e="ENVMAP_BLENDING_ADD";break}return e}function n3(s){const e=s.envMapCubeUVHeight;if(e===null)return null;const t=Math.log2(e)-2,n=1/e;return{texelWidth:1/(3*Math.max(Math.pow(2,t),7*16)),texelHeight:n,maxMip:t}}function i3(s,e,t,n){const i=s.getContext(),r=t.defines;let a=t.vertexShader,o=t.fragmentShader;const l=ZR(t),c=$R(t),u=e3(t),h=t3(t),d=n3(t),f=t.isWebGL2?"":WR(t),v=qR(r),g=i.createProgram();let m,x,w=t.glslVersion?"#version "+t.glslVersion+`
`:"";t.isRawShaderMaterial?(m=[v].filter(hu).join(`
`),m.length>0&&(m+=`
`),x=[f,v].filter(hu).join(`
`),x.length>0&&(x+=`
`)):(m=[Ly(t),"#define SHADER_NAME "+t.shaderName,v,t.instancing?"#define USE_INSTANCING":"",t.instancingColor?"#define USE_INSTANCING_COLOR":"",t.supportsVertexTextures?"#define VERTEX_TEXTURES":"",t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+u:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMap&&t.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",t.normalMap&&t.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.displacementMap&&t.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",t.specularColorMap?"#define USE_SPECULARCOLORMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.sheenColorMap?"#define USE_SHEENCOLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",t.vertexTangents?"#define USE_TANGENT":"",t.vertexColors?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUvs?"#define USE_UV":"",t.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",t.flatShading?"#define FLAT_SHADED":"",t.skinning?"#define USE_SKINNING":"",t.morphTargets?"#define USE_MORPHTARGETS":"",t.morphNormals&&t.flatShading===!1?"#define USE_MORPHNORMALS":"",t.morphColors&&t.isWebGL2?"#define USE_MORPHCOLORS":"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_TEXTURE_STRIDE "+t.morphTextureStride:"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_COUNT "+t.morphTargetsCount:"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+l:"",t.sizeAttenuation?"#define USE_SIZEATTENUATION":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(hu).join(`
`),x=[f,Ly(t),"#define SHADER_NAME "+t.shaderName,v,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.matcap?"#define USE_MATCAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+c:"",t.envMap?"#define "+u:"",t.envMap?"#define "+h:"",d?"#define CUBEUV_TEXEL_WIDTH "+d.texelWidth:"",d?"#define CUBEUV_TEXEL_HEIGHT "+d.texelHeight:"",d?"#define CUBEUV_MAX_MIP "+d.maxMip+".0":"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMap&&t.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",t.normalMap&&t.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",t.clearcoat?"#define USE_CLEARCOAT":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",t.specularColorMap?"#define USE_SPECULARCOLORMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.alphaTest?"#define USE_ALPHATEST":"",t.sheen?"#define USE_SHEEN":"",t.sheenColorMap?"#define USE_SHEENCOLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",t.vertexTangents?"#define USE_TANGENT":"",t.vertexColors||t.instancingColor?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUvs?"#define USE_UV":"",t.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",t.gradientMap?"#define USE_GRADIENTMAP":"",t.flatShading?"#define FLAT_SHADED":"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+l:"",t.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",t.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",t.toneMapping!==js?"#define TONE_MAPPING":"",t.toneMapping!==js?tn.tonemapping_pars_fragment:"",t.toneMapping!==js?HR("toneMapping",t.toneMapping):"",t.dithering?"#define DITHERING":"",t.opaque?"#define OPAQUE":"",tn.encodings_pars_fragment,GR("linearToOutputTexel",t.outputEncoding),t.useDepthPacking?"#define DEPTH_PACKING "+t.depthPacking:"",`
`].filter(hu).join(`
`)),a=Wg(a),a=Iy(a,t),a=Py(a,t),o=Wg(o),o=Iy(o,t),o=Py(o,t),a=Dy(a),o=Dy(o),t.isWebGL2&&t.isRawShaderMaterial!==!0&&(w=`#version 300 es
`,m=["precision mediump sampler2DArray;","#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+m,x=["#define varying in",t.glslVersion===ny?"":"layout(location = 0) out highp vec4 pc_fragColor;",t.glslVersion===ny?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+x);const S=w+m+a,b=w+x+o,E=Cy(i,35633,S),C=Cy(i,35632,b);if(i.attachShader(g,E),i.attachShader(g,C),t.index0AttributeName!==void 0?i.bindAttribLocation(g,0,t.index0AttributeName):t.morphTargets===!0&&i.bindAttribLocation(g,0,"position"),i.linkProgram(g),s.debug.checkShaderErrors){const L=i.getProgramInfoLog(g).trim(),z=i.getShaderInfoLog(E).trim(),V=i.getShaderInfoLog(C).trim();let U=!0,j=!0;if(i.getProgramParameter(g,35714)===!1){U=!1;const F=Ry(i,E,"vertex"),K=Ry(i,C,"fragment");console.error("THREE.WebGLProgram: Shader Error "+i.getError()+" - VALIDATE_STATUS "+i.getProgramParameter(g,35715)+`

Program Info Log: `+L+`
`+F+`
`+K)}else L!==""?console.warn("THREE.WebGLProgram: Program Info Log:",L):(z===""||V==="")&&(j=!1);j&&(this.diagnostics={runnable:U,programLog:L,vertexShader:{log:z,prefix:m},fragmentShader:{log:V,prefix:x}})}i.deleteShader(E),i.deleteShader(C);let P;this.getUniforms=function(){return P===void 0&&(P=new Fa(i,g)),P};let M;return this.getAttributes=function(){return M===void 0&&(M=jR(i,g)),M},this.destroy=function(){n.releaseStatesOfProgram(this),i.deleteProgram(g),this.program=void 0},this.name=t.shaderName,this.id=kR++,this.cacheKey=e,this.usedTimes=1,this.program=g,this.vertexShader=E,this.fragmentShader=C,this}let r3=0;class s3{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(e){const t=e.vertexShader,n=e.fragmentShader,i=this._getShaderStage(t),r=this._getShaderStage(n),a=this._getShaderCacheForMaterial(e);return a.has(i)===!1&&(a.add(i),i.usedTimes++),a.has(r)===!1&&(a.add(r),r.usedTimes++),this}remove(e){const t=this.materialCache.get(e);for(const n of t)n.usedTimes--,n.usedTimes===0&&this.shaderCache.delete(n.code);return this.materialCache.delete(e),this}getVertexShaderID(e){return this._getShaderStage(e.vertexShader).id}getFragmentShaderID(e){return this._getShaderStage(e.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(e){const t=this.materialCache;return t.has(e)===!1&&t.set(e,new Set),t.get(e)}_getShaderStage(e){const t=this.shaderCache;if(t.has(e)===!1){const n=new a3(e);t.set(e,n)}return t.get(e)}}class a3{constructor(e){this.id=r3++,this.code=e,this.usedTimes=0}}function o3(s,e,t,n,i,r,a){const o=new zv,l=new s3,c=[],u=i.isWebGL2,h=i.logarithmicDepthBuffer,d=i.vertexTextures;let f=i.precision;const v={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function g(M,L,z,V,U){const j=V.fog,F=U.geometry,K=M.isMeshStandardMaterial?V.environment:null,J=(M.isMeshStandardMaterial?t:e).get(M.envMap||K),se=J&&J.mapping===Ip?J.image.height:null,le=v[M.type];M.precision!==null&&(f=i.getMaxPrecision(M.precision),f!==M.precision&&console.warn("THREE.WebGLProgram.getParameters:",M.precision,"not supported, using",f,"instead."));const q=F.morphAttributes.position||F.morphAttributes.normal||F.morphAttributes.color,te=q!==void 0?q.length:0;let H=0;F.morphAttributes.position!==void 0&&(H=1),F.morphAttributes.normal!==void 0&&(H=2),F.morphAttributes.color!==void 0&&(H=3);let $,ce,xe,pe;if(le){const ye=Xn[le];$=ye.vertexShader,ce=ye.fragmentShader}else $=M.vertexShader,ce=M.fragmentShader,l.update(M),xe=l.getVertexShaderID(M),pe=l.getFragmentShaderID(M);const Y=s.getRenderTarget(),Ie=M.alphaTest>0,re=M.clearcoat>0;return{isWebGL2:u,shaderID:le,shaderName:M.type,vertexShader:$,fragmentShader:ce,defines:M.defines,customVertexShaderID:xe,customFragmentShaderID:pe,isRawShaderMaterial:M.isRawShaderMaterial===!0,glslVersion:M.glslVersion,precision:f,instancing:U.isInstancedMesh===!0,instancingColor:U.isInstancedMesh===!0&&U.instanceColor!==null,supportsVertexTextures:d,outputEncoding:Y===null?s.outputEncoding:Y.isXRRenderTarget===!0?Y.texture.encoding:Ir,map:!!M.map,matcap:!!M.matcap,envMap:!!J,envMapMode:J&&J.mapping,envMapCubeUVHeight:se,lightMap:!!M.lightMap,aoMap:!!M.aoMap,emissiveMap:!!M.emissiveMap,bumpMap:!!M.bumpMap,normalMap:!!M.normalMap,objectSpaceNormalMap:M.normalMapType===AT,tangentSpaceNormalMap:M.normalMapType===Cc,decodeVideoTexture:!!M.map&&M.map.isVideoTexture===!0&&M.map.encoding===Wt,clearcoat:re,clearcoatMap:re&&!!M.clearcoatMap,clearcoatRoughnessMap:re&&!!M.clearcoatRoughnessMap,clearcoatNormalMap:re&&!!M.clearcoatNormalMap,displacementMap:!!M.displacementMap,roughnessMap:!!M.roughnessMap,metalnessMap:!!M.metalnessMap,specularMap:!!M.specularMap,specularIntensityMap:!!M.specularIntensityMap,specularColorMap:!!M.specularColorMap,opaque:M.transparent===!1&&M.blending===Jl,alphaMap:!!M.alphaMap,alphaTest:Ie,gradientMap:!!M.gradientMap,sheen:M.sheen>0,sheenColorMap:!!M.sheenColorMap,sheenRoughnessMap:!!M.sheenRoughnessMap,transmission:M.transmission>0,transmissionMap:!!M.transmissionMap,thicknessMap:!!M.thicknessMap,combine:M.combine,vertexTangents:!!M.normalMap&&!!F.attributes.tangent,vertexColors:M.vertexColors,vertexAlphas:M.vertexColors===!0&&!!F.attributes.color&&F.attributes.color.itemSize===4,vertexUvs:!!M.map||!!M.bumpMap||!!M.normalMap||!!M.specularMap||!!M.alphaMap||!!M.emissiveMap||!!M.roughnessMap||!!M.metalnessMap||!!M.clearcoatMap||!!M.clearcoatRoughnessMap||!!M.clearcoatNormalMap||!!M.displacementMap||!!M.transmissionMap||!!M.thicknessMap||!!M.specularIntensityMap||!!M.specularColorMap||!!M.sheenColorMap||!!M.sheenRoughnessMap,uvsVertexOnly:!(M.map||M.bumpMap||M.normalMap||M.specularMap||M.alphaMap||M.emissiveMap||M.roughnessMap||M.metalnessMap||M.clearcoatNormalMap||M.transmission>0||M.transmissionMap||M.thicknessMap||M.specularIntensityMap||M.specularColorMap||M.sheen>0||M.sheenColorMap||M.sheenRoughnessMap)&&!!M.displacementMap,fog:!!j,useFog:M.fog===!0,fogExp2:j&&j.isFogExp2,flatShading:!!M.flatShading,sizeAttenuation:M.sizeAttenuation,logarithmicDepthBuffer:h,skinning:U.isSkinnedMesh===!0,morphTargets:F.morphAttributes.position!==void 0,morphNormals:F.morphAttributes.normal!==void 0,morphColors:F.morphAttributes.color!==void 0,morphTargetsCount:te,morphTextureStride:H,numDirLights:L.directional.length,numPointLights:L.point.length,numSpotLights:L.spot.length,numRectAreaLights:L.rectArea.length,numHemiLights:L.hemi.length,numDirLightShadows:L.directionalShadowMap.length,numPointLightShadows:L.pointShadowMap.length,numSpotLightShadows:L.spotShadowMap.length,numClippingPlanes:a.numPlanes,numClipIntersection:a.numIntersection,dithering:M.dithering,shadowMapEnabled:s.shadowMap.enabled&&z.length>0,shadowMapType:s.shadowMap.type,toneMapping:M.toneMapped?s.toneMapping:js,physicallyCorrectLights:s.physicallyCorrectLights,premultipliedAlpha:M.premultipliedAlpha,doubleSided:M.side===Qt,flipSided:M.side===er,useDepthPacking:!!M.depthPacking,depthPacking:M.depthPacking||0,index0AttributeName:M.index0AttributeName,extensionDerivatives:M.extensions&&M.extensions.derivatives,extensionFragDepth:M.extensions&&M.extensions.fragDepth,extensionDrawBuffers:M.extensions&&M.extensions.drawBuffers,extensionShaderTextureLOD:M.extensions&&M.extensions.shaderTextureLOD,rendererExtensionFragDepth:u||n.has("EXT_frag_depth"),rendererExtensionDrawBuffers:u||n.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:u||n.has("EXT_shader_texture_lod"),customProgramCacheKey:M.customProgramCacheKey()}}function m(M){const L=[];if(M.shaderID?L.push(M.shaderID):(L.push(M.customVertexShaderID),L.push(M.customFragmentShaderID)),M.defines!==void 0)for(const z in M.defines)L.push(z),L.push(M.defines[z]);return M.isRawShaderMaterial===!1&&(x(L,M),w(L,M),L.push(s.outputEncoding)),L.push(M.customProgramCacheKey),L.join()}function x(M,L){M.push(L.precision),M.push(L.outputEncoding),M.push(L.envMapMode),M.push(L.envMapCubeUVHeight),M.push(L.combine),M.push(L.vertexUvs),M.push(L.fogExp2),M.push(L.sizeAttenuation),M.push(L.morphTargetsCount),M.push(L.morphAttributeCount),M.push(L.numDirLights),M.push(L.numPointLights),M.push(L.numSpotLights),M.push(L.numHemiLights),M.push(L.numRectAreaLights),M.push(L.numDirLightShadows),M.push(L.numPointLightShadows),M.push(L.numSpotLightShadows),M.push(L.shadowMapType),M.push(L.toneMapping),M.push(L.numClippingPlanes),M.push(L.numClipIntersection),M.push(L.depthPacking)}function w(M,L){o.disableAll(),L.isWebGL2&&o.enable(0),L.supportsVertexTextures&&o.enable(1),L.instancing&&o.enable(2),L.instancingColor&&o.enable(3),L.map&&o.enable(4),L.matcap&&o.enable(5),L.envMap&&o.enable(6),L.lightMap&&o.enable(7),L.aoMap&&o.enable(8),L.emissiveMap&&o.enable(9),L.bumpMap&&o.enable(10),L.normalMap&&o.enable(11),L.objectSpaceNormalMap&&o.enable(12),L.tangentSpaceNormalMap&&o.enable(13),L.clearcoat&&o.enable(14),L.clearcoatMap&&o.enable(15),L.clearcoatRoughnessMap&&o.enable(16),L.clearcoatNormalMap&&o.enable(17),L.displacementMap&&o.enable(18),L.specularMap&&o.enable(19),L.roughnessMap&&o.enable(20),L.metalnessMap&&o.enable(21),L.gradientMap&&o.enable(22),L.alphaMap&&o.enable(23),L.alphaTest&&o.enable(24),L.vertexColors&&o.enable(25),L.vertexAlphas&&o.enable(26),L.vertexUvs&&o.enable(27),L.vertexTangents&&o.enable(28),L.uvsVertexOnly&&o.enable(29),L.fog&&o.enable(30),M.push(o.mask),o.disableAll(),L.useFog&&o.enable(0),L.flatShading&&o.enable(1),L.logarithmicDepthBuffer&&o.enable(2),L.skinning&&o.enable(3),L.morphTargets&&o.enable(4),L.morphNormals&&o.enable(5),L.morphColors&&o.enable(6),L.premultipliedAlpha&&o.enable(7),L.shadowMapEnabled&&o.enable(8),L.physicallyCorrectLights&&o.enable(9),L.doubleSided&&o.enable(10),L.flipSided&&o.enable(11),L.useDepthPacking&&o.enable(12),L.dithering&&o.enable(13),L.specularIntensityMap&&o.enable(14),L.specularColorMap&&o.enable(15),L.transmission&&o.enable(16),L.transmissionMap&&o.enable(17),L.thicknessMap&&o.enable(18),L.sheen&&o.enable(19),L.sheenColorMap&&o.enable(20),L.sheenRoughnessMap&&o.enable(21),L.decodeVideoTexture&&o.enable(22),L.opaque&&o.enable(23),M.push(o.mask)}function S(M){const L=v[M.type];let z;if(L){const V=Xn[L];z=Ga.clone(V.uniforms)}else z=M.uniforms;return z}function b(M,L){let z;for(let V=0,U=c.length;V<U;V++){const j=c[V];if(j.cacheKey===L){z=j,++z.usedTimes;break}}return z===void 0&&(z=new i3(s,L,M,r),c.push(z)),z}function E(M){if(--M.usedTimes===0){const L=c.indexOf(M);c[L]=c[c.length-1],c.pop(),M.destroy()}}function C(M){l.remove(M)}function P(){l.dispose()}return{getParameters:g,getProgramCacheKey:m,getUniforms:S,acquireProgram:b,releaseProgram:E,releaseShaderCache:C,programs:c,dispose:P}}function l3(){let s=new WeakMap;function e(r){let a=s.get(r);return a===void 0&&(a={},s.set(r,a)),a}function t(r){s.delete(r)}function n(r,a,o){s.get(r)[a]=o}function i(){s=new WeakMap}return{get:e,remove:t,update:n,dispose:i}}function c3(s,e){return s.groupOrder!==e.groupOrder?s.groupOrder-e.groupOrder:s.renderOrder!==e.renderOrder?s.renderOrder-e.renderOrder:s.material.id!==e.material.id?s.material.id-e.material.id:s.z!==e.z?s.z-e.z:s.id-e.id}function By(s,e){return s.groupOrder!==e.groupOrder?s.groupOrder-e.groupOrder:s.renderOrder!==e.renderOrder?s.renderOrder-e.renderOrder:s.z!==e.z?e.z-s.z:s.id-e.id}function Oy(){const s=[];let e=0;const t=[],n=[],i=[];function r(){e=0,t.length=0,n.length=0,i.length=0}function a(h,d,f,v,g,m){let x=s[e];return x===void 0?(x={id:h.id,object:h,geometry:d,material:f,groupOrder:v,renderOrder:h.renderOrder,z:g,group:m},s[e]=x):(x.id=h.id,x.object=h,x.geometry=d,x.material=f,x.groupOrder=v,x.renderOrder=h.renderOrder,x.z=g,x.group=m),e++,x}function o(h,d,f,v,g,m){const x=a(h,d,f,v,g,m);f.transmission>0?n.push(x):f.transparent===!0?i.push(x):t.push(x)}function l(h,d,f,v,g,m){const x=a(h,d,f,v,g,m);f.transmission>0?n.unshift(x):f.transparent===!0?i.unshift(x):t.unshift(x)}function c(h,d){t.length>1&&t.sort(h||c3),n.length>1&&n.sort(d||By),i.length>1&&i.sort(d||By)}function u(){for(let h=e,d=s.length;h<d;h++){const f=s[h];if(f.id===null)break;f.id=null,f.object=null,f.geometry=null,f.material=null,f.group=null}}return{opaque:t,transmissive:n,transparent:i,init:r,push:o,unshift:l,finish:u,sort:c}}function u3(){let s=new WeakMap;function e(n,i){let r;return s.has(n)===!1?(r=new Oy,s.set(n,[r])):i>=s.get(n).length?(r=new Oy,s.get(n).push(r)):r=s.get(n)[i],r}function t(){s=new WeakMap}return{get:e,dispose:t}}function h3(){const s={};return{get:function(e){if(s[e.id]!==void 0)return s[e.id];let t;switch(e.type){case"DirectionalLight":t={direction:new T,color:new ot};break;case"SpotLight":t={position:new T,direction:new T,color:new ot,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":t={position:new T,color:new ot,distance:0,decay:0};break;case"HemisphereLight":t={direction:new T,skyColor:new ot,groundColor:new ot};break;case"RectAreaLight":t={color:new ot,position:new T,halfWidth:new T,halfHeight:new T};break}return s[e.id]=t,t}}}function d3(){const s={};return{get:function(e){if(s[e.id]!==void 0)return s[e.id];let t;switch(e.type){case"DirectionalLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Me};break;case"SpotLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Me};break;case"PointLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Me,shadowCameraNear:1,shadowCameraFar:1e3};break}return s[e.id]=t,t}}}let f3=0;function p3(s,e){return(e.castShadow?1:0)-(s.castShadow?1:0)}function m3(s,e){const t=new h3,n=d3(),i={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let u=0;u<9;u++)i.probe.push(new T);const r=new T,a=new Ne,o=new Ne;function l(u,h){let d=0,f=0,v=0;for(let L=0;L<9;L++)i.probe[L].set(0,0,0);let g=0,m=0,x=0,w=0,S=0,b=0,E=0,C=0;u.sort(p3);const P=h!==!0?Math.PI:1;for(let L=0,z=u.length;L<z;L++){const V=u[L],U=V.color,j=V.intensity,F=V.distance,K=V.shadow&&V.shadow.map?V.shadow.map.texture:null;if(V.isAmbientLight)d+=U.r*j*P,f+=U.g*j*P,v+=U.b*j*P;else if(V.isLightProbe)for(let J=0;J<9;J++)i.probe[J].addScaledVector(V.sh.coefficients[J],j);else if(V.isDirectionalLight){const J=t.get(V);if(J.color.copy(V.color).multiplyScalar(V.intensity*P),V.castShadow){const se=V.shadow,le=n.get(V);le.shadowBias=se.bias,le.shadowNormalBias=se.normalBias,le.shadowRadius=se.radius,le.shadowMapSize=se.mapSize,i.directionalShadow[g]=le,i.directionalShadowMap[g]=K,i.directionalShadowMatrix[g]=V.shadow.matrix,b++}i.directional[g]=J,g++}else if(V.isSpotLight){const J=t.get(V);if(J.position.setFromMatrixPosition(V.matrixWorld),J.color.copy(U).multiplyScalar(j*P),J.distance=F,J.coneCos=Math.cos(V.angle),J.penumbraCos=Math.cos(V.angle*(1-V.penumbra)),J.decay=V.decay,V.castShadow){const se=V.shadow,le=n.get(V);le.shadowBias=se.bias,le.shadowNormalBias=se.normalBias,le.shadowRadius=se.radius,le.shadowMapSize=se.mapSize,i.spotShadow[x]=le,i.spotShadowMap[x]=K,i.spotShadowMatrix[x]=V.shadow.matrix,C++}i.spot[x]=J,x++}else if(V.isRectAreaLight){const J=t.get(V);J.color.copy(U).multiplyScalar(j),J.halfWidth.set(V.width*.5,0,0),J.halfHeight.set(0,V.height*.5,0),i.rectArea[w]=J,w++}else if(V.isPointLight){const J=t.get(V);if(J.color.copy(V.color).multiplyScalar(V.intensity*P),J.distance=V.distance,J.decay=V.decay,V.castShadow){const se=V.shadow,le=n.get(V);le.shadowBias=se.bias,le.shadowNormalBias=se.normalBias,le.shadowRadius=se.radius,le.shadowMapSize=se.mapSize,le.shadowCameraNear=se.camera.near,le.shadowCameraFar=se.camera.far,i.pointShadow[m]=le,i.pointShadowMap[m]=K,i.pointShadowMatrix[m]=V.shadow.matrix,E++}i.point[m]=J,m++}else if(V.isHemisphereLight){const J=t.get(V);J.skyColor.copy(V.color).multiplyScalar(j*P),J.groundColor.copy(V.groundColor).multiplyScalar(j*P),i.hemi[S]=J,S++}}w>0&&(e.isWebGL2||s.has("OES_texture_float_linear")===!0?(i.rectAreaLTC1=xt.LTC_FLOAT_1,i.rectAreaLTC2=xt.LTC_FLOAT_2):s.has("OES_texture_half_float_linear")===!0?(i.rectAreaLTC1=xt.LTC_HALF_1,i.rectAreaLTC2=xt.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),i.ambient[0]=d,i.ambient[1]=f,i.ambient[2]=v;const M=i.hash;(M.directionalLength!==g||M.pointLength!==m||M.spotLength!==x||M.rectAreaLength!==w||M.hemiLength!==S||M.numDirectionalShadows!==b||M.numPointShadows!==E||M.numSpotShadows!==C)&&(i.directional.length=g,i.spot.length=x,i.rectArea.length=w,i.point.length=m,i.hemi.length=S,i.directionalShadow.length=b,i.directionalShadowMap.length=b,i.pointShadow.length=E,i.pointShadowMap.length=E,i.spotShadow.length=C,i.spotShadowMap.length=C,i.directionalShadowMatrix.length=b,i.pointShadowMatrix.length=E,i.spotShadowMatrix.length=C,M.directionalLength=g,M.pointLength=m,M.spotLength=x,M.rectAreaLength=w,M.hemiLength=S,M.numDirectionalShadows=b,M.numPointShadows=E,M.numSpotShadows=C,i.version=f3++)}function c(u,h){let d=0,f=0,v=0,g=0,m=0;const x=h.matrixWorldInverse;for(let w=0,S=u.length;w<S;w++){const b=u[w];if(b.isDirectionalLight){const E=i.directional[d];E.direction.setFromMatrixPosition(b.matrixWorld),r.setFromMatrixPosition(b.target.matrixWorld),E.direction.sub(r),E.direction.transformDirection(x),d++}else if(b.isSpotLight){const E=i.spot[v];E.position.setFromMatrixPosition(b.matrixWorld),E.position.applyMatrix4(x),E.direction.setFromMatrixPosition(b.matrixWorld),r.setFromMatrixPosition(b.target.matrixWorld),E.direction.sub(r),E.direction.transformDirection(x),v++}else if(b.isRectAreaLight){const E=i.rectArea[g];E.position.setFromMatrixPosition(b.matrixWorld),E.position.applyMatrix4(x),o.identity(),a.copy(b.matrixWorld),a.premultiply(x),o.extractRotation(a),E.halfWidth.set(b.width*.5,0,0),E.halfHeight.set(0,b.height*.5,0),E.halfWidth.applyMatrix4(o),E.halfHeight.applyMatrix4(o),g++}else if(b.isPointLight){const E=i.point[f];E.position.setFromMatrixPosition(b.matrixWorld),E.position.applyMatrix4(x),f++}else if(b.isHemisphereLight){const E=i.hemi[m];E.direction.setFromMatrixPosition(b.matrixWorld),E.direction.transformDirection(x),m++}}}return{setup:l,setupView:c,state:i}}function Ny(s,e){const t=new m3(s,e),n=[],i=[];function r(){n.length=0,i.length=0}function a(h){n.push(h)}function o(h){i.push(h)}function l(h){t.setup(n,h)}function c(h){t.setupView(n,h)}return{init:r,state:{lightsArray:n,shadowsArray:i,lights:t},setupLights:l,setupLightsView:c,pushLight:a,pushShadow:o}}function g3(s,e){let t=new WeakMap;function n(r,a=0){let o;return t.has(r)===!1?(o=new Ny(s,e),t.set(r,[o])):a>=t.get(r).length?(o=new Ny(s,e),t.get(r).push(o)):o=t.get(r)[a],o}function i(){t=new WeakMap}return{get:n,dispose:i}}class Ah extends di{constructor(e){super(),this.type="MeshDepthMaterial",this.depthPacking=jS,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(e)}copy(e){return super.copy(e),this.depthPacking=e.depthPacking,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this}}Ah.prototype.isMeshDepthMaterial=!0;class Op extends di{constructor(e){super(),this.type="MeshDistanceMaterial",this.referencePosition=new T,this.nearDistance=1,this.farDistance=1e3,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(e)}copy(e){return super.copy(e),this.referencePosition.copy(e.referencePosition),this.nearDistance=e.nearDistance,this.farDistance=e.farDistance,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this}}Op.prototype.isMeshDistanceMaterial=!0;const v3=`void main() {
	gl_Position = vec4( position, 1.0 );
}`,y3=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;function nb(s,e,t){let n=new bh;const i=new Me,r=new Me,a=new Ft,o=new Ah({depthPacking:Ko}),l=new Op,c={},u=t.maxTextureSize,h={0:er,1:gr,2:Qt},d=new $n({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new Me},radius:{value:4}},vertexShader:v3,fragmentShader:y3}),f=d.clone();f.defines.HORIZONTAL_PASS=1;const v=new Xt;v.setAttribute("position",new Sn(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const g=new gn(v,d),m=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=AS,this.render=function(b,E,C){if(m.enabled===!1||m.autoUpdate===!1&&m.needsUpdate===!1||b.length===0)return;const P=s.getRenderTarget(),M=s.getActiveCubeFace(),L=s.getActiveMipmapLevel(),z=s.state;z.setBlending(ui),z.buffers.color.setClear(1,1,1,1),z.buffers.depth.setTest(!0),z.setScissorTest(!1);for(let V=0,U=b.length;V<U;V++){const j=b[V],F=j.shadow;if(F===void 0){console.warn("THREE.WebGLShadowMap:",j,"has no shadow.");continue}if(F.autoUpdate===!1&&F.needsUpdate===!1)continue;i.copy(F.mapSize);const K=F.getFrameExtents();if(i.multiply(K),r.copy(F.mapSize),(i.x>u||i.y>u)&&(i.x>u&&(r.x=Math.floor(u/K.x),i.x=r.x*K.x,F.mapSize.x=r.x),i.y>u&&(r.y=Math.floor(u/K.y),i.y=r.y*K.y,F.mapSize.y=r.y)),F.map===null&&!F.isPointLightShadow&&this.type===_l&&(F.map=new Yn(i.x,i.y),F.map.texture.name=j.name+".shadowMap",F.mapPass=new Yn(i.x,i.y),F.camera.updateProjectionMatrix()),F.map===null){const se={minFilter:wn,magFilter:wn,format:qi};F.map=new Yn(i.x,i.y,se),F.map.texture.name=j.name+".shadowMap",F.camera.updateProjectionMatrix()}s.setRenderTarget(F.map),s.clear();const J=F.getViewportCount();for(let se=0;se<J;se++){const le=F.getViewport(se);a.set(r.x*le.x,r.y*le.y,r.x*le.z,r.y*le.w),z.viewport(a),F.updateMatrices(j,se),n=F.getFrustum(),S(E,C,F.camera,j,this.type)}!F.isPointLightShadow&&this.type===_l&&x(F,C),F.needsUpdate=!1}m.needsUpdate=!1,s.setRenderTarget(P,M,L)};function x(b,E){const C=e.update(g);d.defines.VSM_SAMPLES!==b.blurSamples&&(d.defines.VSM_SAMPLES=b.blurSamples,f.defines.VSM_SAMPLES=b.blurSamples,d.needsUpdate=!0,f.needsUpdate=!0),d.uniforms.shadow_pass.value=b.map.texture,d.uniforms.resolution.value=b.mapSize,d.uniforms.radius.value=b.radius,s.setRenderTarget(b.mapPass),s.clear(),s.renderBufferDirect(E,null,C,d,g,null),f.uniforms.shadow_pass.value=b.mapPass.texture,f.uniforms.resolution.value=b.mapSize,f.uniforms.radius.value=b.radius,s.setRenderTarget(b.map),s.clear(),s.renderBufferDirect(E,null,C,f,g,null)}function w(b,E,C,P,M,L){let z=null;const V=C.isPointLight===!0?b.customDistanceMaterial:b.customDepthMaterial;if(V!==void 0?z=V:z=C.isPointLight===!0?l:o,s.localClippingEnabled&&E.clipShadows===!0&&E.clippingPlanes.length!==0||E.displacementMap&&E.displacementScale!==0||E.alphaMap&&E.alphaTest>0){const U=z.uuid,j=E.uuid;let F=c[U];F===void 0&&(F={},c[U]=F);let K=F[j];K===void 0&&(K=z.clone(),F[j]=K),z=K}return z.visible=E.visible,z.wireframe=E.wireframe,L===_l?z.side=E.shadowSide!==null?E.shadowSide:E.side:z.side=E.shadowSide!==null?E.shadowSide:h[E.side],z.alphaMap=E.alphaMap,z.alphaTest=E.alphaTest,z.clipShadows=E.clipShadows,z.clippingPlanes=E.clippingPlanes,z.clipIntersection=E.clipIntersection,z.displacementMap=E.displacementMap,z.displacementScale=E.displacementScale,z.displacementBias=E.displacementBias,z.wireframeLinewidth=E.wireframeLinewidth,z.linewidth=E.linewidth,C.isPointLight===!0&&z.isMeshDistanceMaterial===!0&&(z.referencePosition.setFromMatrixPosition(C.matrixWorld),z.nearDistance=P,z.farDistance=M),z}function S(b,E,C,P,M){if(b.visible===!1)return;if(b.layers.test(E.layers)&&(b.isMesh||b.isLine||b.isPoints)&&(b.castShadow||b.receiveShadow&&M===_l)&&(!b.frustumCulled||n.intersectsObject(b))){b.modelViewMatrix.multiplyMatrices(C.matrixWorldInverse,b.matrixWorld);const V=e.update(b),U=b.material;if(Array.isArray(U)){const j=V.groups;for(let F=0,K=j.length;F<K;F++){const J=j[F],se=U[J.materialIndex];if(se&&se.visible){const le=w(b,se,P,C.near,C.far,M);s.renderBufferDirect(C,null,V,le,b,J)}}}else if(U.visible){const j=w(b,U,P,C.near,C.far,M);s.renderBufferDirect(C,null,V,j,b,null)}}const z=b.children;for(let V=0,U=z.length;V<U;V++)S(z[V],E,C,P,M)}}function x3(s,e,t){const n=t.isWebGL2;function i(){let ee=!1;const We=new Ft;let Fe=null;const Oe=new Ft(0,0,0,0);return{setMask:function(nt){Fe!==nt&&!ee&&(s.colorMask(nt,nt,nt,nt),Fe=nt)},setLocked:function(nt){ee=nt},setClear:function(nt,st,Je,ae,Ot){Ot===!0&&(nt*=ae,st*=ae,Je*=ae),We.set(nt,st,Je,ae),Oe.equals(We)===!1&&(s.clearColor(nt,st,Je,ae),Oe.copy(We))},reset:function(){ee=!1,Fe=null,Oe.set(-1,0,0,0)}}}function r(){let ee=!1,We=null,Fe=null,Oe=null;return{setTest:function(nt){nt?pe(2929):Y(2929)},setMask:function(nt){We!==nt&&!ee&&(s.depthMask(nt),We=nt)},setFunc:function(nt){if(Fe!==nt){if(nt)switch(nt){case sT:s.depthFunc(512);break;case aT:s.depthFunc(519);break;case oT:s.depthFunc(513);break;case Ug:s.depthFunc(515);break;case lT:s.depthFunc(514);break;case cT:s.depthFunc(518);break;case uT:s.depthFunc(516);break;case hT:s.depthFunc(517);break;default:s.depthFunc(515)}else s.depthFunc(515);Fe=nt}},setLocked:function(nt){ee=nt},setClear:function(nt){Oe!==nt&&(s.clearDepth(nt),Oe=nt)},reset:function(){ee=!1,We=null,Fe=null,Oe=null}}}function a(){let ee=!1,We=null,Fe=null,Oe=null,nt=null,st=null,Je=null,ae=null,Ot=null;return{setTest:function(_t){ee||(_t?pe(2960):Y(2960))},setMask:function(_t){We!==_t&&!ee&&(s.stencilMask(_t),We=_t)},setFunc:function(_t,Bn,On){(Fe!==_t||Oe!==Bn||nt!==On)&&(s.stencilFunc(_t,Bn,On),Fe=_t,Oe=Bn,nt=On)},setOp:function(_t,Bn,On){(st!==_t||Je!==Bn||ae!==On)&&(s.stencilOp(_t,Bn,On),st=_t,Je=Bn,ae=On)},setLocked:function(_t){ee=_t},setClear:function(_t){Ot!==_t&&(s.clearStencil(_t),Ot=_t)},reset:function(){ee=!1,We=null,Fe=null,Oe=null,nt=null,st=null,Je=null,ae=null,Ot=null}}}const o=new i,l=new r,c=new a;let u={},h={},d=new WeakMap,f=[],v=null,g=!1,m=null,x=null,w=null,S=null,b=null,E=null,C=null,P=!1,M=null,L=null,z=null,V=null,U=null;const j=s.getParameter(35661);let F=!1,K=0;const J=s.getParameter(7938);J.indexOf("WebGL")!==-1?(K=parseFloat(/^WebGL (\d)/.exec(J)[1]),F=K>=1):J.indexOf("OpenGL ES")!==-1&&(K=parseFloat(/^OpenGL ES (\d)/.exec(J)[1]),F=K>=2);let se=null,le={};const q=s.getParameter(3088),te=s.getParameter(2978),H=new Ft().fromArray(q),$=new Ft().fromArray(te);function ce(ee,We,Fe){const Oe=new Uint8Array(4),nt=s.createTexture();s.bindTexture(ee,nt),s.texParameteri(ee,10241,9728),s.texParameteri(ee,10240,9728);for(let st=0;st<Fe;st++)s.texImage2D(We+st,0,6408,1,1,0,6408,5121,Oe);return nt}const xe={};xe[3553]=ce(3553,3553,1),xe[34067]=ce(34067,34069,6),o.setClear(0,0,0,1),l.setClear(1),c.setClear(0),pe(2929),l.setFunc(Ug),qe(!1),Qe(J0),pe(2884),X(ui);function pe(ee){u[ee]!==!0&&(s.enable(ee),u[ee]=!0)}function Y(ee){u[ee]!==!1&&(s.disable(ee),u[ee]=!1)}function Ie(ee,We){return h[ee]!==We?(s.bindFramebuffer(ee,We),h[ee]=We,n&&(ee===36009&&(h[36160]=We),ee===36160&&(h[36009]=We)),!0):!1}function re(ee,We){let Fe=f,Oe=!1;if(ee)if(Fe=d.get(We),Fe===void 0&&(Fe=[],d.set(We,Fe)),ee.isWebGLMultipleRenderTargets){const nt=ee.texture;if(Fe.length!==nt.length||Fe[0]!==36064){for(let st=0,Je=nt.length;st<Je;st++)Fe[st]=36064+st;Fe.length=nt.length,Oe=!0}}else Fe[0]!==36064&&(Fe[0]=36064,Oe=!0);else Fe[0]!==1029&&(Fe[0]=1029,Oe=!0);Oe&&(t.isWebGL2?s.drawBuffers(Fe):e.get("WEBGL_draw_buffers").drawBuffersWEBGL(Fe))}function oe(ee){return v!==ee?(s.useProgram(ee),v=ee,!0):!1}const ye={[rs]:32774,[$A]:32778,[ES]:32779};if(n)ye[$0]=32775,ye[Fg]=32776;else{const ee=e.get("EXT_blend_minmax");ee!==null&&(ye[$0]=ee.MIN_EXT,ye[Fg]=ee.MAX_EXT)}const ke={[Cf]:0,[Ao]:1,[eT]:768,[MS]:770,[rT]:776,[RS]:774,[Rv]:772,[tT]:769,[CS]:771,[iT]:775,[nT]:773};function X(ee,We,Fe,Oe,nt,st,Je,ae){if(ee===ui){g===!0&&(Y(3042),g=!1);return}if(g===!1&&(pe(3042),g=!0),ee!==Cp){if(ee!==m||ae!==P){if((x!==rs||b!==rs)&&(s.blendEquation(32774),x=rs,b=rs),ae)switch(ee){case Jl:s.blendFuncSeparate(1,771,1,771);break;case K0:s.blendFunc(1,1);break;case Y0:s.blendFuncSeparate(0,769,0,1);break;case Z0:s.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",ee);break}else switch(ee){case Jl:s.blendFuncSeparate(770,771,1,771);break;case K0:s.blendFunc(770,1);break;case Y0:s.blendFuncSeparate(0,769,0,1);break;case Z0:s.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",ee);break}w=null,S=null,E=null,C=null,m=ee,P=ae}return}nt=nt||We,st=st||Fe,Je=Je||Oe,(We!==x||nt!==b)&&(s.blendEquationSeparate(ye[We],ye[nt]),x=We,b=nt),(Fe!==w||Oe!==S||st!==E||Je!==C)&&(s.blendFuncSeparate(ke[Fe],ke[Oe],ke[st],ke[Je]),w=Fe,S=Oe,E=st,C=Je),m=ee,P=null}function Se(ee,We){ee.side===Qt?Y(2884):pe(2884);let Fe=ee.side===er;We&&(Fe=!Fe),qe(Fe),ee.blending===Jl&&ee.transparent===!1?X(ui):X(ee.blending,ee.blendEquation,ee.blendSrc,ee.blendDst,ee.blendEquationAlpha,ee.blendSrcAlpha,ee.blendDstAlpha,ee.premultipliedAlpha),l.setFunc(ee.depthFunc),l.setTest(ee.depthTest),l.setMask(ee.depthWrite),o.setMask(ee.colorWrite);const Oe=ee.stencilWrite;c.setTest(Oe),Oe&&(c.setMask(ee.stencilWriteMask),c.setFunc(ee.stencilFunc,ee.stencilRef,ee.stencilFuncMask),c.setOp(ee.stencilFail,ee.stencilZFail,ee.stencilZPass)),pt(ee.polygonOffset,ee.polygonOffsetFactor,ee.polygonOffsetUnits),ee.alphaToCoverage===!0?pe(32926):Y(32926)}function qe(ee){M!==ee&&(ee?s.frontFace(2304):s.frontFace(2305),M=ee)}function Qe(ee){ee!==KA?(pe(2884),ee!==L&&(ee===J0?s.cullFace(1029):ee===YA?s.cullFace(1028):s.cullFace(1032))):Y(2884),L=ee}function Ke(ee){ee!==z&&(F&&s.lineWidth(ee),z=ee)}function pt(ee,We,Fe){ee?(pe(32823),(V!==We||U!==Fe)&&(s.polygonOffset(We,Fe),V=We,U=Fe)):Y(32823)}function He(ee){ee?pe(3089):Y(3089)}function ze(ee){ee===void 0&&(ee=33984+j-1),se!==ee&&(s.activeTexture(ee),se=ee)}function rt(ee,We){se===null&&ze();let Fe=le[se];Fe===void 0&&(Fe={type:void 0,texture:void 0},le[se]=Fe),(Fe.type!==ee||Fe.texture!==We)&&(s.bindTexture(ee,We||xe[ee]),Fe.type=ee,Fe.texture=We)}function Le(){const ee=le[se];ee!==void 0&&ee.type!==void 0&&(s.bindTexture(ee.type,null),ee.type=void 0,ee.texture=void 0)}function k(){try{s.compressedTexImage2D.apply(s,arguments)}catch(ee){console.error("THREE.WebGLState:",ee)}}function B(){try{s.texSubImage2D.apply(s,arguments)}catch(ee){console.error("THREE.WebGLState:",ee)}}function G(){try{s.texSubImage3D.apply(s,arguments)}catch(ee){console.error("THREE.WebGLState:",ee)}}function ne(){try{s.compressedTexSubImage2D.apply(s,arguments)}catch(ee){console.error("THREE.WebGLState:",ee)}}function _e(){try{s.texStorage2D.apply(s,arguments)}catch(ee){console.error("THREE.WebGLState:",ee)}}function Ye(){try{s.texStorage3D.apply(s,arguments)}catch(ee){console.error("THREE.WebGLState:",ee)}}function et(){try{s.texImage2D.apply(s,arguments)}catch(ee){console.error("THREE.WebGLState:",ee)}}function we(){try{s.texImage3D.apply(s,arguments)}catch(ee){console.error("THREE.WebGLState:",ee)}}function bt(ee){H.equals(ee)===!1&&(s.scissor(ee.x,ee.y,ee.z,ee.w),H.copy(ee))}function wt(ee){$.equals(ee)===!1&&(s.viewport(ee.x,ee.y,ee.z,ee.w),$.copy(ee))}function tt(){s.disable(3042),s.disable(2884),s.disable(2929),s.disable(32823),s.disable(3089),s.disable(2960),s.disable(32926),s.blendEquation(32774),s.blendFunc(1,0),s.blendFuncSeparate(1,0,1,0),s.colorMask(!0,!0,!0,!0),s.clearColor(0,0,0,0),s.depthMask(!0),s.depthFunc(513),s.clearDepth(1),s.stencilMask(4294967295),s.stencilFunc(519,0,4294967295),s.stencilOp(7680,7680,7680),s.clearStencil(0),s.cullFace(1029),s.frontFace(2305),s.polygonOffset(0,0),s.activeTexture(33984),s.bindFramebuffer(36160,null),n===!0&&(s.bindFramebuffer(36009,null),s.bindFramebuffer(36008,null)),s.useProgram(null),s.lineWidth(1),s.scissor(0,0,s.canvas.width,s.canvas.height),s.viewport(0,0,s.canvas.width,s.canvas.height),u={},se=null,le={},h={},d=new WeakMap,f=[],v=null,g=!1,m=null,x=null,w=null,S=null,b=null,E=null,C=null,P=!1,M=null,L=null,z=null,V=null,U=null,H.set(0,0,s.canvas.width,s.canvas.height),$.set(0,0,s.canvas.width,s.canvas.height),o.reset(),l.reset(),c.reset()}return{buffers:{color:o,depth:l,stencil:c},enable:pe,disable:Y,bindFramebuffer:Ie,drawBuffers:re,useProgram:oe,setBlending:X,setMaterial:Se,setFlipSided:qe,setCullFace:Qe,setLineWidth:Ke,setPolygonOffset:pt,setScissorTest:He,activeTexture:ze,bindTexture:rt,unbindTexture:Le,compressedTexImage2D:k,texImage2D:et,texImage3D:we,texStorage2D:_e,texStorage3D:Ye,texSubImage2D:B,texSubImage3D:G,compressedTexSubImage2D:ne,scissor:bt,viewport:wt,reset:tt}}function w3(s,e,t,n,i,r,a){const o=i.isWebGL2,l=i.maxTextures,c=i.maxCubemapSize,u=i.maxTextureSize,h=i.maxSamples,d=e.has("WEBGL_multisampled_render_to_texture")?e.get("WEBGL_multisampled_render_to_texture"):null,f=/OculusBrowser/g.test(navigator.userAgent),v=new WeakMap;let g;const m=new WeakMap;let x=!1;try{x=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function w(k,B){return x?new OffscreenCanvas(k,B):Lu("canvas")}function S(k,B,G,ne){let _e=1;if((k.width>ne||k.height>ne)&&(_e=ne/Math.max(k.width,k.height)),_e<1||B===!0)if(typeof HTMLImageElement<"u"&&k instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&k instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&k instanceof ImageBitmap){const Ye=B?$f:Math.floor,et=Ye(_e*k.width),we=Ye(_e*k.height);g===void 0&&(g=w(et,we));const bt=G?w(et,we):g;return bt.width=et,bt.height=we,bt.getContext("2d").drawImage(k,0,0,et,we),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+k.width+"x"+k.height+") to ("+et+"x"+we+")."),bt}else return"data"in k&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+k.width+"x"+k.height+")."),k;return k}function b(k){return Gg(k.width)&&Gg(k.height)}function E(k){return o?!1:k.wrapS!==fr||k.wrapT!==fr||k.minFilter!==wn&&k.minFilter!==cn}function C(k,B){return k.generateMipmaps&&B&&k.minFilter!==wn&&k.minFilter!==cn}function P(k){s.generateMipmap(k)}function M(k,B,G,ne,_e=!1){if(o===!1)return B;if(k!==null){if(s[k]!==void 0)return s[k];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+k+"'")}let Ye=B;return B===6403&&(G===5126&&(Ye=33326),G===5131&&(Ye=33325),G===5121&&(Ye=33321)),B===33319&&(G===5126&&(Ye=33328),G===5131&&(Ye=33327),G===5121&&(Ye=33323)),B===6408&&(G===5126&&(Ye=34836),G===5131&&(Ye=34842),G===5121&&(Ye=ne===Wt&&_e===!1?35907:32856),G===32819&&(Ye=32854),G===32820&&(Ye=32855)),(Ye===33325||Ye===33326||Ye===33327||Ye===33328||Ye===34842||Ye===34836)&&e.get("EXT_color_buffer_float"),Ye}function L(k,B,G){return C(k,G)===!0||k.isFramebufferTexture&&k.minFilter!==wn&&k.minFilter!==cn?Math.log2(Math.max(B.width,B.height))+1:k.mipmaps!==void 0&&k.mipmaps.length>0?k.mipmaps.length:k.isCompressedTexture&&Array.isArray(k.image)?B.mipmaps.length:1}function z(k){return k===wn||k===ey||k===ty?9728:9729}function V(k){const B=k.target;B.removeEventListener("dispose",V),j(B),B.isVideoTexture&&v.delete(B)}function U(k){const B=k.target;B.removeEventListener("dispose",U),K(B)}function j(k){const B=n.get(k);if(B.__webglInit===void 0)return;const G=k.source,ne=m.get(G);if(ne){const _e=ne[B.__cacheKey];_e.usedTimes--,_e.usedTimes===0&&F(k),Object.keys(ne).length===0&&m.delete(G)}n.remove(k)}function F(k){const B=n.get(k);s.deleteTexture(B.__webglTexture);const G=k.source,ne=m.get(G);delete ne[B.__cacheKey],a.memory.textures--}function K(k){const B=k.texture,G=n.get(k),ne=n.get(B);if(ne.__webglTexture!==void 0&&(s.deleteTexture(ne.__webglTexture),a.memory.textures--),k.depthTexture&&k.depthTexture.dispose(),k.isWebGLCubeRenderTarget)for(let _e=0;_e<6;_e++)s.deleteFramebuffer(G.__webglFramebuffer[_e]),G.__webglDepthbuffer&&s.deleteRenderbuffer(G.__webglDepthbuffer[_e]);else s.deleteFramebuffer(G.__webglFramebuffer),G.__webglDepthbuffer&&s.deleteRenderbuffer(G.__webglDepthbuffer),G.__webglMultisampledFramebuffer&&s.deleteFramebuffer(G.__webglMultisampledFramebuffer),G.__webglColorRenderbuffer&&s.deleteRenderbuffer(G.__webglColorRenderbuffer),G.__webglDepthRenderbuffer&&s.deleteRenderbuffer(G.__webglDepthRenderbuffer);if(k.isWebGLMultipleRenderTargets)for(let _e=0,Ye=B.length;_e<Ye;_e++){const et=n.get(B[_e]);et.__webglTexture&&(s.deleteTexture(et.__webglTexture),a.memory.textures--),n.remove(B[_e])}n.remove(B),n.remove(k)}let J=0;function se(){J=0}function le(){const k=J;return k>=l&&console.warn("THREE.WebGLTextures: Trying to use "+k+" texture units while this GPU supports only "+l),J+=1,k}function q(k){const B=[];return B.push(k.wrapS),B.push(k.wrapT),B.push(k.magFilter),B.push(k.minFilter),B.push(k.anisotropy),B.push(k.internalFormat),B.push(k.format),B.push(k.type),B.push(k.generateMipmaps),B.push(k.premultiplyAlpha),B.push(k.flipY),B.push(k.unpackAlignment),B.push(k.encoding),B.join()}function te(k,B){const G=n.get(k);if(k.isVideoTexture&&rt(k),k.isRenderTargetTexture===!1&&k.version>0&&G.__version!==k.version){const ne=k.image;if(ne===null)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else if(ne.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{re(G,k,B);return}}t.activeTexture(33984+B),t.bindTexture(3553,G.__webglTexture)}function H(k,B){const G=n.get(k);if(k.version>0&&G.__version!==k.version){re(G,k,B);return}t.activeTexture(33984+B),t.bindTexture(35866,G.__webglTexture)}function $(k,B){const G=n.get(k);if(k.version>0&&G.__version!==k.version){re(G,k,B);return}t.activeTexture(33984+B),t.bindTexture(32879,G.__webglTexture)}function ce(k,B){const G=n.get(k);if(k.version>0&&G.__version!==k.version){oe(G,k,B);return}t.activeTexture(33984+B),t.bindTexture(34067,G.__webglTexture)}const xe={[Ho]:10497,[fr]:33071,[Vg]:33648},pe={[wn]:9728,[ey]:9984,[ty]:9986,[cn]:9729,[yT]:9985,[wh]:9987};function Y(k,B,G){if(G?(s.texParameteri(k,10242,xe[B.wrapS]),s.texParameteri(k,10243,xe[B.wrapT]),(k===32879||k===35866)&&s.texParameteri(k,32882,xe[B.wrapR]),s.texParameteri(k,10240,pe[B.magFilter]),s.texParameteri(k,10241,pe[B.minFilter])):(s.texParameteri(k,10242,33071),s.texParameteri(k,10243,33071),(k===32879||k===35866)&&s.texParameteri(k,32882,33071),(B.wrapS!==fr||B.wrapT!==fr)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),s.texParameteri(k,10240,z(B.magFilter)),s.texParameteri(k,10241,z(B.minFilter)),B.minFilter!==wn&&B.minFilter!==cn&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),e.has("EXT_texture_filter_anisotropic")===!0){const ne=e.get("EXT_texture_filter_anisotropic");if(B.type===Oi&&e.has("OES_texture_float_linear")===!1||o===!1&&B.type===Zi&&e.has("OES_texture_half_float_linear")===!1)return;(B.anisotropy>1||n.get(B).__currentAnisotropy)&&(s.texParameterf(k,ne.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(B.anisotropy,i.getMaxAnisotropy())),n.get(B).__currentAnisotropy=B.anisotropy)}}function Ie(k,B){let G=!1;k.__webglInit===void 0&&(k.__webglInit=!0,B.addEventListener("dispose",V));const ne=B.source;let _e=m.get(ne);_e===void 0&&(_e={},m.set(ne,_e));const Ye=q(B);if(Ye!==k.__cacheKey){_e[Ye]===void 0&&(_e[Ye]={texture:s.createTexture(),usedTimes:0},a.memory.textures++,G=!0),_e[Ye].usedTimes++;const et=_e[k.__cacheKey];et!==void 0&&(_e[k.__cacheKey].usedTimes--,et.usedTimes===0&&F(B)),k.__cacheKey=Ye,k.__webglTexture=_e[Ye].texture}return G}function re(k,B,G){let ne=3553;B.isDataArrayTexture&&(ne=35866),B.isData3DTexture&&(ne=32879);const _e=Ie(k,B),Ye=B.source;if(t.activeTexture(33984+G),t.bindTexture(ne,k.__webglTexture),Ye.version!==Ye.__currentVersion||_e===!0){s.pixelStorei(37440,B.flipY),s.pixelStorei(37441,B.premultiplyAlpha),s.pixelStorei(3317,B.unpackAlignment),s.pixelStorei(37443,0);const et=E(B)&&b(B.image)===!1;let we=S(B.image,et,!1,u);we=Le(B,we);const bt=b(we)||o,wt=r.convert(B.format,B.encoding);let tt=r.convert(B.type),ee=M(B.internalFormat,wt,tt,B.encoding,B.isVideoTexture);Y(ne,B,bt);let We;const Fe=B.mipmaps,Oe=o&&B.isVideoTexture!==!0,nt=k.__version===void 0||_e===!0,st=L(B,we,bt);if(B.isDepthTexture)ee=6402,o?B.type===Oi?ee=36012:B.type===gu?ee=33190:B.type===Fo?ee=35056:ee=33189:B.type===Oi&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),B.format===za&&ee===6402&&B.type!==vc&&B.type!==gu&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),B.type=vc,tt=r.convert(B.type)),B.format===Wo&&ee===6402&&(ee=34041,B.type!==Fo&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),B.type=Fo,tt=r.convert(B.type))),nt&&(Oe?t.texStorage2D(3553,1,ee,we.width,we.height):t.texImage2D(3553,0,ee,we.width,we.height,0,wt,tt,null));else if(B.isDataTexture)if(Fe.length>0&&bt){Oe&&nt&&t.texStorage2D(3553,st,ee,Fe[0].width,Fe[0].height);for(let Je=0,ae=Fe.length;Je<ae;Je++)We=Fe[Je],Oe?t.texSubImage2D(3553,Je,0,0,We.width,We.height,wt,tt,We.data):t.texImage2D(3553,Je,ee,We.width,We.height,0,wt,tt,We.data);B.generateMipmaps=!1}else Oe?(nt&&t.texStorage2D(3553,st,ee,we.width,we.height),t.texSubImage2D(3553,0,0,0,we.width,we.height,wt,tt,we.data)):t.texImage2D(3553,0,ee,we.width,we.height,0,wt,tt,we.data);else if(B.isCompressedTexture){Oe&&nt&&t.texStorage2D(3553,st,ee,Fe[0].width,Fe[0].height);for(let Je=0,ae=Fe.length;Je<ae;Je++)We=Fe[Je],B.format!==qi?wt!==null?Oe?t.compressedTexSubImage2D(3553,Je,0,0,We.width,We.height,wt,We.data):t.compressedTexImage2D(3553,Je,ee,We.width,We.height,0,We.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):Oe?t.texSubImage2D(3553,Je,0,0,We.width,We.height,wt,tt,We.data):t.texImage2D(3553,Je,ee,We.width,We.height,0,wt,tt,We.data)}else if(B.isDataArrayTexture)Oe?(nt&&t.texStorage3D(35866,st,ee,we.width,we.height,we.depth),t.texSubImage3D(35866,0,0,0,0,we.width,we.height,we.depth,wt,tt,we.data)):t.texImage3D(35866,0,ee,we.width,we.height,we.depth,0,wt,tt,we.data);else if(B.isData3DTexture)Oe?(nt&&t.texStorage3D(32879,st,ee,we.width,we.height,we.depth),t.texSubImage3D(32879,0,0,0,0,we.width,we.height,we.depth,wt,tt,we.data)):t.texImage3D(32879,0,ee,we.width,we.height,we.depth,0,wt,tt,we.data);else if(B.isFramebufferTexture){if(nt)if(Oe)t.texStorage2D(3553,st,ee,we.width,we.height);else{let Je=we.width,ae=we.height;for(let Ot=0;Ot<st;Ot++)t.texImage2D(3553,Ot,ee,Je,ae,0,wt,tt,null),Je>>=1,ae>>=1}}else if(Fe.length>0&&bt){Oe&&nt&&t.texStorage2D(3553,st,ee,Fe[0].width,Fe[0].height);for(let Je=0,ae=Fe.length;Je<ae;Je++)We=Fe[Je],Oe?t.texSubImage2D(3553,Je,0,0,wt,tt,We):t.texImage2D(3553,Je,ee,wt,tt,We);B.generateMipmaps=!1}else Oe?(nt&&t.texStorage2D(3553,st,ee,we.width,we.height),t.texSubImage2D(3553,0,0,0,wt,tt,we)):t.texImage2D(3553,0,ee,wt,tt,we);C(B,bt)&&P(ne),Ye.__currentVersion=Ye.version,B.onUpdate&&B.onUpdate(B)}k.__version=B.version}function oe(k,B,G){if(B.image.length!==6)return;const ne=Ie(k,B),_e=B.source;if(t.activeTexture(33984+G),t.bindTexture(34067,k.__webglTexture),_e.version!==_e.__currentVersion||ne===!0){s.pixelStorei(37440,B.flipY),s.pixelStorei(37441,B.premultiplyAlpha),s.pixelStorei(3317,B.unpackAlignment),s.pixelStorei(37443,0);const Ye=B.isCompressedTexture||B.image[0].isCompressedTexture,et=B.image[0]&&B.image[0].isDataTexture,we=[];for(let Je=0;Je<6;Je++)!Ye&&!et?we[Je]=S(B.image[Je],!1,!0,c):we[Je]=et?B.image[Je].image:B.image[Je],we[Je]=Le(B,we[Je]);const bt=we[0],wt=b(bt)||o,tt=r.convert(B.format,B.encoding),ee=r.convert(B.type),We=M(B.internalFormat,tt,ee,B.encoding),Fe=o&&B.isVideoTexture!==!0,Oe=k.__version===void 0;let nt=L(B,bt,wt);Y(34067,B,wt);let st;if(Ye){Fe&&Oe&&t.texStorage2D(34067,nt,We,bt.width,bt.height);for(let Je=0;Je<6;Je++){st=we[Je].mipmaps;for(let ae=0;ae<st.length;ae++){const Ot=st[ae];B.format!==qi?tt!==null?Fe?t.compressedTexSubImage2D(34069+Je,ae,0,0,Ot.width,Ot.height,tt,Ot.data):t.compressedTexImage2D(34069+Je,ae,We,Ot.width,Ot.height,0,Ot.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):Fe?t.texSubImage2D(34069+Je,ae,0,0,Ot.width,Ot.height,tt,ee,Ot.data):t.texImage2D(34069+Je,ae,We,Ot.width,Ot.height,0,tt,ee,Ot.data)}}}else{st=B.mipmaps,Fe&&Oe&&(st.length>0&&nt++,t.texStorage2D(34067,nt,We,we[0].width,we[0].height));for(let Je=0;Je<6;Je++)if(et){Fe?t.texSubImage2D(34069+Je,0,0,0,we[Je].width,we[Je].height,tt,ee,we[Je].data):t.texImage2D(34069+Je,0,We,we[Je].width,we[Je].height,0,tt,ee,we[Je].data);for(let ae=0;ae<st.length;ae++){const _t=st[ae].image[Je].image;Fe?t.texSubImage2D(34069+Je,ae+1,0,0,_t.width,_t.height,tt,ee,_t.data):t.texImage2D(34069+Je,ae+1,We,_t.width,_t.height,0,tt,ee,_t.data)}}else{Fe?t.texSubImage2D(34069+Je,0,0,0,tt,ee,we[Je]):t.texImage2D(34069+Je,0,We,tt,ee,we[Je]);for(let ae=0;ae<st.length;ae++){const Ot=st[ae];Fe?t.texSubImage2D(34069+Je,ae+1,0,0,tt,ee,Ot.image[Je]):t.texImage2D(34069+Je,ae+1,We,tt,ee,Ot.image[Je])}}}C(B,wt)&&P(34067),_e.__currentVersion=_e.version,B.onUpdate&&B.onUpdate(B)}k.__version=B.version}function ye(k,B,G,ne,_e){const Ye=r.convert(G.format,G.encoding),et=r.convert(G.type),we=M(G.internalFormat,Ye,et,G.encoding);n.get(B).__hasExternalTextures||(_e===32879||_e===35866?t.texImage3D(_e,0,we,B.width,B.height,B.depth,0,Ye,et,null):t.texImage2D(_e,0,we,B.width,B.height,0,Ye,et,null)),t.bindFramebuffer(36160,k),ze(B)?d.framebufferTexture2DMultisampleEXT(36160,ne,_e,n.get(G).__webglTexture,0,He(B)):s.framebufferTexture2D(36160,ne,_e,n.get(G).__webglTexture,0),t.bindFramebuffer(36160,null)}function ke(k,B,G){if(s.bindRenderbuffer(36161,k),B.depthBuffer&&!B.stencilBuffer){let ne=33189;if(G||ze(B)){const _e=B.depthTexture;_e&&_e.isDepthTexture&&(_e.type===Oi?ne=36012:_e.type===gu&&(ne=33190));const Ye=He(B);ze(B)?d.renderbufferStorageMultisampleEXT(36161,Ye,ne,B.width,B.height):s.renderbufferStorageMultisample(36161,Ye,ne,B.width,B.height)}else s.renderbufferStorage(36161,ne,B.width,B.height);s.framebufferRenderbuffer(36160,36096,36161,k)}else if(B.depthBuffer&&B.stencilBuffer){const ne=He(B);G&&ze(B)===!1?s.renderbufferStorageMultisample(36161,ne,35056,B.width,B.height):ze(B)?d.renderbufferStorageMultisampleEXT(36161,ne,35056,B.width,B.height):s.renderbufferStorage(36161,34041,B.width,B.height),s.framebufferRenderbuffer(36160,33306,36161,k)}else{const ne=B.isWebGLMultipleRenderTargets===!0?B.texture[0]:B.texture,_e=r.convert(ne.format,ne.encoding),Ye=r.convert(ne.type),et=M(ne.internalFormat,_e,Ye,ne.encoding),we=He(B);G&&ze(B)===!1?s.renderbufferStorageMultisample(36161,we,et,B.width,B.height):ze(B)?d.renderbufferStorageMultisampleEXT(36161,we,et,B.width,B.height):s.renderbufferStorage(36161,et,B.width,B.height)}s.bindRenderbuffer(36161,null)}function X(k,B){if(B&&B.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(t.bindFramebuffer(36160,k),!(B.depthTexture&&B.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!n.get(B.depthTexture).__webglTexture||B.depthTexture.image.width!==B.width||B.depthTexture.image.height!==B.height)&&(B.depthTexture.image.width=B.width,B.depthTexture.image.height=B.height,B.depthTexture.needsUpdate=!0),te(B.depthTexture,0);const ne=n.get(B.depthTexture).__webglTexture,_e=He(B);if(B.depthTexture.format===za)ze(B)?d.framebufferTexture2DMultisampleEXT(36160,36096,3553,ne,0,_e):s.framebufferTexture2D(36160,36096,3553,ne,0);else if(B.depthTexture.format===Wo)ze(B)?d.framebufferTexture2DMultisampleEXT(36160,33306,3553,ne,0,_e):s.framebufferTexture2D(36160,33306,3553,ne,0);else throw new Error("Unknown depthTexture format")}function Se(k){const B=n.get(k),G=k.isWebGLCubeRenderTarget===!0;if(k.depthTexture&&!B.__autoAllocateDepthBuffer){if(G)throw new Error("target.depthTexture not supported in Cube render targets");X(B.__webglFramebuffer,k)}else if(G){B.__webglDepthbuffer=[];for(let ne=0;ne<6;ne++)t.bindFramebuffer(36160,B.__webglFramebuffer[ne]),B.__webglDepthbuffer[ne]=s.createRenderbuffer(),ke(B.__webglDepthbuffer[ne],k,!1)}else t.bindFramebuffer(36160,B.__webglFramebuffer),B.__webglDepthbuffer=s.createRenderbuffer(),ke(B.__webglDepthbuffer,k,!1);t.bindFramebuffer(36160,null)}function qe(k,B,G){const ne=n.get(k);B!==void 0&&ye(ne.__webglFramebuffer,k,k.texture,36064,3553),G!==void 0&&Se(k)}function Qe(k){const B=k.texture,G=n.get(k),ne=n.get(B);k.addEventListener("dispose",U),k.isWebGLMultipleRenderTargets!==!0&&(ne.__webglTexture===void 0&&(ne.__webglTexture=s.createTexture()),ne.__version=B.version,a.memory.textures++);const _e=k.isWebGLCubeRenderTarget===!0,Ye=k.isWebGLMultipleRenderTargets===!0,et=b(k)||o;if(_e){G.__webglFramebuffer=[];for(let we=0;we<6;we++)G.__webglFramebuffer[we]=s.createFramebuffer()}else if(G.__webglFramebuffer=s.createFramebuffer(),Ye)if(i.drawBuffers){const we=k.texture;for(let bt=0,wt=we.length;bt<wt;bt++){const tt=n.get(we[bt]);tt.__webglTexture===void 0&&(tt.__webglTexture=s.createTexture(),a.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");else if(o&&k.samples>0&&ze(k)===!1){G.__webglMultisampledFramebuffer=s.createFramebuffer(),G.__webglColorRenderbuffer=s.createRenderbuffer(),s.bindRenderbuffer(36161,G.__webglColorRenderbuffer);const we=r.convert(B.format,B.encoding),bt=r.convert(B.type),wt=M(B.internalFormat,we,bt,B.encoding),tt=He(k);s.renderbufferStorageMultisample(36161,tt,wt,k.width,k.height),t.bindFramebuffer(36160,G.__webglMultisampledFramebuffer),s.framebufferRenderbuffer(36160,36064,36161,G.__webglColorRenderbuffer),s.bindRenderbuffer(36161,null),k.depthBuffer&&(G.__webglDepthRenderbuffer=s.createRenderbuffer(),ke(G.__webglDepthRenderbuffer,k,!0)),t.bindFramebuffer(36160,null)}if(_e){t.bindTexture(34067,ne.__webglTexture),Y(34067,B,et);for(let we=0;we<6;we++)ye(G.__webglFramebuffer[we],k,B,36064,34069+we);C(B,et)&&P(34067),t.unbindTexture()}else if(Ye){const we=k.texture;for(let bt=0,wt=we.length;bt<wt;bt++){const tt=we[bt],ee=n.get(tt);t.bindTexture(3553,ee.__webglTexture),Y(3553,tt,et),ye(G.__webglFramebuffer,k,tt,36064+bt,3553),C(tt,et)&&P(3553)}t.unbindTexture()}else{let we=3553;(k.isWebGL3DRenderTarget||k.isWebGLArrayRenderTarget)&&(o?we=k.isWebGL3DRenderTarget?32879:35866:console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),t.bindTexture(we,ne.__webglTexture),Y(we,B,et),ye(G.__webglFramebuffer,k,B,36064,we),C(B,et)&&P(we),t.unbindTexture()}k.depthBuffer&&Se(k)}function Ke(k){const B=b(k)||o,G=k.isWebGLMultipleRenderTargets===!0?k.texture:[k.texture];for(let ne=0,_e=G.length;ne<_e;ne++){const Ye=G[ne];if(C(Ye,B)){const et=k.isWebGLCubeRenderTarget?34067:3553,we=n.get(Ye).__webglTexture;t.bindTexture(et,we),P(et),t.unbindTexture()}}}function pt(k){if(o&&k.samples>0&&ze(k)===!1){const B=k.width,G=k.height;let ne=16384;const _e=[36064],Ye=k.stencilBuffer?33306:36096;k.depthBuffer&&_e.push(Ye);const et=n.get(k),we=et.__ignoreDepthValues!==void 0?et.__ignoreDepthValues:!1;we===!1&&(k.depthBuffer&&(ne|=256),k.stencilBuffer&&(ne|=1024)),t.bindFramebuffer(36008,et.__webglMultisampledFramebuffer),t.bindFramebuffer(36009,et.__webglFramebuffer),we===!0&&(s.invalidateFramebuffer(36008,[Ye]),s.invalidateFramebuffer(36009,[Ye])),s.blitFramebuffer(0,0,B,G,0,0,B,G,ne,9728),f&&s.invalidateFramebuffer(36008,_e),t.bindFramebuffer(36008,null),t.bindFramebuffer(36009,et.__webglMultisampledFramebuffer)}}function He(k){return Math.min(h,k.samples)}function ze(k){const B=n.get(k);return o&&k.samples>0&&e.has("WEBGL_multisampled_render_to_texture")===!0&&B.__useRenderToTexture!==!1}function rt(k){const B=a.render.frame;v.get(k)!==B&&(v.set(k,B),k.update())}function Le(k,B){const G=k.encoding,ne=k.format,_e=k.type;return k.isCompressedTexture===!0||k.isVideoTexture===!0||k.format===Zf||G!==Ir&&(G===Wt?o===!1?e.has("EXT_sRGB")===!0&&ne===qi?(k.format=Zf,k.minFilter=cn,k.generateMipmaps=!1):B=Zo.sRGBToLinear(B):(ne!==qi||_e!==Js)&&console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture encoding:",G)),B}this.allocateTextureUnit=le,this.resetTextureUnits=se,this.setTexture2D=te,this.setTexture2DArray=H,this.setTexture3D=$,this.setTextureCube=ce,this.rebindTextures=qe,this.setupRenderTarget=Qe,this.updateRenderTargetMipmap=Ke,this.updateMultisampleRenderTarget=pt,this.setupDepthRenderbuffer=Se,this.setupFrameBufferTexture=ye,this.useMultisampledRTT=ze}function S3(s,e,t){const n=t.isWebGL2;function i(r,a=null){let o;if(r===Js)return 5121;if(r===OS)return 32819;if(r===NS)return 32820;if(r===DS)return 5120;if(r===LS)return 5122;if(r===vc)return 5123;if(r===BS)return 5124;if(r===gu)return 5125;if(r===Oi)return 5126;if(r===Zi)return n?5131:(o=e.get("OES_texture_half_float"),o!==null?o.HALF_FLOAT_OES:null);if(r===zS)return 6406;if(r===qi)return 6408;if(r===US)return 6409;if(r===kS)return 6410;if(r===za)return 6402;if(r===Wo)return 34041;if(r===Iv)return 6403;if(r===FS)return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"),6408;if(r===Zf)return o=e.get("EXT_sRGB"),o!==null?o.SRGB_ALPHA_EXT:null;if(r===_S)return 36244;if(r===VS)return 33319;if(r===GS)return 33320;if(r===HS)return 36249;if(r===Kl||r===Yl||r===Zl||r===$l)if(a===Wt)if(o=e.get("WEBGL_compressed_texture_s3tc_srgb"),o!==null){if(r===Kl)return o.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(r===Yl)return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(r===Zl)return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(r===$l)return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else return null;else if(o=e.get("WEBGL_compressed_texture_s3tc"),o!==null){if(r===Kl)return o.COMPRESSED_RGB_S3TC_DXT1_EXT;if(r===Yl)return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(r===Zl)return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(r===$l)return o.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(r===Rf||r===If||r===Pf||r===Df)if(o=e.get("WEBGL_compressed_texture_pvrtc"),o!==null){if(r===Rf)return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(r===If)return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(r===Pf)return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(r===Df)return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(r===WS)return o=e.get("WEBGL_compressed_texture_etc1"),o!==null?o.COMPRESSED_RGB_ETC1_WEBGL:null;if(r===Lf||r===Bf)if(o=e.get("WEBGL_compressed_texture_etc"),o!==null){if(r===Lf)return a===Wt?o.COMPRESSED_SRGB8_ETC2:o.COMPRESSED_RGB8_ETC2;if(r===Bf)return a===Wt?o.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:o.COMPRESSED_RGBA8_ETC2_EAC}else return null;if(r===Of||r===Nf||r===zf||r===Ff||r===Uf||r===kf||r===_f||r===Vf||r===Gf||r===Hf||r===Wf||r===qf||r===jf||r===Qf)if(o=e.get("WEBGL_compressed_texture_astc"),o!==null){if(r===Of)return a===Wt?o.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:o.COMPRESSED_RGBA_ASTC_4x4_KHR;if(r===Nf)return a===Wt?o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:o.COMPRESSED_RGBA_ASTC_5x4_KHR;if(r===zf)return a===Wt?o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:o.COMPRESSED_RGBA_ASTC_5x5_KHR;if(r===Ff)return a===Wt?o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:o.COMPRESSED_RGBA_ASTC_6x5_KHR;if(r===Uf)return a===Wt?o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:o.COMPRESSED_RGBA_ASTC_6x6_KHR;if(r===kf)return a===Wt?o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:o.COMPRESSED_RGBA_ASTC_8x5_KHR;if(r===_f)return a===Wt?o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:o.COMPRESSED_RGBA_ASTC_8x6_KHR;if(r===Vf)return a===Wt?o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:o.COMPRESSED_RGBA_ASTC_8x8_KHR;if(r===Gf)return a===Wt?o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:o.COMPRESSED_RGBA_ASTC_10x5_KHR;if(r===Hf)return a===Wt?o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:o.COMPRESSED_RGBA_ASTC_10x6_KHR;if(r===Wf)return a===Wt?o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:o.COMPRESSED_RGBA_ASTC_10x8_KHR;if(r===qf)return a===Wt?o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:o.COMPRESSED_RGBA_ASTC_10x10_KHR;if(r===jf)return a===Wt?o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:o.COMPRESSED_RGBA_ASTC_12x10_KHR;if(r===Qf)return a===Wt?o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:o.COMPRESSED_RGBA_ASTC_12x12_KHR}else return null;if(r===Xf)if(o=e.get("EXT_texture_compression_bptc"),o!==null){if(r===Xf)return a===Wt?o.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:o.COMPRESSED_RGBA_BPTC_UNORM_EXT}else return null;return r===Fo?n?34042:(o=e.get("WEBGL_depth_texture"),o!==null?o.UNSIGNED_INT_24_8_WEBGL:null):s[r]!==void 0?s[r]:null}return{convert:i}}class ib extends li{constructor(e=[]){super(),this.cameras=e}}ib.prototype.isArrayCamera=!0;class Er extends fn{constructor(){super(),this.type="Group"}}Er.prototype.isGroup=!0;const b3={type:"move"};class Nm{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new Er,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new Er,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new T,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new T),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new Er,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new T,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new T),this._grip}dispatchEvent(e){return this._targetRay!==null&&this._targetRay.dispatchEvent(e),this._grip!==null&&this._grip.dispatchEvent(e),this._hand!==null&&this._hand.dispatchEvent(e),this}disconnect(e){return this.dispatchEvent({type:"disconnected",data:e}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(e,t,n){let i=null,r=null,a=null;const o=this._targetRay,l=this._grip,c=this._hand;if(e&&t.session.visibilityState!=="visible-blurred")if(o!==null&&(i=t.getPose(e.targetRaySpace,n),i!==null&&(o.matrix.fromArray(i.transform.matrix),o.matrix.decompose(o.position,o.rotation,o.scale),i.linearVelocity?(o.hasLinearVelocity=!0,o.linearVelocity.copy(i.linearVelocity)):o.hasLinearVelocity=!1,i.angularVelocity?(o.hasAngularVelocity=!0,o.angularVelocity.copy(i.angularVelocity)):o.hasAngularVelocity=!1,this.dispatchEvent(b3))),c&&e.hand){a=!0;for(const g of e.hand.values()){const m=t.getJointPose(g,n);if(c.joints[g.jointName]===void 0){const w=new Er;w.matrixAutoUpdate=!1,w.visible=!1,c.joints[g.jointName]=w,c.add(w)}const x=c.joints[g.jointName];m!==null&&(x.matrix.fromArray(m.transform.matrix),x.matrix.decompose(x.position,x.rotation,x.scale),x.jointRadius=m.radius),x.visible=m!==null}const u=c.joints["index-finger-tip"],h=c.joints["thumb-tip"],d=u.position.distanceTo(h.position),f=.02,v=.005;c.inputState.pinching&&d>f+v?(c.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:e.handedness,target:this})):!c.inputState.pinching&&d<=f-v&&(c.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:e.handedness,target:this}))}else l!==null&&e.gripSpace&&(r=t.getPose(e.gripSpace,n),r!==null&&(l.matrix.fromArray(r.transform.matrix),l.matrix.decompose(l.position,l.rotation,l.scale),r.linearVelocity?(l.hasLinearVelocity=!0,l.linearVelocity.copy(r.linearVelocity)):l.hasLinearVelocity=!1,r.angularVelocity?(l.hasAngularVelocity=!0,l.angularVelocity.copy(r.angularVelocity)):l.hasAngularVelocity=!1));return o!==null&&(o.visible=i!==null),l!==null&&(l.visible=r!==null),c!==null&&(c.visible=a!==null),this}}class rb extends hi{constructor(e,t,n,i,r,a,o,l,c,u){if(u=u!==void 0?u:za,u!==za&&u!==Wo)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");n===void 0&&u===za&&(n=vc),n===void 0&&u===Wo&&(n=Fo),super(null,i,r,a,o,l,u,n,c),this.image={width:e,height:t},this.magFilter=o!==void 0?o:wn,this.minFilter=l!==void 0?l:wn,this.flipY=!1,this.generateMipmaps=!1}}rb.prototype.isDepthTexture=!0;class A3 extends Yo{constructor(e,t){super();const n=this;let i=null,r=1,a=null,o="local-floor",l=null,c=null,u=null,h=null,d=null,f=null;const v=t.getContextAttributes();let g=null,m=null;const x=[],w=new Map,S=new li;S.layers.enable(1),S.viewport=new Ft;const b=new li;b.layers.enable(2),b.viewport=new Ft;const E=[S,b],C=new ib;C.layers.enable(1),C.layers.enable(2);let P=null,M=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(q){let te=x[q];return te===void 0&&(te=new Nm,x[q]=te),te.getTargetRaySpace()},this.getControllerGrip=function(q){let te=x[q];return te===void 0&&(te=new Nm,x[q]=te),te.getGripSpace()},this.getHand=function(q){let te=x[q];return te===void 0&&(te=new Nm,x[q]=te),te.getHandSpace()};function L(q){const te=w.get(q.inputSource);te&&te.dispatchEvent({type:q.type,data:q.inputSource})}function z(){w.forEach(function(q,te){q.disconnect(te)}),w.clear(),P=null,M=null,e.setRenderTarget(g),d=null,h=null,u=null,i=null,m=null,le.stop(),n.isPresenting=!1,n.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(q){r=q,n.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(q){o=q,n.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return l||a},this.setReferenceSpace=function(q){l=q},this.getBaseLayer=function(){return h!==null?h:d},this.getBinding=function(){return u},this.getFrame=function(){return f},this.getSession=function(){return i},this.setSession=async function(q){if(i=q,i!==null){if(g=e.getRenderTarget(),i.addEventListener("select",L),i.addEventListener("selectstart",L),i.addEventListener("selectend",L),i.addEventListener("squeeze",L),i.addEventListener("squeezestart",L),i.addEventListener("squeezeend",L),i.addEventListener("end",z),i.addEventListener("inputsourceschange",V),v.xrCompatible!==!0&&await t.makeXRCompatible(),i.renderState.layers===void 0||e.capabilities.isWebGL2===!1){const te={antialias:i.renderState.layers===void 0?v.antialias:!0,alpha:v.alpha,depth:v.depth,stencil:v.stencil,framebufferScaleFactor:r};d=new XRWebGLLayer(i,t,te),i.updateRenderState({baseLayer:d}),m=new Yn(d.framebufferWidth,d.framebufferHeight,{format:qi,type:Js,encoding:e.outputEncoding})}else{let te=null,H=null,$=null;v.depth&&($=v.stencil?35056:33190,te=v.stencil?Wo:za,H=v.stencil?Fo:vc);const ce={colorFormat:e.outputEncoding===Wt?35907:32856,depthFormat:$,scaleFactor:r};u=new XRWebGLBinding(i,t),h=u.createProjectionLayer(ce),i.updateRenderState({layers:[h]}),m=new Yn(h.textureWidth,h.textureHeight,{format:qi,type:Js,depthTexture:new rb(h.textureWidth,h.textureHeight,H,void 0,void 0,void 0,void 0,void 0,void 0,te),stencilBuffer:v.stencil,encoding:e.outputEncoding,samples:v.antialias?4:0});const xe=e.properties.get(m);xe.__ignoreDepthValues=h.ignoreDepthValues}m.isXRRenderTarget=!0,this.setFoveation(1),a=await i.requestReferenceSpace(o),le.setContext(i),le.start(),n.isPresenting=!0,n.dispatchEvent({type:"sessionstart"})}};function V(q){const te=i.inputSources;for(let H=0;H<te.length;H++){const $=te[H].handedness==="right"?1:0;w.set(te[H],x[$])}for(let H=0;H<q.removed.length;H++){const $=q.removed[H],ce=w.get($);ce&&(ce.dispatchEvent({type:"disconnected",data:$}),w.delete($))}for(let H=0;H<q.added.length;H++){const $=q.added[H],ce=w.get($);ce&&ce.dispatchEvent({type:"connected",data:$})}}const U=new T,j=new T;function F(q,te,H){U.setFromMatrixPosition(te.matrixWorld),j.setFromMatrixPosition(H.matrixWorld);const $=U.distanceTo(j),ce=te.projectionMatrix.elements,xe=H.projectionMatrix.elements,pe=ce[14]/(ce[10]-1),Y=ce[14]/(ce[10]+1),Ie=(ce[9]+1)/ce[5],re=(ce[9]-1)/ce[5],oe=(ce[8]-1)/ce[0],ye=(xe[8]+1)/xe[0],ke=pe*oe,X=pe*ye,Se=$/(-oe+ye),qe=Se*-oe;te.matrixWorld.decompose(q.position,q.quaternion,q.scale),q.translateX(qe),q.translateZ(Se),q.matrixWorld.compose(q.position,q.quaternion,q.scale),q.matrixWorldInverse.copy(q.matrixWorld).invert();const Qe=pe+Se,Ke=Y+Se,pt=ke-qe,He=X+($-qe),ze=Ie*Y/Ke*Qe,rt=re*Y/Ke*Qe;q.projectionMatrix.makePerspective(pt,He,ze,rt,Qe,Ke)}function K(q,te){te===null?q.matrixWorld.copy(q.matrix):q.matrixWorld.multiplyMatrices(te.matrixWorld,q.matrix),q.matrixWorldInverse.copy(q.matrixWorld).invert()}this.updateCamera=function(q){if(i===null)return;C.near=b.near=S.near=q.near,C.far=b.far=S.far=q.far,(P!==C.near||M!==C.far)&&(i.updateRenderState({depthNear:C.near,depthFar:C.far}),P=C.near,M=C.far);const te=q.parent,H=C.cameras;K(C,te);for(let ce=0;ce<H.length;ce++)K(H[ce],te);C.matrixWorld.decompose(C.position,C.quaternion,C.scale),q.position.copy(C.position),q.quaternion.copy(C.quaternion),q.scale.copy(C.scale),q.matrix.copy(C.matrix),q.matrixWorld.copy(C.matrixWorld);const $=q.children;for(let ce=0,xe=$.length;ce<xe;ce++)$[ce].updateMatrixWorld(!0);H.length===2?F(C,S,b):C.projectionMatrix.copy(S.projectionMatrix)},this.getCamera=function(){return C},this.getFoveation=function(){if(h!==null)return h.fixedFoveation;if(d!==null)return d.fixedFoveation},this.setFoveation=function(q){h!==null&&(h.fixedFoveation=q),d!==null&&d.fixedFoveation!==void 0&&(d.fixedFoveation=q)};let J=null;function se(q,te){if(c=te.getViewerPose(l||a),f=te,c!==null){const $=c.views;d!==null&&(e.setRenderTargetFramebuffer(m,d.framebuffer),e.setRenderTarget(m));let ce=!1;$.length!==C.cameras.length&&(C.cameras.length=0,ce=!0);for(let xe=0;xe<$.length;xe++){const pe=$[xe];let Y=null;if(d!==null)Y=d.getViewport(pe);else{const re=u.getViewSubImage(h,pe);Y=re.viewport,xe===0&&(e.setRenderTargetTextures(m,re.colorTexture,h.ignoreDepthValues?void 0:re.depthStencilTexture),e.setRenderTarget(m))}const Ie=E[xe];Ie.matrix.fromArray(pe.transform.matrix),Ie.projectionMatrix.fromArray(pe.projectionMatrix),Ie.viewport.set(Y.x,Y.y,Y.width,Y.height),xe===0&&C.matrix.copy(Ie.matrix),ce===!0&&C.cameras.push(Ie)}}const H=i.inputSources;for(let $=0;$<x.length;$++){const ce=H[$],xe=w.get(ce);xe!==void 0&&xe.update(ce,te,l||a)}J&&J(q,te),f=null}const le=new JS;le.setAnimationLoop(se),this.setAnimationLoop=function(q){J=q},this.dispose=function(){}}}function T3(s,e){function t(g,m){g.fogColor.value.copy(m.color),m.isFog?(g.fogNear.value=m.near,g.fogFar.value=m.far):m.isFogExp2&&(g.fogDensity.value=m.density)}function n(g,m,x,w,S){m.isMeshBasicMaterial||m.isMeshLambertMaterial?i(g,m):m.isMeshToonMaterial?(i(g,m),u(g,m)):m.isMeshPhongMaterial?(i(g,m),c(g,m)):m.isMeshStandardMaterial?(i(g,m),h(g,m),m.isMeshPhysicalMaterial&&d(g,m,S)):m.isMeshMatcapMaterial?(i(g,m),f(g,m)):m.isMeshDepthMaterial?i(g,m):m.isMeshDistanceMaterial?(i(g,m),v(g,m)):m.isMeshNormalMaterial?i(g,m):m.isLineBasicMaterial?(r(g,m),m.isLineDashedMaterial&&a(g,m)):m.isPointsMaterial?o(g,m,x,w):m.isSpriteMaterial?l(g,m):m.isShadowMaterial?(g.color.value.copy(m.color),g.opacity.value=m.opacity):m.isShaderMaterial&&(m.uniformsNeedUpdate=!1)}function i(g,m){g.opacity.value=m.opacity,m.color&&g.diffuse.value.copy(m.color),m.emissive&&g.emissive.value.copy(m.emissive).multiplyScalar(m.emissiveIntensity),m.map&&(g.map.value=m.map),m.alphaMap&&(g.alphaMap.value=m.alphaMap),m.bumpMap&&(g.bumpMap.value=m.bumpMap,g.bumpScale.value=m.bumpScale,m.side===er&&(g.bumpScale.value*=-1)),m.displacementMap&&(g.displacementMap.value=m.displacementMap,g.displacementScale.value=m.displacementScale,g.displacementBias.value=m.displacementBias),m.emissiveMap&&(g.emissiveMap.value=m.emissiveMap),m.normalMap&&(g.normalMap.value=m.normalMap,g.normalScale.value.copy(m.normalScale),m.side===er&&g.normalScale.value.negate()),m.specularMap&&(g.specularMap.value=m.specularMap),m.alphaTest>0&&(g.alphaTest.value=m.alphaTest);const x=e.get(m).envMap;if(x&&(g.envMap.value=x,g.flipEnvMap.value=x.isCubeTexture&&x.isRenderTargetTexture===!1?-1:1,g.reflectivity.value=m.reflectivity,g.ior.value=m.ior,g.refractionRatio.value=m.refractionRatio),m.lightMap){g.lightMap.value=m.lightMap;const b=s.physicallyCorrectLights!==!0?Math.PI:1;g.lightMapIntensity.value=m.lightMapIntensity*b}m.aoMap&&(g.aoMap.value=m.aoMap,g.aoMapIntensity.value=m.aoMapIntensity);let w;m.map?w=m.map:m.specularMap?w=m.specularMap:m.displacementMap?w=m.displacementMap:m.normalMap?w=m.normalMap:m.bumpMap?w=m.bumpMap:m.roughnessMap?w=m.roughnessMap:m.metalnessMap?w=m.metalnessMap:m.alphaMap?w=m.alphaMap:m.emissiveMap?w=m.emissiveMap:m.clearcoatMap?w=m.clearcoatMap:m.clearcoatNormalMap?w=m.clearcoatNormalMap:m.clearcoatRoughnessMap?w=m.clearcoatRoughnessMap:m.specularIntensityMap?w=m.specularIntensityMap:m.specularColorMap?w=m.specularColorMap:m.transmissionMap?w=m.transmissionMap:m.thicknessMap?w=m.thicknessMap:m.sheenColorMap?w=m.sheenColorMap:m.sheenRoughnessMap&&(w=m.sheenRoughnessMap),w!==void 0&&(w.isWebGLRenderTarget&&(w=w.texture),w.matrixAutoUpdate===!0&&w.updateMatrix(),g.uvTransform.value.copy(w.matrix));let S;m.aoMap?S=m.aoMap:m.lightMap&&(S=m.lightMap),S!==void 0&&(S.isWebGLRenderTarget&&(S=S.texture),S.matrixAutoUpdate===!0&&S.updateMatrix(),g.uv2Transform.value.copy(S.matrix))}function r(g,m){g.diffuse.value.copy(m.color),g.opacity.value=m.opacity}function a(g,m){g.dashSize.value=m.dashSize,g.totalSize.value=m.dashSize+m.gapSize,g.scale.value=m.scale}function o(g,m,x,w){g.diffuse.value.copy(m.color),g.opacity.value=m.opacity,g.size.value=m.size*x,g.scale.value=w*.5,m.map&&(g.map.value=m.map),m.alphaMap&&(g.alphaMap.value=m.alphaMap),m.alphaTest>0&&(g.alphaTest.value=m.alphaTest);let S;m.map?S=m.map:m.alphaMap&&(S=m.alphaMap),S!==void 0&&(S.matrixAutoUpdate===!0&&S.updateMatrix(),g.uvTransform.value.copy(S.matrix))}function l(g,m){g.diffuse.value.copy(m.color),g.opacity.value=m.opacity,g.rotation.value=m.rotation,m.map&&(g.map.value=m.map),m.alphaMap&&(g.alphaMap.value=m.alphaMap),m.alphaTest>0&&(g.alphaTest.value=m.alphaTest);let x;m.map?x=m.map:m.alphaMap&&(x=m.alphaMap),x!==void 0&&(x.matrixAutoUpdate===!0&&x.updateMatrix(),g.uvTransform.value.copy(x.matrix))}function c(g,m){g.specular.value.copy(m.specular),g.shininess.value=Math.max(m.shininess,1e-4)}function u(g,m){m.gradientMap&&(g.gradientMap.value=m.gradientMap)}function h(g,m){g.roughness.value=m.roughness,g.metalness.value=m.metalness,m.roughnessMap&&(g.roughnessMap.value=m.roughnessMap),m.metalnessMap&&(g.metalnessMap.value=m.metalnessMap),e.get(m).envMap&&(g.envMapIntensity.value=m.envMapIntensity)}function d(g,m,x){g.ior.value=m.ior,m.sheen>0&&(g.sheenColor.value.copy(m.sheenColor).multiplyScalar(m.sheen),g.sheenRoughness.value=m.sheenRoughness,m.sheenColorMap&&(g.sheenColorMap.value=m.sheenColorMap),m.sheenRoughnessMap&&(g.sheenRoughnessMap.value=m.sheenRoughnessMap)),m.clearcoat>0&&(g.clearcoat.value=m.clearcoat,g.clearcoatRoughness.value=m.clearcoatRoughness,m.clearcoatMap&&(g.clearcoatMap.value=m.clearcoatMap),m.clearcoatRoughnessMap&&(g.clearcoatRoughnessMap.value=m.clearcoatRoughnessMap),m.clearcoatNormalMap&&(g.clearcoatNormalScale.value.copy(m.clearcoatNormalScale),g.clearcoatNormalMap.value=m.clearcoatNormalMap,m.side===er&&g.clearcoatNormalScale.value.negate())),m.transmission>0&&(g.transmission.value=m.transmission,g.transmissionSamplerMap.value=x.texture,g.transmissionSamplerSize.value.set(x.width,x.height),m.transmissionMap&&(g.transmissionMap.value=m.transmissionMap),g.thickness.value=m.thickness,m.thicknessMap&&(g.thicknessMap.value=m.thicknessMap),g.attenuationDistance.value=m.attenuationDistance,g.attenuationColor.value.copy(m.attenuationColor)),g.specularIntensity.value=m.specularIntensity,g.specularColor.value.copy(m.specularColor),m.specularIntensityMap&&(g.specularIntensityMap.value=m.specularIntensityMap),m.specularColorMap&&(g.specularColorMap.value=m.specularColorMap)}function f(g,m){m.matcap&&(g.matcap.value=m.matcap)}function v(g,m){g.referencePosition.value.copy(m.referencePosition),g.nearDistance.value=m.nearDistance,g.farDistance.value=m.farDistance}return{refreshFogUniforms:t,refreshMaterialUniforms:n}}function E3(){const s=Lu("canvas");return s.style.display="block",s}function Tn(s={}){const e=s.canvas!==void 0?s.canvas:E3(),t=s.context!==void 0?s.context:null,n=s.depth!==void 0?s.depth:!0,i=s.stencil!==void 0?s.stencil:!0,r=s.antialias!==void 0?s.antialias:!1,a=s.premultipliedAlpha!==void 0?s.premultipliedAlpha:!0,o=s.preserveDrawingBuffer!==void 0?s.preserveDrawingBuffer:!1,l=s.powerPreference!==void 0?s.powerPreference:"default",c=s.failIfMajorPerformanceCaveat!==void 0?s.failIfMajorPerformanceCaveat:!1;let u;t!==null?u=t.getContextAttributes().alpha:u=s.alpha!==void 0?s.alpha:!1;let h=null,d=null;const f=[],v=[];this.domElement=e,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.outputEncoding=Ir,this.physicallyCorrectLights=!1,this.toneMapping=js,this.toneMappingExposure=1;const g=this;let m=!1,x=0,w=0,S=null,b=-1,E=null;const C=new Ft,P=new Ft;let M=null,L=e.width,z=e.height,V=1,U=null,j=null;const F=new Ft(0,0,L,z),K=new Ft(0,0,L,z);let J=!1;const se=new bh;let le=!1,q=!1,te=null;const H=new Ne,$=new Me,ce=new T,xe={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function pe(){return S===null?V:1}let Y=t;function Ie(_,Ae){for(let Be=0;Be<_.length;Be++){const Ce=_[Be],Ee=e.getContext(Ce,Ae);if(Ee!==null)return Ee}return null}try{const _={alpha:!0,depth:n,stencil:i,antialias:r,premultipliedAlpha:a,preserveDrawingBuffer:o,powerPreference:l,failIfMajorPerformanceCaveat:c};if("setAttribute"in e&&e.setAttribute("data-engine",`three.js r${Cv}`),e.addEventListener("webglcontextlost",ee,!1),e.addEventListener("webglcontextrestored",We,!1),Y===null){const Ae=["webgl2","webgl","experimental-webgl"];if(g.isWebGL1Renderer===!0&&Ae.shift(),Y=Ie(Ae,_),Y===null)throw Ie(Ae)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}Y.getShaderPrecisionFormat===void 0&&(Y.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(_){throw console.error("THREE.WebGLRenderer: "+_.message),_}let re,oe,ye,ke,X,Se,qe,Qe,Ke,pt,He,ze,rt,Le,k,B,G,ne,_e,Ye,et,we,bt;function wt(){re=new GC(Y),oe=new zC(Y,re,s),re.init(oe),we=new S3(Y,re,oe),ye=new x3(Y,re,oe),ke=new qC,X=new l3,Se=new w3(Y,re,ye,X,oe,we,ke),qe=new UC(g),Qe=new VC(g),Ke=new sE(Y,oe),bt=new OC(Y,re,Ke,oe),pt=new HC(Y,Ke,ke,bt),He=new JC(Y,pt,Ke,ke),_e=new XC(Y,oe,Se),B=new FC(X),ze=new o3(g,qe,Qe,re,oe,bt,B),rt=new T3(g,X),Le=new u3,k=new g3(re,oe),ne=new BC(g,qe,ye,He,u,a),G=new nb(g,He,oe),Ye=new NC(Y,re,ke,oe),et=new WC(Y,re,ke,oe),ke.programs=ze.programs,g.capabilities=oe,g.extensions=re,g.properties=X,g.renderLists=Le,g.shadowMap=G,g.state=ye,g.info=ke}wt();const tt=new A3(g,Y);this.xr=tt,this.getContext=function(){return Y},this.getContextAttributes=function(){return Y.getContextAttributes()},this.forceContextLoss=function(){const _=re.get("WEBGL_lose_context");_&&_.loseContext()},this.forceContextRestore=function(){const _=re.get("WEBGL_lose_context");_&&_.restoreContext()},this.getPixelRatio=function(){return V},this.setPixelRatio=function(_){_!==void 0&&(V=_,this.setSize(L,z,!1))},this.getSize=function(_){return _.set(L,z)},this.setSize=function(_,Ae,Be){if(tt.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}L=_,z=Ae,e.width=Math.floor(_*V),e.height=Math.floor(Ae*V),Be!==!1&&(e.style.width=_+"px",e.style.height=Ae+"px"),this.setViewport(0,0,_,Ae)},this.getDrawingBufferSize=function(_){return _.set(L*V,z*V).floor()},this.setDrawingBufferSize=function(_,Ae,Be){L=_,z=Ae,V=Be,e.width=Math.floor(_*Be),e.height=Math.floor(Ae*Be),this.setViewport(0,0,_,Ae)},this.getCurrentViewport=function(_){return _.copy(C)},this.getViewport=function(_){return _.copy(F)},this.setViewport=function(_,Ae,Be,Ce){_.isVector4?F.set(_.x,_.y,_.z,_.w):F.set(_,Ae,Be,Ce),ye.viewport(C.copy(F).multiplyScalar(V).floor())},this.getScissor=function(_){return _.copy(K)},this.setScissor=function(_,Ae,Be,Ce){_.isVector4?K.set(_.x,_.y,_.z,_.w):K.set(_,Ae,Be,Ce),ye.scissor(P.copy(K).multiplyScalar(V).floor())},this.getScissorTest=function(){return J},this.setScissorTest=function(_){ye.setScissorTest(J=_)},this.setOpaqueSort=function(_){U=_},this.setTransparentSort=function(_){j=_},this.getClearColor=function(_){return _.copy(ne.getClearColor())},this.setClearColor=function(){ne.setClearColor.apply(ne,arguments)},this.getClearAlpha=function(){return ne.getClearAlpha()},this.setClearAlpha=function(){ne.setClearAlpha.apply(ne,arguments)},this.clear=function(_=!0,Ae=!0,Be=!0){let Ce=0;_&&(Ce|=16384),Ae&&(Ce|=256),Be&&(Ce|=1024),Y.clear(Ce)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){e.removeEventListener("webglcontextlost",ee,!1),e.removeEventListener("webglcontextrestored",We,!1),Le.dispose(),k.dispose(),X.dispose(),qe.dispose(),Qe.dispose(),He.dispose(),bt.dispose(),ze.dispose(),tt.dispose(),tt.removeEventListener("sessionstart",ae),tt.removeEventListener("sessionend",Ot),te&&(te.dispose(),te=null),_t.stop()};function ee(_){_.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),m=!0}function We(){console.log("THREE.WebGLRenderer: Context Restored."),m=!1;const _=ke.autoReset,Ae=G.enabled,Be=G.autoUpdate,Ce=G.needsUpdate,Ee=G.type;wt(),ke.autoReset=_,G.enabled=Ae,G.autoUpdate=Be,G.needsUpdate=Ce,G.type=Ee}function Fe(_){const Ae=_.target;Ae.removeEventListener("dispose",Fe),Oe(Ae)}function Oe(_){nt(_),X.remove(_)}function nt(_){const Ae=X.get(_).programs;Ae!==void 0&&(Ae.forEach(function(Be){ze.releaseProgram(Be)}),_.isShaderMaterial&&ze.releaseShaderCache(_))}this.renderBufferDirect=function(_,Ae,Be,Ce,Ee,Ct){Ae===null&&(Ae=xe);const Nt=Ee.isMesh&&Ee.matrixWorld.determinant()<0,I=vn(_,Ae,Be,Ce,Ee);ye.setMaterial(Ce,Nt);let N=Be.index;const Q=Be.attributes.position;if(N===null){if(Q===void 0||Q.count===0)return}else if(N.count===0)return;let de=1;Ce.wireframe===!0&&(N=pt.getWireframeAttribute(Be),de=2),bt.setup(Ee,Ce,I,Be,N);let Re,Pe=Ye;N!==null&&(Re=Ke.get(N),Pe=et,Pe.setIndex(Re));const it=N!==null?N.count:Q.count,at=Be.drawRange.start*de,lt=Be.drawRange.count*de,je=Ct!==null?Ct.start*de:0,Ze=Ct!==null?Ct.count*de:1/0,Xe=Math.max(at,je),ct=Math.min(it,at+lt,je+Ze)-1,Et=Math.max(0,ct-Xe+1);if(Et!==0){if(Ee.isMesh)Ce.wireframe===!0?(ye.setLineWidth(Ce.wireframeLinewidth*pe()),Pe.setMode(1)):Pe.setMode(4);else if(Ee.isLine){let zt=Ce.linewidth;zt===void 0&&(zt=1),ye.setLineWidth(zt*pe()),Ee.isLineSegments?Pe.setMode(1):Ee.isLineLoop?Pe.setMode(2):Pe.setMode(3)}else Ee.isPoints?Pe.setMode(0):Ee.isSprite&&Pe.setMode(4);if(Ee.isInstancedMesh)Pe.renderInstances(Xe,Et,Ee.count);else if(Be.isInstancedBufferGeometry){const zt=Math.min(Be.instanceCount,Be._maxInstanceCount);Pe.renderInstances(Xe,Et,zt)}else Pe.render(Xe,Et)}},this.compile=function(_,Ae){d=k.get(_),d.init(),v.push(d),_.traverseVisible(function(Be){Be.isLight&&Be.layers.test(Ae.layers)&&(d.pushLight(Be),Be.castShadow&&d.pushShadow(Be))}),d.setupLights(g.physicallyCorrectLights),_.traverse(function(Be){const Ce=Be.material;if(Ce)if(Array.isArray(Ce))for(let Ee=0;Ee<Ce.length;Ee++){const Ct=Ce[Ee];yi(Ct,_,Be)}else yi(Ce,_,Be)}),v.pop(),d=null};let st=null;function Je(_){st&&st(_)}function ae(){_t.stop()}function Ot(){_t.start()}const _t=new JS;_t.setAnimationLoop(Je),typeof self<"u"&&_t.setContext(self),this.setAnimationLoop=function(_){st=_,tt.setAnimationLoop(_),_===null?_t.stop():_t.start()},tt.addEventListener("sessionstart",ae),tt.addEventListener("sessionend",Ot),this.render=function(_,Ae){if(Ae!==void 0&&Ae.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(m===!0)return;_.autoUpdate===!0&&_.updateMatrixWorld(),Ae.parent===null&&Ae.updateMatrixWorld(),tt.enabled===!0&&tt.isPresenting===!0&&(tt.cameraAutoUpdate===!0&&tt.updateCamera(Ae),Ae=tt.getCamera()),_.isScene===!0&&_.onBeforeRender(g,_,Ae,S),d=k.get(_,v.length),d.init(),v.push(d),H.multiplyMatrices(Ae.projectionMatrix,Ae.matrixWorldInverse),se.setFromProjectionMatrix(H),q=this.localClippingEnabled,le=B.init(this.clippingPlanes,q,Ae),h=Le.get(_,f.length),h.init(),f.push(h),Bn(_,Ae,0,g.sortObjects),h.finish(),g.sortObjects===!0&&h.sort(U,j),le===!0&&B.beginShadows();const Be=d.state.shadowsArray;if(G.render(Be,_,Ae),le===!0&&B.endShadows(),this.info.autoReset===!0&&this.info.reset(),ne.render(h,_),d.setupLights(g.physicallyCorrectLights),Ae.isArrayCamera){const Ce=Ae.cameras;for(let Ee=0,Ct=Ce.length;Ee<Ct;Ee++){const Nt=Ce[Ee];On(h,_,Nt,Nt.viewport)}}else On(h,_,Ae);S!==null&&(Se.updateMultisampleRenderTarget(S),Se.updateRenderTargetMipmap(S)),_.isScene===!0&&_.onAfterRender(g,_,Ae),bt.resetDefaultState(),b=-1,E=null,v.pop(),v.length>0?d=v[v.length-1]:d=null,f.pop(),f.length>0?h=f[f.length-1]:h=null};function Bn(_,Ae,Be,Ce){if(_.visible===!1)return;if(_.layers.test(Ae.layers)){if(_.isGroup)Be=_.renderOrder;else if(_.isLOD)_.autoUpdate===!0&&_.update(Ae);else if(_.isLight)d.pushLight(_),_.castShadow&&d.pushShadow(_);else if(_.isSprite){if(!_.frustumCulled||se.intersectsSprite(_)){Ce&&ce.setFromMatrixPosition(_.matrixWorld).applyMatrix4(H);const Nt=He.update(_),I=_.material;I.visible&&h.push(_,Nt,I,Be,ce.z,null)}}else if((_.isMesh||_.isLine||_.isPoints)&&(_.isSkinnedMesh&&_.skeleton.frame!==ke.render.frame&&(_.skeleton.update(),_.skeleton.frame=ke.render.frame),!_.frustumCulled||se.intersectsObject(_))){Ce&&ce.setFromMatrixPosition(_.matrixWorld).applyMatrix4(H);const Nt=He.update(_),I=_.material;if(Array.isArray(I)){const N=Nt.groups;for(let Q=0,de=N.length;Q<de;Q++){const Re=N[Q],Pe=I[Re.materialIndex];Pe&&Pe.visible&&h.push(_,Nt,Pe,Be,ce.z,Re)}}else I.visible&&h.push(_,Nt,I,Be,ce.z,null)}}const Ct=_.children;for(let Nt=0,I=Ct.length;Nt<I;Nt++)Bn(Ct[Nt],Ae,Be,Ce)}function On(_,Ae,Be,Ce){const Ee=_.opaque,Ct=_.transmissive,Nt=_.transparent;d.setupLightsView(Be),Ct.length>0&&ei(Ee,Ae,Be),Ce&&ye.viewport(C.copy(Ce)),Ee.length>0&&Vn(Ee,Ae,Be),Ct.length>0&&Vn(Ct,Ae,Be),Nt.length>0&&Vn(Nt,Ae,Be),ye.buffers.depth.setTest(!0),ye.buffers.depth.setMask(!0),ye.buffers.color.setMask(!0),ye.setPolygonOffset(!1)}function ei(_,Ae,Be){const Ce=oe.isWebGL2;te===null&&(te=new Yn(1,1,{generateMipmaps:!0,type:re.has("EXT_color_buffer_half_float")?Zi:Js,minFilter:wh,samples:Ce&&r===!0?4:0})),g.getDrawingBufferSize($),Ce?te.setSize($.x,$.y):te.setSize($f($.x),$f($.y));const Ee=g.getRenderTarget();g.setRenderTarget(te),g.clear();const Ct=g.toneMapping;g.toneMapping=js,Vn(_,Ae,Be),g.toneMapping=Ct,Se.updateMultisampleRenderTarget(te),Se.updateRenderTargetMipmap(te),g.setRenderTarget(Ee)}function Vn(_,Ae,Be){const Ce=Ae.isScene===!0?Ae.overrideMaterial:null;for(let Ee=0,Ct=_.length;Ee<Ct;Ee++){const Nt=_[Ee],I=Nt.object,N=Nt.geometry,Q=Ce===null?Nt.material:Ce,de=Nt.group;I.layers.test(Be.layers)&&En(I,Ae,Be,N,Q,de)}}function En(_,Ae,Be,Ce,Ee,Ct){_.onBeforeRender(g,Ae,Be,Ce,Ee,Ct),_.modelViewMatrix.multiplyMatrices(Be.matrixWorldInverse,_.matrixWorld),_.normalMatrix.getNormalMatrix(_.modelViewMatrix),Ee.onBeforeRender(g,Ae,Be,Ce,_,Ct),Ee.transparent===!0&&Ee.side===Qt?(Ee.side=er,Ee.needsUpdate=!0,g.renderBufferDirect(Be,Ae,Ce,Ee,_,Ct),Ee.side=gr,Ee.needsUpdate=!0,g.renderBufferDirect(Be,Ae,Ce,Ee,_,Ct),Ee.side=Qt):g.renderBufferDirect(Be,Ae,Ce,Ee,_,Ct),_.onAfterRender(g,Ae,Be,Ce,Ee,Ct)}function yi(_,Ae,Be){Ae.isScene!==!0&&(Ae=xe);const Ce=X.get(_),Ee=d.state.lights,Ct=d.state.shadowsArray,Nt=Ee.state.version,I=ze.getParameters(_,Ee.state,Ct,Ae,Be),N=ze.getProgramCacheKey(I);let Q=Ce.programs;Ce.environment=_.isMeshStandardMaterial?Ae.environment:null,Ce.fog=Ae.fog,Ce.envMap=(_.isMeshStandardMaterial?Qe:qe).get(_.envMap||Ce.environment),Q===void 0&&(_.addEventListener("dispose",Fe),Q=new Map,Ce.programs=Q);let de=Q.get(N);if(de!==void 0){if(Ce.currentProgram===de&&Ce.lightsStateVersion===Nt)return dn(_,I),de}else I.uniforms=ze.getUniforms(_),_.onBuild(Be,I,g),_.onBeforeCompile(I,g),de=ze.acquireProgram(I,N),Q.set(N,de),Ce.uniforms=I.uniforms;const Re=Ce.uniforms;(!_.isShaderMaterial&&!_.isRawShaderMaterial||_.clipping===!0)&&(Re.clippingPlanes=B.uniform),dn(_,I),Ce.needsLights=qt(_),Ce.lightsStateVersion=Nt,Ce.needsLights&&(Re.ambientLightColor.value=Ee.state.ambient,Re.lightProbe.value=Ee.state.probe,Re.directionalLights.value=Ee.state.directional,Re.directionalLightShadows.value=Ee.state.directionalShadow,Re.spotLights.value=Ee.state.spot,Re.spotLightShadows.value=Ee.state.spotShadow,Re.rectAreaLights.value=Ee.state.rectArea,Re.ltc_1.value=Ee.state.rectAreaLTC1,Re.ltc_2.value=Ee.state.rectAreaLTC2,Re.pointLights.value=Ee.state.point,Re.pointLightShadows.value=Ee.state.pointShadow,Re.hemisphereLights.value=Ee.state.hemi,Re.directionalShadowMap.value=Ee.state.directionalShadowMap,Re.directionalShadowMatrix.value=Ee.state.directionalShadowMatrix,Re.spotShadowMap.value=Ee.state.spotShadowMap,Re.spotShadowMatrix.value=Ee.state.spotShadowMatrix,Re.pointShadowMap.value=Ee.state.pointShadowMap,Re.pointShadowMatrix.value=Ee.state.pointShadowMatrix);const Pe=de.getUniforms(),it=Fa.seqWithValue(Pe.seq,Re);return Ce.currentProgram=de,Ce.uniformsList=it,de}function dn(_,Ae){const Be=X.get(_);Be.outputEncoding=Ae.outputEncoding,Be.instancing=Ae.instancing,Be.skinning=Ae.skinning,Be.morphTargets=Ae.morphTargets,Be.morphNormals=Ae.morphNormals,Be.morphColors=Ae.morphColors,Be.morphTargetsCount=Ae.morphTargetsCount,Be.numClippingPlanes=Ae.numClippingPlanes,Be.numIntersection=Ae.numClipIntersection,Be.vertexAlphas=Ae.vertexAlphas,Be.vertexTangents=Ae.vertexTangents,Be.toneMapping=Ae.toneMapping}function vn(_,Ae,Be,Ce,Ee){Ae.isScene!==!0&&(Ae=xe),Se.resetTextureUnits();const Ct=Ae.fog,Nt=Ce.isMeshStandardMaterial?Ae.environment:null,I=S===null?g.outputEncoding:S.isXRRenderTarget===!0?S.texture.encoding:Ir,N=(Ce.isMeshStandardMaterial?Qe:qe).get(Ce.envMap||Nt),Q=Ce.vertexColors===!0&&!!Be.attributes.color&&Be.attributes.color.itemSize===4,de=!!Ce.normalMap&&!!Be.attributes.tangent,Re=!!Be.morphAttributes.position,Pe=!!Be.morphAttributes.normal,it=!!Be.morphAttributes.color,at=Ce.toneMapped?g.toneMapping:js,lt=Be.morphAttributes.position||Be.morphAttributes.normal||Be.morphAttributes.color,je=lt!==void 0?lt.length:0,Ze=X.get(Ce),Xe=d.state.lights;if(le===!0&&(q===!0||_!==E)){const yn=_===E&&Ce.id===b;B.setState(Ce,_,yn)}let ct=!1;Ce.version===Ze.__version?(Ze.needsLights&&Ze.lightsStateVersion!==Xe.state.version||Ze.outputEncoding!==I||Ee.isInstancedMesh&&Ze.instancing===!1||!Ee.isInstancedMesh&&Ze.instancing===!0||Ee.isSkinnedMesh&&Ze.skinning===!1||!Ee.isSkinnedMesh&&Ze.skinning===!0||Ze.envMap!==N||Ce.fog===!0&&Ze.fog!==Ct||Ze.numClippingPlanes!==void 0&&(Ze.numClippingPlanes!==B.numPlanes||Ze.numIntersection!==B.numIntersection)||Ze.vertexAlphas!==Q||Ze.vertexTangents!==de||Ze.morphTargets!==Re||Ze.morphNormals!==Pe||Ze.morphColors!==it||Ze.toneMapping!==at||oe.isWebGL2===!0&&Ze.morphTargetsCount!==je)&&(ct=!0):(ct=!0,Ze.__version=Ce.version);let Et=Ze.currentProgram;ct===!0&&(Et=yi(Ce,Ae,Ee));let zt=!1,At=!1,Pt=!1;const Dt=Et.getUniforms(),rn=Ze.uniforms;if(ye.useProgram(Et.program)&&(zt=!0,At=!0,Pt=!0),Ce.id!==b&&(b=Ce.id,At=!0),zt||E!==_){if(Dt.setValue(Y,"projectionMatrix",_.projectionMatrix),oe.logarithmicDepthBuffer&&Dt.setValue(Y,"logDepthBufFC",2/(Math.log(_.far+1)/Math.LN2)),E!==_&&(E=_,At=!0,Pt=!0),Ce.isShaderMaterial||Ce.isMeshPhongMaterial||Ce.isMeshToonMaterial||Ce.isMeshStandardMaterial||Ce.envMap){const yn=Dt.map.cameraPosition;yn!==void 0&&yn.setValue(Y,ce.setFromMatrixPosition(_.matrixWorld))}(Ce.isMeshPhongMaterial||Ce.isMeshToonMaterial||Ce.isMeshLambertMaterial||Ce.isMeshBasicMaterial||Ce.isMeshStandardMaterial||Ce.isShaderMaterial)&&Dt.setValue(Y,"isOrthographic",_.isOrthographicCamera===!0),(Ce.isMeshPhongMaterial||Ce.isMeshToonMaterial||Ce.isMeshLambertMaterial||Ce.isMeshBasicMaterial||Ce.isMeshStandardMaterial||Ce.isShaderMaterial||Ce.isShadowMaterial||Ee.isSkinnedMesh)&&Dt.setValue(Y,"viewMatrix",_.matrixWorldInverse)}if(Ee.isSkinnedMesh){Dt.setOptional(Y,Ee,"bindMatrix"),Dt.setOptional(Y,Ee,"bindMatrixInverse");const yn=Ee.skeleton;yn&&(oe.floatVertexTextures?(yn.boneTexture===null&&yn.computeBoneTexture(),Dt.setValue(Y,"boneTexture",yn.boneTexture,Se),Dt.setValue(Y,"boneTextureSize",yn.boneTextureSize)):console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))}const on=Be.morphAttributes;return(on.position!==void 0||on.normal!==void 0||on.color!==void 0&&oe.isWebGL2===!0)&&_e.update(Ee,Be,Ce,Et),(At||Ze.receiveShadow!==Ee.receiveShadow)&&(Ze.receiveShadow=Ee.receiveShadow,Dt.setValue(Y,"receiveShadow",Ee.receiveShadow)),At&&(Dt.setValue(Y,"toneMappingExposure",g.toneMappingExposure),Ze.needsLights&&ti(rn,Pt),Ct&&Ce.fog===!0&&rt.refreshFogUniforms(rn,Ct),rt.refreshMaterialUniforms(rn,Ce,V,z,te),Fa.upload(Y,Ze.uniformsList,rn,Se)),Ce.isShaderMaterial&&Ce.uniformsNeedUpdate===!0&&(Fa.upload(Y,Ze.uniformsList,rn,Se),Ce.uniformsNeedUpdate=!1),Ce.isSpriteMaterial&&Dt.setValue(Y,"center",Ee.center),Dt.setValue(Y,"modelViewMatrix",Ee.modelViewMatrix),Dt.setValue(Y,"normalMatrix",Ee.normalMatrix),Dt.setValue(Y,"modelMatrix",Ee.matrixWorld),Et}function ti(_,Ae){_.ambientLightColor.needsUpdate=Ae,_.lightProbe.needsUpdate=Ae,_.directionalLights.needsUpdate=Ae,_.directionalLightShadows.needsUpdate=Ae,_.pointLights.needsUpdate=Ae,_.pointLightShadows.needsUpdate=Ae,_.spotLights.needsUpdate=Ae,_.spotLightShadows.needsUpdate=Ae,_.rectAreaLights.needsUpdate=Ae,_.hemisphereLights.needsUpdate=Ae}function qt(_){return _.isMeshLambertMaterial||_.isMeshToonMaterial||_.isMeshPhongMaterial||_.isMeshStandardMaterial||_.isShadowMaterial||_.isShaderMaterial&&_.lights===!0}this.getActiveCubeFace=function(){return x},this.getActiveMipmapLevel=function(){return w},this.getRenderTarget=function(){return S},this.setRenderTargetTextures=function(_,Ae,Be){X.get(_.texture).__webglTexture=Ae,X.get(_.depthTexture).__webglTexture=Be;const Ce=X.get(_);Ce.__hasExternalTextures=!0,Ce.__hasExternalTextures&&(Ce.__autoAllocateDepthBuffer=Be===void 0,Ce.__autoAllocateDepthBuffer||re.has("WEBGL_multisampled_render_to_texture")===!0&&(console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),Ce.__useRenderToTexture=!1))},this.setRenderTargetFramebuffer=function(_,Ae){const Be=X.get(_);Be.__webglFramebuffer=Ae,Be.__useDefaultFramebuffer=Ae===void 0},this.setRenderTarget=function(_,Ae=0,Be=0){S=_,x=Ae,w=Be;let Ce=!0;if(_){const N=X.get(_);N.__useDefaultFramebuffer!==void 0?(ye.bindFramebuffer(36160,null),Ce=!1):N.__webglFramebuffer===void 0?Se.setupRenderTarget(_):N.__hasExternalTextures&&Se.rebindTextures(_,X.get(_.texture).__webglTexture,X.get(_.depthTexture).__webglTexture)}let Ee=null,Ct=!1,Nt=!1;if(_){const N=_.texture;(N.isData3DTexture||N.isDataArrayTexture)&&(Nt=!0);const Q=X.get(_).__webglFramebuffer;_.isWebGLCubeRenderTarget?(Ee=Q[Ae],Ct=!0):oe.isWebGL2&&_.samples>0&&Se.useMultisampledRTT(_)===!1?Ee=X.get(_).__webglMultisampledFramebuffer:Ee=Q,C.copy(_.viewport),P.copy(_.scissor),M=_.scissorTest}else C.copy(F).multiplyScalar(V).floor(),P.copy(K).multiplyScalar(V).floor(),M=J;if(ye.bindFramebuffer(36160,Ee)&&oe.drawBuffers&&Ce&&ye.drawBuffers(_,Ee),ye.viewport(C),ye.scissor(P),ye.setScissorTest(M),Ct){const N=X.get(_.texture);Y.framebufferTexture2D(36160,36064,34069+Ae,N.__webglTexture,Be)}else if(Nt){const N=X.get(_.texture),Q=Ae||0;Y.framebufferTextureLayer(36160,36064,N.__webglTexture,Be||0,Q)}b=-1},this.readRenderTargetPixels=function(_,Ae,Be,Ce,Ee,Ct,Nt){if(!(_&&_.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let I=X.get(_).__webglFramebuffer;if(_.isWebGLCubeRenderTarget&&Nt!==void 0&&(I=I[Nt]),I){ye.bindFramebuffer(36160,I);try{const N=_.texture,Q=N.format,de=N.type;if(Q!==qi&&we.convert(Q)!==Y.getParameter(35739)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}const Re=de===Zi&&(re.has("EXT_color_buffer_half_float")||oe.isWebGL2&&re.has("EXT_color_buffer_float"));if(de!==Js&&we.convert(de)!==Y.getParameter(35738)&&!(de===Oi&&(oe.isWebGL2||re.has("OES_texture_float")||re.has("WEBGL_color_buffer_float")))&&!Re){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}Ae>=0&&Ae<=_.width-Ce&&Be>=0&&Be<=_.height-Ee&&Y.readPixels(Ae,Be,Ce,Ee,we.convert(Q),we.convert(de),Ct)}finally{const N=S!==null?X.get(S).__webglFramebuffer:null;ye.bindFramebuffer(36160,N)}}},this.copyFramebufferToTexture=function(_,Ae,Be=0){if(Ae.isFramebufferTexture!==!0){console.error("THREE.WebGLRenderer: copyFramebufferToTexture() can only be used with FramebufferTexture.");return}const Ce=Math.pow(2,-Be),Ee=Math.floor(Ae.image.width*Ce),Ct=Math.floor(Ae.image.height*Ce);Se.setTexture2D(Ae,0),Y.copyTexSubImage2D(3553,Be,0,0,_.x,_.y,Ee,Ct),ye.unbindTexture()},this.copyTextureToTexture=function(_,Ae,Be,Ce=0){const Ee=Ae.image.width,Ct=Ae.image.height,Nt=we.convert(Be.format),I=we.convert(Be.type);Se.setTexture2D(Be,0),Y.pixelStorei(37440,Be.flipY),Y.pixelStorei(37441,Be.premultiplyAlpha),Y.pixelStorei(3317,Be.unpackAlignment),Ae.isDataTexture?Y.texSubImage2D(3553,Ce,_.x,_.y,Ee,Ct,Nt,I,Ae.image.data):Ae.isCompressedTexture?Y.compressedTexSubImage2D(3553,Ce,_.x,_.y,Ae.mipmaps[0].width,Ae.mipmaps[0].height,Nt,Ae.mipmaps[0].data):Y.texSubImage2D(3553,Ce,_.x,_.y,Nt,I,Ae.image),Ce===0&&Be.generateMipmaps&&Y.generateMipmap(3553),ye.unbindTexture()},this.copyTextureToTexture3D=function(_,Ae,Be,Ce,Ee=0){if(g.isWebGL1Renderer){console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");return}const Ct=_.max.x-_.min.x+1,Nt=_.max.y-_.min.y+1,I=_.max.z-_.min.z+1,N=we.convert(Ce.format),Q=we.convert(Ce.type);let de;if(Ce.isData3DTexture)Se.setTexture3D(Ce,0),de=32879;else if(Ce.isDataArrayTexture)Se.setTexture2DArray(Ce,0),de=35866;else{console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");return}Y.pixelStorei(37440,Ce.flipY),Y.pixelStorei(37441,Ce.premultiplyAlpha),Y.pixelStorei(3317,Ce.unpackAlignment);const Re=Y.getParameter(3314),Pe=Y.getParameter(32878),it=Y.getParameter(3316),at=Y.getParameter(3315),lt=Y.getParameter(32877),je=Be.isCompressedTexture?Be.mipmaps[0]:Be.image;Y.pixelStorei(3314,je.width),Y.pixelStorei(32878,je.height),Y.pixelStorei(3316,_.min.x),Y.pixelStorei(3315,_.min.y),Y.pixelStorei(32877,_.min.z),Be.isDataTexture||Be.isData3DTexture?Y.texSubImage3D(de,Ee,Ae.x,Ae.y,Ae.z,Ct,Nt,I,N,Q,je.data):Be.isCompressedTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),Y.compressedTexSubImage3D(de,Ee,Ae.x,Ae.y,Ae.z,Ct,Nt,I,N,je.data)):Y.texSubImage3D(de,Ee,Ae.x,Ae.y,Ae.z,Ct,Nt,I,N,Q,je),Y.pixelStorei(3314,Re),Y.pixelStorei(32878,Pe),Y.pixelStorei(3316,it),Y.pixelStorei(3315,at),Y.pixelStorei(32877,lt),Ee===0&&Ce.generateMipmaps&&Y.generateMipmap(de),ye.unbindTexture()},this.initTexture=function(_){Se.setTexture2D(_,0),ye.unbindTexture()},this.resetState=function(){x=0,w=0,S=null,ye.reset(),bt.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}Tn.prototype.isWebGLRenderer=!0;class M3 extends Tn{}M3.prototype.isWebGL1Renderer=!0;class _v extends fn{constructor(){super(),this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(e,t){return super.copy(e,t),e.background!==null&&(this.background=e.background.clone()),e.environment!==null&&(this.environment=e.environment.clone()),e.fog!==null&&(this.fog=e.fog.clone()),e.overrideMaterial!==null&&(this.overrideMaterial=e.overrideMaterial.clone()),this.autoUpdate=e.autoUpdate,this.matrixAutoUpdate=e.matrixAutoUpdate,this}toJSON(e){const t=super.toJSON(e);return this.fog!==null&&(t.object.fog=this.fog.toJSON()),t}}_v.prototype.isScene=!0;class Th{constructor(e,t){this.array=e,this.stride=t,this.count=e!==void 0?e.length/t:0,this.usage=Pu,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=Qr()}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}copy(e){return this.array=new e.array.constructor(e.array),this.count=e.count,this.stride=e.stride,this.usage=e.usage,this}copyAt(e,t,n){e*=this.stride,n*=t.stride;for(let i=0,r=this.stride;i<r;i++)this.array[e+i]=t.array[n+i];return this}set(e,t=0){return this.array.set(e,t),this}clone(e){e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Qr()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const t=new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),n=new this.constructor(t,this.stride);return n.setUsage(this.usage),n}onUpload(e){return this.onUploadCallback=e,this}toJSON(e){return e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Qr()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=Array.prototype.slice.call(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}Th.prototype.isInterleavedBuffer=!0;const Ji=new T;class $i{constructor(e,t,n,i=!1){this.name="",this.data=e,this.itemSize=t,this.offset=n,this.normalized=i===!0}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(e){this.data.needsUpdate=e}applyMatrix4(e){for(let t=0,n=this.data.count;t<n;t++)Ji.fromBufferAttribute(this,t),Ji.applyMatrix4(e),this.setXYZ(t,Ji.x,Ji.y,Ji.z);return this}applyNormalMatrix(e){for(let t=0,n=this.count;t<n;t++)Ji.fromBufferAttribute(this,t),Ji.applyNormalMatrix(e),this.setXYZ(t,Ji.x,Ji.y,Ji.z);return this}transformDirection(e){for(let t=0,n=this.count;t<n;t++)Ji.fromBufferAttribute(this,t),Ji.transformDirection(e),this.setXYZ(t,Ji.x,Ji.y,Ji.z);return this}setX(e,t){return this.data.array[e*this.data.stride+this.offset]=t,this}setY(e,t){return this.data.array[e*this.data.stride+this.offset+1]=t,this}setZ(e,t){return this.data.array[e*this.data.stride+this.offset+2]=t,this}setW(e,t){return this.data.array[e*this.data.stride+this.offset+3]=t,this}getX(e){return this.data.array[e*this.data.stride+this.offset]}getY(e){return this.data.array[e*this.data.stride+this.offset+1]}getZ(e){return this.data.array[e*this.data.stride+this.offset+2]}getW(e){return this.data.array[e*this.data.stride+this.offset+3]}setXY(e,t,n){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=n,this}setXYZ(e,t,n,i){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=n,this.data.array[e+2]=i,this}setXYZW(e,t,n,i,r){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=n,this.data.array[e+2]=i,this.data.array[e+3]=r,this}clone(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");const t=[];for(let n=0;n<this.count;n++){const i=n*this.data.stride+this.offset;for(let r=0;r<this.itemSize;r++)t.push(this.data.array[i+r])}return new Sn(new this.array.constructor(t),this.itemSize,this.normalized)}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.clone(e)),new $i(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");const t=[];for(let n=0;n<this.count;n++){const i=n*this.data.stride+this.offset;for(let r=0;r<this.itemSize;r++)t.push(this.data.array[i+r])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:t,normalized:this.normalized}}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.toJSON(e)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}$i.prototype.isInterleavedBufferAttribute=!0;class Vv extends di{constructor(e){super(),this.type="SpriteMaterial",this.color=new ot(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.rotation=e.rotation,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}}Vv.prototype.isSpriteMaterial=!0;let Al;const $c=new T,Tl=new T,El=new T,Ml=new Me,eu=new Me,sb=new Ne,gd=new T,tu=new T,vd=new T,zy=new Me,zm=new Me,Fy=new Me;class C3 extends fn{constructor(e){if(super(),this.type="Sprite",Al===void 0){Al=new Xt;const t=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),n=new Th(t,5);Al.setIndex([0,1,2,0,2,3]),Al.setAttribute("position",new $i(n,3,0,!1)),Al.setAttribute("uv",new $i(n,2,3,!1))}this.geometry=Al,this.material=e!==void 0?e:new Vv,this.center=new Me(.5,.5)}raycast(e,t){e.camera===null&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),Tl.setFromMatrixScale(this.matrixWorld),sb.copy(e.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse,this.matrixWorld),El.setFromMatrixPosition(this.modelViewMatrix),e.camera.isPerspectiveCamera&&this.material.sizeAttenuation===!1&&Tl.multiplyScalar(-El.z);const n=this.material.rotation;let i,r;n!==0&&(r=Math.cos(n),i=Math.sin(n));const a=this.center;yd(gd.set(-.5,-.5,0),El,a,Tl,i,r),yd(tu.set(.5,-.5,0),El,a,Tl,i,r),yd(vd.set(.5,.5,0),El,a,Tl,i,r),zy.set(0,0),zm.set(1,0),Fy.set(1,1);let o=e.ray.intersectTriangle(gd,tu,vd,!1,$c);if(o===null&&(yd(tu.set(-.5,.5,0),El,a,Tl,i,r),zm.set(0,1),o=e.ray.intersectTriangle(gd,vd,tu,!1,$c),o===null))return;const l=e.ray.origin.distanceTo($c);l<e.near||l>e.far||t.push({distance:l,point:$c.clone(),uv:Cn.getUV($c,gd,tu,vd,zy,zm,Fy,new Me),face:null,object:this})}copy(e){return super.copy(e),e.center!==void 0&&this.center.copy(e.center),this.material=e.material,this}}C3.prototype.isSprite=!0;function yd(s,e,t,n,i,r){Ml.subVectors(s,t).addScalar(.5).multiply(n),i!==void 0?(eu.x=r*Ml.x-i*Ml.y,eu.y=i*Ml.x+r*Ml.y):eu.copy(Ml),s.copy(e),s.x+=eu.x,s.y+=eu.y,s.applyMatrix4(sb)}const Uy=new T,ky=new Ft,_y=new Ft,R3=new T,Vy=new Ne;class ab extends gn{constructor(e,t){super(e,t),this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new Ne,this.bindMatrixInverse=new Ne}copy(e){return super.copy(e),this.bindMode=e.bindMode,this.bindMatrix.copy(e.bindMatrix),this.bindMatrixInverse.copy(e.bindMatrixInverse),this.skeleton=e.skeleton,this}bind(e,t){this.skeleton=e,t===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),t=this.matrixWorld),this.bindMatrix.copy(t),this.bindMatrixInverse.copy(t).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const e=new Ft,t=this.geometry.attributes.skinWeight;for(let n=0,i=t.count;n<i;n++){e.fromBufferAttribute(t,n);const r=1/e.manhattanLength();r!==1/0?e.multiplyScalar(r):e.set(1,0,0,0),t.setXYZW(n,e.x,e.y,e.z,e.w)}}updateMatrixWorld(e){super.updateMatrixWorld(e),this.bindMode==="attached"?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode==="detached"?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}boneTransform(e,t){const n=this.skeleton,i=this.geometry;ky.fromBufferAttribute(i.attributes.skinIndex,e),_y.fromBufferAttribute(i.attributes.skinWeight,e),Uy.copy(t).applyMatrix4(this.bindMatrix),t.set(0,0,0);for(let r=0;r<4;r++){const a=_y.getComponent(r);if(a!==0){const o=ky.getComponent(r);Vy.multiplyMatrices(n.bones[o].matrixWorld,n.boneInverses[o]),t.addScaledVector(R3.copy(Uy).applyMatrix4(Vy),a)}}return t.applyMatrix4(this.bindMatrixInverse)}}ab.prototype.isSkinnedMesh=!0;class I3 extends fn{constructor(){super(),this.type="Bone"}}I3.prototype.isBone=!0;class Eh extends hi{constructor(e=null,t=1,n=1,i,r,a,o,l,c=wn,u=wn,h,d){super(null,a,o,l,c,u,i,r,h,d),this.image={data:e,width:t,height:n},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}Eh.prototype.isDataTexture=!0;class ko extends Sn{constructor(e,t,n,i=1){typeof n=="number"&&(i=n,n=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),super(e,t,n),this.meshPerAttribute=i}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}toJSON(){const e=super.toJSON();return e.meshPerAttribute=this.meshPerAttribute,e.isInstancedBufferAttribute=!0,e}}ko.prototype.isInstancedBufferAttribute=!0;const Gy=new Ne,Hy=new Ne,xd=[],nu=new gn;class ob extends gn{constructor(e,t,n){super(e,t),this.instanceMatrix=new ko(new Float32Array(n*16),16),this.instanceColor=null,this.count=n,this.frustumCulled=!1}copy(e){return super.copy(e),this.instanceMatrix.copy(e.instanceMatrix),e.instanceColor!==null&&(this.instanceColor=e.instanceColor.clone()),this.count=e.count,this}getColorAt(e,t){t.fromArray(this.instanceColor.array,e*3)}getMatrixAt(e,t){t.fromArray(this.instanceMatrix.array,e*16)}raycast(e,t){const n=this.matrixWorld,i=this.count;if(nu.geometry=this.geometry,nu.material=this.material,nu.material!==void 0)for(let r=0;r<i;r++){this.getMatrixAt(r,Gy),Hy.multiplyMatrices(n,Gy),nu.matrixWorld=Hy,nu.raycast(e,xd);for(let a=0,o=xd.length;a<o;a++){const l=xd[a];l.instanceId=r,l.object=this,t.push(l)}xd.length=0}}setColorAt(e,t){this.instanceColor===null&&(this.instanceColor=new ko(new Float32Array(this.instanceMatrix.count*3),3)),t.toArray(this.instanceColor.array,e*3)}setMatrixAt(e,t){t.toArray(this.instanceMatrix.array,e*16)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}}ob.prototype.isInstancedMesh=!0;class na extends di{constructor(e){super(),this.type="LineBasicMaterial",this.color=new ot(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.linewidth=e.linewidth,this.linecap=e.linecap,this.linejoin=e.linejoin,this.fog=e.fog,this}}na.prototype.isLineBasicMaterial=!0;const Wy=new T,qy=new T,jy=new Ne,Fm=new Ti,wd=new Zn;class Bu extends fn{constructor(e=new Xt,t=new na){super(),this.type="Line",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e){return super.copy(e),this.material=e.material,this.geometry=e.geometry,this}computeLineDistances(){const e=this.geometry;if(e.isBufferGeometry)if(e.index===null){const t=e.attributes.position,n=[0];for(let i=1,r=t.count;i<r;i++)Wy.fromBufferAttribute(t,i-1),qy.fromBufferAttribute(t,i),n[i]=n[i-1],n[i]+=Wy.distanceTo(qy);e.setAttribute("lineDistance",new Vt(n,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else e.isGeometry&&console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}raycast(e,t){const n=this.geometry,i=this.matrixWorld,r=e.params.Line.threshold,a=n.drawRange;if(n.boundingSphere===null&&n.computeBoundingSphere(),wd.copy(n.boundingSphere),wd.applyMatrix4(i),wd.radius+=r,e.ray.intersectsSphere(wd)===!1)return;jy.copy(i).invert(),Fm.copy(e.ray).applyMatrix4(jy);const o=r/((this.scale.x+this.scale.y+this.scale.z)/3),l=o*o,c=new T,u=new T,h=new T,d=new T,f=this.isLineSegments?2:1;if(n.isBufferGeometry){const v=n.index,m=n.attributes.position;if(v!==null){const x=Math.max(0,a.start),w=Math.min(v.count,a.start+a.count);for(let S=x,b=w-1;S<b;S+=f){const E=v.getX(S),C=v.getX(S+1);if(c.fromBufferAttribute(m,E),u.fromBufferAttribute(m,C),Fm.distanceSqToSegment(c,u,d,h)>l)continue;d.applyMatrix4(this.matrixWorld);const M=e.ray.origin.distanceTo(d);M<e.near||M>e.far||t.push({distance:M,point:h.clone().applyMatrix4(this.matrixWorld),index:S,face:null,faceIndex:null,object:this})}}else{const x=Math.max(0,a.start),w=Math.min(m.count,a.start+a.count);for(let S=x,b=w-1;S<b;S+=f){if(c.fromBufferAttribute(m,S),u.fromBufferAttribute(m,S+1),Fm.distanceSqToSegment(c,u,d,h)>l)continue;d.applyMatrix4(this.matrixWorld);const C=e.ray.origin.distanceTo(d);C<e.near||C>e.far||t.push({distance:C,point:h.clone().applyMatrix4(this.matrixWorld),index:S,face:null,faceIndex:null,object:this})}}}else n.isGeometry&&console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes,n=Object.keys(t);if(n.length>0){const i=t[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,a=i.length;r<a;r++){const o=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=r}}}}else{const t=e.morphTargets;t!==void 0&&t.length>0&&console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}Bu.prototype.isLine=!0;const Qy=new T,Xy=new T;class Np extends Bu{constructor(e,t){super(e,t),this.type="LineSegments"}computeLineDistances(){const e=this.geometry;if(e.isBufferGeometry)if(e.index===null){const t=e.attributes.position,n=[];for(let i=0,r=t.count;i<r;i+=2)Qy.fromBufferAttribute(t,i),Xy.fromBufferAttribute(t,i+1),n[i]=i===0?0:n[i-1],n[i+1]=n[i]+Qy.distanceTo(Xy);e.setAttribute("lineDistance",new Vt(n,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else e.isGeometry&&console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}}Np.prototype.isLineSegments=!0;class P3 extends Bu{constructor(e,t){super(e,t),this.type="LineLoop"}}P3.prototype.isLineLoop=!0;class zp extends di{constructor(e){super(),this.type="PointsMaterial",this.color=new ot(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.size=e.size,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}}zp.prototype.isPointsMaterial=!0;const Jy=new Ne,qg=new Ti,Sd=new Zn,bd=new T;class lb extends fn{constructor(e=new Xt,t=new zp){super(),this.type="Points",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e){return super.copy(e),this.material=e.material,this.geometry=e.geometry,this}raycast(e,t){const n=this.geometry,i=this.matrixWorld,r=e.params.Points.threshold,a=n.drawRange;if(n.boundingSphere===null&&n.computeBoundingSphere(),Sd.copy(n.boundingSphere),Sd.applyMatrix4(i),Sd.radius+=r,e.ray.intersectsSphere(Sd)===!1)return;Jy.copy(i).invert(),qg.copy(e.ray).applyMatrix4(Jy);const o=r/((this.scale.x+this.scale.y+this.scale.z)/3),l=o*o;if(n.isBufferGeometry){const c=n.index,h=n.attributes.position;if(c!==null){const d=Math.max(0,a.start),f=Math.min(c.count,a.start+a.count);for(let v=d,g=f;v<g;v++){const m=c.getX(v);bd.fromBufferAttribute(h,m),Ky(bd,m,l,i,e,t,this)}}else{const d=Math.max(0,a.start),f=Math.min(h.count,a.start+a.count);for(let v=d,g=f;v<g;v++)bd.fromBufferAttribute(h,v),Ky(bd,v,l,i,e,t,this)}}else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes,n=Object.keys(t);if(n.length>0){const i=t[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,a=i.length;r<a;r++){const o=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=r}}}}else{const t=e.morphTargets;t!==void 0&&t.length>0&&console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}lb.prototype.isPoints=!0;function Ky(s,e,t,n,i,r,a){const o=qg.distanceSqToPoint(s);if(o<t){const l=new T;qg.closestPointToPoint(s,l),l.applyMatrix4(n);const c=i.ray.origin.distanceTo(l);if(c<i.near||c>i.far)return;r.push({distance:c,distanceToRay:Math.sqrt(o),point:l,index:e,face:null,object:a})}}class D3 extends hi{constructor(e,t,n,i,r,a,o,l,c){super(e,t,n,i,r,a,o,l,c),this.minFilter=a!==void 0?a:cn,this.magFilter=r!==void 0?r:cn,this.generateMipmaps=!1;const u=this;function h(){u.needsUpdate=!0,e.requestVideoFrameCallback(h)}"requestVideoFrameCallback"in e&&e.requestVideoFrameCallback(h)}clone(){return new this.constructor(this.image).copy(this)}update(){const e=this.image;"requestVideoFrameCallback"in e===!1&&e.readyState>=e.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}D3.prototype.isVideoTexture=!0;class L3 extends hi{constructor(e,t,n){super({width:e,height:t}),this.format=n,this.magFilter=wn,this.minFilter=wn,this.generateMipmaps=!1,this.needsUpdate=!0}}L3.prototype.isFramebufferTexture=!0;class B3 extends hi{constructor(e,t,n,i,r,a,o,l,c,u,h,d){super(null,a,o,l,c,u,i,r,h,d),this.image={width:t,height:n},this.mipmaps=e,this.flipY=!1,this.generateMipmaps=!1}}B3.prototype.isCompressedTexture=!0;class O3 extends hi{constructor(e,t,n,i,r,a,o,l,c){super(e,t,n,i,r,a,o,l,c),this.needsUpdate=!0}}O3.prototype.isCanvasTexture=!0;class Dr{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(e,t){const n=this.getUtoTmapping(e);return this.getPoint(n,t)}getPoints(e=5){const t=[];for(let n=0;n<=e;n++)t.push(this.getPoint(n/e));return t}getSpacedPoints(e=5){const t=[];for(let n=0;n<=e;n++)t.push(this.getPointAt(n/e));return t}getLength(){const e=this.getLengths();return e[e.length-1]}getLengths(e=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===e+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const t=[];let n,i=this.getPoint(0),r=0;t.push(0);for(let a=1;a<=e;a++)n=this.getPoint(a/e),r+=n.distanceTo(i),t.push(r),i=n;return this.cacheArcLengths=t,t}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(e,t){const n=this.getLengths();let i=0;const r=n.length;let a;t?a=t:a=e*n[r-1];let o=0,l=r-1,c;for(;o<=l;)if(i=Math.floor(o+(l-o)/2),c=n[i]-a,c<0)o=i+1;else if(c>0)l=i-1;else{l=i;break}if(i=l,n[i]===a)return i/(r-1);const u=n[i],d=n[i+1]-u,f=(a-u)/d;return(i+f)/(r-1)}getTangent(e,t){let i=e-1e-4,r=e+1e-4;i<0&&(i=0),r>1&&(r=1);const a=this.getPoint(i),o=this.getPoint(r),l=t||(a.isVector2?new Me:new T);return l.copy(o).sub(a).normalize(),l}getTangentAt(e,t){const n=this.getUtoTmapping(e);return this.getTangent(n,t)}computeFrenetFrames(e,t){const n=new T,i=[],r=[],a=[],o=new T,l=new Ne;for(let f=0;f<=e;f++){const v=f/e;i[f]=this.getTangentAt(v,new T)}r[0]=new T,a[0]=new T;let c=Number.MAX_VALUE;const u=Math.abs(i[0].x),h=Math.abs(i[0].y),d=Math.abs(i[0].z);u<=c&&(c=u,n.set(1,0,0)),h<=c&&(c=h,n.set(0,1,0)),d<=c&&n.set(0,0,1),o.crossVectors(i[0],n).normalize(),r[0].crossVectors(i[0],o),a[0].crossVectors(i[0],r[0]);for(let f=1;f<=e;f++){if(r[f]=r[f-1].clone(),a[f]=a[f-1].clone(),o.crossVectors(i[f-1],i[f]),o.length()>Number.EPSILON){o.normalize();const v=Math.acos(oi(i[f-1].dot(i[f]),-1,1));r[f].applyMatrix4(l.makeRotationAxis(o,v))}a[f].crossVectors(i[f],r[f])}if(t===!0){let f=Math.acos(oi(r[0].dot(r[e]),-1,1));f/=e,i[0].dot(o.crossVectors(r[0],r[e]))>0&&(f=-f);for(let v=1;v<=e;v++)r[v].applyMatrix4(l.makeRotationAxis(i[v],f*v)),a[v].crossVectors(i[v],r[v])}return{tangents:i,normals:r,binormals:a}}clone(){return new this.constructor().copy(this)}copy(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}toJSON(){const e={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return e.arcLengthDivisions=this.arcLengthDivisions,e.type=this.type,e}fromJSON(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}}class Mh extends Dr{constructor(e=0,t=0,n=1,i=1,r=0,a=Math.PI*2,o=!1,l=0){super(),this.type="EllipseCurve",this.aX=e,this.aY=t,this.xRadius=n,this.yRadius=i,this.aStartAngle=r,this.aEndAngle=a,this.aClockwise=o,this.aRotation=l}getPoint(e,t){const n=t||new Me,i=Math.PI*2;let r=this.aEndAngle-this.aStartAngle;const a=Math.abs(r)<Number.EPSILON;for(;r<0;)r+=i;for(;r>i;)r-=i;r<Number.EPSILON&&(a?r=0:r=i),this.aClockwise===!0&&!a&&(r===i?r=-i:r=r-i);const o=this.aStartAngle+e*r;let l=this.aX+this.xRadius*Math.cos(o),c=this.aY+this.yRadius*Math.sin(o);if(this.aRotation!==0){const u=Math.cos(this.aRotation),h=Math.sin(this.aRotation),d=l-this.aX,f=c-this.aY;l=d*u-f*h+this.aX,c=d*h+f*u+this.aY}return n.set(l,c)}copy(e){return super.copy(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}toJSON(){const e=super.toJSON();return e.aX=this.aX,e.aY=this.aY,e.xRadius=this.xRadius,e.yRadius=this.yRadius,e.aStartAngle=this.aStartAngle,e.aEndAngle=this.aEndAngle,e.aClockwise=this.aClockwise,e.aRotation=this.aRotation,e}fromJSON(e){return super.fromJSON(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}}Mh.prototype.isEllipseCurve=!0;class cb extends Mh{constructor(e,t,n,i,r,a){super(e,t,n,n,i,r,a),this.type="ArcCurve"}}cb.prototype.isArcCurve=!0;function Gv(){let s=0,e=0,t=0,n=0;function i(r,a,o,l){s=r,e=o,t=-3*r+3*a-2*o-l,n=2*r-2*a+o+l}return{initCatmullRom:function(r,a,o,l,c){i(a,o,c*(o-r),c*(l-a))},initNonuniformCatmullRom:function(r,a,o,l,c,u,h){let d=(a-r)/c-(o-r)/(c+u)+(o-a)/u,f=(o-a)/u-(l-a)/(u+h)+(l-o)/h;d*=u,f*=u,i(a,o,d,f)},calc:function(r){const a=r*r,o=a*r;return s+e*r+t*a+n*o}}}const Ad=new T,Um=new Gv,km=new Gv,_m=new Gv;class ub extends Dr{constructor(e=[],t=!1,n="centripetal",i=.5){super(),this.type="CatmullRomCurve3",this.points=e,this.closed=t,this.curveType=n,this.tension=i}getPoint(e,t=new T){const n=t,i=this.points,r=i.length,a=(r-(this.closed?0:1))*e;let o=Math.floor(a),l=a-o;this.closed?o+=o>0?0:(Math.floor(Math.abs(o)/r)+1)*r:l===0&&o===r-1&&(o=r-2,l=1);let c,u;this.closed||o>0?c=i[(o-1)%r]:(Ad.subVectors(i[0],i[1]).add(i[0]),c=Ad);const h=i[o%r],d=i[(o+1)%r];if(this.closed||o+2<r?u=i[(o+2)%r]:(Ad.subVectors(i[r-1],i[r-2]).add(i[r-1]),u=Ad),this.curveType==="centripetal"||this.curveType==="chordal"){const f=this.curveType==="chordal"?.5:.25;let v=Math.pow(c.distanceToSquared(h),f),g=Math.pow(h.distanceToSquared(d),f),m=Math.pow(d.distanceToSquared(u),f);g<1e-4&&(g=1),v<1e-4&&(v=g),m<1e-4&&(m=g),Um.initNonuniformCatmullRom(c.x,h.x,d.x,u.x,v,g,m),km.initNonuniformCatmullRom(c.y,h.y,d.y,u.y,v,g,m),_m.initNonuniformCatmullRom(c.z,h.z,d.z,u.z,v,g,m)}else this.curveType==="catmullrom"&&(Um.initCatmullRom(c.x,h.x,d.x,u.x,this.tension),km.initCatmullRom(c.y,h.y,d.y,u.y,this.tension),_m.initCatmullRom(c.z,h.z,d.z,u.z,this.tension));return n.set(Um.calc(l),km.calc(l),_m.calc(l)),n}copy(e){super.copy(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const i=e.points[t];this.points.push(i.clone())}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}toJSON(){const e=super.toJSON();e.points=[];for(let t=0,n=this.points.length;t<n;t++){const i=this.points[t];e.points.push(i.toArray())}return e.closed=this.closed,e.curveType=this.curveType,e.tension=this.tension,e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const i=e.points[t];this.points.push(new T().fromArray(i))}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}}ub.prototype.isCatmullRomCurve3=!0;function Yy(s,e,t,n,i){const r=(n-e)*.5,a=(i-t)*.5,o=s*s,l=s*o;return(2*t-2*n+r+a)*l+(-3*t+3*n-2*r-a)*o+r*s+t}function N3(s,e){const t=1-s;return t*t*e}function z3(s,e){return 2*(1-s)*s*e}function F3(s,e){return s*s*e}function xu(s,e,t,n){return N3(s,e)+z3(s,t)+F3(s,n)}function U3(s,e){const t=1-s;return t*t*t*e}function k3(s,e){const t=1-s;return 3*t*t*s*e}function _3(s,e){return 3*(1-s)*s*s*e}function V3(s,e){return s*s*s*e}function wu(s,e,t,n,i){return U3(s,e)+k3(s,t)+_3(s,n)+V3(s,i)}class Hv extends Dr{constructor(e=new Me,t=new Me,n=new Me,i=new Me){super(),this.type="CubicBezierCurve",this.v0=e,this.v1=t,this.v2=n,this.v3=i}getPoint(e,t=new Me){const n=t,i=this.v0,r=this.v1,a=this.v2,o=this.v3;return n.set(wu(e,i.x,r.x,a.x,o.x),wu(e,i.y,r.y,a.y,o.y)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}Hv.prototype.isCubicBezierCurve=!0;class hb extends Dr{constructor(e=new T,t=new T,n=new T,i=new T){super(),this.type="CubicBezierCurve3",this.v0=e,this.v1=t,this.v2=n,this.v3=i}getPoint(e,t=new T){const n=t,i=this.v0,r=this.v1,a=this.v2,o=this.v3;return n.set(wu(e,i.x,r.x,a.x,o.x),wu(e,i.y,r.y,a.y,o.y),wu(e,i.z,r.z,a.z,o.z)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}hb.prototype.isCubicBezierCurve3=!0;class Fp extends Dr{constructor(e=new Me,t=new Me){super(),this.type="LineCurve",this.v1=e,this.v2=t}getPoint(e,t=new Me){const n=t;return e===1?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(e).add(this.v1)),n}getPointAt(e,t){return this.getPoint(e,t)}getTangent(e,t){const n=t||new Me;return n.copy(this.v2).sub(this.v1).normalize(),n}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}Fp.prototype.isLineCurve=!0;class G3 extends Dr{constructor(e=new T,t=new T){super(),this.type="LineCurve3",this.isLineCurve3=!0,this.v1=e,this.v2=t}getPoint(e,t=new T){const n=t;return e===1?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(e).add(this.v1)),n}getPointAt(e,t){return this.getPoint(e,t)}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class Wv extends Dr{constructor(e=new Me,t=new Me,n=new Me){super(),this.type="QuadraticBezierCurve",this.v0=e,this.v1=t,this.v2=n}getPoint(e,t=new Me){const n=t,i=this.v0,r=this.v1,a=this.v2;return n.set(xu(e,i.x,r.x,a.x),xu(e,i.y,r.y,a.y)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}Wv.prototype.isQuadraticBezierCurve=!0;class db extends Dr{constructor(e=new T,t=new T,n=new T){super(),this.type="QuadraticBezierCurve3",this.v0=e,this.v1=t,this.v2=n}getPoint(e,t=new T){const n=t,i=this.v0,r=this.v1,a=this.v2;return n.set(xu(e,i.x,r.x,a.x),xu(e,i.y,r.y,a.y),xu(e,i.z,r.z,a.z)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}db.prototype.isQuadraticBezierCurve3=!0;class qv extends Dr{constructor(e=[]){super(),this.type="SplineCurve",this.points=e}getPoint(e,t=new Me){const n=t,i=this.points,r=(i.length-1)*e,a=Math.floor(r),o=r-a,l=i[a===0?a:a-1],c=i[a],u=i[a>i.length-2?i.length-1:a+1],h=i[a>i.length-3?i.length-1:a+2];return n.set(Yy(o,l.x,c.x,u.x,h.x),Yy(o,l.y,c.y,u.y,h.y)),n}copy(e){super.copy(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const i=e.points[t];this.points.push(i.clone())}return this}toJSON(){const e=super.toJSON();e.points=[];for(let t=0,n=this.points.length;t<n;t++){const i=this.points[t];e.points.push(i.toArray())}return e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const i=e.points[t];this.points.push(new Me().fromArray(i))}return this}}qv.prototype.isSplineCurve=!0;var fb=Object.freeze({__proto__:null,ArcCurve:cb,CatmullRomCurve3:ub,CubicBezierCurve:Hv,CubicBezierCurve3:hb,EllipseCurve:Mh,LineCurve:Fp,LineCurve3:G3,QuadraticBezierCurve:Wv,QuadraticBezierCurve3:db,SplineCurve:qv});class H3 extends Dr{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(e){this.curves.push(e)}closePath(){const e=this.curves[0].getPoint(0),t=this.curves[this.curves.length-1].getPoint(1);e.equals(t)||this.curves.push(new Fp(t,e))}getPoint(e,t){const n=e*this.getLength(),i=this.getCurveLengths();let r=0;for(;r<i.length;){if(i[r]>=n){const a=i[r]-n,o=this.curves[r],l=o.getLength(),c=l===0?0:1-a/l;return o.getPointAt(c,t)}r++}return null}getLength(){const e=this.getCurveLengths();return e[e.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const e=[];let t=0;for(let n=0,i=this.curves.length;n<i;n++)t+=this.curves[n].getLength(),e.push(t);return this.cacheLengths=e,e}getSpacedPoints(e=40){const t=[];for(let n=0;n<=e;n++)t.push(this.getPoint(n/e));return this.autoClose&&t.push(t[0]),t}getPoints(e=12){const t=[];let n;for(let i=0,r=this.curves;i<r.length;i++){const a=r[i],o=a.isEllipseCurve?e*2:a.isLineCurve||a.isLineCurve3?1:a.isSplineCurve?e*a.points.length:e,l=a.getPoints(o);for(let c=0;c<l.length;c++){const u=l[c];n&&n.equals(u)||(t.push(u),n=u)}}return this.autoClose&&t.length>1&&!t[t.length-1].equals(t[0])&&t.push(t[0]),t}copy(e){super.copy(e),this.curves=[];for(let t=0,n=e.curves.length;t<n;t++){const i=e.curves[t];this.curves.push(i.clone())}return this.autoClose=e.autoClose,this}toJSON(){const e=super.toJSON();e.autoClose=this.autoClose,e.curves=[];for(let t=0,n=this.curves.length;t<n;t++){const i=this.curves[t];e.curves.push(i.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.autoClose=e.autoClose,this.curves=[];for(let t=0,n=e.curves.length;t<n;t++){const i=e.curves[t];this.curves.push(new fb[i.type]().fromJSON(i))}return this}}class ep extends H3{constructor(e){super(),this.type="Path",this.currentPoint=new Me,e&&this.setFromPoints(e)}setFromPoints(e){this.moveTo(e[0].x,e[0].y);for(let t=1,n=e.length;t<n;t++)this.lineTo(e[t].x,e[t].y);return this}moveTo(e,t){return this.currentPoint.set(e,t),this}lineTo(e,t){const n=new Fp(this.currentPoint.clone(),new Me(e,t));return this.curves.push(n),this.currentPoint.set(e,t),this}quadraticCurveTo(e,t,n,i){const r=new Wv(this.currentPoint.clone(),new Me(e,t),new Me(n,i));return this.curves.push(r),this.currentPoint.set(n,i),this}bezierCurveTo(e,t,n,i,r,a){const o=new Hv(this.currentPoint.clone(),new Me(e,t),new Me(n,i),new Me(r,a));return this.curves.push(o),this.currentPoint.set(r,a),this}splineThru(e){const t=[this.currentPoint.clone()].concat(e),n=new qv(t);return this.curves.push(n),this.currentPoint.copy(e[e.length-1]),this}arc(e,t,n,i,r,a){const o=this.currentPoint.x,l=this.currentPoint.y;return this.absarc(e+o,t+l,n,i,r,a),this}absarc(e,t,n,i,r,a){return this.absellipse(e,t,n,n,i,r,a),this}ellipse(e,t,n,i,r,a,o,l){const c=this.currentPoint.x,u=this.currentPoint.y;return this.absellipse(e+c,t+u,n,i,r,a,o,l),this}absellipse(e,t,n,i,r,a,o,l){const c=new Mh(e,t,n,i,r,a,o,l);if(this.curves.length>0){const h=c.getPoint(0);h.equals(this.currentPoint)||this.lineTo(h.x,h.y)}this.curves.push(c);const u=c.getPoint(1);return this.currentPoint.copy(u),this}copy(e){return super.copy(e),this.currentPoint.copy(e.currentPoint),this}toJSON(){const e=super.toJSON();return e.currentPoint=this.currentPoint.toArray(),e}fromJSON(e){return super.fromJSON(e),this.currentPoint.fromArray(e.currentPoint),this}}class jv extends Xt{constructor(e=1,t=8,n=0,i=Math.PI*2){super(),this.type="CircleGeometry",this.parameters={radius:e,segments:t,thetaStart:n,thetaLength:i},t=Math.max(3,t);const r=[],a=[],o=[],l=[],c=new T,u=new Me;a.push(0,0,0),o.push(0,0,1),l.push(.5,.5);for(let h=0,d=3;h<=t;h++,d+=3){const f=n+h/t*i;c.x=e*Math.cos(f),c.y=e*Math.sin(f),a.push(c.x,c.y,c.z),o.push(0,0,1),u.x=(a[d]/e+1)/2,u.y=(a[d+1]/e+1)/2,l.push(u.x,u.y)}for(let h=1;h<=t;h++)r.push(h,h+1,0);this.setIndex(r),this.setAttribute("position",new Vt(a,3)),this.setAttribute("normal",new Vt(o,3)),this.setAttribute("uv",new Vt(l,2))}static fromJSON(e){return new jv(e.radius,e.segments,e.thetaStart,e.thetaLength)}}class Ua extends ep{constructor(e){super(e),this.uuid=Qr(),this.type="Shape",this.holes=[]}getPointsHoles(e){const t=[];for(let n=0,i=this.holes.length;n<i;n++)t[n]=this.holes[n].getPoints(e);return t}extractPoints(e){return{shape:this.getPoints(e),holes:this.getPointsHoles(e)}}copy(e){super.copy(e),this.holes=[];for(let t=0,n=e.holes.length;t<n;t++){const i=e.holes[t];this.holes.push(i.clone())}return this}toJSON(){const e=super.toJSON();e.uuid=this.uuid,e.holes=[];for(let t=0,n=this.holes.length;t<n;t++){const i=this.holes[t];e.holes.push(i.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.uuid=e.uuid,this.holes=[];for(let t=0,n=e.holes.length;t<n;t++){const i=e.holes[t];this.holes.push(new ep().fromJSON(i))}return this}}const W3={triangulate:function(s,e,t=2){const n=e&&e.length,i=n?e[0]*t:s.length;let r=pb(s,0,i,t,!0);const a=[];if(!r||r.next===r.prev)return a;let o,l,c,u,h,d,f;if(n&&(r=J3(s,e,r,t)),s.length>80*t){o=c=s[0],l=u=s[1];for(let v=t;v<i;v+=t)h=s[v],d=s[v+1],h<o&&(o=h),d<l&&(l=d),h>c&&(c=h),d>u&&(u=d);f=Math.max(c-o,u-l),f=f!==0?1/f:0}return Ou(r,a,t,o,l,f),a}};function pb(s,e,t,n,i){let r,a;if(i===aI(s,e,t,n)>0)for(r=e;r<t;r+=n)a=Zy(r,s[r],s[r+1],a);else for(r=t-n;r>=e;r-=n)a=Zy(r,s[r],s[r+1],a);return a&&Up(a,a.next)&&(zu(a),a=a.next),a}function Ha(s,e){if(!s)return s;e||(e=s);let t=s,n;do if(n=!1,!t.steiner&&(Up(t,t.next)||_n(t.prev,t,t.next)===0)){if(zu(t),t=e=t.prev,t===t.next)break;n=!0}else t=t.next;while(n||t!==e);return e}function Ou(s,e,t,n,i,r,a){if(!s)return;!a&&r&&eI(s,n,i,r);let o=s,l,c;for(;s.prev!==s.next;){if(l=s.prev,c=s.next,r?j3(s,n,i,r):q3(s)){e.push(l.i/t),e.push(s.i/t),e.push(c.i/t),zu(s),s=c.next,o=c.next;continue}if(s=c,s===o){a?a===1?(s=Q3(Ha(s),e,t),Ou(s,e,t,n,i,r,2)):a===2&&X3(s,e,t,n,i,r):Ou(Ha(s),e,t,n,i,r,1);break}}}function q3(s){const e=s.prev,t=s,n=s.next;if(_n(e,t,n)>=0)return!1;let i=s.next.next;for(;i!==s.prev;){if(Wl(e.x,e.y,t.x,t.y,n.x,n.y,i.x,i.y)&&_n(i.prev,i,i.next)>=0)return!1;i=i.next}return!0}function j3(s,e,t,n){const i=s.prev,r=s,a=s.next;if(_n(i,r,a)>=0)return!1;const o=i.x<r.x?i.x<a.x?i.x:a.x:r.x<a.x?r.x:a.x,l=i.y<r.y?i.y<a.y?i.y:a.y:r.y<a.y?r.y:a.y,c=i.x>r.x?i.x>a.x?i.x:a.x:r.x>a.x?r.x:a.x,u=i.y>r.y?i.y>a.y?i.y:a.y:r.y>a.y?r.y:a.y,h=jg(o,l,e,t,n),d=jg(c,u,e,t,n);let f=s.prevZ,v=s.nextZ;for(;f&&f.z>=h&&v&&v.z<=d;){if(f!==s.prev&&f!==s.next&&Wl(i.x,i.y,r.x,r.y,a.x,a.y,f.x,f.y)&&_n(f.prev,f,f.next)>=0||(f=f.prevZ,v!==s.prev&&v!==s.next&&Wl(i.x,i.y,r.x,r.y,a.x,a.y,v.x,v.y)&&_n(v.prev,v,v.next)>=0))return!1;v=v.nextZ}for(;f&&f.z>=h;){if(f!==s.prev&&f!==s.next&&Wl(i.x,i.y,r.x,r.y,a.x,a.y,f.x,f.y)&&_n(f.prev,f,f.next)>=0)return!1;f=f.prevZ}for(;v&&v.z<=d;){if(v!==s.prev&&v!==s.next&&Wl(i.x,i.y,r.x,r.y,a.x,a.y,v.x,v.y)&&_n(v.prev,v,v.next)>=0)return!1;v=v.nextZ}return!0}function Q3(s,e,t){let n=s;do{const i=n.prev,r=n.next.next;!Up(i,r)&&mb(i,n,n.next,r)&&Nu(i,r)&&Nu(r,i)&&(e.push(i.i/t),e.push(n.i/t),e.push(r.i/t),zu(n),zu(n.next),n=s=r),n=n.next}while(n!==s);return Ha(n)}function X3(s,e,t,n,i,r){let a=s;do{let o=a.next.next;for(;o!==a.prev;){if(a.i!==o.i&&iI(a,o)){let l=gb(a,o);a=Ha(a,a.next),l=Ha(l,l.next),Ou(a,e,t,n,i,r),Ou(l,e,t,n,i,r);return}o=o.next}a=a.next}while(a!==s)}function J3(s,e,t,n){const i=[];let r,a,o,l,c;for(r=0,a=e.length;r<a;r++)o=e[r]*n,l=r<a-1?e[r+1]*n:s.length,c=pb(s,o,l,n,!1),c===c.next&&(c.steiner=!0),i.push(nI(c));for(i.sort(K3),r=0;r<i.length;r++)Y3(i[r],t),t=Ha(t,t.next);return t}function K3(s,e){return s.x-e.x}function Y3(s,e){if(e=Z3(s,e),e){const t=gb(e,s);Ha(e,e.next),Ha(t,t.next)}}function Z3(s,e){let t=e;const n=s.x,i=s.y;let r=-1/0,a;do{if(i<=t.y&&i>=t.next.y&&t.next.y!==t.y){const d=t.x+(i-t.y)*(t.next.x-t.x)/(t.next.y-t.y);if(d<=n&&d>r){if(r=d,d===n){if(i===t.y)return t;if(i===t.next.y)return t.next}a=t.x<t.next.x?t:t.next}}t=t.next}while(t!==e);if(!a)return null;if(n===r)return a;const o=a,l=a.x,c=a.y;let u=1/0,h;t=a;do n>=t.x&&t.x>=l&&n!==t.x&&Wl(i<c?n:r,i,l,c,i<c?r:n,i,t.x,t.y)&&(h=Math.abs(i-t.y)/(n-t.x),Nu(t,s)&&(h<u||h===u&&(t.x>a.x||t.x===a.x&&$3(a,t)))&&(a=t,u=h)),t=t.next;while(t!==o);return a}function $3(s,e){return _n(s.prev,s,e.prev)<0&&_n(e.next,s,s.next)<0}function eI(s,e,t,n){let i=s;do i.z===null&&(i.z=jg(i.x,i.y,e,t,n)),i.prevZ=i.prev,i.nextZ=i.next,i=i.next;while(i!==s);i.prevZ.nextZ=null,i.prevZ=null,tI(i)}function tI(s){let e,t,n,i,r,a,o,l,c=1;do{for(t=s,s=null,r=null,a=0;t;){for(a++,n=t,o=0,e=0;e<c&&(o++,n=n.nextZ,!!n);e++);for(l=c;o>0||l>0&&n;)o!==0&&(l===0||!n||t.z<=n.z)?(i=t,t=t.nextZ,o--):(i=n,n=n.nextZ,l--),r?r.nextZ=i:s=i,i.prevZ=r,r=i;t=n}r.nextZ=null,c*=2}while(a>1);return s}function jg(s,e,t,n,i){return s=32767*(s-t)*i,e=32767*(e-n)*i,s=(s|s<<8)&16711935,s=(s|s<<4)&252645135,s=(s|s<<2)&858993459,s=(s|s<<1)&1431655765,e=(e|e<<8)&16711935,e=(e|e<<4)&252645135,e=(e|e<<2)&858993459,e=(e|e<<1)&1431655765,s|e<<1}function nI(s){let e=s,t=s;do(e.x<t.x||e.x===t.x&&e.y<t.y)&&(t=e),e=e.next;while(e!==s);return t}function Wl(s,e,t,n,i,r,a,o){return(i-a)*(e-o)-(s-a)*(r-o)>=0&&(s-a)*(n-o)-(t-a)*(e-o)>=0&&(t-a)*(r-o)-(i-a)*(n-o)>=0}function iI(s,e){return s.next.i!==e.i&&s.prev.i!==e.i&&!rI(s,e)&&(Nu(s,e)&&Nu(e,s)&&sI(s,e)&&(_n(s.prev,s,e.prev)||_n(s,e.prev,e))||Up(s,e)&&_n(s.prev,s,s.next)>0&&_n(e.prev,e,e.next)>0)}function _n(s,e,t){return(e.y-s.y)*(t.x-e.x)-(e.x-s.x)*(t.y-e.y)}function Up(s,e){return s.x===e.x&&s.y===e.y}function mb(s,e,t,n){const i=Ed(_n(s,e,t)),r=Ed(_n(s,e,n)),a=Ed(_n(t,n,s)),o=Ed(_n(t,n,e));return!!(i!==r&&a!==o||i===0&&Td(s,t,e)||r===0&&Td(s,n,e)||a===0&&Td(t,s,n)||o===0&&Td(t,e,n))}function Td(s,e,t){return e.x<=Math.max(s.x,t.x)&&e.x>=Math.min(s.x,t.x)&&e.y<=Math.max(s.y,t.y)&&e.y>=Math.min(s.y,t.y)}function Ed(s){return s>0?1:s<0?-1:0}function rI(s,e){let t=s;do{if(t.i!==s.i&&t.next.i!==s.i&&t.i!==e.i&&t.next.i!==e.i&&mb(t,t.next,s,e))return!0;t=t.next}while(t!==s);return!1}function Nu(s,e){return _n(s.prev,s,s.next)<0?_n(s,e,s.next)>=0&&_n(s,s.prev,e)>=0:_n(s,e,s.prev)<0||_n(s,s.next,e)<0}function sI(s,e){let t=s,n=!1;const i=(s.x+e.x)/2,r=(s.y+e.y)/2;do t.y>r!=t.next.y>r&&t.next.y!==t.y&&i<(t.next.x-t.x)*(r-t.y)/(t.next.y-t.y)+t.x&&(n=!n),t=t.next;while(t!==s);return n}function gb(s,e){const t=new Qg(s.i,s.x,s.y),n=new Qg(e.i,e.x,e.y),i=s.next,r=e.prev;return s.next=e,e.prev=s,t.next=i,i.prev=t,n.next=t,t.prev=n,r.next=n,n.prev=r,n}function Zy(s,e,t,n){const i=new Qg(s,e,t);return n?(i.next=n.next,i.prev=n,n.next.prev=i,n.next=i):(i.prev=i,i.next=i),i}function zu(s){s.next.prev=s.prev,s.prev.next=s.next,s.prevZ&&(s.prevZ.nextZ=s.nextZ),s.nextZ&&(s.nextZ.prevZ=s.prevZ)}function Qg(s,e,t){this.i=s,this.x=e,this.y=t,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}function aI(s,e,t,n){let i=0;for(let r=e,a=t-n;r<t;r+=n)i+=(s[a]-s[r])*(s[r+1]+s[a+1]),a=r;return i}class Qs{static area(e){const t=e.length;let n=0;for(let i=t-1,r=0;r<t;i=r++)n+=e[i].x*e[r].y-e[r].x*e[i].y;return n*.5}static isClockWise(e){return Qs.area(e)<0}static triangulateShape(e,t){const n=[],i=[],r=[];$y(e),ex(n,e);let a=e.length;t.forEach($y);for(let l=0;l<t.length;l++)i.push(a),a+=t[l].length,ex(n,t[l]);const o=W3.triangulate(n,i);for(let l=0;l<o.length;l+=3)r.push(o.slice(l,l+3));return r}}function $y(s){const e=s.length;e>2&&s[e-1].equals(s[0])&&s.pop()}function ex(s,e){for(let t=0;t<e.length;t++)s.push(e[t].x),s.push(e[t].y)}class Ic extends Xt{constructor(e=new Ua([new Me(.5,.5),new Me(-.5,.5),new Me(-.5,-.5),new Me(.5,-.5)]),t={}){super(),this.type="ExtrudeGeometry",this.parameters={shapes:e,options:t},e=Array.isArray(e)?e:[e];const n=this,i=[],r=[];for(let o=0,l=e.length;o<l;o++){const c=e[o];a(c)}this.setAttribute("position",new Vt(i,3)),this.setAttribute("uv",new Vt(r,2)),this.computeVertexNormals();function a(o){const l=[],c=t.curveSegments!==void 0?t.curveSegments:12,u=t.steps!==void 0?t.steps:1;let h=t.depth!==void 0?t.depth:1,d=t.bevelEnabled!==void 0?t.bevelEnabled:!0,f=t.bevelThickness!==void 0?t.bevelThickness:.2,v=t.bevelSize!==void 0?t.bevelSize:f-.1,g=t.bevelOffset!==void 0?t.bevelOffset:0,m=t.bevelSegments!==void 0?t.bevelSegments:3;const x=t.extrudePath,w=t.UVGenerator!==void 0?t.UVGenerator:oI;t.amount!==void 0&&(console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),h=t.amount);let S,b=!1,E,C,P,M;x&&(S=x.getSpacedPoints(u),b=!0,d=!1,E=x.computeFrenetFrames(u,!1),C=new T,P=new T,M=new T),d||(m=0,f=0,v=0,g=0);const L=o.extractPoints(c);let z=L.shape;const V=L.holes;if(!Qs.isClockWise(z)){z=z.reverse();for(let X=0,Se=V.length;X<Se;X++){const qe=V[X];Qs.isClockWise(qe)&&(V[X]=qe.reverse())}}const j=Qs.triangulateShape(z,V),F=z;for(let X=0,Se=V.length;X<Se;X++){const qe=V[X];z=z.concat(qe)}function K(X,Se,qe){return Se||console.error("THREE.ExtrudeGeometry: vec does not exist"),Se.clone().multiplyScalar(qe).add(X)}const J=z.length,se=j.length;function le(X,Se,qe){let Qe,Ke,pt;const He=X.x-Se.x,ze=X.y-Se.y,rt=qe.x-X.x,Le=qe.y-X.y,k=He*He+ze*ze,B=He*Le-ze*rt;if(Math.abs(B)>Number.EPSILON){const G=Math.sqrt(k),ne=Math.sqrt(rt*rt+Le*Le),_e=Se.x-ze/G,Ye=Se.y+He/G,et=qe.x-Le/ne,we=qe.y+rt/ne,bt=((et-_e)*Le-(we-Ye)*rt)/(He*Le-ze*rt);Qe=_e+He*bt-X.x,Ke=Ye+ze*bt-X.y;const wt=Qe*Qe+Ke*Ke;if(wt<=2)return new Me(Qe,Ke);pt=Math.sqrt(wt/2)}else{let G=!1;He>Number.EPSILON?rt>Number.EPSILON&&(G=!0):He<-Number.EPSILON?rt<-Number.EPSILON&&(G=!0):Math.sign(ze)===Math.sign(Le)&&(G=!0),G?(Qe=-ze,Ke=He,pt=Math.sqrt(k)):(Qe=He,Ke=ze,pt=Math.sqrt(k/2))}return new Me(Qe/pt,Ke/pt)}const q=[];for(let X=0,Se=F.length,qe=Se-1,Qe=X+1;X<Se;X++,qe++,Qe++)qe===Se&&(qe=0),Qe===Se&&(Qe=0),q[X]=le(F[X],F[qe],F[Qe]);const te=[];let H,$=q.concat();for(let X=0,Se=V.length;X<Se;X++){const qe=V[X];H=[];for(let Qe=0,Ke=qe.length,pt=Ke-1,He=Qe+1;Qe<Ke;Qe++,pt++,He++)pt===Ke&&(pt=0),He===Ke&&(He=0),H[Qe]=le(qe[Qe],qe[pt],qe[He]);te.push(H),$=$.concat(H)}for(let X=0;X<m;X++){const Se=X/m,qe=f*Math.cos(Se*Math.PI/2),Qe=v*Math.sin(Se*Math.PI/2)+g;for(let Ke=0,pt=F.length;Ke<pt;Ke++){const He=K(F[Ke],q[Ke],Qe);Ie(He.x,He.y,-qe)}for(let Ke=0,pt=V.length;Ke<pt;Ke++){const He=V[Ke];H=te[Ke];for(let ze=0,rt=He.length;ze<rt;ze++){const Le=K(He[ze],H[ze],Qe);Ie(Le.x,Le.y,-qe)}}}const ce=v+g;for(let X=0;X<J;X++){const Se=d?K(z[X],$[X],ce):z[X];b?(P.copy(E.normals[0]).multiplyScalar(Se.x),C.copy(E.binormals[0]).multiplyScalar(Se.y),M.copy(S[0]).add(P).add(C),Ie(M.x,M.y,M.z)):Ie(Se.x,Se.y,0)}for(let X=1;X<=u;X++)for(let Se=0;Se<J;Se++){const qe=d?K(z[Se],$[Se],ce):z[Se];b?(P.copy(E.normals[X]).multiplyScalar(qe.x),C.copy(E.binormals[X]).multiplyScalar(qe.y),M.copy(S[X]).add(P).add(C),Ie(M.x,M.y,M.z)):Ie(qe.x,qe.y,h/u*X)}for(let X=m-1;X>=0;X--){const Se=X/m,qe=f*Math.cos(Se*Math.PI/2),Qe=v*Math.sin(Se*Math.PI/2)+g;for(let Ke=0,pt=F.length;Ke<pt;Ke++){const He=K(F[Ke],q[Ke],Qe);Ie(He.x,He.y,h+qe)}for(let Ke=0,pt=V.length;Ke<pt;Ke++){const He=V[Ke];H=te[Ke];for(let ze=0,rt=He.length;ze<rt;ze++){const Le=K(He[ze],H[ze],Qe);b?Ie(Le.x,Le.y+S[u-1].y,S[u-1].x+qe):Ie(Le.x,Le.y,h+qe)}}}xe(),pe();function xe(){const X=i.length/3;if(d){let Se=0,qe=J*Se;for(let Qe=0;Qe<se;Qe++){const Ke=j[Qe];re(Ke[2]+qe,Ke[1]+qe,Ke[0]+qe)}Se=u+m*2,qe=J*Se;for(let Qe=0;Qe<se;Qe++){const Ke=j[Qe];re(Ke[0]+qe,Ke[1]+qe,Ke[2]+qe)}}else{for(let Se=0;Se<se;Se++){const qe=j[Se];re(qe[2],qe[1],qe[0])}for(let Se=0;Se<se;Se++){const qe=j[Se];re(qe[0]+J*u,qe[1]+J*u,qe[2]+J*u)}}n.addGroup(X,i.length/3-X,0)}function pe(){const X=i.length/3;let Se=0;Y(F,Se),Se+=F.length;for(let qe=0,Qe=V.length;qe<Qe;qe++){const Ke=V[qe];Y(Ke,Se),Se+=Ke.length}n.addGroup(X,i.length/3-X,1)}function Y(X,Se){let qe=X.length;for(;--qe>=0;){const Qe=qe;let Ke=qe-1;Ke<0&&(Ke=X.length-1);for(let pt=0,He=u+m*2;pt<He;pt++){const ze=J*pt,rt=J*(pt+1),Le=Se+Qe+ze,k=Se+Ke+ze,B=Se+Ke+rt,G=Se+Qe+rt;oe(Le,k,B,G)}}}function Ie(X,Se,qe){l.push(X),l.push(Se),l.push(qe)}function re(X,Se,qe){ye(X),ye(Se),ye(qe);const Qe=i.length/3,Ke=w.generateTopUV(n,i,Qe-3,Qe-2,Qe-1);ke(Ke[0]),ke(Ke[1]),ke(Ke[2])}function oe(X,Se,qe,Qe){ye(X),ye(Se),ye(Qe),ye(Se),ye(qe),ye(Qe);const Ke=i.length/3,pt=w.generateSideWallUV(n,i,Ke-6,Ke-3,Ke-2,Ke-1);ke(pt[0]),ke(pt[1]),ke(pt[3]),ke(pt[1]),ke(pt[2]),ke(pt[3])}function ye(X){i.push(l[X*3+0]),i.push(l[X*3+1]),i.push(l[X*3+2])}function ke(X){r.push(X.x),r.push(X.y)}}}toJSON(){const e=super.toJSON(),t=this.parameters.shapes,n=this.parameters.options;return lI(t,n,e)}static fromJSON(e,t){const n=[];for(let r=0,a=e.shapes.length;r<a;r++){const o=t[e.shapes[r]];n.push(o)}const i=e.options.extrudePath;return i!==void 0&&(e.options.extrudePath=new fb[i.type]().fromJSON(i)),new Ic(n,e.options)}}const oI={generateTopUV:function(s,e,t,n,i){const r=e[t*3],a=e[t*3+1],o=e[n*3],l=e[n*3+1],c=e[i*3],u=e[i*3+1];return[new Me(r,a),new Me(o,l),new Me(c,u)]},generateSideWallUV:function(s,e,t,n,i,r){const a=e[t*3],o=e[t*3+1],l=e[t*3+2],c=e[n*3],u=e[n*3+1],h=e[n*3+2],d=e[i*3],f=e[i*3+1],v=e[i*3+2],g=e[r*3],m=e[r*3+1],x=e[r*3+2];return Math.abs(o-u)<Math.abs(a-c)?[new Me(a,1-l),new Me(c,1-h),new Me(d,1-v),new Me(g,1-x)]:[new Me(o,1-l),new Me(u,1-h),new Me(f,1-v),new Me(m,1-x)]}};function lI(s,e,t){if(t.shapes=[],Array.isArray(s))for(let n=0,i=s.length;n<i;n++){const r=s[n];t.shapes.push(r.uuid)}else t.shapes.push(s.uuid);return e.extrudePath!==void 0&&(t.options.extrudePath=e.extrudePath.toJSON()),t}class Qv extends Xt{constructor(e=new Ua([new Me(0,.5),new Me(-.5,-.5),new Me(.5,-.5)]),t=12){super(),this.type="ShapeGeometry",this.parameters={shapes:e,curveSegments:t};const n=[],i=[],r=[],a=[];let o=0,l=0;if(Array.isArray(e)===!1)c(e);else for(let u=0;u<e.length;u++)c(e[u]),this.addGroup(o,l,u),o+=l,l=0;this.setIndex(n),this.setAttribute("position",new Vt(i,3)),this.setAttribute("normal",new Vt(r,3)),this.setAttribute("uv",new Vt(a,2));function c(u){const h=i.length/3,d=u.extractPoints(t);let f=d.shape;const v=d.holes;Qs.isClockWise(f)===!1&&(f=f.reverse());for(let m=0,x=v.length;m<x;m++){const w=v[m];Qs.isClockWise(w)===!0&&(v[m]=w.reverse())}const g=Qs.triangulateShape(f,v);for(let m=0,x=v.length;m<x;m++){const w=v[m];f=f.concat(w)}for(let m=0,x=f.length;m<x;m++){const w=f[m];i.push(w.x,w.y,0),r.push(0,0,1),a.push(w.x,w.y)}for(let m=0,x=g.length;m<x;m++){const w=g[m],S=w[0]+h,b=w[1]+h,E=w[2]+h;n.push(S,b,E),l+=3}}}toJSON(){const e=super.toJSON(),t=this.parameters.shapes;return cI(t,e)}static fromJSON(e,t){const n=[];for(let i=0,r=e.shapes.length;i<r;i++){const a=t[e.shapes[i]];n.push(a)}return new Qv(n,e.curveSegments)}}function cI(s,e){if(e.shapes=[],Array.isArray(s))for(let t=0,n=s.length;t<n;t++){const i=s[t];e.shapes.push(i.uuid)}else e.shapes.push(s.uuid);return e}class Xv extends Xt{constructor(e=1,t=32,n=16,i=0,r=Math.PI*2,a=0,o=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:e,widthSegments:t,heightSegments:n,phiStart:i,phiLength:r,thetaStart:a,thetaLength:o},t=Math.max(3,Math.floor(t)),n=Math.max(2,Math.floor(n));const l=Math.min(a+o,Math.PI);let c=0;const u=[],h=new T,d=new T,f=[],v=[],g=[],m=[];for(let x=0;x<=n;x++){const w=[],S=x/n;let b=0;x==0&&a==0?b=.5/t:x==n&&l==Math.PI&&(b=-.5/t);for(let E=0;E<=t;E++){const C=E/t;h.x=-e*Math.cos(i+C*r)*Math.sin(a+S*o),h.y=e*Math.cos(a+S*o),h.z=e*Math.sin(i+C*r)*Math.sin(a+S*o),v.push(h.x,h.y,h.z),d.copy(h).normalize(),g.push(d.x,d.y,d.z),m.push(C+b,1-S),w.push(c++)}u.push(w)}for(let x=0;x<n;x++)for(let w=0;w<t;w++){const S=u[x][w+1],b=u[x][w],E=u[x+1][w],C=u[x+1][w+1];(x!==0||a>0)&&f.push(S,b,C),(x!==n-1||l<Math.PI)&&f.push(b,E,C)}this.setIndex(f),this.setAttribute("position",new Vt(v,3)),this.setAttribute("normal",new Vt(g,3)),this.setAttribute("uv",new Vt(m,2))}static fromJSON(e){return new Xv(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)}}class uI extends Xt{constructor(e=null){if(super(),this.type="WireframeGeometry",this.parameters={geometry:e},e!==null){const t=[],n=new Set,i=new T,r=new T;if(e.index!==null){const a=e.attributes.position,o=e.index;let l=e.groups;l.length===0&&(l=[{start:0,count:o.count,materialIndex:0}]);for(let c=0,u=l.length;c<u;++c){const h=l[c],d=h.start,f=h.count;for(let v=d,g=d+f;v<g;v+=3)for(let m=0;m<3;m++){const x=o.getX(v+m),w=o.getX(v+(m+1)%3);i.fromBufferAttribute(a,x),r.fromBufferAttribute(a,w),tx(i,r,n)===!0&&(t.push(i.x,i.y,i.z),t.push(r.x,r.y,r.z))}}}else{const a=e.attributes.position;for(let o=0,l=a.count/3;o<l;o++)for(let c=0;c<3;c++){const u=3*o+c,h=3*o+(c+1)%3;i.fromBufferAttribute(a,u),r.fromBufferAttribute(a,h),tx(i,r,n)===!0&&(t.push(i.x,i.y,i.z),t.push(r.x,r.y,r.z))}}this.setAttribute("position",new Vt(t,3))}}}function tx(s,e,t){const n=`${s.x},${s.y},${s.z}-${e.x},${e.y},${e.z}`,i=`${e.x},${e.y},${e.z}-${s.x},${s.y},${s.z}`;return t.has(n)===!0||t.has(i)===!0?!1:(t.add(n),t.add(i),!0)}class vb extends di{constructor(e){super(),this.type="ShadowMaterial",this.color=new ot(0),this.transparent=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.fog=e.fog,this}}vb.prototype.isShadowMaterial=!0;class yb extends $n{constructor(e){super(e),this.type="RawShaderMaterial"}}yb.prototype.isRawShaderMaterial=!0;class kp extends di{constructor(e){super(),this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new ot(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new ot(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Cc,this.normalScale=new Me(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={STANDARD:""},this.color.copy(e.color),this.roughness=e.roughness,this.metalness=e.metalness,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.roughnessMap=e.roughnessMap,this.metalnessMap=e.metalnessMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapIntensity=e.envMapIntensity,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}kp.prototype.isMeshStandardMaterial=!0;class xb extends kp{constructor(e){super(),this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new Me(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return oi(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(t){this.ior=(1+.4*t)/(1-.4*t)}}),this.sheenColor=new ot(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=0,this.attenuationColor=new ot(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new ot(1,1,1),this.specularColorMap=null,this._sheen=0,this._clearcoat=0,this._transmission=0,this.setValues(e)}get sheen(){return this._sheen}set sheen(e){this._sheen>0!=e>0&&this.version++,this._sheen=e}get clearcoat(){return this._clearcoat}set clearcoat(e){this._clearcoat>0!=e>0&&this.version++,this._clearcoat=e}get transmission(){return this._transmission}set transmission(e){this._transmission>0!=e>0&&this.version++,this._transmission=e}copy(e){return super.copy(e),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=e.clearcoat,this.clearcoatMap=e.clearcoatMap,this.clearcoatRoughness=e.clearcoatRoughness,this.clearcoatRoughnessMap=e.clearcoatRoughnessMap,this.clearcoatNormalMap=e.clearcoatNormalMap,this.clearcoatNormalScale.copy(e.clearcoatNormalScale),this.ior=e.ior,this.sheen=e.sheen,this.sheenColor.copy(e.sheenColor),this.sheenColorMap=e.sheenColorMap,this.sheenRoughness=e.sheenRoughness,this.sheenRoughnessMap=e.sheenRoughnessMap,this.transmission=e.transmission,this.transmissionMap=e.transmissionMap,this.thickness=e.thickness,this.thicknessMap=e.thicknessMap,this.attenuationDistance=e.attenuationDistance,this.attenuationColor.copy(e.attenuationColor),this.specularIntensity=e.specularIntensity,this.specularIntensityMap=e.specularIntensityMap,this.specularColor.copy(e.specularColor),this.specularColorMap=e.specularColorMap,this}}xb.prototype.isMeshPhysicalMaterial=!0;class wb extends di{constructor(e){super(),this.type="MeshPhongMaterial",this.color=new ot(16777215),this.specular=new ot(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new ot(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Cc,this.normalScale=new Me(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Rp,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.specular.copy(e.specular),this.shininess=e.shininess,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}wb.prototype.isMeshPhongMaterial=!0;class Sb extends di{constructor(e){super(),this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new ot(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new ot(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Cc,this.normalScale=new Me(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.gradientMap=e.gradientMap,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}Sb.prototype.isMeshToonMaterial=!0;class Jv extends di{constructor(e){super(),this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Cc,this.normalScale=new Me(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.flatShading=e.flatShading,this}}Jv.prototype.isMeshNormalMaterial=!0;class bb extends di{constructor(e){super(),this.type="MeshLambertMaterial",this.color=new ot(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new ot(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Rp,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}bb.prototype.isMeshLambertMaterial=!0;class Kv extends di{constructor(e){super(),this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new ot(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Cc,this.normalScale=new Me(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={MATCAP:""},this.color.copy(e.color),this.matcap=e.matcap,this.map=e.map,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.flatShading=e.flatShading,this.fog=e.fog,this}}Kv.prototype.isMeshMatcapMaterial=!0;class Ab extends na{constructor(e){super(),this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(e)}copy(e){return super.copy(e),this.scale=e.scale,this.dashSize=e.dashSize,this.gapSize=e.gapSize,this}}Ab.prototype.isLineDashedMaterial=!0;const hI={ShadowMaterial:vb,SpriteMaterial:Vv,RawShaderMaterial:yb,ShaderMaterial:$n,PointsMaterial:zp,MeshPhysicalMaterial:xb,MeshStandardMaterial:kp,MeshPhongMaterial:wb,MeshToonMaterial:Sb,MeshNormalMaterial:Jv,MeshLambertMaterial:bb,MeshDepthMaterial:Ah,MeshDistanceMaterial:Op,MeshBasicMaterial:Ja,MeshMatcapMaterial:Kv,LineDashedMaterial:Ab,LineBasicMaterial:na,Material:di};di.fromType=function(s){return new hI[s]};const zn={arraySlice:function(s,e,t){return zn.isTypedArray(s)?new s.constructor(s.subarray(e,t!==void 0?t:s.length)):s.slice(e,t)},convertArray:function(s,e,t){return!s||!t&&s.constructor===e?s:typeof e.BYTES_PER_ELEMENT=="number"?new e(s):Array.prototype.slice.call(s)},isTypedArray:function(s){return ArrayBuffer.isView(s)&&!(s instanceof DataView)},getKeyframeOrder:function(s){function e(i,r){return s[i]-s[r]}const t=s.length,n=new Array(t);for(let i=0;i!==t;++i)n[i]=i;return n.sort(e),n},sortedArray:function(s,e,t){const n=s.length,i=new s.constructor(n);for(let r=0,a=0;a!==n;++r){const o=t[r]*e;for(let l=0;l!==e;++l)i[a++]=s[o+l]}return i},flattenJSON:function(s,e,t,n){let i=1,r=s[0];for(;r!==void 0&&r[n]===void 0;)r=s[i++];if(r===void 0)return;let a=r[n];if(a!==void 0)if(Array.isArray(a))do a=r[n],a!==void 0&&(e.push(r.time),t.push.apply(t,a)),r=s[i++];while(r!==void 0);else if(a.toArray!==void 0)do a=r[n],a!==void 0&&(e.push(r.time),a.toArray(t,t.length)),r=s[i++];while(r!==void 0);else do a=r[n],a!==void 0&&(e.push(r.time),t.push(a)),r=s[i++];while(r!==void 0)},subclip:function(s,e,t,n,i=30){const r=s.clone();r.name=e;const a=[];for(let l=0;l<r.tracks.length;++l){const c=r.tracks[l],u=c.getValueSize(),h=[],d=[];for(let f=0;f<c.times.length;++f){const v=c.times[f]*i;if(!(v<t||v>=n)){h.push(c.times[f]);for(let g=0;g<u;++g)d.push(c.values[f*u+g])}}h.length!==0&&(c.times=zn.convertArray(h,c.times.constructor),c.values=zn.convertArray(d,c.values.constructor),a.push(c))}r.tracks=a;let o=1/0;for(let l=0;l<r.tracks.length;++l)o>r.tracks[l].times[0]&&(o=r.tracks[l].times[0]);for(let l=0;l<r.tracks.length;++l)r.tracks[l].shift(-1*o);return r.resetDuration(),r},makeClipAdditive:function(s,e=0,t=s,n=30){n<=0&&(n=30);const i=t.tracks.length,r=e/n;for(let a=0;a<i;++a){const o=t.tracks[a],l=o.ValueTypeName;if(l==="bool"||l==="string")continue;const c=s.tracks.find(function(x){return x.name===o.name&&x.ValueTypeName===l});if(c===void 0)continue;let u=0;const h=o.getValueSize();o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(u=h/3);let d=0;const f=c.getValueSize();c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(d=f/3);const v=o.times.length-1;let g;if(r<=o.times[0]){const x=u,w=h-u;g=zn.arraySlice(o.values,x,w)}else if(r>=o.times[v]){const x=v*h+u,w=x+h-u;g=zn.arraySlice(o.values,x,w)}else{const x=o.createInterpolant(),w=u,S=h-u;x.evaluate(r),g=zn.arraySlice(x.resultBuffer,w,S)}l==="quaternion"&&new An().fromArray(g).normalize().conjugate().toArray(g);const m=c.times.length;for(let x=0;x<m;++x){const w=x*f+d;if(l==="quaternion")An.multiplyQuaternionsFlat(c.values,w,g,0,c.values,w);else{const S=f-d*2;for(let b=0;b<S;++b)c.values[w+b]-=g[b]}}}return s.blendMode=qS,s}};class Wa{constructor(e,t,n,i){this.parameterPositions=e,this._cachedIndex=0,this.resultBuffer=i!==void 0?i:new t.constructor(n),this.sampleValues=t,this.valueSize=n,this.settings=null,this.DefaultSettings_={}}evaluate(e){const t=this.parameterPositions;let n=this._cachedIndex,i=t[n],r=t[n-1];e:{t:{let a;n:{i:if(!(e<i)){for(let o=n+2;;){if(i===void 0){if(e<r)break i;return n=t.length,this._cachedIndex=n,this.afterEnd_(n-1,e,r)}if(n===o)break;if(r=i,i=t[++n],e<i)break t}a=t.length;break n}if(!(e>=r)){const o=t[1];e<o&&(n=2,r=o);for(let l=n-2;;){if(r===void 0)return this._cachedIndex=0,this.beforeStart_(0,e,i);if(n===l)break;if(i=r,r=t[--n-1],e>=r)break t}a=n,n=0;break n}break e}for(;n<a;){const o=n+a>>>1;e<t[o]?a=o:n=o+1}if(i=t[n],r=t[n-1],r===void 0)return this._cachedIndex=0,this.beforeStart_(0,e,i);if(i===void 0)return n=t.length,this._cachedIndex=n,this.afterEnd_(n-1,r,e)}this._cachedIndex=n,this.intervalChanged_(n,r,i)}return this.interpolate_(n,r,e,i)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(e){const t=this.resultBuffer,n=this.sampleValues,i=this.valueSize,r=e*i;for(let a=0;a!==i;++a)t[a]=n[r+a];return t}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}Wa.prototype.beforeStart_=Wa.prototype.copySampleValue_;Wa.prototype.afterEnd_=Wa.prototype.copySampleValue_;class dI extends Wa{constructor(e,t,n,i){super(e,t,n,i),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:Vl,endingEnd:Vl}}intervalChanged_(e,t,n){const i=this.parameterPositions;let r=e-2,a=e+1,o=i[r],l=i[a];if(o===void 0)switch(this.getSettings_().endingStart){case Gl:r=e,o=2*t-n;break;case Yf:r=i.length-2,o=t+i[r]-i[r+1];break;default:r=e,o=n}if(l===void 0)switch(this.getSettings_().endingEnd){case Gl:a=e,l=2*n-t;break;case Yf:a=1,l=n+i[1]-i[0];break;default:a=e-1,l=t}const c=(n-t)*.5,u=this.valueSize;this._weightPrev=c/(t-o),this._weightNext=c/(l-n),this._offsetPrev=r*u,this._offsetNext=a*u}interpolate_(e,t,n,i){const r=this.resultBuffer,a=this.sampleValues,o=this.valueSize,l=e*o,c=l-o,u=this._offsetPrev,h=this._offsetNext,d=this._weightPrev,f=this._weightNext,v=(n-t)/(i-t),g=v*v,m=g*v,x=-d*m+2*d*g-d*v,w=(1+d)*m+(-1.5-2*d)*g+(-.5+d)*v+1,S=(-1-f)*m+(1.5+f)*g+.5*v,b=f*m-f*g;for(let E=0;E!==o;++E)r[E]=x*a[u+E]+w*a[c+E]+S*a[l+E]+b*a[h+E];return r}}class Tb extends Wa{constructor(e,t,n,i){super(e,t,n,i)}interpolate_(e,t,n,i){const r=this.resultBuffer,a=this.sampleValues,o=this.valueSize,l=e*o,c=l-o,u=(n-t)/(i-t),h=1-u;for(let d=0;d!==o;++d)r[d]=a[c+d]*h+a[l+d]*u;return r}}class fI extends Wa{constructor(e,t,n,i){super(e,t,n,i)}interpolate_(e){return this.copySampleValue_(e-1)}}class hs{constructor(e,t,n,i){if(e===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(t===void 0||t.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+e);this.name=e,this.times=zn.convertArray(t,this.TimeBufferType),this.values=zn.convertArray(n,this.ValueBufferType),this.setInterpolation(i||this.DefaultInterpolation)}static toJSON(e){const t=e.constructor;let n;if(t.toJSON!==this.toJSON)n=t.toJSON(e);else{n={name:e.name,times:zn.convertArray(e.times,Array),values:zn.convertArray(e.values,Array)};const i=e.getInterpolation();i!==e.DefaultInterpolation&&(n.interpolation=i)}return n.type=e.ValueTypeName,n}InterpolantFactoryMethodDiscrete(e){return new fI(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodLinear(e){return new Tb(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodSmooth(e){return new dI(this.times,this.values,this.getValueSize(),e)}setInterpolation(e){let t;switch(e){case Jf:t=this.InterpolantFactoryMethodDiscrete;break;case Kf:t=this.InterpolantFactoryMethodLinear;break;case lm:t=this.InterpolantFactoryMethodSmooth;break}if(t===void 0){const n="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(e!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(n);return console.warn("THREE.KeyframeTrack:",n),this}return this.createInterpolant=t,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return Jf;case this.InterpolantFactoryMethodLinear:return Kf;case this.InterpolantFactoryMethodSmooth:return lm}}getValueSize(){return this.values.length/this.times.length}shift(e){if(e!==0){const t=this.times;for(let n=0,i=t.length;n!==i;++n)t[n]+=e}return this}scale(e){if(e!==1){const t=this.times;for(let n=0,i=t.length;n!==i;++n)t[n]*=e}return this}trim(e,t){const n=this.times,i=n.length;let r=0,a=i-1;for(;r!==i&&n[r]<e;)++r;for(;a!==-1&&n[a]>t;)--a;if(++a,r!==0||a!==i){r>=a&&(a=Math.max(a,1),r=a-1);const o=this.getValueSize();this.times=zn.arraySlice(n,r,a),this.values=zn.arraySlice(this.values,r*o,a*o)}return this}validate(){let e=!0;const t=this.getValueSize();t-Math.floor(t)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),e=!1);const n=this.times,i=this.values,r=n.length;r===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),e=!1);let a=null;for(let o=0;o!==r;o++){const l=n[o];if(typeof l=="number"&&isNaN(l)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,o,l),e=!1;break}if(a!==null&&a>l){console.error("THREE.KeyframeTrack: Out of order keys.",this,o,l,a),e=!1;break}a=l}if(i!==void 0&&zn.isTypedArray(i))for(let o=0,l=i.length;o!==l;++o){const c=i[o];if(isNaN(c)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,o,c),e=!1;break}}return e}optimize(){const e=zn.arraySlice(this.times),t=zn.arraySlice(this.values),n=this.getValueSize(),i=this.getInterpolation()===lm,r=e.length-1;let a=1;for(let o=1;o<r;++o){let l=!1;const c=e[o],u=e[o+1];if(c!==u&&(o!==1||c!==e[0]))if(i)l=!0;else{const h=o*n,d=h-n,f=h+n;for(let v=0;v!==n;++v){const g=t[h+v];if(g!==t[d+v]||g!==t[f+v]){l=!0;break}}}if(l){if(o!==a){e[a]=e[o];const h=o*n,d=a*n;for(let f=0;f!==n;++f)t[d+f]=t[h+f]}++a}}if(r>0){e[a]=e[r];for(let o=r*n,l=a*n,c=0;c!==n;++c)t[l+c]=t[o+c];++a}return a!==e.length?(this.times=zn.arraySlice(e,0,a),this.values=zn.arraySlice(t,0,a*n)):(this.times=e,this.values=t),this}clone(){const e=zn.arraySlice(this.times,0),t=zn.arraySlice(this.values,0),n=this.constructor,i=new n(this.name,e,t);return i.createInterpolant=this.createInterpolant,i}}hs.prototype.TimeBufferType=Float32Array;hs.prototype.ValueBufferType=Float32Array;hs.prototype.DefaultInterpolation=Kf;class Pc extends hs{}Pc.prototype.ValueTypeName="bool";Pc.prototype.ValueBufferType=Array;Pc.prototype.DefaultInterpolation=Jf;Pc.prototype.InterpolantFactoryMethodLinear=void 0;Pc.prototype.InterpolantFactoryMethodSmooth=void 0;class Eb extends hs{}Eb.prototype.ValueTypeName="color";class tp extends hs{}tp.prototype.ValueTypeName="number";class pI extends Wa{constructor(e,t,n,i){super(e,t,n,i)}interpolate_(e,t,n,i){const r=this.resultBuffer,a=this.sampleValues,o=this.valueSize,l=(n-t)/(i-t);let c=e*o;for(let u=c+o;c!==u;c+=4)An.slerpFlat(r,0,a,c-o,a,c,l);return r}}class Ch extends hs{InterpolantFactoryMethodLinear(e){return new pI(this.times,this.values,this.getValueSize(),e)}}Ch.prototype.ValueTypeName="quaternion";Ch.prototype.DefaultInterpolation=Kf;Ch.prototype.InterpolantFactoryMethodSmooth=void 0;class Dc extends hs{}Dc.prototype.ValueTypeName="string";Dc.prototype.ValueBufferType=Array;Dc.prototype.DefaultInterpolation=Jf;Dc.prototype.InterpolantFactoryMethodLinear=void 0;Dc.prototype.InterpolantFactoryMethodSmooth=void 0;class np extends hs{}np.prototype.ValueTypeName="vector";class nx{constructor(e,t=-1,n,i=Pv){this.name=e,this.tracks=n,this.duration=t,this.blendMode=i,this.uuid=Qr(),this.duration<0&&this.resetDuration()}static parse(e){const t=[],n=e.tracks,i=1/(e.fps||1);for(let a=0,o=n.length;a!==o;++a)t.push(gI(n[a]).scale(i));const r=new this(e.name,e.duration,t,e.blendMode);return r.uuid=e.uuid,r}static toJSON(e){const t=[],n=e.tracks,i={name:e.name,duration:e.duration,tracks:t,uuid:e.uuid,blendMode:e.blendMode};for(let r=0,a=n.length;r!==a;++r)t.push(hs.toJSON(n[r]));return i}static CreateFromMorphTargetSequence(e,t,n,i){const r=t.length,a=[];for(let o=0;o<r;o++){let l=[],c=[];l.push((o+r-1)%r,o,(o+1)%r),c.push(0,1,0);const u=zn.getKeyframeOrder(l);l=zn.sortedArray(l,1,u),c=zn.sortedArray(c,1,u),!i&&l[0]===0&&(l.push(r),c.push(c[0])),a.push(new tp(".morphTargetInfluences["+t[o].name+"]",l,c).scale(1/n))}return new this(e,-1,a)}static findByName(e,t){let n=e;if(!Array.isArray(e)){const i=e;n=i.geometry&&i.geometry.animations||i.animations}for(let i=0;i<n.length;i++)if(n[i].name===t)return n[i];return null}static CreateClipsFromMorphTargetSequences(e,t,n){const i={},r=/^([\w-]*?)([\d]+)$/;for(let o=0,l=e.length;o<l;o++){const c=e[o],u=c.name.match(r);if(u&&u.length>1){const h=u[1];let d=i[h];d||(i[h]=d=[]),d.push(c)}}const a=[];for(const o in i)a.push(this.CreateFromMorphTargetSequence(o,i[o],t,n));return a}static parseAnimation(e,t){if(!e)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const n=function(h,d,f,v,g){if(f.length!==0){const m=[],x=[];zn.flattenJSON(f,m,x,v),m.length!==0&&g.push(new h(d,m,x))}},i=[],r=e.name||"default",a=e.fps||30,o=e.blendMode;let l=e.length||-1;const c=e.hierarchy||[];for(let h=0;h<c.length;h++){const d=c[h].keys;if(!(!d||d.length===0))if(d[0].morphTargets){const f={};let v;for(v=0;v<d.length;v++)if(d[v].morphTargets)for(let g=0;g<d[v].morphTargets.length;g++)f[d[v].morphTargets[g]]=-1;for(const g in f){const m=[],x=[];for(let w=0;w!==d[v].morphTargets.length;++w){const S=d[v];m.push(S.time),x.push(S.morphTarget===g?1:0)}i.push(new tp(".morphTargetInfluence["+g+"]",m,x))}l=f.length*a}else{const f=".bones["+t[h].name+"]";n(np,f+".position",d,"pos",i),n(Ch,f+".quaternion",d,"rot",i),n(np,f+".scale",d,"scl",i)}}return i.length===0?null:new this(r,l,i,o)}resetDuration(){const e=this.tracks;let t=0;for(let n=0,i=e.length;n!==i;++n){const r=this.tracks[n];t=Math.max(t,r.times[r.times.length-1])}return this.duration=t,this}trim(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].trim(0,this.duration);return this}validate(){let e=!0;for(let t=0;t<this.tracks.length;t++)e=e&&this.tracks[t].validate();return e}optimize(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].optimize();return this}clone(){const e=[];for(let t=0;t<this.tracks.length;t++)e.push(this.tracks[t].clone());return new this.constructor(this.name,this.duration,e,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function mI(s){switch(s.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return tp;case"vector":case"vector2":case"vector3":case"vector4":return np;case"color":return Eb;case"quaternion":return Ch;case"bool":case"boolean":return Pc;case"string":return Dc}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+s)}function gI(s){if(s.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const e=mI(s.type);if(s.times===void 0){const t=[],n=[];zn.flattenJSON(s.keys,t,n,"value"),s.times=t,s.values=n}return e.parse!==void 0?e.parse(s):new e(s.name,s.times,s.values,s.interpolation)}const xc={enabled:!1,files:{},add:function(s,e){this.enabled!==!1&&(this.files[s]=e)},get:function(s){if(this.enabled!==!1)return this.files[s]},remove:function(s){delete this.files[s]},clear:function(){this.files={}}};class vI{constructor(e,t,n){const i=this;let r=!1,a=0,o=0,l;const c=[];this.onStart=void 0,this.onLoad=e,this.onProgress=t,this.onError=n,this.itemStart=function(u){o++,r===!1&&i.onStart!==void 0&&i.onStart(u,a,o),r=!0},this.itemEnd=function(u){a++,i.onProgress!==void 0&&i.onProgress(u,a,o),a===o&&(r=!1,i.onLoad!==void 0&&i.onLoad())},this.itemError=function(u){i.onError!==void 0&&i.onError(u)},this.resolveURL=function(u){return l?l(u):u},this.setURLModifier=function(u){return l=u,this},this.addHandler=function(u,h){return c.push(u,h),this},this.removeHandler=function(u){const h=c.indexOf(u);return h!==-1&&c.splice(h,2),this},this.getHandler=function(u){for(let h=0,d=c.length;h<d;h+=2){const f=c[h],v=c[h+1];if(f.global&&(f.lastIndex=0),f.test(u))return v}return null}}}const yI=new vI;class ds{constructor(e){this.manager=e!==void 0?e:yI,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(e,t){const n=this;return new Promise(function(i,r){n.load(e,i,t,r)})}parse(){}setCrossOrigin(e){return this.crossOrigin=e,this}setWithCredentials(e){return this.withCredentials=e,this}setPath(e){return this.path=e,this}setResourcePath(e){return this.resourcePath=e,this}setRequestHeader(e){return this.requestHeader=e,this}}const Cs={};class Yv extends ds{constructor(e){super(e)}load(e,t,n,i){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const r=xc.get(e);if(r!==void 0)return this.manager.itemStart(e),setTimeout(()=>{t&&t(r),this.manager.itemEnd(e)},0),r;if(Cs[e]!==void 0){Cs[e].push({onLoad:t,onProgress:n,onError:i});return}Cs[e]=[],Cs[e].push({onLoad:t,onProgress:n,onError:i});const a=new Request(e,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),o=this.mimeType,l=this.responseType;fetch(a).then(c=>{if(c.status===200||c.status===0){if(c.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),typeof ReadableStream>"u"||c.body===void 0||c.body.getReader===void 0)return c;const u=Cs[e],h=c.body.getReader(),d=c.headers.get("Content-Length"),f=d?parseInt(d):0,v=f!==0;let g=0;const m=new ReadableStream({start(x){w();function w(){h.read().then(({done:S,value:b})=>{if(S)x.close();else{g+=b.byteLength;const E=new ProgressEvent("progress",{lengthComputable:v,loaded:g,total:f});for(let C=0,P=u.length;C<P;C++){const M=u[C];M.onProgress&&M.onProgress(E)}x.enqueue(b),w()}})}}});return new Response(m)}else throw Error(`fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`)}).then(c=>{switch(l){case"arraybuffer":return c.arrayBuffer();case"blob":return c.blob();case"document":return c.text().then(u=>new DOMParser().parseFromString(u,o));case"json":return c.json();default:if(o===void 0)return c.text();{const h=/charset="?([^;"\s]*)"?/i.exec(o),d=h&&h[1]?h[1].toLowerCase():void 0,f=new TextDecoder(d);return c.arrayBuffer().then(v=>f.decode(v))}}}).then(c=>{xc.add(e,c);const u=Cs[e];delete Cs[e];for(let h=0,d=u.length;h<d;h++){const f=u[h];f.onLoad&&f.onLoad(c)}}).catch(c=>{const u=Cs[e];if(u===void 0)throw this.manager.itemError(e),c;delete Cs[e];for(let h=0,d=u.length;h<d;h++){const f=u[h];f.onError&&f.onError(c)}this.manager.itemError(e)}).finally(()=>{this.manager.itemEnd(e)}),this.manager.itemStart(e)}setResponseType(e){return this.responseType=e,this}setMimeType(e){return this.mimeType=e,this}}class Mb extends ds{constructor(e){super(e)}load(e,t,n,i){this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const r=this,a=xc.get(e);if(a!==void 0)return r.manager.itemStart(e),setTimeout(function(){t&&t(a),r.manager.itemEnd(e)},0),a;const o=Lu("img");function l(){u(),xc.add(e,this),t&&t(this),r.manager.itemEnd(e)}function c(h){u(),i&&i(h),r.manager.itemError(e),r.manager.itemEnd(e)}function u(){o.removeEventListener("load",l,!1),o.removeEventListener("error",c,!1)}return o.addEventListener("load",l,!1),o.addEventListener("error",c,!1),e.slice(0,5)!=="data:"&&this.crossOrigin!==void 0&&(o.crossOrigin=this.crossOrigin),r.manager.itemStart(e),o.src=e,o}}class xI extends ds{constructor(e){super(e)}load(e,t,n,i){const r=new Lp,a=new Mb(this.manager);a.setCrossOrigin(this.crossOrigin),a.setPath(this.path);let o=0;function l(c){a.load(e[c],function(u){r.images[c]=u,o++,o===6&&(r.needsUpdate=!0,t&&t(r))},void 0,i)}for(let c=0;c<e.length;++c)l(c);return r}}class Cb extends ds{constructor(e){super(e)}load(e,t,n,i){const r=this,a=new Eh,o=new Yv(this.manager);return o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.setPath(this.path),o.setWithCredentials(r.withCredentials),o.load(e,function(l){const c=r.parse(l);c&&(c.image!==void 0?a.image=c.image:c.data!==void 0&&(a.image.width=c.width,a.image.height=c.height,a.image.data=c.data),a.wrapS=c.wrapS!==void 0?c.wrapS:fr,a.wrapT=c.wrapT!==void 0?c.wrapT:fr,a.magFilter=c.magFilter!==void 0?c.magFilter:cn,a.minFilter=c.minFilter!==void 0?c.minFilter:cn,a.anisotropy=c.anisotropy!==void 0?c.anisotropy:1,c.encoding!==void 0&&(a.encoding=c.encoding),c.flipY!==void 0&&(a.flipY=c.flipY),c.format!==void 0&&(a.format=c.format),c.type!==void 0&&(a.type=c.type),c.mipmaps!==void 0&&(a.mipmaps=c.mipmaps,a.minFilter=wh),c.mipmapCount===1&&(a.minFilter=cn),c.generateMipmaps!==void 0&&(a.generateMipmaps=c.generateMipmaps),a.needsUpdate=!0,t&&t(a,c))},n,i),a}}class Rb extends ds{constructor(e){super(e)}load(e,t,n,i){const r=new hi,a=new Mb(this.manager);return a.setCrossOrigin(this.crossOrigin),a.setPath(this.path),a.load(e,function(o){r.image=o,r.needsUpdate=!0,t!==void 0&&t(r)},n,i),r}}class os extends fn{constructor(e,t=1){super(),this.type="Light",this.color=new ot(e),this.intensity=t}dispose(){}copy(e){return super.copy(e),this.color.copy(e.color),this.intensity=e.intensity,this}toJSON(e){const t=super.toJSON(e);return t.object.color=this.color.getHex(),t.object.intensity=this.intensity,this.groundColor!==void 0&&(t.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(t.object.distance=this.distance),this.angle!==void 0&&(t.object.angle=this.angle),this.decay!==void 0&&(t.object.decay=this.decay),this.penumbra!==void 0&&(t.object.penumbra=this.penumbra),this.shadow!==void 0&&(t.object.shadow=this.shadow.toJSON()),t}}os.prototype.isLight=!0;class wI extends os{constructor(e,t,n){super(e,n),this.type="HemisphereLight",this.position.copy(fn.DefaultUp),this.updateMatrix(),this.groundColor=new ot(t)}copy(e){return os.prototype.copy.call(this,e),this.groundColor.copy(e.groundColor),this}}wI.prototype.isHemisphereLight=!0;const ix=new Ne,rx=new T,sx=new T;class Zv{constructor(e){this.camera=e,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new Me(512,512),this.map=null,this.mapPass=null,this.matrix=new Ne,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new bh,this._frameExtents=new Me(1,1),this._viewportCount=1,this._viewports=[new Ft(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(e){const t=this.camera,n=this.matrix;rx.setFromMatrixPosition(e.matrixWorld),t.position.copy(rx),sx.setFromMatrixPosition(e.target.matrixWorld),t.lookAt(sx),t.updateMatrixWorld(),ix.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),this._frustum.setFromProjectionMatrix(ix),n.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),n.multiply(t.projectionMatrix),n.multiply(t.matrixWorldInverse)}getViewport(e){return this._viewports[e]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(e){return this.camera=e.camera.clone(),this.bias=e.bias,this.radius=e.radius,this.mapSize.copy(e.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const e={};return this.bias!==0&&(e.bias=this.bias),this.normalBias!==0&&(e.normalBias=this.normalBias),this.radius!==1&&(e.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(e.mapSize=this.mapSize.toArray()),e.camera=this.camera.toJSON(!1).object,delete e.camera.matrix,e}}class Ib extends Zv{constructor(){super(new li(50,1,.5,500)),this.focus=1}updateMatrices(e){const t=this.camera,n=Du*2*e.angle*this.focus,i=this.mapSize.width/this.mapSize.height,r=e.distance||t.far;(n!==t.fov||i!==t.aspect||r!==t.far)&&(t.fov=n,t.aspect=i,t.far=r,t.updateProjectionMatrix()),super.updateMatrices(e)}copy(e){return super.copy(e),this.focus=e.focus,this}}Ib.prototype.isSpotLightShadow=!0;class SI extends os{constructor(e,t,n=0,i=Math.PI/3,r=0,a=1){super(e,t),this.type="SpotLight",this.position.copy(fn.DefaultUp),this.updateMatrix(),this.target=new fn,this.distance=n,this.angle=i,this.penumbra=r,this.decay=a,this.shadow=new Ib}get power(){return this.intensity*Math.PI}set power(e){this.intensity=e/Math.PI}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.distance=e.distance,this.angle=e.angle,this.penumbra=e.penumbra,this.decay=e.decay,this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}SI.prototype.isSpotLight=!0;const ax=new Ne,iu=new T,Vm=new T;class Pb extends Zv{constructor(){super(new li(90,1,.5,500)),this._frameExtents=new Me(4,2),this._viewportCount=6,this._viewports=[new Ft(2,1,1,1),new Ft(0,1,1,1),new Ft(3,1,1,1),new Ft(1,1,1,1),new Ft(3,0,1,1),new Ft(1,0,1,1)],this._cubeDirections=[new T(1,0,0),new T(-1,0,0),new T(0,0,1),new T(0,0,-1),new T(0,1,0),new T(0,-1,0)],this._cubeUps=[new T(0,1,0),new T(0,1,0),new T(0,1,0),new T(0,1,0),new T(0,0,1),new T(0,0,-1)]}updateMatrices(e,t=0){const n=this.camera,i=this.matrix,r=e.distance||n.far;r!==n.far&&(n.far=r,n.updateProjectionMatrix()),iu.setFromMatrixPosition(e.matrixWorld),n.position.copy(iu),Vm.copy(n.position),Vm.add(this._cubeDirections[t]),n.up.copy(this._cubeUps[t]),n.lookAt(Vm),n.updateMatrixWorld(),i.makeTranslation(-iu.x,-iu.y,-iu.z),ax.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),this._frustum.setFromProjectionMatrix(ax)}}Pb.prototype.isPointLightShadow=!0;class bI extends os{constructor(e,t,n=0,i=1){super(e,t),this.type="PointLight",this.distance=n,this.decay=i,this.shadow=new Pb}get power(){return this.intensity*4*Math.PI}set power(e){this.intensity=e/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.distance=e.distance,this.decay=e.decay,this.shadow=e.shadow.clone(),this}}bI.prototype.isPointLight=!0;class Db extends Zv{constructor(){super(new Xr(-5,5,5,-5,.5,500))}}Db.prototype.isDirectionalLightShadow=!0;class Lb extends os{constructor(e,t){super(e,t),this.type="DirectionalLight",this.position.copy(fn.DefaultUp),this.updateMatrix(),this.target=new fn,this.shadow=new Db}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}Lb.prototype.isDirectionalLight=!0;class AI extends os{constructor(e,t){super(e,t),this.type="AmbientLight"}}AI.prototype.isAmbientLight=!0;class TI extends os{constructor(e,t,n=10,i=10){super(e,t),this.type="RectAreaLight",this.width=n,this.height=i}get power(){return this.intensity*this.width*this.height*Math.PI}set power(e){this.intensity=e/(this.width*this.height*Math.PI)}copy(e){return super.copy(e),this.width=e.width,this.height=e.height,this}toJSON(e){const t=super.toJSON(e);return t.object.width=this.width,t.object.height=this.height,t}}TI.prototype.isRectAreaLight=!0;class Bb{constructor(){this.coefficients=[];for(let e=0;e<9;e++)this.coefficients.push(new T)}set(e){for(let t=0;t<9;t++)this.coefficients[t].copy(e[t]);return this}zero(){for(let e=0;e<9;e++)this.coefficients[e].set(0,0,0);return this}getAt(e,t){const n=e.x,i=e.y,r=e.z,a=this.coefficients;return t.copy(a[0]).multiplyScalar(.282095),t.addScaledVector(a[1],.488603*i),t.addScaledVector(a[2],.488603*r),t.addScaledVector(a[3],.488603*n),t.addScaledVector(a[4],1.092548*(n*i)),t.addScaledVector(a[5],1.092548*(i*r)),t.addScaledVector(a[6],.315392*(3*r*r-1)),t.addScaledVector(a[7],1.092548*(n*r)),t.addScaledVector(a[8],.546274*(n*n-i*i)),t}getIrradianceAt(e,t){const n=e.x,i=e.y,r=e.z,a=this.coefficients;return t.copy(a[0]).multiplyScalar(.886227),t.addScaledVector(a[1],2*.511664*i),t.addScaledVector(a[2],2*.511664*r),t.addScaledVector(a[3],2*.511664*n),t.addScaledVector(a[4],2*.429043*n*i),t.addScaledVector(a[5],2*.429043*i*r),t.addScaledVector(a[6],.743125*r*r-.247708),t.addScaledVector(a[7],2*.429043*n*r),t.addScaledVector(a[8],.429043*(n*n-i*i)),t}add(e){for(let t=0;t<9;t++)this.coefficients[t].add(e.coefficients[t]);return this}addScaledSH(e,t){for(let n=0;n<9;n++)this.coefficients[n].addScaledVector(e.coefficients[n],t);return this}scale(e){for(let t=0;t<9;t++)this.coefficients[t].multiplyScalar(e);return this}lerp(e,t){for(let n=0;n<9;n++)this.coefficients[n].lerp(e.coefficients[n],t);return this}equals(e){for(let t=0;t<9;t++)if(!this.coefficients[t].equals(e.coefficients[t]))return!1;return!0}copy(e){return this.set(e.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(e,t=0){const n=this.coefficients;for(let i=0;i<9;i++)n[i].fromArray(e,t+i*3);return this}toArray(e=[],t=0){const n=this.coefficients;for(let i=0;i<9;i++)n[i].toArray(e,t+i*3);return e}static getBasisAt(e,t){const n=e.x,i=e.y,r=e.z;t[0]=.282095,t[1]=.488603*i,t[2]=.488603*r,t[3]=.488603*n,t[4]=1.092548*n*i,t[5]=1.092548*i*r,t[6]=.315392*(3*r*r-1),t[7]=1.092548*n*r,t[8]=.546274*(n*n-i*i)}}Bb.prototype.isSphericalHarmonics3=!0;class $v extends os{constructor(e=new Bb,t=1){super(void 0,t),this.sh=e}copy(e){return super.copy(e),this.sh.copy(e.sh),this}fromJSON(e){return this.intensity=e.intensity,this.sh.fromArray(e.sh),this}toJSON(e){const t=super.toJSON(e);return t.object.sh=this.sh.toArray(),t}}$v.prototype.isLightProbe=!0;class EI{static decodeText(e){if(typeof TextDecoder<"u")return new TextDecoder().decode(e);let t="";for(let n=0,i=e.length;n<i;n++)t+=String.fromCharCode(e[n]);try{return decodeURIComponent(escape(t))}catch{return t}}static extractUrlBase(e){const t=e.lastIndexOf("/");return t===-1?"./":e.slice(0,t+1)}static resolveURL(e,t){return typeof e!="string"||e===""?"":(/^https?:\/\//i.test(t)&&/^\//.test(e)&&(t=t.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(e)||/^data:.*,.*$/i.test(e)||/^blob:.*$/i.test(e)?e:t+e)}}class e0 extends Xt{constructor(){super(),this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(e){return super.copy(e),this.instanceCount=e.instanceCount,this}clone(){return new this.constructor().copy(this)}toJSON(){const e=super.toJSON(this);return e.instanceCount=this.instanceCount,e.isInstancedBufferGeometry=!0,e}}e0.prototype.isInstancedBufferGeometry=!0;class MI extends ds{constructor(e){super(e),typeof createImageBitmap>"u"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch>"u"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(e){return this.options=e,this}load(e,t,n,i){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const r=this,a=xc.get(e);if(a!==void 0)return r.manager.itemStart(e),setTimeout(function(){t&&t(a),r.manager.itemEnd(e)},0),a;const o={};o.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",o.headers=this.requestHeader,fetch(e,o).then(function(l){return l.blob()}).then(function(l){return createImageBitmap(l,Object.assign(r.options,{colorSpaceConversion:"none"}))}).then(function(l){xc.add(e,l),t&&t(l),r.manager.itemEnd(e)}).catch(function(l){i&&i(l),r.manager.itemError(e),r.manager.itemEnd(e)}),r.manager.itemStart(e)}}MI.prototype.isImageBitmapLoader=!0;let Md;const CI={getContext:function(){return Md===void 0&&(Md=new(window.AudioContext||window.webkitAudioContext)),Md},setContext:function(s){Md=s}};class RI extends ds{constructor(e){super(e)}load(e,t,n,i){const r=this,a=new Yv(this.manager);a.setResponseType("arraybuffer"),a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(e,function(o){try{const l=o.slice(0);CI.getContext().decodeAudioData(l,function(u){t(u)})}catch(l){i?i(l):console.error(l),r.manager.itemError(e)}},n,i)}}class II extends $v{constructor(e,t,n=1){super(void 0,n);const i=new ot().set(e),r=new ot().set(t),a=new T(i.r,i.g,i.b),o=new T(r.r,r.g,r.b),l=Math.sqrt(Math.PI),c=l*Math.sqrt(.75);this.sh.coefficients[0].copy(a).add(o).multiplyScalar(l),this.sh.coefficients[1].copy(a).sub(o).multiplyScalar(c)}}II.prototype.isHemisphereLightProbe=!0;class PI extends $v{constructor(e,t=1){super(void 0,t);const n=new ot().set(e);this.sh.coefficients[0].set(n.r,n.g,n.b).multiplyScalar(2*Math.sqrt(Math.PI))}}PI.prototype.isAmbientLightProbe=!0;class DI{constructor(e=!0){this.autoStart=e,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=ox(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let e=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const t=ox();e=(t-this.oldTime)/1e3,this.oldTime=t,this.elapsedTime+=e}return e}}function ox(){return(typeof performance>"u"?Date:performance).now()}class LI extends fn{constructor(e){super(),this.type="Audio",this.listener=e,this.context=e.context,this.gain=this.context.createGain(),this.gain.connect(e.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(e){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=e,this.connect(),this}setMediaElementSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(e),this.connect(),this}setMediaStreamSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(e),this.connect(),this}setBuffer(e){return this.buffer=e,this.sourceType="buffer",this.autoplay&&this.play(),this}play(e=0){if(this.isPlaying===!0){console.warn("THREE.Audio: Audio is already playing.");return}if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}this._startedAt=this.context.currentTime+e;const t=this.context.createBufferSource();return t.buffer=this.buffer,t.loop=this.loop,t.loopStart=this.loopStart,t.loopEnd=this.loopEnd,t.onended=this.onEnded.bind(this),t.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=t,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.isPlaying===!0&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,this.loop===!0&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this}stop(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this._progress=0,this.source.stop(),this.source.onended=null,this.isPlaying=!1,this}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].connect(this.filters[e]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].disconnect(this.filters[e]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}getFilters(){return this.filters}setFilters(e){return e||(e=[]),this._connected===!0?(this.disconnect(),this.filters=e.slice(),this.connect()):this.filters=e.slice(),this}setDetune(e){if(this.detune=e,this.source.detune!==void 0)return this.isPlaying===!0&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(e){return this.setFilters(e?[e]:[])}setPlaybackRate(e){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.playbackRate=e,this.isPlaying===!0&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return this.hasPlaybackControl===!1?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(e){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.loop=e,this.isPlaying===!0&&(this.source.loop=this.loop),this}setLoopStart(e){return this.loopStart=e,this}setLoopEnd(e){return this.loopEnd=e,this}getVolume(){return this.gain.gain.value}setVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}}class BI{constructor(e,t,n){this.binding=e,this.valueSize=n;let i,r,a;switch(t){case"quaternion":i=this._slerp,r=this._slerpAdditive,a=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(n*6),this._workIndex=5;break;case"string":case"bool":i=this._select,r=this._select,a=this._setAdditiveIdentityOther,this.buffer=new Array(n*5);break;default:i=this._lerp,r=this._lerpAdditive,a=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(n*5)}this._mixBufferRegion=i,this._mixBufferRegionAdditive=r,this._setIdentity=a,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(e,t){const n=this.buffer,i=this.valueSize,r=e*i+i;let a=this.cumulativeWeight;if(a===0){for(let o=0;o!==i;++o)n[r+o]=n[o];a=t}else{a+=t;const o=t/a;this._mixBufferRegion(n,r,0,o,i)}this.cumulativeWeight=a}accumulateAdditive(e){const t=this.buffer,n=this.valueSize,i=n*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(t,i,0,e,n),this.cumulativeWeightAdditive+=e}apply(e){const t=this.valueSize,n=this.buffer,i=e*t+t,r=this.cumulativeWeight,a=this.cumulativeWeightAdditive,o=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,r<1){const l=t*this._origIndex;this._mixBufferRegion(n,i,l,1-r,t)}a>0&&this._mixBufferRegionAdditive(n,i,this._addIndex*t,1,t);for(let l=t,c=t+t;l!==c;++l)if(n[l]!==n[l+t]){o.setValue(n,i);break}}saveOriginalState(){const e=this.binding,t=this.buffer,n=this.valueSize,i=n*this._origIndex;e.getValue(t,i);for(let r=n,a=i;r!==a;++r)t[r]=t[i+r%n];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const e=this.valueSize*3;this.binding.setValue(this.buffer,e)}_setAdditiveIdentityNumeric(){const e=this._addIndex*this.valueSize,t=e+this.valueSize;for(let n=e;n<t;n++)this.buffer[n]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const e=this._origIndex*this.valueSize,t=this._addIndex*this.valueSize;for(let n=0;n<this.valueSize;n++)this.buffer[t+n]=this.buffer[e+n]}_select(e,t,n,i,r){if(i>=.5)for(let a=0;a!==r;++a)e[t+a]=e[n+a]}_slerp(e,t,n,i){An.slerpFlat(e,t,e,t,e,n,i)}_slerpAdditive(e,t,n,i,r){const a=this._workIndex*r;An.multiplyQuaternionsFlat(e,a,e,t,e,n),An.slerpFlat(e,t,e,t,e,a,i)}_lerp(e,t,n,i,r){const a=1-i;for(let o=0;o!==r;++o){const l=t+o;e[l]=e[l]*a+e[n+o]*i}}_lerpAdditive(e,t,n,i,r){for(let a=0;a!==r;++a){const o=t+a;e[o]=e[o]+e[n+a]*i}}}const t0="\\[\\]\\.:\\/",OI=new RegExp("["+t0+"]","g"),n0="[^"+t0+"]",NI="[^"+t0.replace("\\.","")+"]",zI=/((?:WC+[\/:])*)/.source.replace("WC",n0),FI=/(WCOD+)?/.source.replace("WCOD",NI),UI=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",n0),kI=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",n0),_I=new RegExp("^"+zI+FI+UI+kI+"$"),VI=["material","materials","bones"];class GI{constructor(e,t,n){const i=n||bn.parseTrackName(t);this._targetGroup=e,this._bindings=e.subscribe_(t,i)}getValue(e,t){this.bind();const n=this._targetGroup.nCachedObjects_,i=this._bindings[n];i!==void 0&&i.getValue(e,t)}setValue(e,t){const n=this._bindings;for(let i=this._targetGroup.nCachedObjects_,r=n.length;i!==r;++i)n[i].setValue(e,t)}bind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,n=e.length;t!==n;++t)e[t].bind()}unbind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,n=e.length;t!==n;++t)e[t].unbind()}}class bn{constructor(e,t,n){this.path=t,this.parsedPath=n||bn.parseTrackName(t),this.node=bn.findNode(e,this.parsedPath.nodeName)||e,this.rootNode=e,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(e,t,n){return e&&e.isAnimationObjectGroup?new bn.Composite(e,t,n):new bn(e,t,n)}static sanitizeNodeName(e){return e.replace(/\s/g,"_").replace(OI,"")}static parseTrackName(e){const t=_I.exec(e);if(t===null)throw new Error("PropertyBinding: Cannot parse trackName: "+e);const n={nodeName:t[2],objectName:t[3],objectIndex:t[4],propertyName:t[5],propertyIndex:t[6]},i=n.nodeName&&n.nodeName.lastIndexOf(".");if(i!==void 0&&i!==-1){const r=n.nodeName.substring(i+1);VI.indexOf(r)!==-1&&(n.nodeName=n.nodeName.substring(0,i),n.objectName=r)}if(n.propertyName===null||n.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+e);return n}static findNode(e,t){if(t===void 0||t===""||t==="."||t===-1||t===e.name||t===e.uuid)return e;if(e.skeleton){const n=e.skeleton.getBoneByName(t);if(n!==void 0)return n}if(e.children){const n=function(r){for(let a=0;a<r.length;a++){const o=r[a];if(o.name===t||o.uuid===t)return o;const l=n(o.children);if(l)return l}return null},i=n(e.children);if(i)return i}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(e,t){e[t]=this.targetObject[this.propertyName]}_getValue_array(e,t){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)e[t++]=n[i]}_getValue_arrayElement(e,t){e[t]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(e,t){this.resolvedProperty.toArray(e,t)}_setValue_direct(e,t){this.targetObject[this.propertyName]=e[t]}_setValue_direct_setNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(e,t){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)n[i]=e[t++]}_setValue_array_setNeedsUpdate(e,t){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)n[i]=e[t++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(e,t){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)n[i]=e[t++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(e,t){this.resolvedProperty[this.propertyIndex]=e[t]}_setValue_arrayElement_setNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(e,t){this.resolvedProperty.fromArray(e,t)}_setValue_fromArray_setNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(e,t){this.bind(),this.getValue(e,t)}_setValue_unbound(e,t){this.bind(),this.setValue(e,t)}bind(){let e=this.node;const t=this.parsedPath,n=t.objectName,i=t.propertyName;let r=t.propertyIndex;if(e||(e=bn.findNode(this.rootNode,t.nodeName)||this.rootNode,this.node=e),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!e){console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");return}if(n){let c=t.objectIndex;switch(n){case"materials":if(!e.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!e.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}e=e.material.materials;break;case"bones":if(!e.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}e=e.skeleton.bones;for(let u=0;u<e.length;u++)if(e[u].name===c){c=u;break}break;default:if(e[n]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}e=e[n]}if(c!==void 0){if(e[c]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,e);return}e=e[c]}}const a=e[i];if(a===void 0){const c=t.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+c+"."+i+" but it wasn't found.",e);return}let o=this.Versioning.None;this.targetObject=e,e.needsUpdate!==void 0?o=this.Versioning.NeedsUpdate:e.matrixWorldNeedsUpdate!==void 0&&(o=this.Versioning.MatrixWorldNeedsUpdate);let l=this.BindingType.Direct;if(r!==void 0){if(i==="morphTargetInfluences"){if(!e.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(e.geometry.isBufferGeometry){if(!e.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}e.morphTargetDictionary[r]!==void 0&&(r=e.morphTargetDictionary[r])}else{console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",this);return}}l=this.BindingType.ArrayElement,this.resolvedProperty=a,this.propertyIndex=r}else a.fromArray!==void 0&&a.toArray!==void 0?(l=this.BindingType.HasFromToArray,this.resolvedProperty=a):Array.isArray(a)?(l=this.BindingType.EntireArray,this.resolvedProperty=a):this.propertyName=i;this.getValue=this.GetterByBindingType[l],this.setValue=this.SetterByBindingTypeAndVersioning[l][o]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}bn.Composite=GI;bn.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3};bn.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2};bn.prototype.GetterByBindingType=[bn.prototype._getValue_direct,bn.prototype._getValue_array,bn.prototype._getValue_arrayElement,bn.prototype._getValue_toArray];bn.prototype.SetterByBindingTypeAndVersioning=[[bn.prototype._setValue_direct,bn.prototype._setValue_direct_setNeedsUpdate,bn.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[bn.prototype._setValue_array,bn.prototype._setValue_array_setNeedsUpdate,bn.prototype._setValue_array_setMatrixWorldNeedsUpdate],[bn.prototype._setValue_arrayElement,bn.prototype._setValue_arrayElement_setNeedsUpdate,bn.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[bn.prototype._setValue_fromArray,bn.prototype._setValue_fromArray_setNeedsUpdate,bn.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class HI{constructor(e,t,n=null,i=t.blendMode){this._mixer=e,this._clip=t,this._localRoot=n,this.blendMode=i;const r=t.tracks,a=r.length,o=new Array(a),l={endingStart:Vl,endingEnd:Vl};for(let c=0;c!==a;++c){const u=r[c].createInterpolant(null);o[c]=u,u.settings=l}this._interpolantSettings=l,this._interpolants=o,this._propertyBindings=new Array(a),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=wT,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(e){return this._startTime=e,this}setLoop(e,t){return this.loop=e,this.repetitions=t,this}setEffectiveWeight(e){return this.weight=e,this._effectiveWeight=this.enabled?e:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(e){return this._scheduleFading(e,0,1)}fadeOut(e){return this._scheduleFading(e,1,0)}crossFadeFrom(e,t,n){if(e.fadeOut(t),this.fadeIn(t),n){const i=this._clip.duration,r=e._clip.duration,a=r/i,o=i/r;e.warp(1,a,t),this.warp(o,1,t)}return this}crossFadeTo(e,t,n){return e.crossFadeFrom(this,t,n)}stopFading(){const e=this._weightInterpolant;return e!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}setEffectiveTimeScale(e){return this.timeScale=e,this._effectiveTimeScale=this.paused?0:e,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(e){return this.timeScale=this._clip.duration/e,this.stopWarping()}syncWith(e){return this.time=e.time,this.timeScale=e.timeScale,this.stopWarping()}halt(e){return this.warp(this._effectiveTimeScale,0,e)}warp(e,t,n){const i=this._mixer,r=i.time,a=this.timeScale;let o=this._timeScaleInterpolant;o===null&&(o=i._lendControlInterpolant(),this._timeScaleInterpolant=o);const l=o.parameterPositions,c=o.sampleValues;return l[0]=r,l[1]=r+n,c[0]=e/a,c[1]=t/a,this}stopWarping(){const e=this._timeScaleInterpolant;return e!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(e,t,n,i){if(!this.enabled){this._updateWeight(e);return}const r=this._startTime;if(r!==null){const l=(e-r)*n;if(l<0||n===0)return;this._startTime=null,t=n*l}t*=this._updateTimeScale(e);const a=this._updateTime(t),o=this._updateWeight(e);if(o>0){const l=this._interpolants,c=this._propertyBindings;switch(this.blendMode){case qS:for(let u=0,h=l.length;u!==h;++u)l[u].evaluate(a),c[u].accumulateAdditive(o);break;case Pv:default:for(let u=0,h=l.length;u!==h;++u)l[u].evaluate(a),c[u].accumulate(i,o)}}}_updateWeight(e){let t=0;if(this.enabled){t=this.weight;const n=this._weightInterpolant;if(n!==null){const i=n.evaluate(e)[0];t*=i,e>n.parameterPositions[1]&&(this.stopFading(),i===0&&(this.enabled=!1))}}return this._effectiveWeight=t,t}_updateTimeScale(e){let t=0;if(!this.paused){t=this.timeScale;const n=this._timeScaleInterpolant;if(n!==null){const i=n.evaluate(e)[0];t*=i,e>n.parameterPositions[1]&&(this.stopWarping(),t===0?this.paused=!0:this.timeScale=t)}}return this._effectiveTimeScale=t,t}_updateTime(e){const t=this._clip.duration,n=this.loop;let i=this.time+e,r=this._loopCount;const a=n===ST;if(e===0)return r===-1?i:a&&(r&1)===1?t-i:i;if(n===xT){r===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));e:{if(i>=t)i=t;else if(i<0)i=0;else{this.time=i;break e}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:e<0?-1:1})}}else{if(r===-1&&(e>=0?(r=0,this._setEndings(!0,this.repetitions===0,a)):this._setEndings(this.repetitions===0,!0,a)),i>=t||i<0){const o=Math.floor(i/t);i-=t*o,r+=Math.abs(o);const l=this.repetitions-r;if(l<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,i=e>0?t:0,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:e>0?1:-1});else{if(l===1){const c=e<0;this._setEndings(c,!c,a)}else this._setEndings(!1,!1,a);this._loopCount=r,this.time=i,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:o})}}else this.time=i;if(a&&(r&1)===1)return t-i}return i}_setEndings(e,t,n){const i=this._interpolantSettings;n?(i.endingStart=Gl,i.endingEnd=Gl):(e?i.endingStart=this.zeroSlopeAtStart?Gl:Vl:i.endingStart=Yf,t?i.endingEnd=this.zeroSlopeAtEnd?Gl:Vl:i.endingEnd=Yf)}_scheduleFading(e,t,n){const i=this._mixer,r=i.time;let a=this._weightInterpolant;a===null&&(a=i._lendControlInterpolant(),this._weightInterpolant=a);const o=a.parameterPositions,l=a.sampleValues;return o[0]=r,l[0]=t,o[1]=r+e,l[1]=n,this}}class WI extends Yo{constructor(e){super(),this._root=e,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(e,t){const n=e._localRoot||this._root,i=e._clip.tracks,r=i.length,a=e._propertyBindings,o=e._interpolants,l=n.uuid,c=this._bindingsByRootAndName;let u=c[l];u===void 0&&(u={},c[l]=u);for(let h=0;h!==r;++h){const d=i[h],f=d.name;let v=u[f];if(v!==void 0)++v.referenceCount,a[h]=v;else{if(v=a[h],v!==void 0){v._cacheIndex===null&&(++v.referenceCount,this._addInactiveBinding(v,l,f));continue}const g=t&&t._propertyBindings[h].binding.parsedPath;v=new BI(bn.create(n,f,g),d.ValueTypeName,d.getValueSize()),++v.referenceCount,this._addInactiveBinding(v,l,f),a[h]=v}o[h].resultBuffer=v.buffer}}_activateAction(e){if(!this._isActiveAction(e)){if(e._cacheIndex===null){const n=(e._localRoot||this._root).uuid,i=e._clip.uuid,r=this._actionsByClip[i];this._bindAction(e,r&&r.knownActions[0]),this._addInactiveAction(e,i,n)}const t=e._propertyBindings;for(let n=0,i=t.length;n!==i;++n){const r=t[n];r.useCount++===0&&(this._lendBinding(r),r.saveOriginalState())}this._lendAction(e)}}_deactivateAction(e){if(this._isActiveAction(e)){const t=e._propertyBindings;for(let n=0,i=t.length;n!==i;++n){const r=t[n];--r.useCount===0&&(r.restoreOriginalState(),this._takeBackBinding(r))}this._takeBackAction(e)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const e=this;this.stats={actions:{get total(){return e._actions.length},get inUse(){return e._nActiveActions}},bindings:{get total(){return e._bindings.length},get inUse(){return e._nActiveBindings}},controlInterpolants:{get total(){return e._controlInterpolants.length},get inUse(){return e._nActiveControlInterpolants}}}}_isActiveAction(e){const t=e._cacheIndex;return t!==null&&t<this._nActiveActions}_addInactiveAction(e,t,n){const i=this._actions,r=this._actionsByClip;let a=r[t];if(a===void 0)a={knownActions:[e],actionByRoot:{}},e._byClipCacheIndex=0,r[t]=a;else{const o=a.knownActions;e._byClipCacheIndex=o.length,o.push(e)}e._cacheIndex=i.length,i.push(e),a.actionByRoot[n]=e}_removeInactiveAction(e){const t=this._actions,n=t[t.length-1],i=e._cacheIndex;n._cacheIndex=i,t[i]=n,t.pop(),e._cacheIndex=null;const r=e._clip.uuid,a=this._actionsByClip,o=a[r],l=o.knownActions,c=l[l.length-1],u=e._byClipCacheIndex;c._byClipCacheIndex=u,l[u]=c,l.pop(),e._byClipCacheIndex=null;const h=o.actionByRoot,d=(e._localRoot||this._root).uuid;delete h[d],l.length===0&&delete a[r],this._removeInactiveBindingsForAction(e)}_removeInactiveBindingsForAction(e){const t=e._propertyBindings;for(let n=0,i=t.length;n!==i;++n){const r=t[n];--r.referenceCount===0&&this._removeInactiveBinding(r)}}_lendAction(e){const t=this._actions,n=e._cacheIndex,i=this._nActiveActions++,r=t[i];e._cacheIndex=i,t[i]=e,r._cacheIndex=n,t[n]=r}_takeBackAction(e){const t=this._actions,n=e._cacheIndex,i=--this._nActiveActions,r=t[i];e._cacheIndex=i,t[i]=e,r._cacheIndex=n,t[n]=r}_addInactiveBinding(e,t,n){const i=this._bindingsByRootAndName,r=this._bindings;let a=i[t];a===void 0&&(a={},i[t]=a),a[n]=e,e._cacheIndex=r.length,r.push(e)}_removeInactiveBinding(e){const t=this._bindings,n=e.binding,i=n.rootNode.uuid,r=n.path,a=this._bindingsByRootAndName,o=a[i],l=t[t.length-1],c=e._cacheIndex;l._cacheIndex=c,t[c]=l,t.pop(),delete o[r],Object.keys(o).length===0&&delete a[i]}_lendBinding(e){const t=this._bindings,n=e._cacheIndex,i=this._nActiveBindings++,r=t[i];e._cacheIndex=i,t[i]=e,r._cacheIndex=n,t[n]=r}_takeBackBinding(e){const t=this._bindings,n=e._cacheIndex,i=--this._nActiveBindings,r=t[i];e._cacheIndex=i,t[i]=e,r._cacheIndex=n,t[n]=r}_lendControlInterpolant(){const e=this._controlInterpolants,t=this._nActiveControlInterpolants++;let n=e[t];return n===void 0&&(n=new Tb(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),n.__cacheIndex=t,e[t]=n),n}_takeBackControlInterpolant(e){const t=this._controlInterpolants,n=e.__cacheIndex,i=--this._nActiveControlInterpolants,r=t[i];e.__cacheIndex=i,t[i]=e,r.__cacheIndex=n,t[n]=r}clipAction(e,t,n){const i=t||this._root,r=i.uuid;let a=typeof e=="string"?nx.findByName(i,e):e;const o=a!==null?a.uuid:e,l=this._actionsByClip[o];let c=null;if(n===void 0&&(a!==null?n=a.blendMode:n=Pv),l!==void 0){const h=l.actionByRoot[r];if(h!==void 0&&h.blendMode===n)return h;c=l.knownActions[0],a===null&&(a=c._clip)}if(a===null)return null;const u=new HI(this,a,t,n);return this._bindAction(u,c),this._addInactiveAction(u,o,r),u}existingAction(e,t){const n=t||this._root,i=n.uuid,r=typeof e=="string"?nx.findByName(n,e):e,a=r?r.uuid:e,o=this._actionsByClip[a];return o!==void 0&&o.actionByRoot[i]||null}stopAllAction(){const e=this._actions,t=this._nActiveActions;for(let n=t-1;n>=0;--n)e[n].stop();return this}update(e){e*=this.timeScale;const t=this._actions,n=this._nActiveActions,i=this.time+=e,r=Math.sign(e),a=this._accuIndex^=1;for(let c=0;c!==n;++c)t[c]._update(i,e,r,a);const o=this._bindings,l=this._nActiveBindings;for(let c=0;c!==l;++c)o[c].apply(a);return this}setTime(e){this.time=0;for(let t=0;t<this._actions.length;t++)this._actions[t].time=0;return this.update(e)}getRoot(){return this._root}uncacheClip(e){const t=this._actions,n=e.uuid,i=this._actionsByClip,r=i[n];if(r!==void 0){const a=r.knownActions;for(let o=0,l=a.length;o!==l;++o){const c=a[o];this._deactivateAction(c);const u=c._cacheIndex,h=t[t.length-1];c._cacheIndex=null,c._byClipCacheIndex=null,h._cacheIndex=u,t[u]=h,t.pop(),this._removeInactiveBindingsForAction(c)}delete i[n]}}uncacheRoot(e){const t=e.uuid,n=this._actionsByClip;for(const a in n){const o=n[a].actionByRoot,l=o[t];l!==void 0&&(this._deactivateAction(l),this._removeInactiveAction(l))}const i=this._bindingsByRootAndName,r=i[t];if(r!==void 0)for(const a in r){const o=r[a];o.restoreOriginalState(),this._removeInactiveBinding(o)}}uncacheAction(e,t){const n=this.existingAction(e,t);n!==null&&(this._deactivateAction(n),this._removeInactiveAction(n))}}WI.prototype._controlInterpolantsResultBuffer=new Float32Array(1);class wc extends Th{constructor(e,t,n=1){super(e,t),this.meshPerAttribute=n}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}clone(e){const t=super.clone(e);return t.meshPerAttribute=this.meshPerAttribute,t}toJSON(e){const t=super.toJSON(e);return t.isInstancedInterleavedBuffer=!0,t.meshPerAttribute=this.meshPerAttribute,t}}wc.prototype.isInstancedInterleavedBuffer=!0;class Ob{constructor(e,t,n=0,i=1/0){this.ray=new Ti(e,t),this.near=n,this.far=i,this.camera=null,this.layers=new zv,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(e,t){this.ray.set(e,t)}setFromCamera(e,t){t.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(t.matrixWorld),this.ray.direction.set(e.x,e.y,.5).unproject(t).sub(this.ray.origin).normalize(),this.camera=t):t.isOrthographicCamera?(this.ray.origin.set(e.x,e.y,(t.near+t.far)/(t.near-t.far)).unproject(t),this.ray.direction.set(0,0,-1).transformDirection(t.matrixWorld),this.camera=t):console.error("THREE.Raycaster: Unsupported camera type: "+t.type)}intersectObject(e,t=!0,n=[]){return Xg(e,this,n,t),n.sort(lx),n}intersectObjects(e,t=!0,n=[]){for(let i=0,r=e.length;i<r;i++)Xg(e[i],this,n,t);return n.sort(lx),n}}function lx(s,e){return s.distance-e.distance}function Xg(s,e,t,n){if(s.layers.test(e.layers)&&s.raycast(e,t),n===!0){const i=s.children;for(let r=0,a=i.length;r<a;r++)Xg(i[r],e,t,!0)}}class vf{constructor(e=1,t=0,n=0){return this.radius=e,this.phi=t,this.theta=n,this}set(e,t,n){return this.radius=e,this.phi=t,this.theta=n,this}copy(e){return this.radius=e.radius,this.phi=e.phi,this.theta=e.theta,this}makeSafe(){return this.phi=Math.max(1e-6,Math.min(Math.PI-1e-6,this.phi)),this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,n){return this.radius=Math.sqrt(e*e+t*t+n*n),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(e,n),this.phi=Math.acos(oi(t/this.radius,-1,1))),this}clone(){return new this.constructor().copy(this)}}const cx=new T,Cd=new T;class Mr{constructor(e=new T,t=new T){this.start=e,this.end=t}set(e,t){return this.start.copy(e),this.end.copy(t),this}copy(e){return this.start.copy(e.start),this.end.copy(e.end),this}getCenter(e){return e.addVectors(this.start,this.end).multiplyScalar(.5)}delta(e){return e.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(e,t){return this.delta(t).multiplyScalar(e).add(this.start)}closestPointToPointParameter(e,t){cx.subVectors(e,this.start),Cd.subVectors(this.end,this.start);const n=Cd.dot(Cd);let r=Cd.dot(cx)/n;return t&&(r=oi(r,0,1)),r}closestPointToPoint(e,t,n){const i=this.closestPointToPointParameter(e,t);return this.delta(n).multiplyScalar(i).add(this.start)}applyMatrix4(e){return this.start.applyMatrix4(e),this.end.applyMatrix4(e),this}equals(e){return e.start.equals(this.start)&&e.end.equals(this.end)}clone(){return new this.constructor().copy(this)}}const xa=new T,Rd=new Ne,Gm=new Ne;class qI extends Np{constructor(e){const t=Nb(e),n=new Xt,i=[],r=[],a=new ot(0,0,1),o=new ot(0,1,0);for(let c=0;c<t.length;c++){const u=t[c];u.parent&&u.parent.isBone&&(i.push(0,0,0),i.push(0,0,0),r.push(a.r,a.g,a.b),r.push(o.r,o.g,o.b))}n.setAttribute("position",new Vt(i,3)),n.setAttribute("color",new Vt(r,3));const l=new na({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});super(n,l),this.type="SkeletonHelper",this.isSkeletonHelper=!0,this.root=e,this.bones=t,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(e){const t=this.bones,n=this.geometry,i=n.getAttribute("position");Gm.copy(this.root.matrixWorld).invert();for(let r=0,a=0;r<t.length;r++){const o=t[r];o.parent&&o.parent.isBone&&(Rd.multiplyMatrices(Gm,o.matrixWorld),xa.setFromMatrixPosition(Rd),i.setXYZ(a,xa.x,xa.y,xa.z),Rd.multiplyMatrices(Gm,o.parent.matrixWorld),xa.setFromMatrixPosition(Rd),i.setXYZ(a+1,xa.x,xa.y,xa.z),a+=2)}n.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(e)}}function Nb(s){const e=[];s.isBone===!0&&e.push(s);for(let t=0;t<s.children.length;t++)e.push.apply(e,Nb(s.children[t]));return e}class jI extends Np{constructor(e=10,t=10,n=4473924,i=8947848){n=new ot(n),i=new ot(i);const r=t/2,a=e/t,o=e/2,l=[],c=[];for(let d=0,f=0,v=-o;d<=t;d++,v+=a){l.push(-o,0,v,o,0,v),l.push(v,0,-o,v,0,o);const g=d===r?n:i;g.toArray(c,f),f+=3,g.toArray(c,f),f+=3,g.toArray(c,f),f+=3,g.toArray(c,f),f+=3}const u=new Xt;u.setAttribute("position",new Vt(l,3)),u.setAttribute("color",new Vt(c,3));const h=new na({vertexColors:!0,toneMapped:!1});super(u,h),this.type="GridHelper"}}const ux=new T,Id=new T,hx=new T;class QI extends fn{constructor(e,t,n){super(),this.light=e,this.light.updateMatrixWorld(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=n,t===void 0&&(t=1);let i=new Xt;i.setAttribute("position",new Vt([-t,t,0,t,t,0,t,-t,0,-t,-t,0,-t,t,0],3));const r=new na({fog:!1,toneMapped:!1});this.lightPlane=new Bu(i,r),this.add(this.lightPlane),i=new Xt,i.setAttribute("position",new Vt([0,0,0,0,0,1],3)),this.targetLine=new Bu(i,r),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){ux.setFromMatrixPosition(this.light.matrixWorld),Id.setFromMatrixPosition(this.light.target.matrixWorld),hx.subVectors(Id,ux),this.lightPlane.lookAt(Id),this.color!==void 0?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(Id),this.targetLine.scale.z=hx.length()}}const Pd=new T,Gn=new Dp;class zb extends Np{constructor(e){const t=new Xt,n=new na({color:16777215,vertexColors:!0,toneMapped:!1}),i=[],r=[],a={},o=new ot(16755200),l=new ot(16711680),c=new ot(43775),u=new ot(16777215),h=new ot(3355443);d("n1","n2",o),d("n2","n4",o),d("n4","n3",o),d("n3","n1",o),d("f1","f2",o),d("f2","f4",o),d("f4","f3",o),d("f3","f1",o),d("n1","f1",o),d("n2","f2",o),d("n3","f3",o),d("n4","f4",o),d("p","n1",l),d("p","n2",l),d("p","n3",l),d("p","n4",l),d("u1","u2",c),d("u2","u3",c),d("u3","u1",c),d("c","t",u),d("p","c",h),d("cn1","cn2",h),d("cn3","cn4",h),d("cf1","cf2",h),d("cf3","cf4",h);function d(v,g,m){f(v,m),f(g,m)}function f(v,g){i.push(0,0,0),r.push(g.r,g.g,g.b),a[v]===void 0&&(a[v]=[]),a[v].push(i.length/3-1)}t.setAttribute("position",new Vt(i,3)),t.setAttribute("color",new Vt(r,3)),super(t,n),this.type="CameraHelper",this.camera=e,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=a,this.update()}update(){const e=this.geometry,t=this.pointMap,n=1,i=1;Gn.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),jn("c",t,e,Gn,0,0,-1),jn("t",t,e,Gn,0,0,1),jn("n1",t,e,Gn,-n,-i,-1),jn("n2",t,e,Gn,n,-i,-1),jn("n3",t,e,Gn,-n,i,-1),jn("n4",t,e,Gn,n,i,-1),jn("f1",t,e,Gn,-n,-i,1),jn("f2",t,e,Gn,n,-i,1),jn("f3",t,e,Gn,-n,i,1),jn("f4",t,e,Gn,n,i,1),jn("u1",t,e,Gn,n*.7,i*1.1,-1),jn("u2",t,e,Gn,-n*.7,i*1.1,-1),jn("u3",t,e,Gn,0,i*2,-1),jn("cf1",t,e,Gn,-n,0,1),jn("cf2",t,e,Gn,n,0,1),jn("cf3",t,e,Gn,0,-i,1),jn("cf4",t,e,Gn,0,i,1),jn("cn1",t,e,Gn,-n,0,-1),jn("cn2",t,e,Gn,n,0,-1),jn("cn3",t,e,Gn,0,-i,-1),jn("cn4",t,e,Gn,0,i,-1),e.getAttribute("position").needsUpdate=!0}dispose(){this.geometry.dispose(),this.material.dispose()}}function jn(s,e,t,n,i,r,a){Pd.set(i,r,a).unproject(n);const o=e[s];if(o!==void 0){const l=t.getAttribute("position");for(let c=0,u=o.length;c<u;c++)l.setXYZ(o[c],Pd.x,Pd.y,Pd.z)}}class XI{constructor(){this.type="ShapePath",this.color=new ot,this.subPaths=[],this.currentPath=null}moveTo(e,t){return this.currentPath=new ep,this.subPaths.push(this.currentPath),this.currentPath.moveTo(e,t),this}lineTo(e,t){return this.currentPath.lineTo(e,t),this}quadraticCurveTo(e,t,n,i){return this.currentPath.quadraticCurveTo(e,t,n,i),this}bezierCurveTo(e,t,n,i,r,a){return this.currentPath.bezierCurveTo(e,t,n,i,r,a),this}splineThru(e){return this.currentPath.splineThru(e),this}toShapes(e,t){function n(w){const S=[];for(let b=0,E=w.length;b<E;b++){const C=w[b],P=new Ua;P.curves=C.curves,S.push(P)}return S}function i(w,S){const b=S.length;let E=!1;for(let C=b-1,P=0;P<b;C=P++){let M=S[C],L=S[P],z=L.x-M.x,V=L.y-M.y;if(Math.abs(V)>Number.EPSILON){if(V<0&&(M=S[P],z=-z,L=S[C],V=-V),w.y<M.y||w.y>L.y)continue;if(w.y===M.y){if(w.x===M.x)return!0}else{const U=V*(w.x-M.x)-z*(w.y-M.y);if(U===0)return!0;if(U<0)continue;E=!E}}else{if(w.y!==M.y)continue;if(L.x<=w.x&&w.x<=M.x||M.x<=w.x&&w.x<=L.x)return!0}}return E}const r=Qs.isClockWise,a=this.subPaths;if(a.length===0)return[];if(t===!0)return n(a);let o,l,c;const u=[];if(a.length===1)return l=a[0],c=new Ua,c.curves=l.curves,u.push(c),u;let h=!r(a[0].getPoints());h=e?!h:h;const d=[],f=[];let v=[],g=0,m;f[g]=void 0,v[g]=[];for(let w=0,S=a.length;w<S;w++)l=a[w],m=l.getPoints(),o=r(m),o=e?!o:o,o?(!h&&f[g]&&g++,f[g]={s:new Ua,p:m},f[g].s.curves=l.curves,h&&g++,v[g]=[]):v[g].push({h:l,p:m[0]});if(!f[0])return n(a);if(f.length>1){let w=!1,S=0;for(let b=0,E=f.length;b<E;b++)d[b]=[];for(let b=0,E=f.length;b<E;b++){const C=v[b];for(let P=0;P<C.length;P++){const M=C[P];let L=!0;for(let z=0;z<f.length;z++)i(M.p,f[z].p)&&(b!==z&&S++,L?(L=!1,d[z].push(M)):w=!0);L&&d[b].push(M)}}S>0&&w===!1&&(v=d)}let x;for(let w=0,S=f.length;w<S;w++){c=f[w].s,u.push(c),x=v[w];for(let b=0,E=x.length;b<E;b++)c.holes.push(x[b].h)}return u}}class ql{static toHalfFloat(e){Math.abs(e)>65504&&console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),e=oi(e,-65504,65504),dx[0]=e;const t=fx[0],n=t>>23&511;return _r[n]+((t&8388607)>>Vr[n])}static fromHalfFloat(e){const t=e>>10;return fx[0]=i0[Ub[t]+(e&1023)]+Lc[t],dx[0]}}const Fb=new ArrayBuffer(4),dx=new Float32Array(Fb),fx=new Uint32Array(Fb),_r=new Uint32Array(512),Vr=new Uint32Array(512);for(let s=0;s<256;++s){const e=s-127;e<-27?(_r[s]=0,_r[s|256]=32768,Vr[s]=24,Vr[s|256]=24):e<-14?(_r[s]=1024>>-e-14,_r[s|256]=1024>>-e-14|32768,Vr[s]=-e-1,Vr[s|256]=-e-1):e<=15?(_r[s]=e+15<<10,_r[s|256]=e+15<<10|32768,Vr[s]=13,Vr[s|256]=13):e<128?(_r[s]=31744,_r[s|256]=64512,Vr[s]=24,Vr[s|256]=24):(_r[s]=31744,_r[s|256]=64512,Vr[s]=13,Vr[s|256]=13)}const i0=new Uint32Array(2048),Lc=new Uint32Array(64),Ub=new Uint32Array(64);for(let s=1;s<1024;++s){let e=s<<13,t=0;for(;(e&8388608)===0;)e<<=1,t-=8388608;e&=-8388609,t+=947912704,i0[s]=e|t}for(let s=1024;s<2048;++s)i0[s]=939524096+(s-1024<<13);for(let s=1;s<31;++s)Lc[s]=s<<23;Lc[31]=1199570944;Lc[32]=2147483648;for(let s=33;s<63;++s)Lc[s]=2147483648+(s-32<<23);Lc[63]=3347054592;for(let s=1;s<64;++s)s!==32&&(Ub[s]=1024);Dr.create=function(s,e){return console.log("THREE.Curve.create() has been deprecated"),s.prototype=Object.create(Dr.prototype),s.prototype.constructor=s,s.prototype.getPoint=e,s};ep.prototype.fromPoints=function(s){return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),this.setFromPoints(s)};jI.prototype.setColors=function(){console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")};qI.prototype.update=function(){console.error("THREE.SkeletonHelper: update() no longer needs to be called.")};ds.prototype.extractUrlBase=function(s){return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),EI.extractUrlBase(s)};ds.Handlers={add:function(){console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")},get:function(){console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")}};Tt.prototype.center=function(s){return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),this.getCenter(s)};Tt.prototype.empty=function(){return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),this.isEmpty()};Tt.prototype.isIntersectionBox=function(s){return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(s)};Tt.prototype.isIntersectionSphere=function(s){return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(s)};Tt.prototype.size=function(s){return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),this.getSize(s)};vr.prototype.toVector3=function(){console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead")};Zn.prototype.empty=function(){return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),this.isEmpty()};bh.prototype.setFromMatrix=function(s){return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),this.setFromProjectionMatrix(s)};Mr.prototype.center=function(s){return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."),this.getCenter(s)};Hn.prototype.flattenToArrayOffset=function(s,e){return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(s,e)};Hn.prototype.multiplyVector3=function(s){return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),s.applyMatrix3(this)};Hn.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")};Hn.prototype.applyToBufferAttribute=function(s){return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),s.applyMatrix3(this)};Hn.prototype.applyToVector3Array=function(){console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")};Hn.prototype.getInverse=function(s){return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(s).invert()};Ne.prototype.extractPosition=function(s){return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),this.copyPosition(s)};Ne.prototype.flattenToArrayOffset=function(s,e){return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(s,e)};Ne.prototype.getPosition=function(){return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),new T().setFromMatrixColumn(this,3)};Ne.prototype.setRotationFromQuaternion=function(s){return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),this.makeRotationFromQuaternion(s)};Ne.prototype.multiplyToArray=function(){console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")};Ne.prototype.multiplyVector3=function(s){return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),s.applyMatrix4(this)};Ne.prototype.multiplyVector4=function(s){return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),s.applyMatrix4(this)};Ne.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")};Ne.prototype.rotateAxis=function(s){console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),s.transformDirection(this)};Ne.prototype.crossVector=function(s){return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),s.applyMatrix4(this)};Ne.prototype.translate=function(){console.error("THREE.Matrix4: .translate() has been removed.")};Ne.prototype.rotateX=function(){console.error("THREE.Matrix4: .rotateX() has been removed.")};Ne.prototype.rotateY=function(){console.error("THREE.Matrix4: .rotateY() has been removed.")};Ne.prototype.rotateZ=function(){console.error("THREE.Matrix4: .rotateZ() has been removed.")};Ne.prototype.rotateByAxis=function(){console.error("THREE.Matrix4: .rotateByAxis() has been removed.")};Ne.prototype.applyToBufferAttribute=function(s){return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),s.applyMatrix4(this)};Ne.prototype.applyToVector3Array=function(){console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")};Ne.prototype.makeFrustum=function(s,e,t,n,i,r){return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),this.makePerspective(s,e,n,t,i,r)};Ne.prototype.getInverse=function(s){return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(s).invert()};vi.prototype.isIntersectionLine=function(s){return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),this.intersectsLine(s)};An.prototype.multiplyVector3=function(s){return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),s.applyQuaternion(this)};An.prototype.inverse=function(){return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),this.invert()};Ti.prototype.isIntersectionBox=function(s){return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(s)};Ti.prototype.isIntersectionPlane=function(s){return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),this.intersectsPlane(s)};Ti.prototype.isIntersectionSphere=function(s){return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(s)};Cn.prototype.area=function(){return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),this.getArea()};Cn.prototype.barycoordFromPoint=function(s,e){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),this.getBarycoord(s,e)};Cn.prototype.midpoint=function(s){return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),this.getMidpoint(s)};Cn.prototypenormal=function(s){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),this.getNormal(s)};Cn.prototype.plane=function(s){return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),this.getPlane(s)};Cn.barycoordFromPoint=function(s,e,t,n,i){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),Cn.getBarycoord(s,e,t,n,i)};Cn.normal=function(s,e,t,n){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),Cn.getNormal(s,e,t,n)};Ua.prototype.extractAllPoints=function(s){return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),this.extractPoints(s)};Ua.prototype.extrude=function(s){return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),new Ic(this,s)};Ua.prototype.makeGeometry=function(s){return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),new Qv(this,s)};Me.prototype.fromAttribute=function(s,e,t){return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(s,e,t)};Me.prototype.distanceToManhattan=function(s){return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(s)};Me.prototype.lengthManhattan=function(){return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()};T.prototype.setEulerFromRotationMatrix=function(){console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")};T.prototype.setEulerFromQuaternion=function(){console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")};T.prototype.getPositionFromMatrix=function(s){return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),this.setFromMatrixPosition(s)};T.prototype.getScaleFromMatrix=function(s){return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),this.setFromMatrixScale(s)};T.prototype.getColumnFromMatrix=function(s,e){return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),this.setFromMatrixColumn(e,s)};T.prototype.applyProjection=function(s){return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),this.applyMatrix4(s)};T.prototype.fromAttribute=function(s,e,t){return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(s,e,t)};T.prototype.distanceToManhattan=function(s){return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(s)};T.prototype.lengthManhattan=function(){return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()};Ft.prototype.fromAttribute=function(s,e,t){return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(s,e,t)};Ft.prototype.lengthManhattan=function(){return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()};fn.prototype.getChildByName=function(s){return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),this.getObjectByName(s)};fn.prototype.renderDepth=function(){console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")};fn.prototype.translate=function(s,e){return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),this.translateOnAxis(e,s)};fn.prototype.getWorldRotation=function(){console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")};fn.prototype.applyMatrix=function(s){return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(s)};Object.defineProperties(fn.prototype,{eulerOrder:{get:function(){return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order},set:function(s){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order=s}},useQuaternion:{get:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")},set:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")}}});gn.prototype.setDrawMode=function(){console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")};Object.defineProperties(gn.prototype,{drawMode:{get:function(){return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),bT},set:function(){console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}});ab.prototype.initBones=function(){console.error("THREE.SkinnedMesh: initBones() has been removed.")};li.prototype.setLens=function(s,e){console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),e!==void 0&&(this.filmGauge=e),this.setFocalLength(s)};Object.defineProperties(os.prototype,{onlyShadow:{set:function(){console.warn("THREE.Light: .onlyShadow has been removed.")}},shadowCameraFov:{set:function(s){console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),this.shadow.camera.fov=s}},shadowCameraLeft:{set:function(s){console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),this.shadow.camera.left=s}},shadowCameraRight:{set:function(s){console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),this.shadow.camera.right=s}},shadowCameraTop:{set:function(s){console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),this.shadow.camera.top=s}},shadowCameraBottom:{set:function(s){console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),this.shadow.camera.bottom=s}},shadowCameraNear:{set:function(s){console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),this.shadow.camera.near=s}},shadowCameraFar:{set:function(s){console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),this.shadow.camera.far=s}},shadowCameraVisible:{set:function(){console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")}},shadowBias:{set:function(s){console.warn("THREE.Light: .shadowBias is now .shadow.bias."),this.shadow.bias=s}},shadowDarkness:{set:function(){console.warn("THREE.Light: .shadowDarkness has been removed.")}},shadowMapWidth:{set:function(s){console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),this.shadow.mapSize.width=s}},shadowMapHeight:{set:function(s){console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),this.shadow.mapSize.height=s}}});Object.defineProperties(Sn.prototype,{length:{get:function(){return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),this.array.length}},dynamic:{get:function(){return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.usage===Pr},set:function(){console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.setUsage(Pr)}}});Sn.prototype.setDynamic=function(s){return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(s===!0?Pr:Pu),this};Sn.prototype.copyIndicesArray=function(){console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")},Sn.prototype.setArray=function(){console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")};Xt.prototype.addIndex=function(s){console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),this.setIndex(s)};Xt.prototype.addAttribute=function(s,e){return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),!(e&&e.isBufferAttribute)&&!(e&&e.isInterleavedBufferAttribute)?(console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),this.setAttribute(s,new Sn(arguments[1],arguments[2]))):s==="index"?(console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),this.setIndex(e),this):this.setAttribute(s,e)};Xt.prototype.addDrawCall=function(s,e,t){t!==void 0&&console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),this.addGroup(s,e)};Xt.prototype.clearDrawCalls=function(){console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),this.clearGroups()};Xt.prototype.computeOffsets=function(){console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")};Xt.prototype.removeAttribute=function(s){return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),this.deleteAttribute(s)};Xt.prototype.applyMatrix=function(s){return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(s)};Object.defineProperties(Xt.prototype,{drawcalls:{get:function(){return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),this.groups}},offsets:{get:function(){return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),this.groups}}});Th.prototype.setDynamic=function(s){return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(s===!0?Pr:Pu),this};Th.prototype.setArray=function(){console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")};Ic.prototype.getArrays=function(){console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")};Ic.prototype.addShapeList=function(){console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")};Ic.prototype.addShape=function(){console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")};_v.prototype.dispose=function(){console.error("THREE.Scene: .dispose() has been removed.")};Object.defineProperties(di.prototype,{wrapAround:{get:function(){console.warn("THREE.Material: .wrapAround has been removed.")},set:function(){console.warn("THREE.Material: .wrapAround has been removed.")}},overdraw:{get:function(){console.warn("THREE.Material: .overdraw has been removed.")},set:function(){console.warn("THREE.Material: .overdraw has been removed.")}},wrapRGB:{get:function(){return console.warn("THREE.Material: .wrapRGB has been removed."),new ot}},shading:{get:function(){console.error("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead.")},set:function(s){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=s===TS}},stencilMask:{get:function(){return console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask},set:function(s){console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask=s}},vertexTangents:{get:function(){console.warn("THREE."+this.type+": .vertexTangents has been removed.")},set:function(){console.warn("THREE."+this.type+": .vertexTangents has been removed.")}}});Object.defineProperties($n.prototype,{derivatives:{get:function(){return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives},set:function(s){console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives=s}}});Tn.prototype.clearTarget=function(s,e,t,n){console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),this.setRenderTarget(s),this.clear(e,t,n)};Tn.prototype.animate=function(s){console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),this.setAnimationLoop(s)};Tn.prototype.getCurrentRenderTarget=function(){return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),this.getRenderTarget()};Tn.prototype.getMaxAnisotropy=function(){return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),this.capabilities.getMaxAnisotropy()};Tn.prototype.getPrecision=function(){return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),this.capabilities.precision};Tn.prototype.resetGLState=function(){return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),this.state.reset()};Tn.prototype.supportsFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),this.extensions.get("OES_texture_float")};Tn.prototype.supportsHalfFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),this.extensions.get("OES_texture_half_float")};Tn.prototype.supportsStandardDerivatives=function(){return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),this.extensions.get("OES_standard_derivatives")};Tn.prototype.supportsCompressedTextureS3TC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),this.extensions.get("WEBGL_compressed_texture_s3tc")};Tn.prototype.supportsCompressedTexturePVRTC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),this.extensions.get("WEBGL_compressed_texture_pvrtc")};Tn.prototype.supportsBlendMinMax=function(){return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),this.extensions.get("EXT_blend_minmax")};Tn.prototype.supportsVertexTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),this.capabilities.vertexTextures};Tn.prototype.supportsInstancedArrays=function(){return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),this.extensions.get("ANGLE_instanced_arrays")};Tn.prototype.enableScissorTest=function(s){console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),this.setScissorTest(s)};Tn.prototype.initMaterial=function(){console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")};Tn.prototype.addPrePlugin=function(){console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")};Tn.prototype.addPostPlugin=function(){console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")};Tn.prototype.updateShadowMap=function(){console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")};Tn.prototype.setFaceCulling=function(){console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")};Tn.prototype.allocTextureUnit=function(){console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")};Tn.prototype.setTexture=function(){console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")};Tn.prototype.setTexture2D=function(){console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")};Tn.prototype.setTextureCube=function(){console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")};Tn.prototype.getActiveMipMapLevel=function(){return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),this.getActiveMipmapLevel()};Object.defineProperties(Tn.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled},set:function(s){console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),this.shadowMap.enabled=s}},shadowMapType:{get:function(){return this.shadowMap.type},set:function(s){console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),this.shadowMap.type=s}},shadowMapCullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")}},context:{get:function(){return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),this.getContext()}},vr:{get:function(){return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),this.xr}},gammaInput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),!1},set:function(){console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")}},gammaOutput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),!1},set:function(s){console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),this.outputEncoding=s===!0?Wt:Ir}},toneMappingWhitePoint:{get:function(){return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),1},set:function(){console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")}},gammaFactor:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."),2},set:function(){console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.")}}});Object.defineProperties(nb.prototype,{cullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")}},renderReverseSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")}},renderSingleSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")}}});Object.defineProperties(Yn.prototype,{wrapS:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS},set:function(s){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS=s}},wrapT:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT},set:function(s){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT=s}},magFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter},set:function(s){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter=s}},minFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter},set:function(s){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter=s}},anisotropy:{get:function(){return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy},set:function(s){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy=s}},offset:{get:function(){return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset},set:function(s){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset=s}},repeat:{get:function(){return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat},set:function(s){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat=s}},format:{get:function(){return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format},set:function(s){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format=s}},type:{get:function(){return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type},set:function(s){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type=s}},generateMipmaps:{get:function(){return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps},set:function(s){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps=s}}});LI.prototype.load=function(s){console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");const e=this;return new RI().load(s,function(n){e.setBuffer(n)}),this};Fv.prototype.updateCubeMap=function(s,e){return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),this.update(s,e)};Fv.prototype.clear=function(s,e,t,n){return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),this.renderTarget.clear(s,e,t,n)};Zo.crossOrigin=void 0;Zo.loadTexture=function(s,e,t,n){console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");const i=new Rb;i.setCrossOrigin(this.crossOrigin);const r=i.load(s,t,void 0,n);return e&&(r.mapping=e),r};Zo.loadTextureCube=function(s,e,t,n){console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");const i=new xI;i.setCrossOrigin(this.crossOrigin);const r=i.load(s,t,void 0,n);return e&&(r.mapping=e),r};Zo.loadCompressedTexture=function(){console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")};Zo.loadCompressedTextureCube=function(){console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")};typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:Cv}}));typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=Cv);/*!
fflate - fast JavaScript compression/decompression
<https://101arrowz.github.io/fflate>
Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
version 0.6.9
*/var px={},Jg=function(s){return URL.createObjectURL(new Blob([s],{type:"text/javascript"}))},kb=function(s){return new Worker(s)};try{URL.revokeObjectURL(Jg(""))}catch{Jg=function(e){return"data:application/javascript;charset=UTF-8,"+encodeURI(e)},kb=function(e){return new Worker(e,{type:"module"})}}var JI=function(s,e,t,n,i){var r=kb(px[e]||(px[e]=Jg(s)));return r.onerror=function(a){return i(a.error,null)},r.onmessage=function(a){return i(null,a.data)},r.postMessage(t,n),r},an=Uint8Array,Ai=Uint16Array,Ys=Uint32Array,Bc=new an([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),Oc=new an([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),Fu=new an([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),_b=function(s,e){for(var t=new Ai(31),n=0;n<31;++n)t[n]=e+=1<<s[n-1];for(var i=new Ys(t[30]),n=1;n<30;++n)for(var r=t[n];r<t[n+1];++r)i[r]=r-t[n]<<5|n;return[t,i]},Vb=_b(Bc,2),r0=Vb[0],ip=Vb[1];r0[28]=258,ip[258]=28;var Gb=_b(Oc,0),Hb=Gb[0],Kg=Gb[1],Uu=new Ai(32768);for(var Ln=0;Ln<32768;++Ln){var wa=(Ln&43690)>>>1|(Ln&21845)<<1;wa=(wa&52428)>>>2|(wa&13107)<<2,wa=(wa&61680)>>>4|(wa&3855)<<4,Uu[Ln]=((wa&65280)>>>8|(wa&255)<<8)>>>1}var Cr=function(s,e,t){for(var n=s.length,i=0,r=new Ai(e);i<n;++i)++r[s[i]-1];var a=new Ai(e);for(i=0;i<e;++i)a[i]=a[i-1]+r[i-1]<<1;var o;if(t){o=new Ai(1<<e);var l=15-e;for(i=0;i<n;++i)if(s[i])for(var c=i<<4|s[i],u=e-s[i],h=a[s[i]-1]++<<u,d=h|(1<<u)-1;h<=d;++h)o[Uu[h]>>>l]=c}else for(o=new Ai(n),i=0;i<n;++i)s[i]&&(o[i]=Uu[a[s[i]-1]++]>>>15-s[i]);return o},Zs=new an(288);for(var Ln=0;Ln<144;++Ln)Zs[Ln]=8;for(var Ln=144;Ln<256;++Ln)Zs[Ln]=9;for(var Ln=256;Ln<280;++Ln)Zs[Ln]=7;for(var Ln=280;Ln<288;++Ln)Zs[Ln]=8;var Sc=new an(32);for(var Ln=0;Ln<32;++Ln)Sc[Ln]=5;var Wb=Cr(Zs,9,0),qb=Cr(Zs,9,1),jb=Cr(Sc,5,0),Qb=Cr(Sc,5,1),yf=function(s){for(var e=s[0],t=1;t<s.length;++t)s[t]>e&&(e=s[t]);return e},br=function(s,e,t){var n=e/8|0;return(s[n]|s[n+1]<<8)>>(e&7)&t},xf=function(s,e){var t=e/8|0;return(s[t]|s[t+1]<<8|s[t+2]<<16)>>(e&7)},Rh=function(s){return(s/8|0)+(s&7&&1)},Rr=function(s,e,t){(e==null||e<0)&&(e=0),(t==null||t>s.length)&&(t=s.length);var n=new(s instanceof Ai?Ai:s instanceof Ys?Ys:an)(t-e);return n.set(s.subarray(e,t)),n},Ih=function(s,e,t){var n=s.length;if(!n||t&&!t.l&&n<5)return e||new an(0);var i=!e||t,r=!t||t.i;t||(t={}),e||(e=new an(n*3));var a=function(Y){var Ie=e.length;if(Y>Ie){var re=new an(Math.max(Ie*2,Y));re.set(e),e=re}},o=t.f||0,l=t.p||0,c=t.b||0,u=t.l,h=t.d,d=t.m,f=t.n,v=n*8;do{if(!u){t.f=o=br(s,l,1);var g=br(s,l+1,3);if(l+=3,g)if(g==1)u=qb,h=Qb,d=9,f=5;else if(g==2){var S=br(s,l,31)+257,b=br(s,l+10,15)+4,E=S+br(s,l+5,31)+1;l+=14;for(var C=new an(E),P=new an(19),M=0;M<b;++M)P[Fu[M]]=br(s,l+M*3,7);l+=b*3;for(var L=yf(P),z=(1<<L)-1,V=Cr(P,L,1),M=0;M<E;){var U=V[br(s,l,z)];l+=U&15;var m=U>>>4;if(m<16)C[M++]=m;else{var j=0,F=0;for(m==16?(F=3+br(s,l,3),l+=2,j=C[M-1]):m==17?(F=3+br(s,l,7),l+=3):m==18&&(F=11+br(s,l,127),l+=7);F--;)C[M++]=j}}var K=C.subarray(0,S),J=C.subarray(S);d=yf(K),f=yf(J),u=Cr(K,d,1),h=Cr(J,f,1)}else throw"invalid block type";else{var m=Rh(l)+4,x=s[m-4]|s[m-3]<<8,w=m+x;if(w>n){if(r)throw"unexpected EOF";break}i&&a(c+x),e.set(s.subarray(m,w),c),t.b=c+=x,t.p=l=w*8;continue}if(l>v){if(r)throw"unexpected EOF";break}}i&&a(c+131072);for(var se=(1<<d)-1,le=(1<<f)-1,q=l;;q=l){var j=u[xf(s,l)&se],te=j>>>4;if(l+=j&15,l>v){if(r)throw"unexpected EOF";break}if(!j)throw"invalid length/literal";if(te<256)e[c++]=te;else if(te==256){q=l,u=null;break}else{var H=te-254;if(te>264){var M=te-257,$=Bc[M];H=br(s,l,(1<<$)-1)+r0[M],l+=$}var ce=h[xf(s,l)&le],xe=ce>>>4;if(!ce)throw"invalid distance";l+=ce&15;var J=Hb[xe];if(xe>3){var $=Oc[xe];J+=xf(s,l)&(1<<$)-1,l+=$}if(l>v){if(r)throw"unexpected EOF";break}i&&a(c+131072);for(var pe=c+H;c<pe;c+=4)e[c]=e[c-J],e[c+1]=e[c+1-J],e[c+2]=e[c+2-J],e[c+3]=e[c+3-J];c=pe}}t.l=u,t.p=q,t.b=c,u&&(o=1,t.m=d,t.d=h,t.n=f)}while(!o);return c==e.length?e:Rr(e,0,c)},es=function(s,e,t){t<<=e&7;var n=e/8|0;s[n]|=t,s[n+1]|=t>>>8},Fl=function(s,e,t){t<<=e&7;var n=e/8|0;s[n]|=t,s[n+1]|=t>>>8,s[n+2]|=t>>>16},wf=function(s,e){for(var t=[],n=0;n<s.length;++n)s[n]&&t.push({s:n,f:s[n]});var i=t.length,r=t.slice();if(!i)return[Hs,0];if(i==1){var a=new an(t[0].s+1);return a[t[0].s]=1,[a,1]}t.sort(function(E,C){return E.f-C.f}),t.push({s:-1,f:25001});var o=t[0],l=t[1],c=0,u=1,h=2;for(t[0]={s:-1,f:o.f+l.f,l:o,r:l};u!=i-1;)o=t[t[c].f<t[h].f?c++:h++],l=t[c!=u&&t[c].f<t[h].f?c++:h++],t[u++]={s:-1,f:o.f+l.f,l:o,r:l};for(var d=r[0].s,n=1;n<i;++n)r[n].s>d&&(d=r[n].s);var f=new Ai(d+1),v=rp(t[u-1],f,0);if(v>e){var n=0,g=0,m=v-e,x=1<<m;for(r.sort(function(C,P){return f[P.s]-f[C.s]||C.f-P.f});n<i;++n){var w=r[n].s;if(f[w]>e)g+=x-(1<<v-f[w]),f[w]=e;else break}for(g>>>=m;g>0;){var S=r[n].s;f[S]<e?g-=1<<e-f[S]++-1:++n}for(;n>=0&&g;--n){var b=r[n].s;f[b]==e&&(--f[b],++g)}v=e}return[new an(f),v]},rp=function(s,e,t){return s.s==-1?Math.max(rp(s.l,e,t+1),rp(s.r,e,t+1)):e[s.s]=t},Yg=function(s){for(var e=s.length;e&&!s[--e];);for(var t=new Ai(++e),n=0,i=s[0],r=1,a=function(l){t[n++]=l},o=1;o<=e;++o)if(s[o]==i&&o!=e)++r;else{if(!i&&r>2){for(;r>138;r-=138)a(32754);r>2&&(a(r>10?r-11<<5|28690:r-3<<5|12305),r=0)}else if(r>3){for(a(i),--r;r>6;r-=6)a(8304);r>2&&(a(r-3<<5|8208),r=0)}for(;r--;)a(i);r=1,i=s[o]}return[t.subarray(0,n),e]},Ul=function(s,e){for(var t=0,n=0;n<e.length;++n)t+=s[n]*e[n];return t},Su=function(s,e,t){var n=t.length,i=Rh(e+2);s[i]=n&255,s[i+1]=n>>>8,s[i+2]=s[i]^255,s[i+3]=s[i+1]^255;for(var r=0;r<n;++r)s[i+r+4]=t[r];return(i+4+n)*8},Zg=function(s,e,t,n,i,r,a,o,l,c,u){es(e,u++,t),++i[256];for(var h=wf(i,15),d=h[0],f=h[1],v=wf(r,15),g=v[0],m=v[1],x=Yg(d),w=x[0],S=x[1],b=Yg(g),E=b[0],C=b[1],P=new Ai(19),M=0;M<w.length;++M)P[w[M]&31]++;for(var M=0;M<E.length;++M)P[E[M]&31]++;for(var L=wf(P,7),z=L[0],V=L[1],U=19;U>4&&!z[Fu[U-1]];--U);var j=c+5<<3,F=Ul(i,Zs)+Ul(r,Sc)+a,K=Ul(i,d)+Ul(r,g)+a+14+3*U+Ul(P,z)+(2*P[16]+3*P[17]+7*P[18]);if(j<=F&&j<=K)return Su(e,u,s.subarray(l,l+c));var J,se,le,q;if(es(e,u,1+(K<F)),u+=2,K<F){J=Cr(d,f,0),se=d,le=Cr(g,m,0),q=g;var te=Cr(z,V,0);es(e,u,S-257),es(e,u+5,C-1),es(e,u+10,U-4),u+=14;for(var M=0;M<U;++M)es(e,u+3*M,z[Fu[M]]);u+=3*U;for(var H=[w,E],$=0;$<2;++$)for(var ce=H[$],M=0;M<ce.length;++M){var xe=ce[M]&31;es(e,u,te[xe]),u+=z[xe],xe>15&&(es(e,u,ce[M]>>>5&127),u+=ce[M]>>>12)}}else J=Wb,se=Zs,le=jb,q=Sc;for(var M=0;M<o;++M)if(n[M]>255){var xe=n[M]>>>18&31;Fl(e,u,J[xe+257]),u+=se[xe+257],xe>7&&(es(e,u,n[M]>>>23&31),u+=Bc[xe]);var pe=n[M]&31;Fl(e,u,le[pe]),u+=q[pe],pe>3&&(Fl(e,u,n[M]>>>5&8191),u+=Oc[pe])}else Fl(e,u,J[n[M]]),u+=se[n[M]];return Fl(e,u,J[256]),u+se[256]},Xb=new Ys([65540,131080,131088,131104,262176,1048704,1048832,2114560,2117632]),Hs=new an(0),Jb=function(s,e,t,n,i,r){var a=s.length,o=new an(n+a+5*(1+Math.ceil(a/7e3))+i),l=o.subarray(n,o.length-i),c=0;if(!e||a<8)for(var u=0;u<=a;u+=65535){var h=u+65535;h<a?c=Su(l,c,s.subarray(u,h)):(l[u]=r,c=Su(l,c,s.subarray(u,a)))}else{for(var d=Xb[e-1],f=d>>>13,v=d&8191,g=(1<<t)-1,m=new Ai(32768),x=new Ai(g+1),w=Math.ceil(t/3),S=2*w,b=function(qe){return(s[qe]^s[qe+1]<<w^s[qe+2]<<S)&g},E=new Ys(25e3),C=new Ai(288),P=new Ai(32),M=0,L=0,u=0,z=0,V=0,U=0;u<a;++u){var j=b(u),F=u&32767,K=x[j];if(m[F]=K,x[j]=F,V<=u){var J=a-u;if((M>7e3||z>24576)&&J>423){c=Zg(s,l,0,E,C,P,L,z,U,u-U,c),z=M=L=0,U=u;for(var se=0;se<286;++se)C[se]=0;for(var se=0;se<30;++se)P[se]=0}var le=2,q=0,te=v,H=F-K&32767;if(J>2&&j==b(u-H))for(var $=Math.min(f,J)-1,ce=Math.min(32767,u),xe=Math.min(258,J);H<=ce&&--te&&F!=K;){if(s[u+le]==s[u+le-H]){for(var pe=0;pe<xe&&s[u+pe]==s[u+pe-H];++pe);if(pe>le){if(le=pe,q=H,pe>$)break;for(var Y=Math.min(H,pe-2),Ie=0,se=0;se<Y;++se){var re=u-H+se+32768&32767,oe=m[re],ye=re-oe+32768&32767;ye>Ie&&(Ie=ye,K=re)}}}F=K,K=m[F],H+=F-K+32768&32767}if(q){E[z++]=268435456|ip[le]<<18|Kg[q];var ke=ip[le]&31,X=Kg[q]&31;L+=Bc[ke]+Oc[X],++C[257+ke],++P[X],V=u+le,++M}else E[z++]=s[u],++C[s[u]]}}c=Zg(s,l,r,E,C,P,L,z,U,u-U,c),!r&&c&7&&(c=Su(l,c+1,Hs))}return Rr(o,0,n+Rh(c)+i)},Kb=function(){for(var s=new Ys(256),e=0;e<256;++e){for(var t=e,n=9;--n;)t=(t&1&&3988292384)^t>>>1;s[e]=t}return s}(),Nc=function(){var s=-1;return{p:function(e){for(var t=s,n=0;n<e.length;++n)t=Kb[t&255^e[n]]^t>>>8;s=t},d:function(){return~s}}},s0=function(){var s=1,e=0;return{p:function(t){for(var n=s,i=e,r=t.length,a=0;a!=r;){for(var o=Math.min(a+2655,r);a<o;++a)i+=n+=t[a];n=(n&65535)+15*(n>>16),i=(i&65535)+15*(i>>16)}s=n,e=i},d:function(){return s%=65521,e%=65521,(s&255)<<24|s>>>8<<16|(e&255)<<8|e>>>8}}},$o=function(s,e,t,n,i){return Jb(s,e.level==null?6:e.level,e.mem==null?Math.ceil(Math.max(8,Math.min(13,Math.log(s.length)))*1.5):12+e.mem,t,n,!i)},Ph=function(s,e){var t={};for(var n in s)t[n]=s[n];for(var n in e)t[n]=e[n];return t},mx=function(s,e,t){for(var n=s(),i=s.toString(),r=i.slice(i.indexOf("[")+1,i.lastIndexOf("]")).replace(/ /g,"").split(","),a=0;a<n.length;++a){var o=n[a],l=r[a];if(typeof o=="function"){e+=";"+l+"=";var c=o.toString();if(o.prototype)if(c.indexOf("[native code]")!=-1){var u=c.indexOf(" ",8)+1;e+=c.slice(u,c.indexOf("(",u))}else{e+=c;for(var h in o.prototype)e+=";"+l+".prototype."+h+"="+o.prototype[h].toString()}else e+=c}else t[l]=o}return[e,t]},Dd=[],KI=function(s){var e=[];for(var t in s)(s[t]instanceof an||s[t]instanceof Ai||s[t]instanceof Ys)&&e.push((s[t]=new s[t].constructor(s[t])).buffer);return e},Yb=function(s,e,t,n){var i;if(!Dd[t]){for(var r="",a={},o=s.length-1,l=0;l<o;++l)i=mx(s[l],r,a),r=i[0],a=i[1];Dd[t]=mx(s[o],r,a)}var c=Ph({},Dd[t][1]);return JI(Dd[t][0]+";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage="+e.toString()+"}",t,c,KI(c),n)},zc=function(){return[an,Ai,Ys,Bc,Oc,Fu,r0,Hb,qb,Qb,Uu,Cr,yf,br,xf,Rh,Rr,Ih,_c,Ka,a0]},Fc=function(){return[an,Ai,Ys,Bc,Oc,Fu,ip,Kg,Wb,Zs,jb,Sc,Uu,Xb,Hs,Cr,es,Fl,wf,rp,Yg,Ul,Su,Zg,Rh,Rr,Jb,$o,Dh,Ka]},Zb=function(){return[o0,c0,xn,Nc,Kb]},$b=function(){return[l0,n1]},e1=function(){return[u0,xn,s0]},t1=function(){return[i1]},Ka=function(s){return postMessage(s,[s.buffer])},a0=function(s){return s&&s.size&&new an(s.size)},Uc=function(s,e,t,n,i,r){var a=Yb(t,n,i,function(o,l){a.terminate(),r(o,l)});return a.postMessage([s,e],e.consume?[s.buffer]:[]),function(){a.terminate()}},Lr=function(s){return s.ondata=function(e,t){return postMessage([e,t],[e.buffer])},function(e){return s.push(e.data[0],e.data[1])}},kc=function(s,e,t,n,i){var r,a=Yb(s,n,i,function(o,l){o?(a.terminate(),e.ondata.call(e,o)):(l[1]&&a.terminate(),e.ondata.call(e,o,l[0],l[1]))});a.postMessage(t),e.push=function(o,l){if(r)throw"stream finished";if(!e.ondata)throw"no stream handler";a.postMessage([o,r=l],[o.buffer])},e.terminate=function(){a.terminate()}},Yi=function(s,e){return s[e]|s[e+1]<<8},Jn=function(s,e){return(s[e]|s[e+1]<<8|s[e+2]<<16|s[e+3]<<24)>>>0},Hm=function(s,e){return Jn(s,e)+Jn(s,e+4)*4294967296},xn=function(s,e,t){for(;t;++e)s[e]=t,t>>>=8},o0=function(s,e){var t=e.filename;if(s[0]=31,s[1]=139,s[2]=8,s[8]=e.level<2?4:e.level==9?2:0,s[9]=3,e.mtime!=0&&xn(s,4,Math.floor(new Date(e.mtime||Date.now())/1e3)),t){s[3]=8;for(var n=0;n<=t.length;++n)s[n+10]=t.charCodeAt(n)}},l0=function(s){if(s[0]!=31||s[1]!=139||s[2]!=8)throw"invalid gzip data";var e=s[3],t=10;e&4&&(t+=s[10]|(s[11]<<8)+2);for(var n=(e>>3&1)+(e>>4&1);n>0;n-=!s[t++]);return t+(e&2)},n1=function(s){var e=s.length;return(s[e-4]|s[e-3]<<8|s[e-2]<<16|s[e-1]<<24)>>>0},c0=function(s){return 10+(s.filename&&s.filename.length+1||0)},u0=function(s,e){var t=e.level,n=t==0?0:t<6?1:t==9?3:2;s[0]=120,s[1]=n<<6|(n?32-2*n:1)},i1=function(s){if((s[0]&15)!=8||s[0]>>>4>7||(s[0]<<8|s[1])%31)throw"invalid zlib data";if(s[1]&32)throw"invalid zlib data: preset dictionaries not supported"};function h0(s,e){return!e&&typeof s=="function"&&(e=s,s={}),this.ondata=e,s}var ls=function(){function s(e,t){!t&&typeof e=="function"&&(t=e,e={}),this.ondata=t,this.o=e||{}}return s.prototype.p=function(e,t){this.ondata($o(e,this.o,0,0,!t),t)},s.prototype.push=function(e,t){if(this.d)throw"stream finished";if(!this.ondata)throw"no stream handler";this.d=t,this.p(e,t||!1)},s}(),r1=function(){function s(e,t){kc([Fc,function(){return[Lr,ls]}],this,h0.call(this,e,t),function(n){var i=new ls(n.data);onmessage=Lr(i)},6)}return s}();function s1(s,e,t){if(t||(t=e,e={}),typeof t!="function")throw"no callback";return Uc(s,e,[Fc],function(n){return Ka(Dh(n.data[0],n.data[1]))},0,t)}function Dh(s,e){return $o(s,e||{},0,0)}var rr=function(){function s(e){this.s={},this.p=new an(0),this.ondata=e}return s.prototype.e=function(e){if(this.d)throw"stream finished";if(!this.ondata)throw"no stream handler";var t=this.p.length,n=new an(t+e.length);n.set(this.p),n.set(e,t),this.p=n},s.prototype.c=function(e){this.d=this.s.i=e||!1;var t=this.s.b,n=Ih(this.p,this.o,this.s);this.ondata(Rr(n,t,this.s.b),this.d),this.o=Rr(n,this.s.b-32768),this.s.b=this.o.length,this.p=Rr(this.p,this.s.p/8|0),this.s.p&=7},s.prototype.push=function(e,t){this.e(e),this.c(t)},s}(),d0=function(){function s(e){this.ondata=e,kc([zc,function(){return[Lr,rr]}],this,0,function(){var t=new rr;onmessage=Lr(t)},7)}return s}();function f0(s,e,t){if(t||(t=e,e={}),typeof t!="function")throw"no callback";return Uc(s,e,[zc],function(n){return Ka(_c(n.data[0],a0(n.data[1])))},1,t)}function _c(s,e){return Ih(s,e)}var sp=function(){function s(e,t){this.c=Nc(),this.l=0,this.v=1,ls.call(this,e,t)}return s.prototype.push=function(e,t){ls.prototype.push.call(this,e,t)},s.prototype.p=function(e,t){this.c.p(e),this.l+=e.length;var n=$o(e,this.o,this.v&&c0(this.o),t&&8,!t);this.v&&(o0(n,this.o),this.v=0),t&&(xn(n,n.length-8,this.c.d()),xn(n,n.length-4,this.l)),this.ondata(n,t)},s}(),gx=function(){function s(e,t){kc([Fc,Zb,function(){return[Lr,ls,sp]}],this,h0.call(this,e,t),function(n){var i=new sp(n.data);onmessage=Lr(i)},8)}return s}();function vx(s,e,t){if(t||(t=e,e={}),typeof t!="function")throw"no callback";return Uc(s,e,[Fc,Zb,function(){return[ap]}],function(n){return Ka(ap(n.data[0],n.data[1]))},2,t)}function ap(s,e){e||(e={});var t=Nc(),n=s.length;t.p(s);var i=$o(s,e,c0(e),8),r=i.length;return o0(i,e),xn(i,r-8,t.d()),xn(i,r-4,n),i}var op=function(){function s(e){this.v=1,rr.call(this,e)}return s.prototype.push=function(e,t){if(rr.prototype.e.call(this,e),this.v){var n=this.p.length>3?l0(this.p):4;if(n>=this.p.length&&!t)return;this.p=this.p.subarray(n),this.v=0}if(t){if(this.p.length<8)throw"invalid gzip stream";this.p=this.p.subarray(0,-8)}rr.prototype.c.call(this,t)},s}(),a1=function(){function s(e){this.ondata=e,kc([zc,$b,function(){return[Lr,rr,op]}],this,0,function(){var t=new op;onmessage=Lr(t)},9)}return s}();function o1(s,e,t){if(t||(t=e,e={}),typeof t!="function")throw"no callback";return Uc(s,e,[zc,$b,function(){return[lp]}],function(n){return Ka(lp(n.data[0]))},3,t)}function lp(s,e){return Ih(s.subarray(l0(s),-8),e||new an(n1(s)))}var $g=function(){function s(e,t){this.c=s0(),this.v=1,ls.call(this,e,t)}return s.prototype.push=function(e,t){ls.prototype.push.call(this,e,t)},s.prototype.p=function(e,t){this.c.p(e);var n=$o(e,this.o,this.v&&2,t&&4,!t);this.v&&(u0(n,this.o),this.v=0),t&&xn(n,n.length-4,this.c.d()),this.ondata(n,t)},s}(),YI=function(){function s(e,t){kc([Fc,e1,function(){return[Lr,ls,$g]}],this,h0.call(this,e,t),function(n){var i=new $g(n.data);onmessage=Lr(i)},10)}return s}();function ZI(s,e,t){if(t||(t=e,e={}),typeof t!="function")throw"no callback";return Uc(s,e,[Fc,e1,function(){return[ev]}],function(n){return Ka(ev(n.data[0],n.data[1]))},4,t)}function ev(s,e){e||(e={});var t=s0();t.p(s);var n=$o(s,e,2,4);return u0(n,e),xn(n,n.length-4,t.d()),n}var cp=function(){function s(e){this.v=1,rr.call(this,e)}return s.prototype.push=function(e,t){if(rr.prototype.e.call(this,e),this.v){if(this.p.length<2&&!t)return;this.p=this.p.subarray(2),this.v=0}if(t){if(this.p.length<4)throw"invalid zlib stream";this.p=this.p.subarray(0,-4)}rr.prototype.c.call(this,t)},s}(),l1=function(){function s(e){this.ondata=e,kc([zc,t1,function(){return[Lr,rr,cp]}],this,0,function(){var t=new cp;onmessage=Lr(t)},11)}return s}();function c1(s,e,t){if(t||(t=e,e={}),typeof t!="function")throw"no callback";return Uc(s,e,[zc,t1,function(){return[Oa]}],function(n){return Ka(Oa(n.data[0],a0(n.data[1])))},5,t)}function Oa(s,e){return Ih((i1(s),s.subarray(2,-4)),e)}var u1=function(){function s(e){this.G=op,this.I=rr,this.Z=cp,this.ondata=e}return s.prototype.push=function(e,t){if(!this.ondata)throw"no stream handler";if(this.s)this.s.push(e,t);else{if(this.p&&this.p.length){var n=new an(this.p.length+e.length);n.set(this.p),n.set(e,this.p.length)}else this.p=e;if(this.p.length>2){var i=this,r=function(){i.ondata.apply(i,arguments)};this.s=this.p[0]==31&&this.p[1]==139&&this.p[2]==8?new this.G(r):(this.p[0]&15)!=8||this.p[0]>>4>7||(this.p[0]<<8|this.p[1])%31?new this.I(r):new this.Z(r),this.s.push(this.p,t),this.p=null}}},s}(),$I=function(){function s(e){this.G=a1,this.I=d0,this.Z=l1,this.ondata=e}return s.prototype.push=function(e,t){u1.prototype.push.call(this,e,t)},s}();function e2(s,e,t){if(t||(t=e,e={}),typeof t!="function")throw"no callback";return s[0]==31&&s[1]==139&&s[2]==8?o1(s,e,t):(s[0]&15)!=8||s[0]>>4>7||(s[0]<<8|s[1])%31?f0(s,e,t):c1(s,e,t)}function t2(s,e){return s[0]==31&&s[1]==139&&s[2]==8?lp(s,e):(s[0]&15)!=8||s[0]>>4>7||(s[0]<<8|s[1])%31?_c(s,e):Oa(s,e)}var p0=function(s,e,t,n){for(var i in s){var r=s[i],a=e+i;r instanceof an?t[a]=[r,n]:Array.isArray(r)?t[a]=[r[0],Ph(n,r[1])]:p0(r,a+"/",t,n)}},yx=typeof TextEncoder<"u"&&new TextEncoder,tv=typeof TextDecoder<"u"&&new TextDecoder,h1=0;try{tv.decode(Hs,{stream:!0}),h1=1}catch{}var d1=function(s){for(var e="",t=0;;){var n=s[t++],i=(n>127)+(n>223)+(n>239);if(t+i>s.length)return[e,Rr(s,t-1)];i?i==3?(n=((n&15)<<18|(s[t++]&63)<<12|(s[t++]&63)<<6|s[t++]&63)-65536,e+=String.fromCharCode(55296|n>>10,56320|n&1023)):i&1?e+=String.fromCharCode((n&31)<<6|s[t++]&63):e+=String.fromCharCode((n&15)<<12|(s[t++]&63)<<6|s[t++]&63):e+=String.fromCharCode(n)}},n2=function(){function s(e){this.ondata=e,h1?this.t=new TextDecoder:this.p=Hs}return s.prototype.push=function(e,t){if(!this.ondata)throw"no callback";if(t=!!t,this.t){if(this.ondata(this.t.decode(e,{stream:!0}),t),t){if(this.t.decode().length)throw"invalid utf-8 data";this.t=null}return}if(!this.p)throw"stream finished";var n=new an(this.p.length+e.length);n.set(this.p),n.set(e,this.p.length);var i=d1(n),r=i[0],a=i[1];if(t){if(a.length)throw"invalid utf-8 data";this.p=null}else this.p=a;this.ondata(r,t)},s}(),i2=function(){function s(e){this.ondata=e}return s.prototype.push=function(e,t){if(!this.ondata)throw"no callback";if(this.d)throw"stream finished";this.ondata(qa(e),this.d=t||!1)},s}();function qa(s,e){if(e){for(var t=new an(s.length),n=0;n<s.length;++n)t[n]=s.charCodeAt(n);return t}if(yx)return yx.encode(s);for(var i=s.length,r=new an(s.length+(s.length>>1)),a=0,o=function(u){r[a++]=u},n=0;n<i;++n){if(a+5>r.length){var l=new an(a+8+(i-n<<1));l.set(r),r=l}var c=s.charCodeAt(n);c<128||e?o(c):c<2048?(o(192|c>>6),o(128|c&63)):c>55295&&c<57344?(c=65536+(c&1047552)|s.charCodeAt(++n)&1023,o(240|c>>18),o(128|c>>12&63),o(128|c>>6&63),o(128|c&63)):(o(224|c>>12),o(128|c>>6&63),o(128|c&63))}return Rr(r,0,a)}function m0(s,e){if(e){for(var t="",n=0;n<s.length;n+=16384)t+=String.fromCharCode.apply(null,s.subarray(n,n+16384));return t}else{if(tv)return tv.decode(s);var i=d1(s),r=i[0],a=i[1];if(a.length)throw"invalid utf-8 data";return r}}var f1=function(s){return s==1?3:s<6?2:s==9?1:0},p1=function(s,e){return e+30+Yi(s,e+26)+Yi(s,e+28)},m1=function(s,e,t){var n=Yi(s,e+28),i=m0(s.subarray(e+46,e+46+n),!(Yi(s,e+8)&2048)),r=e+46+n,a=Jn(s,e+20),o=t&&a==4294967295?g1(s,r):[a,Jn(s,e+24),Jn(s,e+42)],l=o[0],c=o[1],u=o[2];return[Yi(s,e+10),l,c,i,r+Yi(s,e+30)+Yi(s,e+32),u]},g1=function(s,e){for(;Yi(s,e)!=1;e+=4+Yi(s,e+2));return[Hm(s,e+12),Hm(s,e+4),Hm(s,e+20)]},ka=function(s){var e=0;if(s)for(var t in s){var n=s[t].length;if(n>65535)throw"extra field too long";e+=n+4}return e},bc=function(s,e,t,n,i,r,a,o){var l=n.length,c=t.extra,u=o&&o.length,h=ka(c);xn(s,e,a!=null?33639248:67324752),e+=4,a!=null&&(s[e++]=20,s[e++]=t.os),s[e]=20,e+=2,s[e++]=t.flag<<1|(r==null&&8),s[e++]=i&&8,s[e++]=t.compression&255,s[e++]=t.compression>>8;var d=new Date(t.mtime==null?Date.now():t.mtime),f=d.getFullYear()-1980;if(f<0||f>119)throw"date not in range 1980-2099";if(xn(s,e,f<<25|d.getMonth()+1<<21|d.getDate()<<16|d.getHours()<<11|d.getMinutes()<<5|d.getSeconds()>>>1),e+=4,r!=null&&(xn(s,e,t.crc),xn(s,e+4,r),xn(s,e+8,t.size)),xn(s,e+12,l),xn(s,e+14,h),e+=16,a!=null&&(xn(s,e,u),xn(s,e+6,t.attrs),xn(s,e+10,a),e+=14),s.set(n,e),e+=l,h)for(var v in c){var g=c[v],m=g.length;xn(s,e,+v),xn(s,e+2,m),s.set(g,e+4),e+=4+m}return u&&(s.set(o,e),e+=u),e},g0=function(s,e,t,n,i){xn(s,e,101010256),xn(s,e+8,t),xn(s,e+10,t),xn(s,e+12,n),xn(s,e+16,i)},ku=function(){function s(e){this.filename=e,this.c=Nc(),this.size=0,this.compression=0}return s.prototype.process=function(e,t){this.ondata(null,e,t)},s.prototype.push=function(e,t){if(!this.ondata)throw"no callback - add to ZIP archive before pushing";this.c.p(e),this.size+=e.length,t&&(this.crc=this.c.d()),this.process(e,t||!1)},s}(),r2=function(){function s(e,t){var n=this;t||(t={}),ku.call(this,e),this.d=new ls(t,function(i,r){n.ondata(null,i,r)}),this.compression=8,this.flag=f1(t.level)}return s.prototype.process=function(e,t){try{this.d.push(e,t)}catch(n){this.ondata(n,null,t)}},s.prototype.push=function(e,t){ku.prototype.push.call(this,e,t)},s}(),s2=function(){function s(e,t){var n=this;t||(t={}),ku.call(this,e),this.d=new r1(t,function(i,r,a){n.ondata(i,r,a)}),this.compression=8,this.flag=f1(t.level),this.terminate=this.d.terminate}return s.prototype.process=function(e,t){this.d.push(e,t)},s.prototype.push=function(e,t){ku.prototype.push.call(this,e,t)},s}(),a2=function(){function s(e){this.ondata=e,this.u=[],this.d=1}return s.prototype.add=function(e){var t=this;if(this.d&2)throw"stream finished";var n=qa(e.filename),i=n.length,r=e.comment,a=r&&qa(r),o=i!=e.filename.length||a&&r.length!=a.length,l=i+ka(e.extra)+30;if(i>65535)throw"filename too long";var c=new an(l);bc(c,0,e,n,o);var u=[c],h=function(){for(var m=0,x=u;m<x.length;m++){var w=x[m];t.ondata(null,w,!1)}u=[]},d=this.d;this.d=0;var f=this.u.length,v=Ph(e,{f:n,u:o,o:a,t:function(){e.terminate&&e.terminate()},r:function(){if(h(),d){var m=t.u[f+1];m?m.r():t.d=1}d=1}}),g=0;e.ondata=function(m,x,w){if(m)t.ondata(m,x,w),t.terminate();else if(g+=x.length,u.push(x),w){var S=new an(16);xn(S,0,134695760),xn(S,4,e.crc),xn(S,8,g),xn(S,12,e.size),u.push(S),v.c=g,v.b=l+g+16,v.crc=e.crc,v.size=e.size,d&&v.r(),d=1}else d&&h()},this.u.push(v)},s.prototype.end=function(){var e=this;if(this.d&2)throw this.d&1?"stream finishing":"stream finished";this.d?this.e():this.u.push({r:function(){e.d&1&&(e.u.splice(-1,1),e.e())},t:function(){}}),this.d=3},s.prototype.e=function(){for(var e=0,t=0,n=0,i=0,r=this.u;i<r.length;i++){var a=r[i];n+=46+a.f.length+ka(a.extra)+(a.o?a.o.length:0)}for(var o=new an(n+22),l=0,c=this.u;l<c.length;l++){var a=c[l];bc(o,e,a,a.f,a.u,a.c,t,a.o),e+=46+a.f.length+ka(a.extra)+(a.o?a.o.length:0),t+=a.b}g0(o,e,this.u.length,n,t),this.ondata(null,o,!0),this.d=2},s.prototype.terminate=function(){for(var e=0,t=this.u;e<t.length;e++){var n=t[e];n.t()}this.d=2},s}();function o2(s,e,t){if(t||(t=e,e={}),typeof t!="function")throw"no callback";var n={};p0(s,"",n,e);var i=Object.keys(n),r=i.length,a=0,o=0,l=r,c=new Array(r),u=[],h=function(){for(var g=0;g<u.length;++g)u[g]()},d=function(){var g=new an(o+22),m=a,x=o-a;o=0;for(var w=0;w<l;++w){var S=c[w];try{var b=S.c.length;bc(g,o,S,S.f,S.u,b);var E=30+S.f.length+ka(S.extra),C=o+E;g.set(S.c,C),bc(g,a,S,S.f,S.u,b,o,S.m),a+=16+E+(S.m?S.m.length:0),o=C+b}catch(P){return t(P,null)}}g0(g,a,c.length,x,m),t(null,g)};r||d();for(var f=function(g){var m=i[g],x=n[m],w=x[0],S=x[1],b=Nc(),E=w.length;b.p(w);var C=qa(m),P=C.length,M=S.comment,L=M&&qa(M),z=L&&L.length,V=ka(S.extra),U=S.level==0?0:8,j=function(F,K){if(F)h(),t(F,null);else{var J=K.length;c[g]=Ph(S,{size:E,crc:b.d(),c:K,f:C,m:L,u:P!=m.length||L&&M.length!=z,compression:U}),a+=30+P+V+J,o+=76+2*(P+V)+(z||0)+J,--r||d()}};if(P>65535&&j("filename too long",null),!U)j(null,w);else if(E<16e4)try{j(null,Dh(w,S))}catch(F){j(F,null)}else u.push(s1(w,S,j))},v=0;v<l;++v)f(v);return h}function l2(s,e){e||(e={});var t={},n=[];p0(s,"",t,e);var i=0,r=0;for(var a in t){var o=t[a],l=o[0],c=o[1],u=c.level==0?0:8,h=qa(a),d=h.length,f=c.comment,v=f&&qa(f),g=v&&v.length,m=ka(c.extra);if(d>65535)throw"filename too long";var x=u?Dh(l,c):l,w=x.length,S=Nc();S.p(l),n.push(Ph(c,{size:l.length,crc:S.d(),c:x,f:h,m:v,u:d!=a.length||v&&f.length!=g,o:i,compression:u})),i+=30+d+m+w,r+=76+2*(d+m)+(g||0)+w}for(var b=new an(r+22),E=i,C=r-i,P=0;P<n.length;++P){var h=n[P];bc(b,h.o,h,h.f,h.u,h.c.length);var M=30+h.f.length+ka(h.extra);b.set(h.c,h.o+M),bc(b,i,h,h.f,h.u,h.c.length,h.o,h.m),i+=16+M+(h.m?h.m.length:0)}return g0(b,i,n.length,C,E),b}var v1=function(){function s(){}return s.prototype.push=function(e,t){this.ondata(null,e,t)},s.compression=0,s}(),c2=function(){function s(){var e=this;this.i=new rr(function(t,n){e.ondata(null,t,n)})}return s.prototype.push=function(e,t){try{this.i.push(e,t)}catch(n){this.ondata(n,e,t)}},s.compression=8,s}(),u2=function(){function s(e,t){var n=this;t<32e4?this.i=new rr(function(i,r){n.ondata(null,i,r)}):(this.i=new d0(function(i,r,a){n.ondata(i,r,a)}),this.terminate=this.i.terminate)}return s.prototype.push=function(e,t){this.i.terminate&&(e=Rr(e,0)),this.i.push(e,t)},s.compression=8,s}(),h2=function(){function s(e){this.onfile=e,this.k=[],this.o={0:v1},this.p=Hs}return s.prototype.push=function(e,t){var n=this;if(!this.onfile)throw"no callback";if(!this.p)throw"stream finished";if(this.c>0){var i=Math.min(this.c,e.length),r=e.subarray(0,i);if(this.c-=i,this.d?this.d.push(r,!this.c):this.k[0].push(r),e=e.subarray(i),e.length)return this.push(e,t)}else{var a=0,o=0,l=void 0,c=void 0;this.p.length?e.length?(c=new an(this.p.length+e.length),c.set(this.p),c.set(e,this.p.length)):c=this.p:c=e;for(var u=c.length,h=this.c,d=h&&this.d,f=function(){var x,w=Jn(c,o);if(w==67324752){a=1,l=o,v.d=null,v.c=0;var S=Yi(c,o+6),b=Yi(c,o+8),E=S&2048,C=S&8,P=Yi(c,o+26),M=Yi(c,o+28);if(u>o+30+P+M){var L=[];v.k.unshift(L),a=2;var z=Jn(c,o+18),V=Jn(c,o+22),U=m0(c.subarray(o+30,o+=30+P),!E);z==4294967295?(x=C?[-2]:g1(c,o),z=x[0],V=x[1]):C&&(z=-1),o+=M,v.c=z;var j,F={name:U,compression:b,start:function(){if(!F.ondata)throw"no callback";if(!z)F.ondata(null,Hs,!0);else{var K=n.o[b];if(!K)throw"unknown compression type "+b;j=z<0?new K(U):new K(U,z,V),j.ondata=function(q,te,H){F.ondata(q,te,H)};for(var J=0,se=L;J<se.length;J++){var le=se[J];j.push(le,!1)}n.k[0]==L&&n.c?n.d=j:j.push(Hs,!0)}},terminate:function(){j&&j.terminate&&j.terminate()}};z>=0&&(F.size=z,F.originalSize=V),v.onfile(F)}return"break"}else if(h){if(w==134695760)return l=o+=12+(h==-2&&8),a=3,v.c=0,"break";if(w==33639248)return l=o-=4,a=3,v.c=0,"break"}},v=this;o<u-4;++o){var g=f();if(g==="break")break}if(this.p=Hs,h<0){var m=a?c.subarray(0,l-12-(h==-2&&8)-(Jn(c,l-16)==134695760&&4)):c.subarray(0,o);d?d.push(m,!!a):this.k[+(a==2)].push(m)}if(a&2)return this.push(c.subarray(o),t);this.p=c.subarray(o)}if(t){if(this.c)throw"invalid zip file";this.p=null}},s.prototype.register=function(e){this.o[e.compression]=e},s}();function d2(s,e){if(typeof e!="function")throw"no callback";for(var t=[],n=function(){for(var d=0;d<t.length;++d)t[d]()},i={},r=s.length-22;Jn(s,r)!=101010256;--r)if(!r||s.length-r>65558){e("invalid zip file",null);return}var a=Yi(s,r+8);a||e(null,{});var o=a,l=Jn(s,r+16),c=l==4294967295;if(c){if(r=Jn(s,r-12),Jn(s,r)!=101075792){e("invalid zip file",null);return}o=a=Jn(s,r+32),l=Jn(s,r+48)}for(var u=function(d){var f=m1(s,l,c),v=f[0],g=f[1],m=f[2],x=f[3],w=f[4],S=f[5],b=p1(s,S);l=w;var E=function(P,M){P?(n(),e(P,null)):(i[x]=M,--a||e(null,i))};if(!v)E(null,Rr(s,b,b+g));else if(v==8){var C=s.subarray(b,b+g);if(g<32e4)try{E(null,_c(C,new an(m)))}catch(P){E(P,null)}else t.push(f0(C,{size:m},E))}else E("unknown compression type "+v,null)},h=0;h<o;++h)u();return n}function f2(s){for(var e={},t=s.length-22;Jn(s,t)!=101010256;--t)if(!t||s.length-t>65558)throw"invalid zip file";var n=Yi(s,t+8);if(!n)return{};var i=Jn(s,t+16),r=i==4294967295;if(r){if(t=Jn(s,t-12),Jn(s,t)!=101075792)throw"invalid zip file";n=Jn(s,t+32),i=Jn(s,t+48)}for(var a=0;a<n;++a){var o=m1(s,i,r),l=o[0],c=o[1],u=o[2],h=o[3],d=o[4],f=o[5],v=p1(s,f);if(i=d,!l)e[h]=Rr(s,v,v+c);else if(l==8)e[h]=_c(s.subarray(v,v+c),new an(u));else throw"unknown compression type "+l}return e}const xx=Object.freeze(Object.defineProperty({__proto__:null,AsyncCompress:gx,AsyncDecompress:$I,AsyncDeflate:r1,AsyncGunzip:a1,AsyncGzip:gx,AsyncInflate:d0,AsyncUnzipInflate:u2,AsyncUnzlib:l1,AsyncZipDeflate:s2,AsyncZlib:YI,Compress:sp,DecodeUTF8:n2,Decompress:u1,Deflate:ls,EncodeUTF8:i2,Gunzip:op,Gzip:sp,Inflate:rr,Unzip:h2,UnzipInflate:c2,UnzipPassThrough:v1,Unzlib:cp,Zip:a2,ZipDeflate:r2,ZipPassThrough:ku,Zlib:$g,compress:vx,compressSync:ap,decompress:e2,decompressSync:t2,deflate:s1,deflateSync:Dh,gunzip:o1,gunzipSync:lp,gzip:vx,gzipSync:ap,inflate:f0,inflateSync:_c,strFromU8:m0,strToU8:qa,unzip:d2,unzipSync:f2,unzlib:c1,unzlibSync:Oa,zip:o2,zipSync:l2,zlib:ZI,zlibSync:ev},Symbol.toStringTag,{value:"Module"}));class p2 extends Cb{constructor(e){super(e),this.type=Zi}parse(e){const L=Math.pow(2.7182818,2.2);function z(I,N){let Q=0;for(let Re=0;Re<65536;++Re)(Re==0||I[Re>>3]&1<<(Re&7))&&(N[Q++]=Re);const de=Q-1;for(;Q<65536;)N[Q++]=0;return de}function V(I){for(let N=0;N<16384;N++)I[N]={},I[N].len=0,I[N].lit=0,I[N].p=null}const U={l:0,c:0,lc:0};function j(I,N,Q,de,Re){for(;Q<I;)N=N<<8|Fe(de,Re),Q+=8;Q-=I,U.l=N>>Q&(1<<I)-1,U.c=N,U.lc=Q}const F=new Array(59);function K(I){for(let Q=0;Q<=58;++Q)F[Q]=0;for(let Q=0;Q<65537;++Q)F[I[Q]]+=1;let N=0;for(let Q=58;Q>0;--Q){const de=N+F[Q]>>1;F[Q]=N,N=de}for(let Q=0;Q<65537;++Q){const de=I[Q];de>0&&(I[Q]=de|F[de]++<<6)}}function J(I,N,Q,de,Re,Pe){const it=N;let at=0,lt=0;for(;de<=Re;de++){if(it.value-N.value>Q)return!1;j(6,at,lt,I,it);const je=U.l;if(at=U.c,lt=U.lc,Pe[de]=je,je==63){if(it.value-N.value>Q)throw new Error("Something wrong with hufUnpackEncTable");j(8,at,lt,I,it);let Ze=U.l+6;if(at=U.c,lt=U.lc,de+Ze>Re+1)throw new Error("Something wrong with hufUnpackEncTable");for(;Ze--;)Pe[de++]=0;de--}else if(je>=59){let Ze=je-59+2;if(de+Ze>Re+1)throw new Error("Something wrong with hufUnpackEncTable");for(;Ze--;)Pe[de++]=0;de--}}K(Pe)}function se(I){return I&63}function le(I){return I>>6}function q(I,N,Q,de){for(;N<=Q;N++){const Re=le(I[N]),Pe=se(I[N]);if(Re>>Pe)throw new Error("Invalid table entry");if(Pe>14){const it=de[Re>>Pe-14];if(it.len)throw new Error("Invalid table entry");if(it.lit++,it.p){const at=it.p;it.p=new Array(it.lit);for(let lt=0;lt<it.lit-1;++lt)it.p[lt]=at[lt]}else it.p=new Array(1);it.p[it.lit-1]=N}else if(Pe){let it=0;for(let at=1<<14-Pe;at>0;at--){const lt=de[(Re<<14-Pe)+it];if(lt.len||lt.p)throw new Error("Invalid table entry");lt.len=Pe,lt.lit=N,it++}}}return!0}const te={c:0,lc:0};function H(I,N,Q,de){I=I<<8|Fe(Q,de),N+=8,te.c=I,te.lc=N}const $={c:0,lc:0};function ce(I,N,Q,de,Re,Pe,it,at,lt){if(I==N){de<8&&(H(Q,de,Re,Pe),Q=te.c,de=te.lc),de-=8;let je=Q>>de;if(je=new Uint8Array([je])[0],at.value+je>lt)return!1;const Ze=it[at.value-1];for(;je-- >0;)it[at.value++]=Ze}else if(at.value<lt)it[at.value++]=I;else return!1;$.c=Q,$.lc=de}function xe(I){return I&65535}function pe(I){const N=xe(I);return N>32767?N-65536:N}const Y={a:0,b:0};function Ie(I,N){const Q=pe(I),Re=pe(N),Pe=Q+(Re&1)+(Re>>1),it=Pe,at=Pe-Re;Y.a=it,Y.b=at}function re(I,N){const Q=xe(I),de=xe(N),Re=Q-(de>>1)&65535,Pe=de+Re-32768&65535;Y.a=Pe,Y.b=Re}function oe(I,N,Q,de,Re,Pe,it){const at=it<16384,lt=Q>Re?Re:Q;let je=1,Ze,Xe;for(;je<=lt;)je<<=1;for(je>>=1,Ze=je,je>>=1;je>=1;){Xe=0;const ct=Xe+Pe*(Re-Ze),Et=Pe*je,zt=Pe*Ze,At=de*je,Pt=de*Ze;let Dt,rn,on,yn;for(;Xe<=ct;Xe+=zt){let Rt=Xe;const Jt=Xe+de*(Q-Ze);for(;Rt<=Jt;Rt+=Pt){const Rn=Rt+At,xi=Rt+Et,kt=xi+At;at?(Ie(I[Rt+N],I[xi+N]),Dt=Y.a,on=Y.b,Ie(I[Rn+N],I[kt+N]),rn=Y.a,yn=Y.b,Ie(Dt,rn),I[Rt+N]=Y.a,I[Rn+N]=Y.b,Ie(on,yn),I[xi+N]=Y.a,I[kt+N]=Y.b):(re(I[Rt+N],I[xi+N]),Dt=Y.a,on=Y.b,re(I[Rn+N],I[kt+N]),rn=Y.a,yn=Y.b,re(Dt,rn),I[Rt+N]=Y.a,I[Rn+N]=Y.b,re(on,yn),I[xi+N]=Y.a,I[kt+N]=Y.b)}if(Q&je){const Rn=Rt+Et;at?Ie(I[Rt+N],I[Rn+N]):re(I[Rt+N],I[Rn+N]),Dt=Y.a,I[Rn+N]=Y.b,I[Rt+N]=Dt}}if(Re&je){let Rt=Xe;const Jt=Xe+de*(Q-Ze);for(;Rt<=Jt;Rt+=Pt){const Rn=Rt+At;at?Ie(I[Rt+N],I[Rn+N]):re(I[Rt+N],I[Rn+N]),Dt=Y.a,I[Rn+N]=Y.b,I[Rt+N]=Dt}}Ze=je,je>>=1}return Xe}function ye(I,N,Q,de,Re,Pe,it,at,lt){let je=0,Ze=0;const Xe=it,ct=Math.trunc(de.value+(Re+7)/8);for(;de.value<ct;)for(H(je,Ze,Q,de),je=te.c,Ze=te.lc;Ze>=14;){const zt=je>>Ze-14&16383,At=N[zt];if(At.len)Ze-=At.len,ce(At.lit,Pe,je,Ze,Q,de,at,lt,Xe),je=$.c,Ze=$.lc;else{if(!At.p)throw new Error("hufDecode issues");let Pt;for(Pt=0;Pt<At.lit;Pt++){const Dt=se(I[At.p[Pt]]);for(;Ze<Dt&&de.value<ct;)H(je,Ze,Q,de),je=te.c,Ze=te.lc;if(Ze>=Dt&&le(I[At.p[Pt]])==(je>>Ze-Dt&(1<<Dt)-1)){Ze-=Dt,ce(At.p[Pt],Pe,je,Ze,Q,de,at,lt,Xe),je=$.c,Ze=$.lc;break}}if(Pt==At.lit)throw new Error("hufDecode issues")}}const Et=8-Re&7;for(je>>=Et,Ze-=Et;Ze>0;){const zt=N[je<<14-Ze&16383];if(zt.len)Ze-=zt.len,ce(zt.lit,Pe,je,Ze,Q,de,at,lt,Xe),je=$.c,Ze=$.lc;else throw new Error("hufDecode issues")}return!0}function ke(I,N,Q,de,Re,Pe){const it={value:0},at=Q.value,lt=We(N,Q),je=We(N,Q);Q.value+=4;const Ze=We(N,Q);if(Q.value+=4,lt<0||lt>=65537||je<0||je>=65537)throw new Error("Something wrong with HUF_ENCSIZE");const Xe=new Array(65537),ct=new Array(16384);V(ct);const Et=de-(Q.value-at);if(J(I,Q,Et,lt,je,Xe),Ze>8*(de-(Q.value-at)))throw new Error("Something wrong with hufUncompress");q(Xe,lt,je,ct),ye(Xe,ct,I,Q,Ze,je,Pe,Re,it)}function X(I,N,Q){for(let de=0;de<Q;++de)N[de]=I[N[de]]}function Se(I){for(let N=1;N<I.length;N++){const Q=I[N-1]+I[N]-128;I[N]=Q}}function qe(I,N){let Q=0,de=Math.floor((I.length+1)/2),Re=0;const Pe=I.length-1;for(;!(Re>Pe||(N[Re++]=I[Q++],Re>Pe));)N[Re++]=I[de++]}function Qe(I){let N=I.byteLength;const Q=new Array;let de=0;const Re=new DataView(I);for(;N>0;){const Pe=Re.getInt8(de++);if(Pe<0){const it=-Pe;N-=it+1;for(let at=0;at<it;at++)Q.push(Re.getUint8(de++))}else{const it=Pe;N-=2;const at=Re.getUint8(de++);for(let lt=0;lt<it+1;lt++)Q.push(at)}}return Q}function Ke(I,N,Q,de,Re,Pe){let it=new DataView(Pe.buffer);const at=Q[I.idx[0]].width,lt=Q[I.idx[0]].height,je=3,Ze=Math.floor(at/8),Xe=Math.ceil(at/8),ct=Math.ceil(lt/8),Et=at-(Xe-1)*8,zt=lt-(ct-1)*8,At={value:0},Pt=new Array(je),Dt=new Array(je),rn=new Array(je),on=new Array(je),yn=new Array(je);for(let Jt=0;Jt<je;++Jt)yn[Jt]=N[I.idx[Jt]],Pt[Jt]=Jt<1?0:Pt[Jt-1]+Xe*ct,Dt[Jt]=new Float32Array(64),rn[Jt]=new Uint16Array(64),on[Jt]=new Uint16Array(Xe*64);for(let Jt=0;Jt<ct;++Jt){let Rn=8;Jt==ct-1&&(Rn=zt);let xi=8;for(let Kt=0;Kt<Xe;++Kt){Kt==Xe-1&&(xi=Et);for(let Yt=0;Yt<je;++Yt)rn[Yt].fill(0),rn[Yt][0]=Re[Pt[Yt]++],pt(At,de,rn[Yt]),He(rn[Yt],Dt[Yt]),ze(Dt[Yt]);rt(Dt);for(let Yt=0;Yt<je;++Yt)Le(Dt[Yt],on[Yt],Kt*64)}let kt=0;for(let Kt=0;Kt<je;++Kt){const Yt=Q[I.idx[Kt]].type;for(let ni=8*Jt;ni<8*Jt+Rn;++ni){kt=yn[Kt][ni];for(let sr=0;sr<Ze;++sr){const wi=sr*64+(ni&7)*8;it.setUint16(kt+0*2*Yt,on[Kt][wi+0],!0),it.setUint16(kt+1*2*Yt,on[Kt][wi+1],!0),it.setUint16(kt+2*2*Yt,on[Kt][wi+2],!0),it.setUint16(kt+3*2*Yt,on[Kt][wi+3],!0),it.setUint16(kt+4*2*Yt,on[Kt][wi+4],!0),it.setUint16(kt+5*2*Yt,on[Kt][wi+5],!0),it.setUint16(kt+6*2*Yt,on[Kt][wi+6],!0),it.setUint16(kt+7*2*Yt,on[Kt][wi+7],!0),kt+=8*2*Yt}}if(Ze!=Xe)for(let ni=8*Jt;ni<8*Jt+Rn;++ni){const sr=yn[Kt][ni]+8*Ze*2*Yt,wi=Ze*64+(ni&7)*8;for(let ii=0;ii<xi;++ii)it.setUint16(sr+ii*2*Yt,on[Kt][wi+ii],!0)}}}const Rt=new Uint16Array(at);it=new DataView(Pe.buffer);for(let Jt=0;Jt<je;++Jt){Q[I.idx[Jt]].decoded=!0;const Rn=Q[I.idx[Jt]].type;if(Q[Jt].type==2)for(let xi=0;xi<lt;++xi){const kt=yn[Jt][xi];for(let Kt=0;Kt<at;++Kt)Rt[Kt]=it.getUint16(kt+Kt*2*Rn,!0);for(let Kt=0;Kt<at;++Kt)it.setFloat32(kt+Kt*2*Rn,ae(Rt[Kt]),!0)}}}function pt(I,N,Q){let de,Re=1;for(;Re<64;)de=N[I.value],de==65280?Re=64:de>>8==255?Re+=de&255:(Q[Re]=de,Re++),I.value++}function He(I,N){N[0]=ae(I[0]),N[1]=ae(I[1]),N[2]=ae(I[5]),N[3]=ae(I[6]),N[4]=ae(I[14]),N[5]=ae(I[15]),N[6]=ae(I[27]),N[7]=ae(I[28]),N[8]=ae(I[2]),N[9]=ae(I[4]),N[10]=ae(I[7]),N[11]=ae(I[13]),N[12]=ae(I[16]),N[13]=ae(I[26]),N[14]=ae(I[29]),N[15]=ae(I[42]),N[16]=ae(I[3]),N[17]=ae(I[8]),N[18]=ae(I[12]),N[19]=ae(I[17]),N[20]=ae(I[25]),N[21]=ae(I[30]),N[22]=ae(I[41]),N[23]=ae(I[43]),N[24]=ae(I[9]),N[25]=ae(I[11]),N[26]=ae(I[18]),N[27]=ae(I[24]),N[28]=ae(I[31]),N[29]=ae(I[40]),N[30]=ae(I[44]),N[31]=ae(I[53]),N[32]=ae(I[10]),N[33]=ae(I[19]),N[34]=ae(I[23]),N[35]=ae(I[32]),N[36]=ae(I[39]),N[37]=ae(I[45]),N[38]=ae(I[52]),N[39]=ae(I[54]),N[40]=ae(I[20]),N[41]=ae(I[22]),N[42]=ae(I[33]),N[43]=ae(I[38]),N[44]=ae(I[46]),N[45]=ae(I[51]),N[46]=ae(I[55]),N[47]=ae(I[60]),N[48]=ae(I[21]),N[49]=ae(I[34]),N[50]=ae(I[37]),N[51]=ae(I[47]),N[52]=ae(I[50]),N[53]=ae(I[56]),N[54]=ae(I[59]),N[55]=ae(I[61]),N[56]=ae(I[35]),N[57]=ae(I[36]),N[58]=ae(I[48]),N[59]=ae(I[49]),N[60]=ae(I[57]),N[61]=ae(I[58]),N[62]=ae(I[62]),N[63]=ae(I[63])}function ze(I){const N=.5*Math.cos(.7853975),Q=.5*Math.cos(3.14159/16),de=.5*Math.cos(3.14159/8),Re=.5*Math.cos(3*3.14159/16),Pe=.5*Math.cos(5*3.14159/16),it=.5*Math.cos(3*3.14159/8),at=.5*Math.cos(7*3.14159/16),lt=new Array(4),je=new Array(4),Ze=new Array(4),Xe=new Array(4);for(let ct=0;ct<8;++ct){const Et=ct*8;lt[0]=de*I[Et+2],lt[1]=it*I[Et+2],lt[2]=de*I[Et+6],lt[3]=it*I[Et+6],je[0]=Q*I[Et+1]+Re*I[Et+3]+Pe*I[Et+5]+at*I[Et+7],je[1]=Re*I[Et+1]-at*I[Et+3]-Q*I[Et+5]-Pe*I[Et+7],je[2]=Pe*I[Et+1]-Q*I[Et+3]+at*I[Et+5]+Re*I[Et+7],je[3]=at*I[Et+1]-Pe*I[Et+3]+Re*I[Et+5]-Q*I[Et+7],Ze[0]=N*(I[Et+0]+I[Et+4]),Ze[3]=N*(I[Et+0]-I[Et+4]),Ze[1]=lt[0]+lt[3],Ze[2]=lt[1]-lt[2],Xe[0]=Ze[0]+Ze[1],Xe[1]=Ze[3]+Ze[2],Xe[2]=Ze[3]-Ze[2],Xe[3]=Ze[0]-Ze[1],I[Et+0]=Xe[0]+je[0],I[Et+1]=Xe[1]+je[1],I[Et+2]=Xe[2]+je[2],I[Et+3]=Xe[3]+je[3],I[Et+4]=Xe[3]-je[3],I[Et+5]=Xe[2]-je[2],I[Et+6]=Xe[1]-je[1],I[Et+7]=Xe[0]-je[0]}for(let ct=0;ct<8;++ct)lt[0]=de*I[16+ct],lt[1]=it*I[16+ct],lt[2]=de*I[48+ct],lt[3]=it*I[48+ct],je[0]=Q*I[8+ct]+Re*I[24+ct]+Pe*I[40+ct]+at*I[56+ct],je[1]=Re*I[8+ct]-at*I[24+ct]-Q*I[40+ct]-Pe*I[56+ct],je[2]=Pe*I[8+ct]-Q*I[24+ct]+at*I[40+ct]+Re*I[56+ct],je[3]=at*I[8+ct]-Pe*I[24+ct]+Re*I[40+ct]-Q*I[56+ct],Ze[0]=N*(I[ct]+I[32+ct]),Ze[3]=N*(I[ct]-I[32+ct]),Ze[1]=lt[0]+lt[3],Ze[2]=lt[1]-lt[2],Xe[0]=Ze[0]+Ze[1],Xe[1]=Ze[3]+Ze[2],Xe[2]=Ze[3]-Ze[2],Xe[3]=Ze[0]-Ze[1],I[0+ct]=Xe[0]+je[0],I[8+ct]=Xe[1]+je[1],I[16+ct]=Xe[2]+je[2],I[24+ct]=Xe[3]+je[3],I[32+ct]=Xe[3]-je[3],I[40+ct]=Xe[2]-je[2],I[48+ct]=Xe[1]-je[1],I[56+ct]=Xe[0]-je[0]}function rt(I){for(let N=0;N<64;++N){const Q=I[0][N],de=I[1][N],Re=I[2][N];I[0][N]=Q+1.5747*Re,I[1][N]=Q-.1873*de-.4682*Re,I[2][N]=Q+1.8556*de}}function Le(I,N,Q){for(let de=0;de<64;++de)N[Q+de]=ql.toHalfFloat(k(I[de]))}function k(I){return I<=1?Math.sign(I)*Math.pow(Math.abs(I),2.2):Math.sign(I)*Math.pow(L,Math.abs(I)-1)}function B(I){return new DataView(I.array.buffer,I.offset.value,I.size)}function G(I){const N=I.viewer.buffer.slice(I.offset.value,I.offset.value+I.size),Q=new Uint8Array(Qe(N)),de=new Uint8Array(Q.length);return Se(Q),qe(Q,de),new DataView(de.buffer)}function ne(I){const N=I.array.slice(I.offset.value,I.offset.value+I.size);typeof xx>"u"&&console.error("THREE.EXRLoader: External library fflate.min.js required.");const Q=Oa(N),de=new Uint8Array(Q.length);return Se(Q),qe(Q,de),new DataView(de.buffer)}function _e(I){const N=I.viewer,Q={value:I.offset.value},de=new Uint16Array(I.width*I.scanlineBlockSize*(I.channels*I.type)),Re=new Uint8Array(8192);let Pe=0;const it=new Array(I.channels);for(let zt=0;zt<I.channels;zt++)it[zt]={},it[zt].start=Pe,it[zt].end=it[zt].start,it[zt].nx=I.width,it[zt].ny=I.lines,it[zt].size=I.type,Pe+=it[zt].nx*it[zt].ny*it[zt].size;const at=Ot(N,Q),lt=Ot(N,Q);if(lt>=8192)throw new Error("Something is wrong with PIZ_COMPRESSION BITMAP_SIZE");if(at<=lt)for(let zt=0;zt<lt-at+1;zt++)Re[zt+at]=Oe(N,Q);const je=new Uint16Array(65536),Ze=z(Re,je),Xe=We(N,Q);ke(I.array,N,Q,Xe,de,Pe);for(let zt=0;zt<I.channels;++zt){const At=it[zt];for(let Pt=0;Pt<it[zt].size;++Pt)oe(de,At.start+Pt,At.nx,At.size,At.ny,At.nx*At.size,Ze)}X(je,de,Pe);let ct=0;const Et=new Uint8Array(de.buffer.byteLength);for(let zt=0;zt<I.lines;zt++)for(let At=0;At<I.channels;At++){const Pt=it[At],Dt=Pt.nx*Pt.size,rn=new Uint8Array(de.buffer,Pt.end*2,Dt*2);Et.set(rn,ct),ct+=Dt*2,Pt.end+=Dt}return new DataView(Et.buffer)}function Ye(I){const N=I.array.slice(I.offset.value,I.offset.value+I.size);typeof xx>"u"&&console.error("THREE.EXRLoader: External library fflate.min.js required.");const Q=Oa(N),de=I.lines*I.channels*I.width,Re=I.type==1?new Uint16Array(de):new Uint32Array(de);let Pe=0,it=0;const at=new Array(4);for(let lt=0;lt<I.lines;lt++)for(let je=0;je<I.channels;je++){let Ze=0;switch(I.type){case 1:at[0]=Pe,at[1]=at[0]+I.width,Pe=at[1]+I.width;for(let Xe=0;Xe<I.width;++Xe){const ct=Q[at[0]++]<<8|Q[at[1]++];Ze+=ct,Re[it]=Ze,it++}break;case 2:at[0]=Pe,at[1]=at[0]+I.width,at[2]=at[1]+I.width,Pe=at[2]+I.width;for(let Xe=0;Xe<I.width;++Xe){const ct=Q[at[0]++]<<24|Q[at[1]++]<<16|Q[at[2]++]<<8;Ze+=ct,Re[it]=Ze,it++}break}}return new DataView(Re.buffer)}function et(I){const N=I.viewer,Q={value:I.offset.value},de=new Uint8Array(I.width*I.lines*(I.channels*I.type*2)),Re={version:nt(N,Q),unknownUncompressedSize:nt(N,Q),unknownCompressedSize:nt(N,Q),acCompressedSize:nt(N,Q),dcCompressedSize:nt(N,Q),rleCompressedSize:nt(N,Q),rleUncompressedSize:nt(N,Q),rleRawSize:nt(N,Q),totalAcUncompressedCount:nt(N,Q),totalDcUncompressedCount:nt(N,Q),acCompression:nt(N,Q)};if(Re.version<2)throw new Error("EXRLoader.parse: "+Ce.compression+" version "+Re.version+" is unsupported");const Pe=new Array;let it=Ot(N,Q)-2;for(;it>0;){const At=we(N.buffer,Q),Pt=Oe(N,Q),Dt=Pt>>2&3,rn=(Pt>>4)-1,on=new Int8Array([rn])[0],yn=Oe(N,Q);Pe.push({name:At,index:on,type:yn,compression:Dt}),it-=At.length+3}const at=Ce.channels,lt=new Array(I.channels);for(let At=0;At<I.channels;++At){const Pt=lt[At]={},Dt=at[At];Pt.name=Dt.name,Pt.compression=0,Pt.decoded=!1,Pt.type=Dt.pixelType,Pt.pLinear=Dt.pLinear,Pt.width=I.width,Pt.height=I.lines}const je={idx:new Array(3)};for(let At=0;At<I.channels;++At){const Pt=lt[At];for(let Dt=0;Dt<Pe.length;++Dt){const rn=Pe[Dt];Pt.name==rn.name&&(Pt.compression=rn.compression,rn.index>=0&&(je.idx[rn.index]=At),Pt.offset=At)}}let Ze,Xe,ct;if(Re.acCompressedSize>0)switch(Re.acCompression){case 0:Ze=new Uint16Array(Re.totalAcUncompressedCount),ke(I.array,N,Q,Re.acCompressedSize,Ze,Re.totalAcUncompressedCount);break;case 1:const At=I.array.slice(Q.value,Q.value+Re.totalAcUncompressedCount),Pt=Oa(At);Ze=new Uint16Array(Pt.buffer),Q.value+=Re.totalAcUncompressedCount;break}if(Re.dcCompressedSize>0){const At={array:I.array,offset:Q,size:Re.dcCompressedSize};Xe=new Uint16Array(ne(At).buffer),Q.value+=Re.dcCompressedSize}if(Re.rleRawSize>0){const At=I.array.slice(Q.value,Q.value+Re.rleCompressedSize),Pt=Oa(At);ct=Qe(Pt.buffer),Q.value+=Re.rleCompressedSize}let Et=0;const zt=new Array(lt.length);for(let At=0;At<zt.length;++At)zt[At]=new Array;for(let At=0;At<I.lines;++At)for(let Pt=0;Pt<lt.length;++Pt)zt[Pt].push(Et),Et+=lt[Pt].width*I.type*2;Ke(je,zt,lt,Ze,Xe,de);for(let At=0;At<lt.length;++At){const Pt=lt[At];if(!Pt.decoded)switch(Pt.compression){case 2:let Dt=0,rn=0;for(let on=0;on<I.lines;++on){let yn=zt[At][Dt];for(let Rt=0;Rt<Pt.width;++Rt){for(let Jt=0;Jt<2*Pt.type;++Jt)de[yn++]=ct[rn+Jt*Pt.width*Pt.height];rn++}Dt++}break;case 1:default:throw new Error("EXRLoader.parse: unsupported channel compression")}}return new DataView(de.buffer)}function we(I,N){const Q=new Uint8Array(I);let de=0;for(;Q[N.value+de]!=0;)de+=1;const Re=new TextDecoder().decode(Q.slice(N.value,N.value+de));return N.value=N.value+de+1,Re}function bt(I,N,Q){const de=new TextDecoder().decode(new Uint8Array(I).slice(N.value,N.value+Q));return N.value=N.value+Q,de}function wt(I,N){const Q=ee(I,N),de=We(I,N);return[Q,de]}function tt(I,N){const Q=We(I,N),de=We(I,N);return[Q,de]}function ee(I,N){const Q=I.getInt32(N.value,!0);return N.value=N.value+4,Q}function We(I,N){const Q=I.getUint32(N.value,!0);return N.value=N.value+4,Q}function Fe(I,N){const Q=I[N.value];return N.value=N.value+1,Q}function Oe(I,N){const Q=I.getUint8(N.value);return N.value=N.value+1,Q}const nt=function(I,N){let Q;return"getBigInt64"in DataView.prototype?Q=Number(I.getBigInt64(N.value,!0)):Q=I.getUint32(N.value+4,!0)+Number(I.getUint32(N.value,!0)<<32),N.value+=8,Q};function st(I,N){const Q=I.getFloat32(N.value,!0);return N.value+=4,Q}function Je(I,N){return ql.toHalfFloat(st(I,N))}function ae(I){const N=(I&31744)>>10,Q=I&1023;return(I>>15?-1:1)*(N?N===31?Q?NaN:1/0:Math.pow(2,N-15)*(1+Q/1024):6103515625e-14*(Q/1024))}function Ot(I,N){const Q=I.getUint16(N.value,!0);return N.value+=2,Q}function _t(I,N){return ae(Ot(I,N))}function Bn(I,N,Q,de){const Re=Q.value,Pe=[];for(;Q.value<Re+de-1;){const it=we(N,Q),at=ee(I,Q),lt=Oe(I,Q);Q.value+=3;const je=ee(I,Q),Ze=ee(I,Q);Pe.push({name:it,pixelType:at,pLinear:lt,xSampling:je,ySampling:Ze})}return Q.value+=1,Pe}function On(I,N){const Q=st(I,N),de=st(I,N),Re=st(I,N),Pe=st(I,N),it=st(I,N),at=st(I,N),lt=st(I,N),je=st(I,N);return{redX:Q,redY:de,greenX:Re,greenY:Pe,blueX:it,blueY:at,whiteX:lt,whiteY:je}}function ei(I,N){const Q=["NO_COMPRESSION","RLE_COMPRESSION","ZIPS_COMPRESSION","ZIP_COMPRESSION","PIZ_COMPRESSION","PXR24_COMPRESSION","B44_COMPRESSION","B44A_COMPRESSION","DWAA_COMPRESSION","DWAB_COMPRESSION"],de=Oe(I,N);return Q[de]}function Vn(I,N){const Q=We(I,N),de=We(I,N),Re=We(I,N),Pe=We(I,N);return{xMin:Q,yMin:de,xMax:Re,yMax:Pe}}function En(I,N){const Q=["INCREASING_Y"],de=Oe(I,N);return Q[de]}function yi(I,N){const Q=st(I,N),de=st(I,N);return[Q,de]}function dn(I,N){const Q=st(I,N),de=st(I,N),Re=st(I,N);return[Q,de,Re]}function vn(I,N,Q,de,Re){if(de==="string"||de==="stringvector"||de==="iccProfile")return bt(N,Q,Re);if(de==="chlist")return Bn(I,N,Q,Re);if(de==="chromaticities")return On(I,Q);if(de==="compression")return ei(I,Q);if(de==="box2i")return Vn(I,Q);if(de==="lineOrder")return En(I,Q);if(de==="float")return st(I,Q);if(de==="v2f")return yi(I,Q);if(de==="v3f")return dn(I,Q);if(de==="int")return ee(I,Q);if(de==="rational")return wt(I,Q);if(de==="timecode")return tt(I,Q);if(de==="preview")return Q.value+=Re,"skipped";Q.value+=Re}function ti(I,N,Q){const de={};if(I.getUint32(0,!0)!=20000630)throw new Error("THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.");de.version=I.getUint8(4);const Re=I.getUint8(5);de.spec={singleTile:!!(Re&2),longName:!!(Re&4),deepFormat:!!(Re&8),multiPart:!!(Re&16)},Q.value=8;let Pe=!0;for(;Pe;){const it=we(N,Q);if(it==0)Pe=!1;else{const at=we(N,Q),lt=We(I,Q),je=vn(I,N,Q,at,lt);je===void 0?console.warn(`EXRLoader.parse: skipped unknown header attribute type '${at}'.`):de[it]=je}}if(Re!=0)throw console.error("EXRHeader:",de),new Error("THREE.EXRLoader: provided file is currently unsupported.");return de}function qt(I,N,Q,de,Re){const Pe={size:0,viewer:N,array:Q,offset:de,width:I.dataWindow.xMax-I.dataWindow.xMin+1,height:I.dataWindow.yMax-I.dataWindow.yMin+1,channels:I.channels.length,bytesPerLine:null,lines:null,inputSize:null,type:I.channels[0].pixelType,uncompress:null,getter:null,format:null,encoding:null};switch(I.compression){case"NO_COMPRESSION":Pe.lines=1,Pe.uncompress=B;break;case"RLE_COMPRESSION":Pe.lines=1,Pe.uncompress=G;break;case"ZIPS_COMPRESSION":Pe.lines=1,Pe.uncompress=ne;break;case"ZIP_COMPRESSION":Pe.lines=16,Pe.uncompress=ne;break;case"PIZ_COMPRESSION":Pe.lines=32,Pe.uncompress=_e;break;case"PXR24_COMPRESSION":Pe.lines=16,Pe.uncompress=Ye;break;case"DWAA_COMPRESSION":Pe.lines=32,Pe.uncompress=et;break;case"DWAB_COMPRESSION":Pe.lines=256,Pe.uncompress=et;break;default:throw new Error("EXRLoader.parse: "+I.compression+" is unsupported")}if(Pe.scanlineBlockSize=Pe.lines,Pe.type==1)switch(Re){case Oi:Pe.getter=_t,Pe.inputSize=2;break;case Zi:Pe.getter=Ot,Pe.inputSize=2;break}else if(Pe.type==2)switch(Re){case Oi:Pe.getter=st,Pe.inputSize=4;break;case Zi:Pe.getter=Je,Pe.inputSize=4}else throw new Error("EXRLoader.parse: unsupported pixelType "+Pe.type+" for "+I.compression+".");Pe.blockCount=(I.dataWindow.yMax+1)/Pe.scanlineBlockSize;for(let at=0;at<Pe.blockCount;at++)nt(N,de);Pe.outputChannels=Pe.channels==3?4:Pe.channels;const it=Pe.width*Pe.height*Pe.outputChannels;switch(Re){case Oi:Pe.byteArray=new Float32Array(it),Pe.channels<Pe.outputChannels&&Pe.byteArray.fill(1,0,it);break;case Zi:Pe.byteArray=new Uint16Array(it),Pe.channels<Pe.outputChannels&&Pe.byteArray.fill(15360,0,it);break;default:console.error("THREE.EXRLoader: unsupported type: ",Re);break}return Pe.bytesPerLine=Pe.width*Pe.inputSize*Pe.channels,Pe.outputChannels==4?(Pe.format=qi,Pe.encoding=Ir):(Pe.format=Iv,Pe.encoding=Ir),Pe}const _=new DataView(e),Ae=new Uint8Array(e),Be={value:0},Ce=ti(_,e,Be),Ee=qt(Ce,_,Ae,Be,this.type),Ct={value:0},Nt={R:0,G:1,B:2,A:3,Y:0};for(let I=0;I<Ee.height/Ee.scanlineBlockSize;I++){const N=We(_,Be);Ee.size=We(_,Be),Ee.lines=N+Ee.scanlineBlockSize>Ee.height?Ee.height-N:Ee.scanlineBlockSize;const de=Ee.size<Ee.lines*Ee.bytesPerLine?Ee.uncompress(Ee):B(Ee);Be.value+=Ee.size;for(let Re=0;Re<Ee.scanlineBlockSize;Re++){const Pe=Re+I*Ee.scanlineBlockSize;if(Pe>=Ee.height)break;for(let it=0;it<Ee.channels;it++){const at=Nt[Ce.channels[it].name];for(let lt=0;lt<Ee.width;lt++){Ct.value=(Re*(Ee.channels*Ee.width)+it*Ee.width+lt)*Ee.inputSize;const je=(Ee.height-1-Pe)*(Ee.width*Ee.outputChannels)+lt*Ee.outputChannels+at;Ee.byteArray[je]=Ee.getter(de,Ct)}}}}return{header:Ce,width:Ee.width,height:Ee.height,data:Ee.byteArray,format:Ee.format,encoding:Ee.encoding,type:this.type}}setDataType(e){return this.type=e,this}load(e,t,n,i){function r(a,o){a.encoding=o.encoding,a.minFilter=cn,a.magFilter=cn,a.generateMipmaps=!1,a.flipY=!1,t&&t(a,o)}return super.load(e,r,n,i)}}class m2 extends Cb{constructor(e){super(e),this.type=Zi}parse(e){const o=function(S,b){switch(S){case 1:console.error("THREE.RGBELoader Read Error: "+(b||""));break;case 2:console.error("THREE.RGBELoader Write Error: "+(b||""));break;case 3:console.error("THREE.RGBELoader Bad File Format: "+(b||""));break;default:case 4:console.error("THREE.RGBELoader: Error: "+(b||""))}return-1},h=`
`,d=function(S,b,E){b=b||1024;let P=S.pos,M=-1,L=0,z="",V=String.fromCharCode.apply(null,new Uint16Array(S.subarray(P,P+128)));for(;0>(M=V.indexOf(h))&&L<b&&P<S.byteLength;)z+=V,L+=V.length,P+=128,V+=String.fromCharCode.apply(null,new Uint16Array(S.subarray(P,P+128)));return-1<M?(S.pos+=L+M+1,z+V.slice(0,M)):!1},f=function(S){const b=/^#\?(\S+)/,E=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,C=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,P=/^\s*FORMAT=(\S+)\s*$/,M=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,L={valid:0,string:"",comments:"",programtype:"RGBE",format:"",gamma:1,exposure:1,width:0,height:0};let z,V;if(S.pos>=S.byteLength||!(z=d(S)))return o(1,"no header found");if(!(V=z.match(b)))return o(3,"bad initial token");for(L.valid|=1,L.programtype=V[1],L.string+=z+`
`;z=d(S),z!==!1;){if(L.string+=z+`
`,z.charAt(0)==="#"){L.comments+=z+`
`;continue}if((V=z.match(E))&&(L.gamma=parseFloat(V[1])),(V=z.match(C))&&(L.exposure=parseFloat(V[1])),(V=z.match(P))&&(L.valid|=2,L.format=V[1]),(V=z.match(M))&&(L.valid|=4,L.height=parseInt(V[1],10),L.width=parseInt(V[2],10)),L.valid&2&&L.valid&4)break}return L.valid&2?L.valid&4?L:o(3,"missing image size specifier"):o(3,"missing format specifier")},v=function(S,b,E){const C=b;if(C<8||C>32767||S[0]!==2||S[1]!==2||S[2]&128)return new Uint8Array(S);if(C!==(S[2]<<8|S[3]))return o(3,"wrong scanline width");const P=new Uint8Array(4*b*E);if(!P.length)return o(4,"unable to allocate buffer space");let M=0,L=0;const z=4*C,V=new Uint8Array(4),U=new Uint8Array(z);let j=E;for(;j>0&&L<S.byteLength;){if(L+4>S.byteLength)return o(1);if(V[0]=S[L++],V[1]=S[L++],V[2]=S[L++],V[3]=S[L++],V[0]!=2||V[1]!=2||(V[2]<<8|V[3])!=C)return o(3,"bad rgbe scanline format");let F=0,K;for(;F<z&&L<S.byteLength;){K=S[L++];const se=K>128;if(se&&(K-=128),K===0||F+K>z)return o(3,"bad scanline data");if(se){const le=S[L++];for(let q=0;q<K;q++)U[F++]=le}else U.set(S.subarray(L,L+K),F),F+=K,L+=K}const J=C;for(let se=0;se<J;se++){let le=0;P[M]=U[se+le],le+=C,P[M+1]=U[se+le],le+=C,P[M+2]=U[se+le],le+=C,P[M+3]=U[se+le],M+=4}j--}return P},g=function(S,b,E,C){const P=S[b+3],M=Math.pow(2,P-128)/255;E[C+0]=S[b+0]*M,E[C+1]=S[b+1]*M,E[C+2]=S[b+2]*M,E[C+3]=1},m=function(S,b,E,C){const P=S[b+3],M=Math.pow(2,P-128)/255;E[C+0]=ql.toHalfFloat(Math.min(S[b+0]*M,65504)),E[C+1]=ql.toHalfFloat(Math.min(S[b+1]*M,65504)),E[C+2]=ql.toHalfFloat(Math.min(S[b+2]*M,65504)),E[C+3]=ql.toHalfFloat(1)},x=new Uint8Array(e);x.pos=0;const w=f(x);if(w!==-1){const S=w.width,b=w.height,E=v(x.subarray(x.pos),S,b);if(E!==-1){let C,P,M,L;switch(this.type){case Oi:L=E.length/4;const z=new Float32Array(L*4);for(let U=0;U<L;U++)g(E,U*4,z,U*4);C=z,M=Oi;break;case Zi:L=E.length/4;const V=new Uint16Array(L*4);for(let U=0;U<L;U++)m(E,U*4,V,U*4);C=V,M=Zi;break;default:console.error("THREE.RGBELoader: unsupported type: ",this.type);break}return{width:S,height:b,data:C,header:w.string,gamma:w.gamma,exposure:w.exposure,format:P,type:M}}}return null}setDataType(e){return this.type=e,this}load(e,t,n,i){function r(a,o){switch(a.type){case Oi:a.encoding=Ir,a.minFilter=cn,a.magFilter=cn,a.generateMipmaps=!1,a.flipY=!0;break;case Zi:a.encoding=Ir,a.minFilter=cn,a.magFilter=cn,a.generateMipmaps=!1,a.flipY=!0;break}t&&t(a,o)}return super.load(e,r,n,i)}}class g2 extends ds{constructor(e){super(e)}load(e,t,n,i){const r=this,a=new Yv(this.manager);a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(r.withCredentials),a.load(e,function(o){let l;try{l=JSON.parse(o)}catch{console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."),l=JSON.parse(o.substring(65,o.length-2))}const c=r.parse(l);t&&t(c)},n,i)}parse(e){return new y1(e)}}class y1{constructor(e){this.type="Font",this.data=e}generateShapes(e,t=100){const n=[],i=v2(e,t,this.data);for(let r=0,a=i.length;r<a;r++)Array.prototype.push.apply(n,i[r].toShapes());return n}}function v2(s,e,t){const n=Array.from(s),i=e/t.resolution,r=(t.boundingBox.yMax-t.boundingBox.yMin+t.underlineThickness)*i,a=[];let o=0,l=0;for(let c=0;c<n.length;c++){const u=n[c];if(u===`
`)o=0,l-=r;else{const h=y2(u,i,o,l,t);o+=h.offsetX,a.push(h.path)}}return a}function y2(s,e,t,n,i){const r=i.glyphs[s]||i.glyphs["?"];if(!r){console.error('THREE.Font: character "'+s+'" does not exists in font family '+i.familyName+".");return}const a=new XI;let o,l,c,u,h,d,f,v;if(r.o){const g=r._cachedOutline||(r._cachedOutline=r.o.split(" "));for(let m=0,x=g.length;m<x;)switch(g[m++]){case"m":o=g[m++]*e+t,l=g[m++]*e+n,a.moveTo(o,l);break;case"l":o=g[m++]*e+t,l=g[m++]*e+n,a.lineTo(o,l);break;case"q":c=g[m++]*e+t,u=g[m++]*e+n,h=g[m++]*e+t,d=g[m++]*e+n,a.quadraticCurveTo(h,d,c,u);break;case"b":c=g[m++]*e+t,u=g[m++]*e+n,h=g[m++]*e+t,d=g[m++]*e+n,f=g[m++]*e+t,v=g[m++]*e+n,a.bezierCurveTo(h,d,f,v,c,u);break}}return{offsetX:r.ha*e,path:a}}y1.prototype.isFont=!0;var mr=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function v0(s){return s&&s.__esModule&&Object.prototype.hasOwnProperty.call(s,"default")?s.default:s}var Sf={exports:{}};/*!
 * js-logger - http://github.com/jonnyreeves/js-logger
 * Jonny Reeves, http://jonnyreeves.co.uk/
 * js-logger may be freely distributed under the MIT license.
 */var x2=Sf.exports,wx;function w2(){return wx||(wx=1,function(s){(function(e){var t={};t.VERSION="1.6.1";var n,i={},r=function(u,h){return function(){return h.apply(u,arguments)}},a=function(){var u=arguments,h=u[0],d,f;for(f=1;f<u.length;f++)for(d in u[f])!(d in h)&&u[f].hasOwnProperty(d)&&(h[d]=u[f][d]);return h},o=function(u,h){return{value:u,name:h}};t.TRACE=o(1,"TRACE"),t.DEBUG=o(2,"DEBUG"),t.INFO=o(3,"INFO"),t.TIME=o(4,"TIME"),t.WARN=o(5,"WARN"),t.ERROR=o(8,"ERROR"),t.OFF=o(99,"OFF");var l=function(u){this.context=u,this.setLevel(u.filterLevel),this.log=this.info};l.prototype={setLevel:function(u){u&&"value"in u&&(this.context.filterLevel=u)},getLevel:function(){return this.context.filterLevel},enabledFor:function(u){var h=this.context.filterLevel;return u.value>=h.value},trace:function(){this.invoke(t.TRACE,arguments)},debug:function(){this.invoke(t.DEBUG,arguments)},info:function(){this.invoke(t.INFO,arguments)},warn:function(){this.invoke(t.WARN,arguments)},error:function(){this.invoke(t.ERROR,arguments)},time:function(u){typeof u=="string"&&u.length>0&&this.invoke(t.TIME,[u,"start"])},timeEnd:function(u){typeof u=="string"&&u.length>0&&this.invoke(t.TIME,[u,"end"])},invoke:function(u,h){n&&this.enabledFor(u)&&n(h,a({level:u},this.context))}};var c=new l({filterLevel:t.OFF});(function(){var u=t;u.enabledFor=r(c,c.enabledFor),u.trace=r(c,c.trace),u.debug=r(c,c.debug),u.time=r(c,c.time),u.timeEnd=r(c,c.timeEnd),u.info=r(c,c.info),u.warn=r(c,c.warn),u.error=r(c,c.error),u.log=u.info})(),t.setHandler=function(u){n=u},t.setLevel=function(u){c.setLevel(u);for(var h in i)i.hasOwnProperty(h)&&i[h].setLevel(u)},t.getLevel=function(){return c.getLevel()},t.get=function(u){return i[u]||(i[u]=new l(a({name:u},c.context)))},t.createDefaultHandler=function(u){u=u||{},u.formatter=u.formatter||function(v,g){g.name&&v.unshift("["+g.name+"]")};var h={},d=function(f,v){Function.prototype.apply.call(f,console,v)};return typeof console>"u"?function(){}:function(f,v){f=Array.prototype.slice.call(f);var g=console.log,m;v.level===t.TIME?(m=(v.name?"["+v.name+"] ":"")+f[0],f[1]==="start"?console.time?console.time(m):h[m]=new Date().getTime():console.timeEnd?console.timeEnd(m):d(g,[m+": "+(new Date().getTime()-h[m])+"ms"])):(v.level===t.WARN&&console.warn?g=console.warn:v.level===t.ERROR&&console.error?g=console.error:v.level===t.INFO&&console.info?g=console.info:v.level===t.DEBUG&&console.debug?g=console.debug:v.level===t.TRACE&&console.trace&&(g=console.trace),u.formatter(f,v),d(g,f))}},t.useDefaults=function(u){t.setLevel(u&&u.defaultLevel||t.DEBUG),t.setHandler(t.createDefaultHandler(u))},t.setDefaults=t.useDefaults,s.exports?s.exports=t:(t._prevLogger=e.Logger,t.noConflict=function(){return e.Logger=t._prevLogger,t},e.Logger=t)})(x2)}(Sf)),Sf.exports}var S2=w2();const Wm=v0(S2);var x1=typeof global=="object"&&global&&global.Object===Object&&global,b2=typeof self=="object"&&self&&self.Object===Object&&self,ia=x1||b2||Function("return this")(),ja=ia.Symbol,w1=Object.prototype,A2=w1.hasOwnProperty,T2=w1.toString,ru=ja?ja.toStringTag:void 0;function E2(s){var e=A2.call(s,ru),t=s[ru];try{s[ru]=void 0;var n=!0}catch{}var i=T2.call(s);return n&&(e?s[ru]=t:delete s[ru]),i}var M2=Object.prototype,C2=M2.toString;function R2(s){return C2.call(s)}var I2="[object Null]",P2="[object Undefined]",Sx=ja?ja.toStringTag:void 0;function Vc(s){return s==null?s===void 0?P2:I2:Sx&&Sx in Object(s)?E2(s):R2(s)}function Ac(s){return s!=null&&typeof s=="object"}var D2="[object Symbol]";function y0(s){return typeof s=="symbol"||Ac(s)&&Vc(s)==D2}function L2(s,e){for(var t=-1,n=s==null?0:s.length,i=Array(n);++t<n;)i[t]=e(s[t],t,s);return i}var $s=Array.isArray,bx=ja?ja.prototype:void 0,Ax=bx?bx.toString:void 0;function S1(s){if(typeof s=="string")return s;if($s(s))return L2(s,S1)+"";if(y0(s))return Ax?Ax.call(s):"";var e=s+"";return e=="0"&&1/s==-1/0?"-0":e}function x0(s){var e=typeof s;return s!=null&&(e=="object"||e=="function")}function B2(s){return s}var O2="[object AsyncFunction]",N2="[object Function]",z2="[object GeneratorFunction]",F2="[object Proxy]";function b1(s){if(!x0(s))return!1;var e=Vc(s);return e==N2||e==z2||e==O2||e==F2}var qm=ia["__core-js_shared__"],Tx=function(){var s=/[^.]+$/.exec(qm&&qm.keys&&qm.keys.IE_PROTO||"");return s?"Symbol(src)_1."+s:""}();function U2(s){return!!Tx&&Tx in s}var k2=Function.prototype,_2=k2.toString;function el(s){if(s!=null){try{return _2.call(s)}catch{}try{return s+""}catch{}}return""}var V2=/[\\^$.*+?()[\]{}|]/g,G2=/^\[object .+?Constructor\]$/,H2=Function.prototype,W2=Object.prototype,q2=H2.toString,j2=W2.hasOwnProperty,Q2=RegExp("^"+q2.call(j2).replace(V2,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");function X2(s){if(!x0(s)||U2(s))return!1;var e=b1(s)?Q2:G2;return e.test(el(s))}function J2(s,e){return s==null?void 0:s[e]}function tl(s,e){var t=J2(s,e);return X2(t)?t:void 0}var nv=tl(ia,"WeakMap");function K2(){}var Ex=function(){try{var s=tl(Object,"defineProperty");return s({},"",{}),s}catch{}}();function Y2(s,e,t,n){for(var i=s.length,r=t+-1;++r<i;)if(e(s[r],r,s))return r;return-1}function Z2(s){return s!==s}function $2(s,e,t){for(var n=t-1,i=s.length;++n<i;)if(s[n]===e)return n;return-1}function eP(s,e,t){return e===e?$2(s,e,t):Y2(s,Z2,t)}function tP(s,e){var t=s==null?0:s.length;return!!t&&eP(s,e,0)>-1}var nP=9007199254740991,iP=/^(?:0|[1-9]\d*)$/;function A1(s,e){var t=typeof s;return e=e??nP,!!e&&(t=="number"||t!="symbol"&&iP.test(s))&&s>-1&&s%1==0&&s<e}function rP(s,e,t){e=="__proto__"&&Ex?Ex(s,e,{configurable:!0,enumerable:!0,value:t,writable:!0}):s[e]=t}function T1(s,e){return s===e||s!==s&&e!==e}var sP=9007199254740991;function w0(s){return typeof s=="number"&&s>-1&&s%1==0&&s<=sP}function aP(s){return s!=null&&w0(s.length)&&!b1(s)}var oP=Object.prototype;function lP(s){var e=s&&s.constructor,t=typeof e=="function"&&e.prototype||oP;return s===t}function cP(s,e){for(var t=-1,n=Array(s);++t<s;)n[t]=e(t);return n}var uP="[object Arguments]";function Mx(s){return Ac(s)&&Vc(s)==uP}var E1=Object.prototype,hP=E1.hasOwnProperty,dP=E1.propertyIsEnumerable,M1=Mx(function(){return arguments}())?Mx:function(s){return Ac(s)&&hP.call(s,"callee")&&!dP.call(s,"callee")};function fP(){return!1}var C1=typeof Ws=="object"&&Ws&&!Ws.nodeType&&Ws,Cx=C1&&typeof qs=="object"&&qs&&!qs.nodeType&&qs,pP=Cx&&Cx.exports===C1,Rx=pP?ia.Buffer:void 0,mP=Rx?Rx.isBuffer:void 0,iv=mP||fP,gP="[object Arguments]",vP="[object Array]",yP="[object Boolean]",xP="[object Date]",wP="[object Error]",SP="[object Function]",bP="[object Map]",AP="[object Number]",TP="[object Object]",EP="[object RegExp]",MP="[object Set]",CP="[object String]",RP="[object WeakMap]",IP="[object ArrayBuffer]",PP="[object DataView]",DP="[object Float32Array]",LP="[object Float64Array]",BP="[object Int8Array]",OP="[object Int16Array]",NP="[object Int32Array]",zP="[object Uint8Array]",FP="[object Uint8ClampedArray]",UP="[object Uint16Array]",kP="[object Uint32Array]",Dn={};Dn[DP]=Dn[LP]=Dn[BP]=Dn[OP]=Dn[NP]=Dn[zP]=Dn[FP]=Dn[UP]=Dn[kP]=!0;Dn[gP]=Dn[vP]=Dn[IP]=Dn[yP]=Dn[PP]=Dn[xP]=Dn[wP]=Dn[SP]=Dn[bP]=Dn[AP]=Dn[TP]=Dn[EP]=Dn[MP]=Dn[CP]=Dn[RP]=!1;function _P(s){return Ac(s)&&w0(s.length)&&!!Dn[Vc(s)]}function VP(s){return function(e){return s(e)}}var R1=typeof Ws=="object"&&Ws&&!Ws.nodeType&&Ws,bu=R1&&typeof qs=="object"&&qs&&!qs.nodeType&&qs,GP=bu&&bu.exports===R1,jm=GP&&x1.process,Ix=function(){try{var s=bu&&bu.require&&bu.require("util").types;return s||jm&&jm.binding&&jm.binding("util")}catch{}}(),Px=Ix&&Ix.isTypedArray,I1=Px?VP(Px):_P,HP=Object.prototype,WP=HP.hasOwnProperty;function qP(s,e){var t=$s(s),n=!t&&M1(s),i=!t&&!n&&iv(s),r=!t&&!n&&!i&&I1(s),a=t||n||i||r,o=a?cP(s.length,String):[],l=o.length;for(var c in s)WP.call(s,c)&&!(a&&(c=="length"||i&&(c=="offset"||c=="parent")||r&&(c=="buffer"||c=="byteLength"||c=="byteOffset")||A1(c,l)))&&o.push(c);return o}function jP(s,e){return function(t){return s(e(t))}}var QP=jP(Object.keys,Object),XP=Object.prototype,JP=XP.hasOwnProperty;function KP(s){if(!lP(s))return QP(s);var e=[];for(var t in Object(s))JP.call(s,t)&&t!="constructor"&&e.push(t);return e}function S0(s){return aP(s)?qP(s):KP(s)}var YP=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,ZP=/^\w*$/;function b0(s,e){if($s(s))return!1;var t=typeof s;return t=="number"||t=="symbol"||t=="boolean"||s==null||y0(s)?!0:ZP.test(s)||!YP.test(s)||e!=null&&s in Object(e)}var _u=tl(Object,"create");function $P(){this.__data__=_u?_u(null):{},this.size=0}function eD(s){var e=this.has(s)&&delete this.__data__[s];return this.size-=e?1:0,e}var tD="__lodash_hash_undefined__",nD=Object.prototype,iD=nD.hasOwnProperty;function rD(s){var e=this.__data__;if(_u){var t=e[s];return t===tD?void 0:t}return iD.call(e,s)?e[s]:void 0}var sD=Object.prototype,aD=sD.hasOwnProperty;function oD(s){var e=this.__data__;return _u?e[s]!==void 0:aD.call(e,s)}var lD="__lodash_hash_undefined__";function cD(s,e){var t=this.__data__;return this.size+=this.has(s)?0:1,t[s]=_u&&e===void 0?lD:e,this}function Qo(s){var e=-1,t=s==null?0:s.length;for(this.clear();++e<t;){var n=s[e];this.set(n[0],n[1])}}Qo.prototype.clear=$P;Qo.prototype.delete=eD;Qo.prototype.get=rD;Qo.prototype.has=oD;Qo.prototype.set=cD;function uD(){this.__data__=[],this.size=0}function _p(s,e){for(var t=s.length;t--;)if(T1(s[t][0],e))return t;return-1}var hD=Array.prototype,dD=hD.splice;function fD(s){var e=this.__data__,t=_p(e,s);if(t<0)return!1;var n=e.length-1;return t==n?e.pop():dD.call(e,t,1),--this.size,!0}function pD(s){var e=this.__data__,t=_p(e,s);return t<0?void 0:e[t][1]}function mD(s){return _p(this.__data__,s)>-1}function gD(s,e){var t=this.__data__,n=_p(t,s);return n<0?(++this.size,t.push([s,e])):t[n][1]=e,this}function ra(s){var e=-1,t=s==null?0:s.length;for(this.clear();++e<t;){var n=s[e];this.set(n[0],n[1])}}ra.prototype.clear=uD;ra.prototype.delete=fD;ra.prototype.get=pD;ra.prototype.has=mD;ra.prototype.set=gD;var Vu=tl(ia,"Map");function vD(){this.size=0,this.__data__={hash:new Qo,map:new(Vu||ra),string:new Qo}}function yD(s){var e=typeof s;return e=="string"||e=="number"||e=="symbol"||e=="boolean"?s!=="__proto__":s===null}function Vp(s,e){var t=s.__data__;return yD(e)?t[typeof e=="string"?"string":"hash"]:t.map}function xD(s){var e=Vp(this,s).delete(s);return this.size-=e?1:0,e}function wD(s){return Vp(this,s).get(s)}function SD(s){return Vp(this,s).has(s)}function bD(s,e){var t=Vp(this,s),n=t.size;return t.set(s,e),this.size+=t.size==n?0:1,this}function sa(s){var e=-1,t=s==null?0:s.length;for(this.clear();++e<t;){var n=s[e];this.set(n[0],n[1])}}sa.prototype.clear=vD;sa.prototype.delete=xD;sa.prototype.get=wD;sa.prototype.has=SD;sa.prototype.set=bD;var AD="Expected a function";function A0(s,e){if(typeof s!="function"||e!=null&&typeof e!="function")throw new TypeError(AD);var t=function(){var n=arguments,i=e?e.apply(this,n):n[0],r=t.cache;if(r.has(i))return r.get(i);var a=s.apply(this,n);return t.cache=r.set(i,a)||r,a};return t.cache=new(A0.Cache||sa),t}A0.Cache=sa;var TD=500;function ED(s){var e=A0(s,function(n){return t.size===TD&&t.clear(),n}),t=e.cache;return e}var MD=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,CD=/\\(\\)?/g,RD=ED(function(s){var e=[];return s.charCodeAt(0)===46&&e.push(""),s.replace(MD,function(t,n,i,r){e.push(i?r.replace(CD,"$1"):n||t)}),e});function ID(s){return s==null?"":S1(s)}function P1(s,e){return $s(s)?s:b0(s,e)?[s]:RD(ID(s))}function Gp(s){if(typeof s=="string"||y0(s))return s;var e=s+"";return e=="0"&&1/s==-1/0?"-0":e}function D1(s,e){e=P1(e,s);for(var t=0,n=e.length;s!=null&&t<n;)s=s[Gp(e[t++])];return t&&t==n?s:void 0}function L1(s,e,t){var n=s==null?void 0:D1(s,e);return n===void 0?t:n}function PD(s,e){for(var t=-1,n=e.length,i=s.length;++t<n;)s[i+t]=e[t];return s}function DD(){this.__data__=new ra,this.size=0}function LD(s){var e=this.__data__,t=e.delete(s);return this.size=e.size,t}function BD(s){return this.__data__.get(s)}function OD(s){return this.__data__.has(s)}var ND=200;function zD(s,e){var t=this.__data__;if(t instanceof ra){var n=t.__data__;if(!Vu||n.length<ND-1)return n.push([s,e]),this.size=++t.size,this;t=this.__data__=new sa(n)}return t.set(s,e),this.size=t.size,this}function Xs(s){var e=this.__data__=new ra(s);this.size=e.size}Xs.prototype.clear=DD;Xs.prototype.delete=LD;Xs.prototype.get=BD;Xs.prototype.has=OD;Xs.prototype.set=zD;function FD(s,e){for(var t=-1,n=s==null?0:s.length,i=0,r=[];++t<n;){var a=s[t];e(a,t,s)&&(r[i++]=a)}return r}function UD(){return[]}var kD=Object.prototype,_D=kD.propertyIsEnumerable,Dx=Object.getOwnPropertySymbols,VD=Dx?function(s){return s==null?[]:(s=Object(s),FD(Dx(s),function(e){return _D.call(s,e)}))}:UD;function GD(s,e,t){var n=e(s);return $s(s)?n:PD(n,t(s))}function Lx(s){return GD(s,S0,VD)}var rv=tl(ia,"DataView"),sv=tl(ia,"Promise"),tc=tl(ia,"Set"),Bx="[object Map]",HD="[object Object]",Ox="[object Promise]",Nx="[object Set]",zx="[object WeakMap]",Fx="[object DataView]",WD=el(rv),qD=el(Vu),jD=el(sv),QD=el(tc),XD=el(nv),Aa=Vc;(rv&&Aa(new rv(new ArrayBuffer(1)))!=Fx||Vu&&Aa(new Vu)!=Bx||sv&&Aa(sv.resolve())!=Ox||tc&&Aa(new tc)!=Nx||nv&&Aa(new nv)!=zx)&&(Aa=function(s){var e=Vc(s),t=e==HD?s.constructor:void 0,n=t?el(t):"";if(n)switch(n){case WD:return Fx;case qD:return Bx;case jD:return Ox;case QD:return Nx;case XD:return zx}return e});var Ux=ia.Uint8Array,JD="__lodash_hash_undefined__";function KD(s){return this.__data__.set(s,JD),this}function YD(s){return this.__data__.has(s)}function Gu(s){var e=-1,t=s==null?0:s.length;for(this.__data__=new sa;++e<t;)this.add(s[e])}Gu.prototype.add=Gu.prototype.push=KD;Gu.prototype.has=YD;function ZD(s,e){for(var t=-1,n=s==null?0:s.length;++t<n;)if(e(s[t],t,s))return!0;return!1}function B1(s,e){return s.has(e)}var $D=1,eL=2;function O1(s,e,t,n,i,r){var a=t&$D,o=s.length,l=e.length;if(o!=l&&!(a&&l>o))return!1;var c=r.get(s),u=r.get(e);if(c&&u)return c==e&&u==s;var h=-1,d=!0,f=t&eL?new Gu:void 0;for(r.set(s,e),r.set(e,s);++h<o;){var v=s[h],g=e[h];if(n)var m=a?n(g,v,h,e,s,r):n(v,g,h,s,e,r);if(m!==void 0){if(m)continue;d=!1;break}if(f){if(!ZD(e,function(x,w){if(!B1(f,w)&&(v===x||i(v,x,t,n,r)))return f.push(w)})){d=!1;break}}else if(!(v===g||i(v,g,t,n,r))){d=!1;break}}return r.delete(s),r.delete(e),d}function tL(s){var e=-1,t=Array(s.size);return s.forEach(function(n,i){t[++e]=[i,n]}),t}function T0(s){var e=-1,t=Array(s.size);return s.forEach(function(n){t[++e]=n}),t}var nL=1,iL=2,rL="[object Boolean]",sL="[object Date]",aL="[object Error]",oL="[object Map]",lL="[object Number]",cL="[object RegExp]",uL="[object Set]",hL="[object String]",dL="[object Symbol]",fL="[object ArrayBuffer]",pL="[object DataView]",kx=ja?ja.prototype:void 0,Qm=kx?kx.valueOf:void 0;function mL(s,e,t,n,i,r,a){switch(t){case pL:if(s.byteLength!=e.byteLength||s.byteOffset!=e.byteOffset)return!1;s=s.buffer,e=e.buffer;case fL:return!(s.byteLength!=e.byteLength||!r(new Ux(s),new Ux(e)));case rL:case sL:case lL:return T1(+s,+e);case aL:return s.name==e.name&&s.message==e.message;case cL:case hL:return s==e+"";case oL:var o=tL;case uL:var l=n&nL;if(o||(o=T0),s.size!=e.size&&!l)return!1;var c=a.get(s);if(c)return c==e;n|=iL,a.set(s,e);var u=O1(o(s),o(e),n,i,r,a);return a.delete(s),u;case dL:if(Qm)return Qm.call(s)==Qm.call(e)}return!1}var gL=1,vL=Object.prototype,yL=vL.hasOwnProperty;function xL(s,e,t,n,i,r){var a=t&gL,o=Lx(s),l=o.length,c=Lx(e),u=c.length;if(l!=u&&!a)return!1;for(var h=l;h--;){var d=o[h];if(!(a?d in e:yL.call(e,d)))return!1}var f=r.get(s),v=r.get(e);if(f&&v)return f==e&&v==s;var g=!0;r.set(s,e),r.set(e,s);for(var m=a;++h<l;){d=o[h];var x=s[d],w=e[d];if(n)var S=a?n(w,x,d,e,s,r):n(x,w,d,s,e,r);if(!(S===void 0?x===w||i(x,w,t,n,r):S)){g=!1;break}m||(m=d=="constructor")}if(g&&!m){var b=s.constructor,E=e.constructor;b!=E&&"constructor"in s&&"constructor"in e&&!(typeof b=="function"&&b instanceof b&&typeof E=="function"&&E instanceof E)&&(g=!1)}return r.delete(s),r.delete(e),g}var wL=1,_x="[object Arguments]",Vx="[object Array]",Ld="[object Object]",SL=Object.prototype,Gx=SL.hasOwnProperty;function bL(s,e,t,n,i,r){var a=$s(s),o=$s(e),l=a?Vx:Aa(s),c=o?Vx:Aa(e);l=l==_x?Ld:l,c=c==_x?Ld:c;var u=l==Ld,h=c==Ld,d=l==c;if(d&&iv(s)){if(!iv(e))return!1;a=!0,u=!1}if(d&&!u)return r||(r=new Xs),a||I1(s)?O1(s,e,t,n,i,r):mL(s,e,l,t,n,i,r);if(!(t&wL)){var f=u&&Gx.call(s,"__wrapped__"),v=h&&Gx.call(e,"__wrapped__");if(f||v){var g=f?s.value():s,m=v?e.value():e;return r||(r=new Xs),i(g,m,t,n,r)}}return d?(r||(r=new Xs),xL(s,e,t,n,i,r)):!1}function E0(s,e,t,n,i){return s===e?!0:s==null||e==null||!Ac(s)&&!Ac(e)?s!==s&&e!==e:bL(s,e,t,n,E0,i)}var AL=1,TL=2;function EL(s,e,t,n){var i=t.length,r=i;if(s==null)return!r;for(s=Object(s);i--;){var a=t[i];if(a[2]?a[1]!==s[a[0]]:!(a[0]in s))return!1}for(;++i<r;){a=t[i];var o=a[0],l=s[o],c=a[1];if(a[2]){if(l===void 0&&!(o in s))return!1}else{var u=new Xs,h;if(!(h===void 0?E0(c,l,AL|TL,n,u):h))return!1}}return!0}function N1(s){return s===s&&!x0(s)}function ML(s){for(var e=S0(s),t=e.length;t--;){var n=e[t],i=s[n];e[t]=[n,i,N1(i)]}return e}function z1(s,e){return function(t){return t==null?!1:t[s]===e&&(e!==void 0||s in Object(t))}}function CL(s){var e=ML(s);return e.length==1&&e[0][2]?z1(e[0][0],e[0][1]):function(t){return t===s||EL(t,s,e)}}function RL(s,e){return s!=null&&e in Object(s)}function F1(s,e,t){e=P1(e,s);for(var n=-1,i=e.length,r=!1;++n<i;){var a=Gp(e[n]);if(!(r=s!=null&&t(s,a)))break;s=s[a]}return r||++n!=i?r:(i=s==null?0:s.length,!!i&&w0(i)&&A1(a,i)&&($s(s)||M1(s)))}function IL(s,e){return s!=null&&F1(s,e,RL)}var PL=1,DL=2;function LL(s,e){return b0(s)&&N1(e)?z1(Gp(s),e):function(t){var n=L1(t,s);return n===void 0&&n===e?IL(t,s):E0(e,n,PL|DL)}}function BL(s){return function(e){return e==null?void 0:e[s]}}function OL(s){return function(e){return D1(e,s)}}function NL(s){return b0(s)?BL(Gp(s)):OL(s)}function U1(s){return typeof s=="function"?s:s==null?B2:typeof s=="object"?$s(s)?LL(s[0],s[1]):CL(s):NL(s)}function zL(s){return function(e,t,n){for(var i=-1,r=Object(e),a=n(e),o=a.length;o--;){var l=a[++i];if(t(r[l],l,r)===!1)break}return e}}var FL=zL();function UL(s,e){return s&&FL(s,e,S0)}var kL=Object.prototype,_L=kL.hasOwnProperty;function VL(s,e){return s!=null&&_L.call(s,e)}function GL(s,e){return s!=null&&F1(s,e,VL)}function HL(s,e){var t={};return e=U1(e),UL(s,function(n,i,r){rP(t,i,e(n,i,r))}),t}var WL=1/0,qL=tc&&1/T0(new tc([,-0]))[1]==WL?function(s){return new tc(s)}:K2,jL=200;function QL(s,e,t){var n=-1,i=tP,r=s.length,a=!0,o=[],l=o;if(r>=jL){var c=e?null:qL(s);if(c)return T0(c);a=!1,i=B1,l=new Gu}else l=e?[]:o;e:for(;++n<r;){var u=s[n],h=e?e(u):u;if(u=u!==0?u:0,a&&h===h){for(var d=l.length;d--;)if(l[d]===h)continue e;e&&l.push(h),o.push(u)}else i(l,h,t)||(l!==o&&l.push(h),o.push(u))}return o}function XL(s,e){return s&&s.length?QL(s,U1(e)):[]}const un={c:null,u:[new T,new T,new T],e:[]},mn={c:null,u:[new T,new T,new T],e:[]},Fn=[[],[],[]],Ht=[[],[],[]],Pn=[],fo=new T,po=new T,mo=new T,mi=new T,Hx=new T,Wx=new T,kr=new Hn,qx=new Tt,Bd=new Ne,jx=new Ne,Qx=new Ti;class Ki{constructor(e=new T,t=new T,n=new Hn){this.center=e,this.halfSize=t,this.rotation=n}set(e,t,n){return this.center=e,this.halfSize=t,this.rotation=n,this}copy(e){return this.center.copy(e.center),this.halfSize.copy(e.halfSize),this.rotation.copy(e.rotation),this}clone(){return new this.constructor().copy(this)}getSize(e){return e.copy(this.halfSize).multiplyScalar(2)}clampPoint(e,t){const n=this.halfSize;mi.subVectors(e,this.center),this.rotation.extractBasis(fo,po,mo),t.copy(this.center);const i=ci.clamp(mi.dot(fo),-n.x,n.x);t.add(fo.multiplyScalar(i));const r=ci.clamp(mi.dot(po),-n.y,n.y);t.add(po.multiplyScalar(r));const a=ci.clamp(mi.dot(mo),-n.z,n.z);return t.add(mo.multiplyScalar(a)),t}containsPoint(e){return mi.subVectors(e,this.center),this.rotation.extractBasis(fo,po,mo),Math.abs(mi.dot(fo))<=this.halfSize.x&&Math.abs(mi.dot(po))<=this.halfSize.y&&Math.abs(mi.dot(mo))<=this.halfSize.z}intersectsBox3(e){return this.intersectsOBB(JL.fromBox3(e))}intersectsSphere(e){return this.clampPoint(e.center,Wx),Wx.distanceToSquared(e.center)<=e.radius*e.radius}intersectsOBB(e,t=Number.EPSILON){un.c=this.center,un.e[0]=this.halfSize.x,un.e[1]=this.halfSize.y,un.e[2]=this.halfSize.z,this.rotation.extractBasis(un.u[0],un.u[1],un.u[2]),mn.c=e.center,mn.e[0]=e.halfSize.x,mn.e[1]=e.halfSize.y,mn.e[2]=e.halfSize.z,e.rotation.extractBasis(mn.u[0],mn.u[1],mn.u[2]);for(let r=0;r<3;r++)for(let a=0;a<3;a++)Fn[r][a]=un.u[r].dot(mn.u[a]);mi.subVectors(mn.c,un.c),Pn[0]=mi.dot(un.u[0]),Pn[1]=mi.dot(un.u[1]),Pn[2]=mi.dot(un.u[2]);for(let r=0;r<3;r++)for(let a=0;a<3;a++)Ht[r][a]=Math.abs(Fn[r][a])+t;let n,i;for(let r=0;r<3;r++)if(n=un.e[r],i=mn.e[0]*Ht[r][0]+mn.e[1]*Ht[r][1]+mn.e[2]*Ht[r][2],Math.abs(Pn[r])>n+i)return!1;for(let r=0;r<3;r++)if(n=un.e[0]*Ht[0][r]+un.e[1]*Ht[1][r]+un.e[2]*Ht[2][r],i=mn.e[r],Math.abs(Pn[0]*Fn[0][r]+Pn[1]*Fn[1][r]+Pn[2]*Fn[2][r])>n+i)return!1;return n=un.e[1]*Ht[2][0]+un.e[2]*Ht[1][0],i=mn.e[1]*Ht[0][2]+mn.e[2]*Ht[0][1],!(Math.abs(Pn[2]*Fn[1][0]-Pn[1]*Fn[2][0])>n+i||(n=un.e[1]*Ht[2][1]+un.e[2]*Ht[1][1],i=mn.e[0]*Ht[0][2]+mn.e[2]*Ht[0][0],Math.abs(Pn[2]*Fn[1][1]-Pn[1]*Fn[2][1])>n+i)||(n=un.e[1]*Ht[2][2]+un.e[2]*Ht[1][2],i=mn.e[0]*Ht[0][1]+mn.e[1]*Ht[0][0],Math.abs(Pn[2]*Fn[1][2]-Pn[1]*Fn[2][2])>n+i)||(n=un.e[0]*Ht[2][0]+un.e[2]*Ht[0][0],i=mn.e[1]*Ht[1][2]+mn.e[2]*Ht[1][1],Math.abs(Pn[0]*Fn[2][0]-Pn[2]*Fn[0][0])>n+i)||(n=un.e[0]*Ht[2][1]+un.e[2]*Ht[0][1],i=mn.e[0]*Ht[1][2]+mn.e[2]*Ht[1][0],Math.abs(Pn[0]*Fn[2][1]-Pn[2]*Fn[0][1])>n+i)||(n=un.e[0]*Ht[2][2]+un.e[2]*Ht[0][2],i=mn.e[0]*Ht[1][1]+mn.e[1]*Ht[1][0],Math.abs(Pn[0]*Fn[2][2]-Pn[2]*Fn[0][2])>n+i)||(n=un.e[0]*Ht[1][0]+un.e[1]*Ht[0][0],i=mn.e[1]*Ht[2][2]+mn.e[2]*Ht[2][1],Math.abs(Pn[1]*Fn[0][0]-Pn[0]*Fn[1][0])>n+i)||(n=un.e[0]*Ht[1][1]+un.e[1]*Ht[0][1],i=mn.e[0]*Ht[2][2]+mn.e[2]*Ht[2][0],Math.abs(Pn[1]*Fn[0][1]-Pn[0]*Fn[1][1])>n+i)||(n=un.e[0]*Ht[1][2]+un.e[1]*Ht[0][2],i=mn.e[0]*Ht[2][1]+mn.e[1]*Ht[2][0],Math.abs(Pn[1]*Fn[0][2]-Pn[0]*Fn[1][2])>n+i))}intersectsPlane(e){this.rotation.extractBasis(fo,po,mo);const t=this.halfSize.x*Math.abs(e.normal.dot(fo))+this.halfSize.y*Math.abs(e.normal.dot(po))+this.halfSize.z*Math.abs(e.normal.dot(mo)),n=e.normal.dot(this.center)-e.constant;return Math.abs(n)<=t}intersectRay(e,t){return this.getSize(Hx),qx.setFromCenterAndSize(mi.set(0,0,0),Hx),Bd.setFromMatrix3(this.rotation),Bd.setPosition(this.center),jx.copy(Bd).invert(),Qx.copy(e).applyMatrix4(jx),Qx.intersectBox(qx,t)?t.applyMatrix4(Bd):null}intersectsRay(e){return this.intersectRay(e,mi)!==null}fromBox3(e){return e.getCenter(this.center),e.getSize(this.halfSize).multiplyScalar(.5),this.rotation.identity(),this}equals(e){return e.center.equals(this.center)&&e.halfSize.equals(this.halfSize)&&e.rotation.equals(this.rotation)}applyMatrix4(e){const t=e.elements;let n=mi.set(t[0],t[1],t[2]).length();const i=mi.set(t[4],t[5],t[6]).length(),r=mi.set(t[8],t[9],t[10]).length();e.determinant()<0&&(n=-n),kr.setFromMatrix4(e);const o=1/n,l=1/i,c=1/r;return kr.elements[0]*=o,kr.elements[1]*=o,kr.elements[2]*=o,kr.elements[3]*=l,kr.elements[4]*=l,kr.elements[5]*=l,kr.elements[6]*=c,kr.elements[7]*=c,kr.elements[8]*=c,this.rotation.multiply(kr),this.halfSize.x*=n,this.halfSize.y*=i,this.halfSize.z*=r,mi.setFromMatrixPosition(e),this.center.add(mi),this}}const JL=new Ki;var Xm,Xx;function KL(){return Xx||(Xx=1,Xm=function(){function s(t,n){var i=n.length,r,a;return i>=2?(r=n.slice(0,i/2),a=n.slice(i/2,i),e(t,s(t,r),s(t,a))):n.slice()}function e(t,n,i){for(var r=[],a=n.length,o=i.length;a>0&&o>0;)t(n[0],i[0])<=0?(r.push(n.shift()),a--):(r.push(i.shift()),o--);return a>0?r.push.apply(r,n):r.push.apply(r,i),r}return s}()),Xm}var Jm,Jx;function YL(){return Jx||(Jx=1,Jm=function(){function s(e,t,n){var i,r;for(i=0,r=t.length;i<r&&!(e(t[i],n)>0);i++);return i}return s}()),Jm}var Km,Kx;function ZL(){if(Kx)return Km;Kx=1;var s,e;return s=KL(),e=YL(),Km=function(){var t;t={};function n(u){return function(){return u}}function i(u){u=u||{},this.config=u,this.config.childrenPropertyName=u.childrenPropertyName||"children",this.config.modelComparatorFn=u.modelComparatorFn}function r(u,h){return h.parent=u,u.children.push(h),h}function a(u,h){this.config=u,this.model=h,this.children=[]}i.prototype.parse=function(u){var h,d,f;if(!(u instanceof Object))throw new TypeError("Model must be of type object.");if(f=new a(this.config,u),u[this.config.childrenPropertyName]instanceof Array)for(this.config.modelComparatorFn&&(u[this.config.childrenPropertyName]=s(this.config.modelComparatorFn,u[this.config.childrenPropertyName])),h=0,d=u[this.config.childrenPropertyName].length;h<d;h++)r(f,this.parse(u[this.config.childrenPropertyName][h]));return f};function o(u){return typeof u.config.modelComparatorFn=="function"}a.prototype.isRoot=function(){return this.parent===void 0},a.prototype.hasChildren=function(){return this.children.length>0};function l(u,h,d){var f;if(!(h instanceof a))throw new TypeError("Child must be of type Node.");if(h.parent=u,u.model[u.config.childrenPropertyName]instanceof Array||(u.model[u.config.childrenPropertyName]=[]),o(u))f=e(u.config.modelComparatorFn,u.model[u.config.childrenPropertyName],h.model),u.model[u.config.childrenPropertyName].splice(f,0,h.model),u.children.splice(f,0,h);else if(d===void 0)u.model[u.config.childrenPropertyName].push(h.model),u.children.push(h);else{if(d<0||d>u.children.length)throw new Error("Invalid index.");u.model[u.config.childrenPropertyName].splice(d,0,h.model),u.children.splice(d,0,h)}return h}a.prototype.addChild=function(u){return l(this,u)},a.prototype.addChildAtIndex=function(u,h){if(o(this))throw new Error("Cannot add child at index when using a comparator function.");return l(this,u,h)},a.prototype.setIndex=function(u){if(o(this))throw new Error("Cannot set node index when using a comparator function.");if(this.isRoot()){if(u===0)return this;throw new Error("Invalid index.")}if(u<0||u>=this.parent.children.length)throw new Error("Invalid index.");var h=this.parent.children.indexOf(this);return this.parent.children.splice(u,0,this.parent.children.splice(h,1)[0]),this.parent.model[this.parent.config.childrenPropertyName].splice(u,0,this.parent.model[this.parent.config.childrenPropertyName].splice(h,1)[0]),this},a.prototype.getPath=function(){var u=[];return function h(d){u.unshift(d),d.isRoot()||h(d.parent)}(this),u},a.prototype.getIndex=function(){return this.isRoot()?0:this.parent.children.indexOf(this)};function c(){var u={};if(arguments.length===1?typeof arguments[0]=="function"?u.fn=arguments[0]:u.options=arguments[0]:arguments.length===2?typeof arguments[0]=="function"?(u.fn=arguments[0],u.ctx=arguments[1]):(u.options=arguments[0],u.fn=arguments[1]):(u.options=arguments[0],u.fn=arguments[1],u.ctx=arguments[2]),u.options=u.options||{},u.options.strategy||(u.options.strategy="pre"),!t[u.options.strategy])throw new Error("Unknown tree walk strategy. Valid strategies are 'pre' [default], 'post' and 'breadth'.");return u}return a.prototype.walk=function(){var u;u=c.apply(this,arguments),t[u.options.strategy].call(this,u.fn,u.ctx)},t.pre=function u(h,d){var f,v,g;for(g=h.call(d,this),f=0,v=this.children.length;f<v;f++){if(g===!1)return!1;g=u.call(this.children[f],h,d)}return g},t.post=function u(h,d){var f,v,g;for(f=0,v=this.children.length;f<v;f++)if(g=u.call(this.children[f],h,d),g===!1)return!1;return g=h.call(d,this),g},t.breadth=function(h,d){var f=[this];(function v(){var g,m,x;if(f.length!==0){for(x=f.shift(),g=0,m=x.children.length;g<m;g++)f.push(x.children[g]);h.call(d,x)!==!1&&v()}})()},a.prototype.all=function(){var u,h=[];return u=c.apply(this,arguments),u.fn=u.fn||n(!0),t[u.options.strategy].call(this,function(d){u.fn.call(u.ctx,d)&&h.push(d)},u.ctx),h},a.prototype.first=function(){var u,h;return u=c.apply(this,arguments),u.fn=u.fn||n(!0),t[u.options.strategy].call(this,function(d){if(u.fn.call(u.ctx,d))return h=d,!1},u.ctx),h},a.prototype.drop=function(){var u;return this.isRoot()||(u=this.parent.children.indexOf(this),this.parent.children.splice(u,1),this.parent.model[this.config.childrenPropertyName].splice(u,1),this.parent=void 0,delete this.parent),this},i}(),Km}var $L=ZL();const Yx=v0($L);xt.line={worldUnits:{value:1},linewidth:{value:1},resolution:{value:new Me(1,1)},dashOffset:{value:0},dashScale:{value:1},dashSize:{value:1},gapSize:{value:1}};Xn.line={uniforms:Ga.merge([xt.common,xt.fog,xt.line]),vertexShader:`
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
				vUv = uv;

			#endif

			float aspect = resolution.x / resolution.y;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			#ifdef WORLD_UNITS

				worldStart = start.xyz;
				worldEnd = end.xyz;

			#else

				vUv = uv;

			#endif

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				// get the offset direction as perpendicular to the view vector
				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 offset;
				if ( position.y < 0.5 ) {

					offset = normalize( cross( start.xyz, worldDir ) );

				} else {

					offset = normalize( cross( end.xyz, worldDir ) );

				}

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				float forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// extend the line bounds to encompass  endcaps
					start.xyz += - worldDir * linewidth * 0.5;
					end.xyz += worldDir * linewidth * 0.5;

					// shift the position of the quad so it hugs the forward edge of the line
					offset.xy -= dir * forwardOffset;
					offset.z += 0.5;

				#endif

				// endcaps
				if ( position.y > 1.0 || position.y < 0.0 ) {

					offset.xy += dir * 2.0 * forwardOffset;

				}

				// adjust for linewidth
				offset *= linewidth * 0.5;

				// set the world position
				worldPos = ( position.y < 0.5 ) ? start : end;
				worldPos.xyz += offset;

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segments overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( position.y < 0.0 ) {

					offset += - dir;

				} else if ( position.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`,fragmentShader:`
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = opacity;

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef USE_ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef USE_ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <encodings_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`};class M0 extends $n{constructor(e){super({type:"LineMaterial",uniforms:Ga.clone(Xn.line.uniforms),vertexShader:Xn.line.vertexShader,fragmentShader:Xn.line.fragmentShader,clipping:!0}),Object.defineProperties(this,{color:{enumerable:!0,get:function(){return this.uniforms.diffuse.value},set:function(t){this.uniforms.diffuse.value=t}},worldUnits:{enumerable:!0,get:function(){return"WORLD_UNITS"in this.defines},set:function(t){t===!0?this.defines.WORLD_UNITS="":delete this.defines.WORLD_UNITS}},linewidth:{enumerable:!0,get:function(){return this.uniforms.linewidth.value},set:function(t){this.uniforms.linewidth.value=t}},dashed:{enumerable:!0,get:function(){return"USE_DASH"in this.defines},set(t){!!t!="USE_DASH"in this.defines&&(this.needsUpdate=!0),t===!0?this.defines.USE_DASH="":delete this.defines.USE_DASH}},dashScale:{enumerable:!0,get:function(){return this.uniforms.dashScale.value},set:function(t){this.uniforms.dashScale.value=t}},dashSize:{enumerable:!0,get:function(){return this.uniforms.dashSize.value},set:function(t){this.uniforms.dashSize.value=t}},dashOffset:{enumerable:!0,get:function(){return this.uniforms.dashOffset.value},set:function(t){this.uniforms.dashOffset.value=t}},gapSize:{enumerable:!0,get:function(){return this.uniforms.gapSize.value},set:function(t){this.uniforms.gapSize.value=t}},opacity:{enumerable:!0,get:function(){return this.uniforms.opacity.value},set:function(t){this.uniforms.opacity.value=t}},resolution:{enumerable:!0,get:function(){return this.uniforms.resolution.value},set:function(t){this.uniforms.resolution.value.copy(t)}},alphaToCoverage:{enumerable:!0,get:function(){return"USE_ALPHA_TO_COVERAGE"in this.defines},set:function(t){!!t!="USE_ALPHA_TO_COVERAGE"in this.defines&&(this.needsUpdate=!0),t===!0?(this.defines.USE_ALPHA_TO_COVERAGE="",this.extensions.derivatives=!0):(delete this.defines.USE_ALPHA_TO_COVERAGE,this.extensions.derivatives=!1)}}}),this.setValues(e)}}M0.prototype.isLineMaterial=!0;function eB(){var s=Object.create(null);function e(i,r){var a=i.id,o=i.name,l=i.dependencies;l===void 0&&(l=[]);var c=i.init;c===void 0&&(c=function(){});var u=i.getTransferables;if(u===void 0&&(u=null),!s[a])try{l=l.map(function(d){return d&&d.isWorkerModule&&(e(d,function(f){if(f instanceof Error)throw f}),d=s[d.id].value),d}),c=n("<"+o+">.init",c),u&&(u=n("<"+o+">.getTransferables",u));var h=null;typeof c=="function"?h=c.apply(void 0,l):console.error("worker module init function failed to rehydrate"),s[a]={id:a,value:h,getTransferables:u},r(h)}catch(d){d&&d.noLog||console.error(d),r(d)}}function t(i,r){var a,o=i.id,l=i.args;(!s[o]||typeof s[o].value!="function")&&r(new Error("Worker module "+o+": not found or its 'init' did not return a function"));try{var c=(a=s[o]).value.apply(a,l);c&&typeof c.then=="function"?c.then(u,function(h){return r(h instanceof Error?h:new Error(""+h))}):u(c)}catch(h){r(h)}function u(h){try{var d=s[o].getTransferables&&s[o].getTransferables(h);(!d||!Array.isArray(d)||!d.length)&&(d=void 0),r(h,d)}catch(f){console.error(f),r(f)}}}function n(i,r){var a=void 0;self.troikaDefine=function(l){return a=l};var o=URL.createObjectURL(new Blob(["/** "+i.replace(/\*/g,"")+` **/

troikaDefine(
`+r+`
)`],{type:"application/javascript"}));try{importScripts(o)}catch(l){console.error(l)}return URL.revokeObjectURL(o),delete self.troikaDefine,a}self.addEventListener("message",function(i){var r=i.data,a=r.messageId,o=r.action,l=r.data;try{o==="registerModule"&&e(l,function(c){c instanceof Error?postMessage({messageId:a,success:!1,error:c.message}):postMessage({messageId:a,success:!0,result:{isCallable:typeof c=="function"}})}),o==="callModule"&&t(l,function(c,u){c instanceof Error?postMessage({messageId:a,success:!1,error:c.message}):postMessage({messageId:a,success:!0,result:c},u||void 0)})}catch(c){postMessage({messageId:a,success:!1,error:c.stack})}})}function tB(s){var e=function(){for(var t=[],n=arguments.length;n--;)t[n]=arguments[n];return e._getInitResult().then(function(i){if(typeof i=="function")return i.apply(void 0,t);throw new Error("Worker module function was called but `init` did not return a callable function")})};return e._getInitResult=function(){var t=s.dependencies,n=s.init;t=Array.isArray(t)?t.map(function(r){return r&&r._getInitResult?r._getInitResult():r}):[];var i=Promise.all(t).then(function(r){return n.apply(null,r)});return e._getInitResult=function(){return i},i},e}var k1=function(){var s=!1;if(typeof window<"u"&&typeof window.document<"u")try{var e=new Worker(URL.createObjectURL(new Blob([""],{type:"application/javascript"})));e.terminate(),s=!0}catch(t){console.log("Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: ["+t.message+"]")}return k1=function(){return s},s},nB=0,iB=0,Ym=!1,Au=Object.create(null),Tu=Object.create(null),av=Object.create(null);function Lh(s){if((!s||typeof s.init!="function")&&!Ym)throw new Error("requires `options.init` function");var e=s.dependencies,t=s.init,n=s.getTransferables,i=s.workerId;if(!k1())return tB(s);i==null&&(i="#default");var r="workerModule"+ ++nB,a=s.name||r,o=null;e=e&&e.map(function(c){return typeof c=="function"&&!c.workerModuleData&&(Ym=!0,c=Lh({workerId:i,name:"<"+a+"> function dependency: "+c.name,init:`function(){return (
`+bf(c)+`
)}`}),Ym=!1),c&&c.workerModuleData&&(c=c.workerModuleData),c});function l(){for(var c=[],u=arguments.length;u--;)c[u]=arguments[u];if(!o){o=Zx(i,"registerModule",l.workerModuleData);var h=function(){o=null,Tu[i].delete(h)};(Tu[i]||(Tu[i]=new Set)).add(h)}return o.then(function(d){var f=d.isCallable;if(f)return Zx(i,"callModule",{id:r,args:c});throw new Error("Worker module function was called but `init` did not return a callable function")})}return l.workerModuleData={isWorkerModule:!0,id:r,name:a,dependencies:e,init:bf(t),getTransferables:n&&bf(n)},l}function rB(s){Tu[s]&&Tu[s].forEach(function(e){e()}),Au[s]&&(Au[s].terminate(),delete Au[s])}function bf(s){var e=s.toString();return!/^function/.test(e)&&/^\w+\s*\(/.test(e)&&(e="function "+e),e}function sB(s){var e=Au[s];if(!e){var t=bf(eB);e=Au[s]=new Worker(URL.createObjectURL(new Blob(["/** Worker Module Bootstrap: "+s.replace(/\*/g,"")+` **/

;(`+t+")()"],{type:"application/javascript"}))),e.onmessage=function(n){var i=n.data,r=i.messageId,a=av[r];if(!a)throw new Error("WorkerModule response with empty or unknown messageId");delete av[r],a(i)}}return e}function Zx(s,e,t){return new Promise(function(n,i){var r=++iB;av[r]=function(a){a.success?n(a.result):i(new Error("Error in worker "+e+" call: "+a.error))},sB(s).postMessage({messageId:r,action:e,data:t})})}function _1(){var s=function(e){function t(q,te,H,$,ce,xe,pe,Y){var Ie=1-pe;Y.x=Ie*Ie*q+2*Ie*pe*H+pe*pe*ce,Y.y=Ie*Ie*te+2*Ie*pe*$+pe*pe*xe}function n(q,te,H,$,ce,xe,pe,Y,Ie,re){var oe=1-Ie;re.x=oe*oe*oe*q+3*oe*oe*Ie*H+3*oe*Ie*Ie*ce+Ie*Ie*Ie*pe,re.y=oe*oe*oe*te+3*oe*oe*Ie*$+3*oe*Ie*Ie*xe+Ie*Ie*Ie*Y}function i(q,te){for(var H=/([MLQCZ])([^MLQCZ]*)/g,$,ce,xe,pe,Y;$=H.exec(q);){var Ie=$[2].replace(/^\s*|\s*$/g,"").split(/[,\s]+/).map(function(re){return parseFloat(re)});switch($[1]){case"M":pe=ce=Ie[0],Y=xe=Ie[1];break;case"L":(Ie[0]!==pe||Ie[1]!==Y)&&te("L",pe,Y,pe=Ie[0],Y=Ie[1]);break;case"Q":{te("Q",pe,Y,pe=Ie[2],Y=Ie[3],Ie[0],Ie[1]);break}case"C":{te("C",pe,Y,pe=Ie[4],Y=Ie[5],Ie[0],Ie[1],Ie[2],Ie[3]);break}case"Z":(pe!==ce||Y!==xe)&&te("L",pe,Y,ce,xe);break}}}function r(q,te,H){H===void 0&&(H=16);var $={x:0,y:0};i(q,function(ce,xe,pe,Y,Ie,re,oe,ye,ke){switch(ce){case"L":te(xe,pe,Y,Ie);break;case"Q":{for(var X=xe,Se=pe,qe=1;qe<H;qe++)t(xe,pe,re,oe,Y,Ie,qe/(H-1),$),te(X,Se,$.x,$.y),X=$.x,Se=$.y;break}case"C":{for(var Qe=xe,Ke=pe,pt=1;pt<H;pt++)n(xe,pe,re,oe,ye,ke,Y,Ie,pt/(H-1),$),te(Qe,Ke,$.x,$.y),Qe=$.x,Ke=$.y;break}}})}var a="precision highp float;attribute vec2 aUV;varying vec2 vUV;void main(){vUV=aUV;gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}",o="precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){gl_FragColor=texture2D(tex,vUV);}",l=new WeakMap,c={premultipliedAlpha:!1,preserveDrawingBuffer:!0,antialias:!1,depth:!1};function u(q,te){var H=q.getContext?q.getContext("webgl",c):q,$=l.get(H);if(!$){let Qe=function(Le){var k=xe[Le];if(!k&&(k=xe[Le]=H.getExtension(Le),!k))throw new Error(Le+" not supported");return k},Ke=function(Le,k){var B=H.createShader(k);return H.shaderSource(B,Le),H.compileShader(B),B},pt=function(Le,k,B,G){if(!pe[Le]){var ne={},_e={},Ye=H.createProgram();H.attachShader(Ye,Ke(k,H.VERTEX_SHADER)),H.attachShader(Ye,Ke(B,H.FRAGMENT_SHADER)),H.linkProgram(Ye),pe[Le]={program:Ye,transaction:function(we){H.useProgram(Ye),we({setUniform:function(wt,tt){for(var ee=[],We=arguments.length-2;We-- >0;)ee[We]=arguments[We+2];var Fe=_e[tt]||(_e[tt]=H.getUniformLocation(Ye,tt));H["uniform"+wt].apply(H,[Fe].concat(ee))},setAttribute:function(wt,tt,ee,We,Fe){var Oe=ne[wt];Oe||(Oe=ne[wt]={buf:H.createBuffer(),loc:H.getAttribLocation(Ye,wt),data:null}),H.bindBuffer(H.ARRAY_BUFFER,Oe.buf),H.vertexAttribPointer(Oe.loc,tt,H.FLOAT,!1,0,0),H.enableVertexAttribArray(Oe.loc),ce?H.vertexAttribDivisor(Oe.loc,We):Qe("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(Oe.loc,We),Fe!==Oe.data&&(H.bufferData(H.ARRAY_BUFFER,Fe,ee),Oe.data=Fe)}})}}}pe[Le].transaction(G)},He=function(Le,k){Ie++;try{H.activeTexture(H.TEXTURE0+Ie);var B=Y[Le];B||(B=Y[Le]=H.createTexture(),H.bindTexture(H.TEXTURE_2D,B),H.texParameteri(H.TEXTURE_2D,H.TEXTURE_MIN_FILTER,H.NEAREST),H.texParameteri(H.TEXTURE_2D,H.TEXTURE_MAG_FILTER,H.NEAREST)),H.bindTexture(H.TEXTURE_2D,B),k(B,Ie)}finally{Ie--}},ze=function(Le,k,B){var G=H.createFramebuffer();re.push(G),H.bindFramebuffer(H.FRAMEBUFFER,G),H.activeTexture(H.TEXTURE0+k),H.bindTexture(H.TEXTURE_2D,Le),H.framebufferTexture2D(H.FRAMEBUFFER,H.COLOR_ATTACHMENT0,H.TEXTURE_2D,Le,0);try{B(G)}finally{H.deleteFramebuffer(G),H.bindFramebuffer(H.FRAMEBUFFER,re[--re.length-1]||null)}},rt=function(){xe={},pe={},Y={},Ie=-1,re.length=0};var oe=Qe,ye=Ke,ke=pt,X=He,Se=ze,qe=rt,ce=typeof WebGL2RenderingContext<"u"&&H instanceof WebGL2RenderingContext,xe={},pe={},Y={},Ie=-1,re=[];H.canvas.addEventListener("webglcontextlost",function(Le){rt(),Le.preventDefault()},!1),l.set(H,$={gl:H,isWebGL2:ce,getExtension:Qe,withProgram:pt,withTexture:He,withTextureFramebuffer:ze,handleContextLoss:rt})}te($)}function h(q,te,H,$,ce,xe,pe,Y){pe===void 0&&(pe=15),Y===void 0&&(Y=null),u(q,function(Ie){var re=Ie.gl,oe=Ie.withProgram,ye=Ie.withTexture;ye("copy",function(ke,X){re.texImage2D(re.TEXTURE_2D,0,re.RGBA,ce,xe,0,re.RGBA,re.UNSIGNED_BYTE,te),oe("copy",a,o,function(Se){var qe=Se.setUniform,Qe=Se.setAttribute;Qe("aUV",2,re.STATIC_DRAW,0,new Float32Array([0,0,2,0,0,2])),qe("1i","image",X),re.bindFramebuffer(re.FRAMEBUFFER,Y||null),re.disable(re.BLEND),re.colorMask(pe&8,pe&4,pe&2,pe&1),re.viewport(H,$,ce,xe),re.scissor(H,$,ce,xe),re.drawArrays(re.TRIANGLES,0,3)})})})}function d(q,te,H){var $=q.width,ce=q.height;u(q,function(xe){var pe=xe.gl,Y=new Uint8Array($*ce*4);pe.readPixels(0,0,$,ce,pe.RGBA,pe.UNSIGNED_BYTE,Y),q.width=te,q.height=H,h(pe,Y,0,0,$,ce)})}var f=Object.freeze({__proto__:null,withWebGLContext:u,renderImageData:h,resizeWebGLCanvasWithoutClearing:d});function v(q,te,H,$,ce,xe){xe===void 0&&(xe=1);var pe=new Uint8Array(q*te),Y=$[2]-$[0],Ie=$[3]-$[1],re=[];r(H,function(Qe,Ke,pt,He){re.push({x1:Qe,y1:Ke,x2:pt,y2:He,minX:Math.min(Qe,pt),minY:Math.min(Ke,He),maxX:Math.max(Qe,pt),maxY:Math.max(Ke,He)})}),re.sort(function(Qe,Ke){return Qe.maxX-Ke.maxX});for(var oe=0;oe<q;oe++)for(var ye=0;ye<te;ye++){var ke=Se($[0]+Y*(oe+.5)/q,$[1]+Ie*(ye+.5)/te),X=Math.pow(1-Math.abs(ke)/ce,xe)/2;ke<0&&(X=1-X),X=Math.max(0,Math.min(255,Math.round(X*255))),pe[ye*q+oe]=X}return pe;function Se(Qe,Ke){for(var pt=1/0,He=1/0,ze=re.length;ze--;){var rt=re[ze];if(rt.maxX+He<=Qe)break;if(Qe+He>rt.minX&&Ke-He<rt.maxY&&Ke+He>rt.minY){var Le=x(Qe,Ke,rt.x1,rt.y1,rt.x2,rt.y2);Le<pt&&(pt=Le,He=Math.sqrt(pt))}}return qe(Qe,Ke)&&(He=-He),He}function qe(Qe,Ke){for(var pt=0,He=re.length;He--;){var ze=re[He];if(ze.maxX<=Qe)break;var rt=ze.y1>Ke!=ze.y2>Ke&&Qe<(ze.x2-ze.x1)*(Ke-ze.y1)/(ze.y2-ze.y1)+ze.x1;rt&&(pt+=ze.y1<ze.y2?1:-1)}return pt!==0}}function g(q,te,H,$,ce,xe,pe,Y,Ie,re){xe===void 0&&(xe=1),Y===void 0&&(Y=0),Ie===void 0&&(Ie=0),re===void 0&&(re=0),m(q,te,H,$,ce,xe,pe,null,Y,Ie,re)}function m(q,te,H,$,ce,xe,pe,Y,Ie,re,oe){xe===void 0&&(xe=1),Ie===void 0&&(Ie=0),re===void 0&&(re=0),oe===void 0&&(oe=0);for(var ye=v(q,te,H,$,ce,xe),ke=new Uint8Array(ye.length*4),X=0;X<ye.length;X++)ke[X*4+oe]=ye[X];h(pe,ke,Ie,re,q,te,1<<3-oe,Y)}function x(q,te,H,$,ce,xe){var pe=ce-H,Y=xe-$,Ie=pe*pe+Y*Y,re=Ie?Math.max(0,Math.min(1,((q-H)*pe+(te-$)*Y)/Ie)):0,oe=q-(H+re*pe),ye=te-($+re*Y);return oe*oe+ye*ye}var w=Object.freeze({__proto__:null,generate:v,generateIntoCanvas:g,generateIntoFramebuffer:m}),S="precision highp float;uniform vec4 uGlyphBounds;attribute vec2 aUV;attribute vec4 aLineSegment;varying vec4 vLineSegment;varying vec2 vGlyphXY;void main(){vLineSegment=aLineSegment;vGlyphXY=mix(uGlyphBounds.xy,uGlyphBounds.zw,aUV);gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}",b="precision highp float;uniform vec4 uGlyphBounds;uniform float uMaxDistance;uniform float uExponent;varying vec4 vLineSegment;varying vec2 vGlyphXY;float absDistToSegment(vec2 point,vec2 lineA,vec2 lineB){vec2 lineDir=lineB-lineA;float lenSq=dot(lineDir,lineDir);float t=lenSq==0.0 ? 0.0 : clamp(dot(point-lineA,lineDir)/lenSq,0.0,1.0);vec2 linePt=lineA+t*lineDir;return distance(point,linePt);}void main(){vec4 seg=vLineSegment;vec2 p=vGlyphXY;float dist=absDistToSegment(p,seg.xy,seg.zw);float val=pow(1.0-clamp(dist/uMaxDistance,0.0,1.0),uExponent)*0.5;bool crossing=(seg.y>p.y!=seg.w>p.y)&&(p.x<(seg.z-seg.x)*(p.y-seg.y)/(seg.w-seg.y)+seg.x);bool crossingUp=crossing&&vLineSegment.y<vLineSegment.w;gl_FragColor=vec4(crossingUp ? 1.0/255.0 : 0.0,crossing&&!crossingUp ? 1.0/255.0 : 0.0,0.0,val);}",E="precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){vec4 color=texture2D(tex,vUV);bool inside=color.r!=color.g;float val=inside ? 1.0-color.a : color.a;gl_FragColor=vec4(val);}",C=new Float32Array([0,0,2,0,0,2]),P=null,M=!1,L={},z=new WeakMap;function V(q){if(!M&&!K(q))throw new Error("WebGL generation not supported")}function U(q,te,H,$,ce,xe,pe){if(xe===void 0&&(xe=1),pe===void 0&&(pe=null),!pe&&(pe=P,!pe)){var Y=typeof OffscreenCanvas=="function"?new OffscreenCanvas(1,1):typeof document<"u"?document.createElement("canvas"):null;if(!Y)throw new Error("OffscreenCanvas or DOM canvas not supported");pe=P=Y.getContext("webgl",{depth:!1})}V(pe);var Ie=new Uint8Array(q*te*4);u(pe,function(ke){var X=ke.gl,Se=ke.withTexture,qe=ke.withTextureFramebuffer;Se("readable",function(Qe,Ke){X.texImage2D(X.TEXTURE_2D,0,X.RGBA,q,te,0,X.RGBA,X.UNSIGNED_BYTE,null),qe(Qe,Ke,function(pt){F(q,te,H,$,ce,xe,X,pt,0,0,0),X.readPixels(0,0,q,te,X.RGBA,X.UNSIGNED_BYTE,Ie)})})});for(var re=new Uint8Array(q*te),oe=0,ye=0;oe<Ie.length;oe+=4)re[ye++]=Ie[oe];return re}function j(q,te,H,$,ce,xe,pe,Y,Ie,re){xe===void 0&&(xe=1),Y===void 0&&(Y=0),Ie===void 0&&(Ie=0),re===void 0&&(re=0),F(q,te,H,$,ce,xe,pe,null,Y,Ie,re)}function F(q,te,H,$,ce,xe,pe,Y,Ie,re,oe){xe===void 0&&(xe=1),Ie===void 0&&(Ie=0),re===void 0&&(re=0),oe===void 0&&(oe=0),V(pe);var ye=[];r(H,function(ke,X,Se,qe){ye.push(ke,X,Se,qe)}),ye=new Float32Array(ye),u(pe,function(ke){var X=ke.gl,Se=ke.isWebGL2,qe=ke.getExtension,Qe=ke.withProgram,Ke=ke.withTexture,pt=ke.withTextureFramebuffer,He=ke.handleContextLoss;if(Ke("rawDistances",function(ze,rt){(q!==ze._lastWidth||te!==ze._lastHeight)&&X.texImage2D(X.TEXTURE_2D,0,X.RGBA,ze._lastWidth=q,ze._lastHeight=te,0,X.RGBA,X.UNSIGNED_BYTE,null),Qe("main",S,b,function(Le){var k=Le.setAttribute,B=Le.setUniform,G=!Se&&qe("ANGLE_instanced_arrays"),ne=!Se&&qe("EXT_blend_minmax");k("aUV",2,X.STATIC_DRAW,0,C),k("aLineSegment",4,X.DYNAMIC_DRAW,1,ye),B.apply(void 0,["4f","uGlyphBounds"].concat($)),B("1f","uMaxDistance",ce),B("1f","uExponent",xe),pt(ze,rt,function(_e){X.enable(X.BLEND),X.colorMask(!0,!0,!0,!0),X.viewport(0,0,q,te),X.scissor(0,0,q,te),X.blendFunc(X.ONE,X.ONE),X.blendEquationSeparate(X.FUNC_ADD,Se?X.MAX:ne.MAX_EXT),X.clear(X.COLOR_BUFFER_BIT),Se?X.drawArraysInstanced(X.TRIANGLES,0,3,ye.length/4):G.drawArraysInstancedANGLE(X.TRIANGLES,0,3,ye.length/4)})}),Qe("post",a,E,function(Le){Le.setAttribute("aUV",2,X.STATIC_DRAW,0,C),Le.setUniform("1i","tex",rt),X.bindFramebuffer(X.FRAMEBUFFER,Y),X.disable(X.BLEND),X.colorMask(oe===0,oe===1,oe===2,oe===3),X.viewport(Ie,re,q,te),X.scissor(Ie,re,q,te),X.drawArrays(X.TRIANGLES,0,3)})}),X.isContextLost())throw He(),new Error("webgl context lost")})}function K(q){var te=!q||q===P?L:q.canvas||q,H=z.get(te);if(H===void 0){M=!0;var $=null;try{var ce=[97,106,97,61,99,137,118,80,80,118,137,99,61,97,106,97],xe=U(4,4,"M8,8L16,8L24,24L16,24Z",[0,0,32,32],24,1,q);H=xe&&ce.length===xe.length&&xe.every(function(pe,Y){return pe===ce[Y]}),H||($="bad trial run results",console.info(ce,xe))}catch(pe){H=!1,$=pe.message}$&&console.warn("WebGL SDF generation not supported:",$),M=!1,z.set(te,H)}return H}var J=Object.freeze({__proto__:null,generate:U,generateIntoCanvas:j,generateIntoFramebuffer:F,isSupported:K});function se(q,te,H,$,ce,xe){ce===void 0&&(ce=Math.max($[2]-$[0],$[3]-$[1])/2),xe===void 0&&(xe=1);try{return U.apply(J,arguments)}catch(pe){return console.info("WebGL SDF generation failed, falling back to JS",pe),v.apply(w,arguments)}}function le(q,te,H,$,ce,xe,pe,Y,Ie,re){ce===void 0&&(ce=Math.max($[2]-$[0],$[3]-$[1])/2),xe===void 0&&(xe=1),Y===void 0&&(Y=0),Ie===void 0&&(Ie=0),re===void 0&&(re=0);try{return j.apply(J,arguments)}catch(oe){return console.info("WebGL SDF generation failed, falling back to JS",oe),g.apply(w,arguments)}}return e.forEachPathCommand=i,e.generate=se,e.generateIntoCanvas=le,e.javascript=w,e.pathToLineSegments=r,e.webgl=J,e.webglUtils=f,Object.defineProperty(e,"__esModule",{value:!0}),e}({});return s}function aB(){var s=function(e){var t={R:"13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73",EN:"1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9",ES:"17,2,6dp+1,f+1,av,16vr,mx+1,4o,2",ET:"z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj",AN:"16o+5,2j+9,2+1,35,ed,1ff2+9,87+u",CS:"18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b",B:"a,3,f+2,2v,690",S:"9,2,k",WS:"c,k,4f4,1vk+a,u,1j,335",ON:"x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i",BN:"0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1",NSM:"lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n",AL:"16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d",LRO:"6ct",RLO:"6cu",LRE:"6cq",RLE:"6cr",PDF:"6cs",LRI:"6ee",RLI:"6ef",FSI:"6eg",PDI:"6eh"},n={},i={};n.L=1,i[1]="L",Object.keys(t).forEach(function(He,ze){n[He]=1<<ze+1,i[n[He]]=He}),Object.freeze(n);var r=n.LRI|n.RLI|n.FSI,a=n.L|n.R|n.AL,o=n.B|n.S|n.WS|n.ON|n.FSI|n.LRI|n.RLI|n.PDI,l=n.BN|n.RLE|n.LRE|n.RLO|n.LRO|n.PDF,c=n.S|n.WS|n.B|r|n.PDI|l,u=null;function h(){if(!u){u=new Map;var He=function(rt){if(t.hasOwnProperty(rt)){var Le=0;t[rt].split(",").forEach(function(k){var B=k.split("+"),G=B[0],ne=B[1];G=parseInt(G,36),ne=ne?parseInt(ne,36):0,u.set(Le+=G,n[rt]);for(var _e=0;_e<ne;_e++)u.set(++Le,n[rt])})}};for(var ze in t)He(ze)}}function d(He){return h(),u.get(He.codePointAt(0))||n.L}function f(He){return i[d(He)]}var v={pairs:"14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1",canonical:"6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye"};function g(He,ze){var rt=36,Le=0,k=new Map,B=ze&&new Map,G;return He.split(",").forEach(function ne(_e){if(_e.indexOf("+")!==-1)for(var Ye=+_e;Ye--;)ne(G);else{G=_e;var et=_e.split(">"),we=et[0],bt=et[1];we=String.fromCodePoint(Le+=parseInt(we,rt)),bt=String.fromCodePoint(Le+=parseInt(bt,rt)),k.set(we,bt),ze&&B.set(bt,we)}}),{map:k,reverseMap:B}}var m,x,w;function S(){if(!m){var He=g(v.pairs,!0),ze=He.map,rt=He.reverseMap;m=ze,x=rt,w=g(v.canonical,!1).map}}function b(He){return S(),m.get(He)||null}function E(He){return S(),x.get(He)||null}function C(He){return S(),w.get(He)||null}var P=n.L,M=n.R,L=n.EN,z=n.ES,V=n.ET,U=n.AN,j=n.CS,F=n.B,K=n.S,J=n.ON,se=n.BN,le=n.NSM,q=n.AL,te=n.LRO,H=n.RLO,$=n.LRE,ce=n.RLE,xe=n.PDF,pe=n.LRI,Y=n.RLI,Ie=n.FSI,re=n.PDI;function oe(He,ze){for(var rt=125,Le=new Uint32Array(He.length),k=0;k<He.length;k++)Le[k]=d(He[k]);var B=new Map;function G(zi,Fi){var Si=Le[zi];Le[zi]=Fi,B.set(Si,B.get(Si)-1),Si&o&&B.set(o,B.get(o)-1),B.set(Fi,(B.get(Fi)||0)+1),Fi&o&&B.set(o,(B.get(o)||0)+1)}for(var ne=new Uint8Array(He.length),_e=new Map,Ye=[],et=null,we=0;we<He.length;we++)et||Ye.push(et={start:we,end:He.length-1,level:ze==="rtl"?1:ze==="ltr"?0:so(we,!1)}),Le[we]&F&&(et.end=we,et=null);for(var bt=ce|$|H|te|r|re|xe|F,wt=function(zi){return zi+(zi&1?1:2)},tt=function(zi){return zi+(zi&1?2:1)},ee=0;ee<Ye.length;ee++){et=Ye[ee];var We=[{_level:et.level,_override:0,_isolate:0}],Fe=void 0,Oe=0,nt=0,st=0;B.clear();for(var Je=et.start;Je<=et.end;Je++){var ae=Le[Je];if(Fe=We[We.length-1],B.set(ae,(B.get(ae)||0)+1),ae&o&&B.set(o,(B.get(o)||0)+1),ae&bt)if(ae&(ce|$)){ne[Je]=Fe._level;var Ot=(ae===ce?tt:wt)(Fe._level);Ot<=rt&&!Oe&&!nt?We.push({_level:Ot,_override:0,_isolate:0}):Oe||nt++}else if(ae&(H|te)){ne[Je]=Fe._level;var _t=(ae===H?tt:wt)(Fe._level);_t<=rt&&!Oe&&!nt?We.push({_level:_t,_override:ae&H?M:P,_isolate:0}):Oe||nt++}else if(ae&r){ae&Ie&&(ae=so(Je+1,!0)===1?Y:pe),ne[Je]=Fe._level,Fe._override&&G(Je,Fe._override);var Bn=(ae===Y?tt:wt)(Fe._level);Bn<=rt&&Oe===0&&nt===0?(st++,We.push({_level:Bn,_override:0,_isolate:1,_isolInitIndex:Je})):Oe++}else if(ae&re){if(Oe>0)Oe--;else if(st>0){for(nt=0;!We[We.length-1]._isolate;)We.pop();var On=We[We.length-1]._isolInitIndex;On!=null&&(_e.set(On,Je),_e.set(Je,On)),We.pop(),st--}Fe=We[We.length-1],ne[Je]=Fe._level,Fe._override&&G(Je,Fe._override)}else ae&xe?(Oe===0&&(nt>0?nt--:!Fe._isolate&&We.length>1&&(We.pop(),Fe=We[We.length-1])),ne[Je]=Fe._level):ae&F&&(ne[Je]=et.level);else ne[Je]=Fe._level,Fe._override&&ae!==se&&G(Je,Fe._override)}for(var ei=[],Vn=null,En=et.start;En<=et.end;En++){var yi=Le[En];if(!(yi&l)){var dn=ne[En],vn=yi&r,ti=yi===re;Vn&&dn===Vn._level?(Vn._end=En,Vn._endsWithIsolInit=vn):ei.push(Vn={_start:En,_end:En,_level:dn,_startsWithPDI:ti,_endsWithIsolInit:vn})}}for(var qt=[],_=0;_<ei.length;_++){var Ae=ei[_];if(!Ae._startsWithPDI||Ae._startsWithPDI&&!_e.has(Ae._start)){for(var Be=[Vn=Ae],Ce=void 0;Vn&&Vn._endsWithIsolInit&&(Ce=_e.get(Vn._end))!=null;)for(var Ee=_+1;Ee<ei.length;Ee++)if(ei[Ee]._start===Ce){Be.push(Vn=ei[Ee]);break}for(var Ct=[],Nt=0;Nt<Be.length;Nt++)for(var I=Be[Nt],N=I._start;N<=I._end;N++)Ct.push(N);for(var Q=ne[Ct[0]],de=et.level,Re=Ct[0]-1;Re>=0;Re--)if(!(Le[Re]&l)){de=ne[Re];break}var Pe=Ct[Ct.length-1],it=ne[Pe],at=et.level;if(!(Le[Pe]&r)){for(var lt=Pe+1;lt<=et.end;lt++)if(!(Le[lt]&l)){at=ne[lt];break}}qt.push({_seqIndices:Ct,_sosType:Math.max(de,Q)%2?M:P,_eosType:Math.max(at,it)%2?M:P})}}for(var je=0;je<qt.length;je++){var Ze=qt[je],Xe=Ze._seqIndices,ct=Ze._sosType,Et=Ze._eosType,zt=ne[Xe[0]]&1?M:P;if(B.get(le))for(var At=0;At<Xe.length;At++){var Pt=Xe[At];if(Le[Pt]&le){for(var Dt=ct,rn=At-1;rn>=0;rn--)if(!(Le[Xe[rn]]&l)){Dt=Le[Xe[rn]];break}G(Pt,Dt&(r|re)?J:Dt)}}if(B.get(L))for(var on=0;on<Xe.length;on++){var yn=Xe[on];if(Le[yn]&L)for(var Rt=on-1;Rt>=-1;Rt--){var Jt=Rt===-1?ct:Le[Xe[Rt]];if(Jt&a){Jt===q&&G(yn,U);break}}}if(B.get(q))for(var Rn=0;Rn<Xe.length;Rn++){var xi=Xe[Rn];Le[xi]&q&&G(xi,M)}if(B.get(z)||B.get(j))for(var kt=1;kt<Xe.length-1;kt++){var Kt=Xe[kt];if(Le[Kt]&(z|j)){for(var Yt=0,ni=0,sr=kt-1;sr>=0&&(Yt=Le[Xe[sr]],!!(Yt&l));sr--);for(var wi=kt+1;wi<Xe.length&&(ni=Le[Xe[wi]],!!(ni&l));wi++);Yt===ni&&(Le[Kt]===z?Yt===L:Yt&(L|U))&&G(Kt,Yt)}}if(B.get(L))for(var ii=0;ii<Xe.length;ii++){var Fh=Xe[ii];if(Le[Fh]&L){for(var fs=ii-1;fs>=0&&Le[Xe[fs]]&(V|l);fs--)G(Xe[fs],L);for(ii++;ii<Xe.length&&Le[Xe[ii]]&(V|l|L);ii++)Le[Xe[ii]]!==L&&G(Xe[ii],L)}}if(B.get(V)||B.get(z)||B.get(j))for(var aa=0;aa<Xe.length;aa++){var oa=Xe[aa];if(Le[oa]&(V|z|j)){G(oa,J);for(var Ya=aa-1;Ya>=0&&Le[Xe[Ya]]&l;Ya--)G(Xe[Ya],J);for(var nl=aa+1;nl<Xe.length&&Le[Xe[nl]]&l;nl++)G(Xe[nl],J)}}if(B.get(L))for(var sn=0,il=ct;sn<Xe.length;sn++){var Uh=Xe[sn],qc=Le[Uh];qc&L?il===P&&G(Uh,P):qc&a&&(il=qc)}if(B.get(o)){var fi=M|L|U,ps=fi|P,ms=[];{for(var ji=[],gs=0;gs<Xe.length;gs++)if(Le[Xe[gs]]&o){var la=He[Xe[gs]],Wn=void 0;if(b(la)!==null)if(ji.length<63)ji.push({char:la,seqIndex:gs});else break;else if((Wn=E(la))!==null)for(var Ni=ji.length-1;Ni>=0;Ni--){var vs=ji[Ni].char;if(vs===Wn||vs===E(C(la))||b(C(vs))===la){ms.push([ji[Ni].seqIndex,gs]),ji.length=Ni;break}}}ms.sort(function(zi,Fi){return zi[0]-Fi[0]})}for(var ys=0;ys<ms.length;ys++){for(var rl=ms[ys],ar=rl[0],jc=rl[1],or=!1,Qi=0,sl=ar+1;sl<jc;sl++){var al=Xe[sl];if(Le[al]&ps){or=!0;var ca=Le[al]&fi?M:P;if(ca===zt){Qi=ca;break}}}if(or&&!Qi){Qi=ct;for(var Za=ar-1;Za>=0;Za--){var Qc=Xe[Za];if(Le[Qc]&ps){var kh=Le[Qc]&fi?M:P;kh!==zt?Qi=kh:Qi=zt;break}}}if(Qi){if(Le[Xe[ar]]=Le[Xe[jc]]=Qi,Qi!==zt){for(var Or=ar+1;Or<Xe.length;Or++)if(!(Le[Xe[Or]]&l)){d(He[Xe[Or]])&le&&(Le[Xe[Or]]=Qi);break}}if(Qi!==zt){for(var $a=jc+1;$a<Xe.length;$a++)if(!(Le[Xe[$a]]&l)){d(He[Xe[$a]])&le&&(Le[Xe[$a]]=Qi);break}}}}for(var Jr=0;Jr<Xe.length;Jr++)if(Le[Xe[Jr]]&o){for(var eo=Jr,ua=Jr,to=ct,no=Jr-1;no>=0;no--)if(Le[Xe[no]]&l)eo=no;else{to=Le[Xe[no]]&fi?M:P;break}for(var _h=Et,io=Jr+1;io<Xe.length;io++)if(Le[Xe[io]]&(o|l))ua=io;else{_h=Le[Xe[io]]&fi?M:P;break}for(var ro=eo;ro<=ua;ro++)Le[Xe[ro]]=to===_h?to:zt;Jr=ua}}}for(var Ei=et.start;Ei<=et.end;Ei++){var Vh=ne[Ei],xs=Le[Ei];if(Vh&1?xs&(P|L|U)&&ne[Ei]++:xs&M?ne[Ei]++:xs&(U|L)&&(ne[Ei]+=2),xs&l&&(ne[Ei]=Ei===0?et.level:ne[Ei-1]),Ei===et.end||d(He[Ei])&(K|F))for(var ws=Ei;ws>=0&&d(He[ws])&c;ws--)ne[ws]=et.level}}return{levels:ne,paragraphs:Ye};function so(zi,Fi){for(var Si=zi;Si<He.length;Si++){var yr=Le[Si];if(yr&(M|q))return 1;if(yr&(F|P)||Fi&&yr===re)return 0;if(yr&r){var ol=Gh(Si);Si=ol===-1?He.length:ol}}return 0}function Gh(zi){for(var Fi=1,Si=zi+1;Si<He.length;Si++){var yr=Le[Si];if(yr&F)break;if(yr&re){if(--Fi===0)return Si}else yr&r&&Fi++}return-1}}var ye="14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1",ke;function X(){if(!ke){var He=g(ye,!0),ze=He.map,rt=He.reverseMap;rt.forEach(function(Le,k){ze.set(k,Le)}),ke=ze}}function Se(He){return X(),ke.get(He)||null}function qe(He,ze,rt,Le){var k=He.length;rt=Math.max(0,rt==null?0:+rt),Le=Math.min(k-1,Le==null?k-1:+Le);for(var B=new Map,G=rt;G<=Le;G++)if(ze[G]&1){var ne=Se(He[G]);ne!==null&&B.set(G,ne)}return B}function Qe(He,ze,rt,Le){var k=He.length;rt=Math.max(0,rt==null?0:+rt),Le=Math.min(k-1,Le==null?k-1:+Le);var B=[];return ze.paragraphs.forEach(function(G){var ne=Math.max(rt,G.start),_e=Math.min(Le,G.end);if(ne<_e){for(var Ye=ze.levels.slice(ne,_e+1),et=_e;et>=ne&&d(He[et])&c;et--)Ye[et]=G.level;for(var we=G.level,bt=1/0,wt=0;wt<Ye.length;wt++){var tt=Ye[wt];tt>we&&(we=tt),tt<bt&&(bt=tt|1)}for(var ee=we;ee>=bt;ee--)for(var We=0;We<Ye.length;We++)if(Ye[We]>=ee){for(var Fe=We;We+1<Ye.length&&Ye[We+1]>=ee;)We++;We>Fe&&B.push([Fe+ne,We+ne])}}}),B}function Ke(He,ze,rt,Le){var k=pt(He,ze,rt,Le),B=[].concat(He);return k.forEach(function(G,ne){B[ne]=(ze.levels[G]&1?Se(He[G]):null)||He[G]}),B.join("")}function pt(He,ze,rt,Le){for(var k=Qe(He,ze,rt,Le),B=[],G=0;G<He.length;G++)B[G]=G;return k.forEach(function(ne){for(var _e=ne[0],Ye=ne[1],et=B.slice(_e,Ye+1),we=et.length;we--;)B[Ye-we]=et[we]}),B}return e.closingToOpeningBracket=E,e.getBidiCharType=d,e.getBidiCharTypeName=f,e.getCanonicalBracket=C,e.getEmbeddingLevels=oe,e.getMirroredCharacter=Se,e.getMirroredCharactersMap=qe,e.getReorderSegments=Qe,e.getReorderedIndices=pt,e.getReorderedString=Ke,e.openingToClosingBracket=b,Object.defineProperty(e,"__esModule",{value:!0}),e}({});return s}const V1=/\bvoid\s+main\s*\(\s*\)\s*{/g;function ov(s){const e=/^[ \t]*#include +<([\w\d./]+)>/gm;function t(n,i){let r=tn[i];return r?ov(r):n}return s.replace(e,t)}const Ii=[];for(let s=0;s<256;s++)Ii[s]=(s<16?"0":"")+s.toString(16);function oB(){const s=Math.random()*4294967295|0,e=Math.random()*4294967295|0,t=Math.random()*4294967295|0,n=Math.random()*4294967295|0;return(Ii[s&255]+Ii[s>>8&255]+Ii[s>>16&255]+Ii[s>>24&255]+"-"+Ii[e&255]+Ii[e>>8&255]+"-"+Ii[e>>16&15|64]+Ii[e>>24&255]+"-"+Ii[t&63|128]+Ii[t>>8&255]+"-"+Ii[t>>16&255]+Ii[t>>24&255]+Ii[n&255]+Ii[n>>8&255]+Ii[n>>16&255]+Ii[n>>24&255]).toUpperCase()}const go=Object.assign||function(){let s=arguments[0];for(let e=1,t=arguments.length;e<t;e++){let n=arguments[e];if(n)for(let i in n)Object.prototype.hasOwnProperty.call(n,i)&&(s[i]=n[i])}return s},lB=Date.now(),$x=new WeakMap,ew=new Map;let cB=1e10;function lv(s,e){const t=fB(e);let n=$x.get(s);if(n||$x.set(s,n=Object.create(null)),n[t])return new n[t];const i=`_onBeforeCompile${t}`,r=function(c,u){s.onBeforeCompile.call(this,c,u);const h=this.customProgramCacheKey()+"|"+c.vertexShader+"|"+c.fragmentShader;let d=ew[h];if(!d){const f=uB(this,c,e,t);d=ew[h]=f}c.vertexShader=d.vertexShader,c.fragmentShader=d.fragmentShader,go(c.uniforms,this.uniforms),e.timeUniform&&(c.uniforms[e.timeUniform]={get value(){return Date.now()-lB}}),this[i]&&this[i](c)},a=function(){return o(e.chained?s:s.clone())},o=function(c){const u=Object.create(c,l);return Object.defineProperty(u,"baseMaterial",{value:s}),Object.defineProperty(u,"id",{value:cB++}),u.uuid=oB(),u.uniforms=go({},c.uniforms,e.uniforms),u.defines=go({},c.defines,e.defines),u.defines[`TROIKA_DERIVED_MATERIAL_${t}`]="",u.extensions=go({},c.extensions,e.extensions),u._listeners=void 0,u},l={constructor:{value:a},isDerivedMaterial:{value:!0},customProgramCacheKey:{writable:!0,configurable:!0,value:function(){return s.customProgramCacheKey()+"|"+t}},onBeforeCompile:{get(){return r},set(c){this[i]=c}},copy:{writable:!0,configurable:!0,value:function(c){return s.copy.call(this,c),!s.isShaderMaterial&&!s.isDerivedMaterial&&(go(this.extensions,c.extensions),go(this.defines,c.defines),go(this.uniforms,Ga.clone(c.uniforms))),this}},clone:{writable:!0,configurable:!0,value:function(){const c=new s.constructor;return o(c).copy(this)}},getDepthMaterial:{writable:!0,configurable:!0,value:function(){let c=this._depthMaterial;return c||(c=this._depthMaterial=lv(s.isDerivedMaterial?s.getDepthMaterial():new Ah({depthPacking:Ko}),e),c.defines.IS_DEPTH_MATERIAL="",c.uniforms=this.uniforms),c}},getDistanceMaterial:{writable:!0,configurable:!0,value:function(){let c=this._distanceMaterial;return c||(c=this._distanceMaterial=lv(s.isDerivedMaterial?s.getDistanceMaterial():new Op,e),c.defines.IS_DISTANCE_MATERIAL="",c.uniforms=this.uniforms),c}},dispose:{writable:!0,configurable:!0,value(){const{_depthMaterial:c,_distanceMaterial:u}=this;c&&c.dispose(),u&&u.dispose(),s.dispose.call(this)}}};return n[t]=a,new a}function uB(s,{vertexShader:e,fragmentShader:t},n,i){let{vertexDefs:r,vertexMainIntro:a,vertexMainOutro:o,vertexTransform:l,fragmentDefs:c,fragmentMainIntro:u,fragmentMainOutro:h,fragmentColorTransform:d,customRewriter:f,timeUniform:v}=n;if(r=r||"",a=a||"",o=o||"",c=c||"",u=u||"",h=h||"",(l||f)&&(e=ov(e)),(d||f)&&(t=t.replace(/^[ \t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm,`
//!BEGIN_POST_CHUNK $1
$&
//!END_POST_CHUNK
`),t=ov(t)),f){let g=f({vertexShader:e,fragmentShader:t});e=g.vertexShader,t=g.fragmentShader}if(d){let g=[];t=t.replace(/^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm,m=>(g.push(m),"")),h=`${d}
${g.join(`
`)}
${h}`}if(v){const g=`
uniform float ${v};
`;r=g+r,c=g+c}return l&&(e=`vec3 troika_position_${i};
vec3 troika_normal_${i};
vec2 troika_uv_${i};
${e}
`,r=`${r}
void troikaVertexTransform${i}(inout vec3 position, inout vec3 normal, inout vec2 uv) {
  ${l}
}
`,a=`
troika_position_${i} = vec3(position);
troika_normal_${i} = vec3(normal);
troika_uv_${i} = vec2(uv);
troikaVertexTransform${i}(troika_position_${i}, troika_normal_${i}, troika_uv_${i});
${a}
`,e=e.replace(/\b(position|normal|uv)\b/g,(g,m,x,w)=>/\battribute\s+vec[23]\s+$/.test(w.substr(0,x))?m:`troika_${m}_${i}`),s.map&&s.map.channel>0||(e=e.replace(/\bMAP_UV\b/g,`troika_uv_${i}`))),e=tw(e,i,r,a,o),t=tw(t,i,c,u,h),{vertexShader:e,fragmentShader:t}}function tw(s,e,t,n,i){return(n||i||t)&&(s=s.replace(V1,`
${t}
void troikaOrigMain${e}() {`),s+=`
void main() {
  ${n}
  troikaOrigMain${e}();
  ${i}
}`),s}function hB(s,e){return s==="uniforms"?void 0:typeof e=="function"?e.toString():e}let dB=0;const nw=new Map;function fB(s){const e=JSON.stringify(s,hB);let t=nw.get(e);return t==null&&nw.set(e,t=++dB),t}function pB(s,e,t){const{defaultFontURL:n}=t,i=Object.create(null),r=1/0,a=/[\u00AD\u034F\u061C\u115F-\u1160\u17B4-\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8]/,o="[^\\S\\u00A0]",l=new RegExp(`${o}|[\\-\\u007C\\u00AD\\u2010\\u2012-\\u2014\\u2027\\u2056\\u2E17\\u2E40]`);function c(w,S){function b(){const E=C=>{console.error(`Failure loading font ${w}${w===n?"":"; trying fallback"}`,C),w!==n&&(w=n,b())};try{const C=new XMLHttpRequest;C.open("get",w,!0),C.responseType="arraybuffer",C.onload=function(){if(C.status>=400)E(new Error(C.statusText));else if(C.status>0)try{const P=s(C.response);S(P)}catch(P){E(P)}},C.onerror=E,C.send()}catch(C){E(C)}}b()}function u(w,S){w||(w=n);let b=i[w];b?b.pending?b.pending.push(S):S(b):(i[w]={pending:[S]},c(w,E=>{let C=i[w].pending;i[w]=E,C.forEach(P=>P(E))}))}function h({text:w="",font:S=n,sdfGlyphSize:b=64,fontSize:E=1,letterSpacing:C=0,lineHeight:P="normal",maxWidth:M=r,direction:L,textAlign:z="left",textIndent:V=0,whiteSpace:U="normal",overflowWrap:j="normal",anchorX:F=0,anchorY:K=0,includeCaretPositions:J=!1,chunkedBoundsSize:se=8192,colorRanges:le=null},q,te=!1){const H=g(),$={fontLoad:0,typesetting:0};w.indexOf("\r")>-1&&(console.info("Typesetter: got text with \\r chars; normalizing to \\n"),w=w.replace(/\r\n/g,`
`).replace(/\r/g,`
`)),E=+E,C=+C,M=+M,P=P||"normal",V=+V,u(S,ce=>{const xe=isFinite(M);let pe=null,Y=null,Ie=null,re=null,oe=null,ye=null,ke=null,X=0,Se=0,qe=U!=="nowrap";const{ascender:Qe,descender:Ke,unitsPerEm:pt,lineGap:He,capHeight:ze,xHeight:rt}=ce;$.fontLoad=g()-H;const Le=g(),k=E/pt;P==="normal"&&(P=(Qe-Ke+He)/pt),P=P*E;const B=(P-(Qe-Ke)*k)/2,G=-(Qe*k+B),ne=Math.min(P,(Qe-Ke)*k),_e=(Qe+Ke)/2*k-ne/2;let Ye=V,et=new m;const we=[et];ce.forEachGlyph(w,E,C,(tt,ee,We)=>{const Fe=w.charAt(We),Oe=tt.advanceWidth*k,nt=et.count;let st;if("isEmpty"in tt||(tt.isWhitespace=!!Fe&&new RegExp(o).test(Fe),tt.canBreakAfter=!!Fe&&l.test(Fe),tt.isEmpty=tt.xMin===tt.xMax||tt.yMin===tt.yMax||a.test(Fe)),!tt.isWhitespace&&!tt.isEmpty&&Se++,qe&&xe&&!tt.isWhitespace&&ee+Oe+Ye>M&&nt){if(et.glyphAt(nt-1).glyphObj.canBreakAfter)st=new m,Ye=-ee;else for(let ae=nt;ae--;)if(ae===0&&j==="break-word"){st=new m,Ye=-ee;break}else if(et.glyphAt(ae).glyphObj.canBreakAfter){st=et.splitAt(ae+1);const Ot=st.glyphAt(0).x;Ye-=Ot;for(let _t=st.count;_t--;)st.glyphAt(_t).x-=Ot;break}st&&(et.isSoftWrapped=!0,et=st,we.push(et),X=M)}let Je=et.glyphAt(et.count);Je.glyphObj=tt,Je.x=ee+Ye,Je.width=Oe,Je.charIndex=We,Fe===`
`&&(et=new m,we.push(et),Ye=-(ee+Oe+C*E)+V)}),we.forEach(tt=>{for(let ee=tt.count;ee--;){let{glyphObj:We,x:Fe,width:Oe}=tt.glyphAt(ee);if(!We.isWhitespace){tt.width=Fe+Oe,tt.width>X&&(X=tt.width);return}}});let bt=0,wt=0;if(F&&(typeof F=="number"?bt=-F:typeof F=="string"&&(bt=-X*(F==="left"?0:F==="center"?.5:F==="right"?1:f(F)))),K){if(typeof K=="number")wt=-K;else if(typeof K=="string"){let tt=we.length*P;wt=K==="top"?0:K==="top-baseline"?-G:K==="top-cap"?-G-ze*k:K==="top-ex"?-G-rt*k:K==="middle"?tt/2:K==="bottom"?tt:K==="bottom-baseline"?tt-B+Ke*k:f(K)*tt}}if(!te){const tt=e.getEmbeddingLevels(w,L);pe=new Uint16Array(Se),Y=new Float32Array(Se*2),Ie={},ye=[r,r,-r,-r],ke=[];let ee=G;J&&(oe=new Float32Array(w.length*3)),le&&(re=new Uint8Array(Se*3));let We=0,Fe=-1,Oe=-1,nt,st;if(we.forEach((Je,ae)=>{let{count:Ot,width:_t}=Je;if(Ot>0){let Bn=0;for(let dn=Ot;dn--&&Je.glyphAt(dn).glyphObj.isWhitespace;)Bn++;let On=0,ei=0;if(z==="center")On=(X-_t)/2;else if(z==="right")On=X-_t;else if(z==="justify"&&Je.isSoftWrapped){let dn=0;for(let vn=Ot-Bn;vn--;)Je.glyphAt(vn).glyphObj.isWhitespace&&dn++;ei=(X-_t)/dn}if(ei||On){let dn=0;for(let vn=0;vn<Ot;vn++){let ti=Je.glyphAt(vn);const qt=ti.glyphObj;ti.x+=On+dn,ei!==0&&qt.isWhitespace&&vn<Ot-Bn&&(dn+=ei,ti.width+=ei)}}const Vn=e.getReorderSegments(w,tt,Je.glyphAt(0).charIndex,Je.glyphAt(Je.count-1).charIndex);for(let dn=0;dn<Vn.length;dn++){const[vn,ti]=Vn[dn];let qt=1/0,_=-1/0;for(let Ae=0;Ae<Ot;Ae++)if(Je.glyphAt(Ae).charIndex>=vn){let Be=Ae,Ce=Ae;for(;Ce<Ot;Ce++){let Ee=Je.glyphAt(Ce);if(Ee.charIndex>ti)break;Ce<Ot-Bn&&(qt=Math.min(qt,Ee.x),_=Math.max(_,Ee.x+Ee.width))}for(let Ee=Be;Ee<Ce;Ee++){const Ct=Je.glyphAt(Ee);Ct.x=_-(Ct.x+Ct.width-qt)}break}}let En;const yi=dn=>En=dn;for(let dn=0;dn<Ot;dn++){let vn=Je.glyphAt(dn);En=vn.glyphObj;const ti=En.index,qt=tt.levels[vn.charIndex]&1;if(qt){const _=e.getMirroredCharacter(w[vn.charIndex]);_&&ce.forEachGlyph(_,0,0,yi)}if(J){const{charIndex:_}=vn,Ae=vn.x+bt,Be=vn.x+vn.width+bt;oe[_*3]=qt?Be:Ae,oe[_*3+1]=qt?Ae:Be,oe[_*3+2]=ee+_e+wt;const Ce=_-Fe;Ce>1&&v(oe,Fe,Ce),Fe=_}if(le){const{charIndex:_}=vn;for(;_>Oe;)Oe++,le.hasOwnProperty(Oe)&&(st=le[Oe])}if(!En.isWhitespace&&!En.isEmpty){const _=We++;Ie[ti]||(Ie[ti]={path:En.path,pathBounds:[En.xMin,En.yMin,En.xMax,En.yMax]});const Ae=vn.x+bt,Be=ee+wt;Y[_*2]=Ae,Y[_*2+1]=Be;const Ce=Ae+En.xMin*k,Ee=Be+En.yMin*k,Ct=Ae+En.xMax*k,Nt=Be+En.yMax*k;Ce<ye[0]&&(ye[0]=Ce),Ee<ye[1]&&(ye[1]=Ee),Ct>ye[2]&&(ye[2]=Ct),Nt>ye[3]&&(ye[3]=Nt),_%se===0&&(nt={start:_,end:_,rect:[r,r,-r,-r]},ke.push(nt)),nt.end++;const I=nt.rect;if(Ce<I[0]&&(I[0]=Ce),Ee<I[1]&&(I[1]=Ee),Ct>I[2]&&(I[2]=Ct),Nt>I[3]&&(I[3]=Nt),pe[_]=ti,le){const N=_*3;re[N]=st>>16&255,re[N+1]=st>>8&255,re[N+2]=st&255}}}}ee-=P}),oe){const Je=w.length-Fe;Je>1&&v(oe,Fe,Je)}}$.typesetting=g()-Le,q({glyphIds:pe,glyphPositions:Y,glyphData:Ie,caretPositions:oe,caretHeight:ne,glyphColors:re,chunkedBounds:ke,fontSize:E,unitsPerEm:pt,ascender:Qe*k,descender:Ke*k,capHeight:ze*k,xHeight:rt*k,lineHeight:P,topBaseline:G,blockBounds:[bt,wt-we.length*P,bt+X,wt],visibleBounds:ye,timings:$})})}function d(w,S){h(w,b=>{const[E,C,P,M]=b.blockBounds;S({width:P-E,height:M-C})},{})}function f(w){let S=w.match(/^([\d.]+)%$/),b=S?parseFloat(S[1]):NaN;return isNaN(b)?0:b/100}function v(w,S,b){const E=w[S*3],C=w[S*3+1],P=w[S*3+2],M=(C-E)/b;for(let L=0;L<b;L++){const z=(S+L)*3;w[z]=E+M*L,w[z+1]=E+M*(L+1),w[z+2]=P}}function g(){return(self.performance||Date).now()}function m(){this.data=[]}const x=["glyphObj","x","width","charIndex"];return m.prototype={width:0,isSoftWrapped:!1,get count(){return Math.ceil(this.data.length/x.length)},glyphAt(w){let S=m.flyweight;return S.data=this.data,S.index=w,S},splitAt(w){let S=new m;return S.data=this.data.splice(w*x.length),S}},m.flyweight=x.reduce((w,S,b,E)=>(Object.defineProperty(w,S,{get(){return this.data[this.index*x.length+b]},set(C){this.data[this.index*x.length+b]=C}}),w),{data:null,index:0}),{typeset:h,measure:d,loadFont:u}}const _o=()=>(self.performance||Date).now(),Hp=_1();let iw;function mB(s,e,t,n,i,r,a,o,l,c,u=!0){return u?vB(s,e,t,n,i,r,a,o,l,c).then(null,h=>(iw||(console.warn("WebGL SDF generation failed, falling back to JS",h),iw=!0),sw(s,e,t,n,i,r,a,o,l,c))):sw(s,e,t,n,i,r,a,o,l,c)}const Af=[],gB=5;let cv=0;function G1(){const s=_o();for(;Af.length&&_o()-s<gB;)Af.shift()();cv=Af.length?setTimeout(G1,0):0}const vB=(...s)=>new Promise((e,t)=>{Af.push(()=>{const n=_o();try{Hp.webgl.generateIntoCanvas(...s),e({timing:_o()-n})}catch(i){t(i)}}),cv||(cv=setTimeout(G1,0))}),yB=4,xB=2e3,rw={};let wB=0;function sw(s,e,t,n,i,r,a,o,l,c){const u="TroikaTextSDFGenerator_JS_"+wB++%yB;let h=rw[u];return h||(h=rw[u]={workerModule:Lh({name:u,workerId:u,dependencies:[_1,_o],init(d,f){const v=d().javascript.generate;return function(...g){const m=f();return{textureData:v(...g),timing:f()-m}}},getTransferables(d){return[d.textureData.buffer]}}),requests:0,idleTimer:null}),h.requests++,clearTimeout(h.idleTimer),h.workerModule(s,e,t,n,i,r).then(({textureData:d,timing:f})=>{const v=_o(),g=new Uint8Array(d.length*4);for(let m=0;m<d.length;m++)g[m*4+c]=d[m];return Hp.webglUtils.renderImageData(a,g,o,l,s,e,1<<3-c),f+=_o()-v,--h.requests===0&&(h.idleTimer=setTimeout(()=>{rB(u)},xB)),{timing:f}})}function SB(s){s._warm||(Hp.webgl.isSupported(s),s._warm=!0)}const bB=Hp.webglUtils.resizeWebGLCanvasWithoutClearing;/*!
Custom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.
Original MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE
*/function AB(){return typeof window>"u"&&(self.window=self),function(s){var e={parse:function(i){var r=e._bin,a=new Uint8Array(i);if(r.readASCII(a,0,4)=="ttcf"){var o=4;r.readUshort(a,o),o+=2,r.readUshort(a,o),o+=2;var l=r.readUint(a,o);o+=4;for(var c=[],u=0;u<l;u++){var h=r.readUint(a,o);o+=4,c.push(e._readFont(a,h))}return c}return[e._readFont(a,0)]},_readFont:function(i,r){var a=e._bin,o=r;a.readFixed(i,r),r+=4;var l=a.readUshort(i,r);r+=2,a.readUshort(i,r),r+=2,a.readUshort(i,r),r+=2,a.readUshort(i,r),r+=2;for(var c=["cmap","head","hhea","maxp","hmtx","name","OS/2","post","loca","glyf","kern","CFF ","GPOS","GSUB","SVG "],u={_data:i,_offset:o},h={},d=0;d<l;d++){var f=a.readASCII(i,r,4);r+=4,a.readUint(i,r),r+=4;var v=a.readUint(i,r);r+=4;var g=a.readUint(i,r);r+=4,h[f]={offset:v,length:g}}for(d=0;d<c.length;d++){var m=c[d];h[m]&&(u[m.trim()]=e[m.trim()].parse(i,h[m].offset,h[m].length,u))}return u},_tabOffset:function(i,r,a){for(var o=e._bin,l=o.readUshort(i,a+4),c=a+12,u=0;u<l;u++){var h=o.readASCII(i,c,4);c+=4,o.readUint(i,c),c+=4;var d=o.readUint(i,c);if(c+=4,o.readUint(i,c),c+=4,h==r)return d}return 0}};e._bin={readFixed:function(i,r){return(i[r]<<8|i[r+1])+(i[r+2]<<8|i[r+3])/65540},readF2dot14:function(i,r){return e._bin.readShort(i,r)/16384},readInt:function(i,r){return e._bin._view(i).getInt32(r)},readInt8:function(i,r){return e._bin._view(i).getInt8(r)},readShort:function(i,r){return e._bin._view(i).getInt16(r)},readUshort:function(i,r){return e._bin._view(i).getUint16(r)},readUshorts:function(i,r,a){for(var o=[],l=0;l<a;l++)o.push(e._bin.readUshort(i,r+2*l));return o},readUint:function(i,r){return e._bin._view(i).getUint32(r)},readUint64:function(i,r){return 4294967296*e._bin.readUint(i,r)+e._bin.readUint(i,r+4)},readASCII:function(i,r,a){for(var o="",l=0;l<a;l++)o+=String.fromCharCode(i[r+l]);return o},readUnicode:function(i,r,a){for(var o="",l=0;l<a;l++){var c=i[r++]<<8|i[r++];o+=String.fromCharCode(c)}return o},_tdec:typeof window<"u"&&window.TextDecoder?new window.TextDecoder:null,readUTF8:function(i,r,a){var o=e._bin._tdec;return o&&r==0&&a==i.length?o.decode(i):e._bin.readASCII(i,r,a)},readBytes:function(i,r,a){for(var o=[],l=0;l<a;l++)o.push(i[r+l]);return o},readASCIIArray:function(i,r,a){for(var o=[],l=0;l<a;l++)o.push(String.fromCharCode(i[r+l]));return o},_view:function(i){return i._dataView||(i._dataView=i.buffer?new DataView(i.buffer,i.byteOffset,i.byteLength):new DataView(new Uint8Array(i).buffer))}},e._lctf={},e._lctf.parse=function(i,r,a,o,l){var c=e._bin,u={},h=r;c.readFixed(i,r),r+=4;var d=c.readUshort(i,r);r+=2;var f=c.readUshort(i,r);r+=2;var v=c.readUshort(i,r);return r+=2,u.scriptList=e._lctf.readScriptList(i,h+d),u.featureList=e._lctf.readFeatureList(i,h+f),u.lookupList=e._lctf.readLookupList(i,h+v,l),u},e._lctf.readLookupList=function(i,r,a){var o=e._bin,l=r,c=[],u=o.readUshort(i,r);r+=2;for(var h=0;h<u;h++){var d=o.readUshort(i,r);r+=2;var f=e._lctf.readLookupTable(i,l+d,a);c.push(f)}return c},e._lctf.readLookupTable=function(i,r,a){var o=e._bin,l=r,c={tabs:[]};c.ltype=o.readUshort(i,r),r+=2,c.flag=o.readUshort(i,r),r+=2;var u=o.readUshort(i,r);r+=2;for(var h=c.ltype,d=0;d<u;d++){var f=o.readUshort(i,r);r+=2;var v=a(i,h,l+f,c);c.tabs.push(v)}return c},e._lctf.numOfOnes=function(i){for(var r=0,a=0;a<32;a++)(i>>>a&1)!=0&&r++;return r},e._lctf.readClassDef=function(i,r){var a=e._bin,o=[],l=a.readUshort(i,r);if(r+=2,l==1){var c=a.readUshort(i,r);r+=2;var u=a.readUshort(i,r);r+=2;for(var h=0;h<u;h++)o.push(c+h),o.push(c+h),o.push(a.readUshort(i,r)),r+=2}if(l==2){var d=a.readUshort(i,r);for(r+=2,h=0;h<d;h++)o.push(a.readUshort(i,r)),r+=2,o.push(a.readUshort(i,r)),r+=2,o.push(a.readUshort(i,r)),r+=2}return o},e._lctf.getInterval=function(i,r){for(var a=0;a<i.length;a+=3){var o=i[a],l=i[a+1];if(i[a+2],o<=r&&r<=l)return a}return-1},e._lctf.readCoverage=function(i,r){var a=e._bin,o={};o.fmt=a.readUshort(i,r),r+=2;var l=a.readUshort(i,r);return r+=2,o.fmt==1&&(o.tab=a.readUshorts(i,r,l)),o.fmt==2&&(o.tab=a.readUshorts(i,r,3*l)),o},e._lctf.coverageIndex=function(i,r){var a=i.tab;if(i.fmt==1)return a.indexOf(r);if(i.fmt==2){var o=e._lctf.getInterval(a,r);if(o!=-1)return a[o+2]+(r-a[o])}return-1},e._lctf.readFeatureList=function(i,r){var a=e._bin,o=r,l=[],c=a.readUshort(i,r);r+=2;for(var u=0;u<c;u++){var h=a.readASCII(i,r,4);r+=4;var d=a.readUshort(i,r);r+=2;var f=e._lctf.readFeatureTable(i,o+d);f.tag=h.trim(),l.push(f)}return l},e._lctf.readFeatureTable=function(i,r){var a=e._bin,o=r,l={},c=a.readUshort(i,r);r+=2,c>0&&(l.featureParams=o+c);var u=a.readUshort(i,r);r+=2,l.tab=[];for(var h=0;h<u;h++)l.tab.push(a.readUshort(i,r+2*h));return l},e._lctf.readScriptList=function(i,r){var a=e._bin,o=r,l={},c=a.readUshort(i,r);r+=2;for(var u=0;u<c;u++){var h=a.readASCII(i,r,4);r+=4;var d=a.readUshort(i,r);r+=2,l[h.trim()]=e._lctf.readScriptTable(i,o+d)}return l},e._lctf.readScriptTable=function(i,r){var a=e._bin,o=r,l={},c=a.readUshort(i,r);r+=2,l.default=e._lctf.readLangSysTable(i,o+c);var u=a.readUshort(i,r);r+=2;for(var h=0;h<u;h++){var d=a.readASCII(i,r,4);r+=4;var f=a.readUshort(i,r);r+=2,l[d.trim()]=e._lctf.readLangSysTable(i,o+f)}return l},e._lctf.readLangSysTable=function(i,r){var a=e._bin,o={};a.readUshort(i,r),r+=2,o.reqFeature=a.readUshort(i,r),r+=2;var l=a.readUshort(i,r);return r+=2,o.features=a.readUshorts(i,r,l),o},e.CFF={},e.CFF.parse=function(i,r,a){var o=e._bin;(i=new Uint8Array(i.buffer,r,a))[r=0],i[++r],i[++r],i[++r],r++;var l=[];r=e.CFF.readIndex(i,r,l);for(var c=[],u=0;u<l.length-1;u++)c.push(o.readASCII(i,r+l[u],l[u+1]-l[u]));r+=l[l.length-1];var h=[];r=e.CFF.readIndex(i,r,h);var d=[];for(u=0;u<h.length-1;u++)d.push(e.CFF.readDict(i,r+h[u],r+h[u+1]));r+=h[h.length-1];var f=d[0],v=[];r=e.CFF.readIndex(i,r,v);var g=[];for(u=0;u<v.length-1;u++)g.push(o.readASCII(i,r+v[u],v[u+1]-v[u]));if(r+=v[v.length-1],e.CFF.readSubrs(i,r,f),f.CharStrings){r=f.CharStrings,v=[],r=e.CFF.readIndex(i,r,v);var m=[];for(u=0;u<v.length-1;u++)m.push(o.readBytes(i,r+v[u],v[u+1]-v[u]));f.CharStrings=m}if(f.ROS){r=f.FDArray;var x=[];for(r=e.CFF.readIndex(i,r,x),f.FDArray=[],u=0;u<x.length-1;u++){var w=e.CFF.readDict(i,r+x[u],r+x[u+1]);e.CFF._readFDict(i,w,g),f.FDArray.push(w)}r+=x[x.length-1],r=f.FDSelect,f.FDSelect=[];var S=i[r];if(r++,S!=3)throw S;var b=o.readUshort(i,r);for(r+=2,u=0;u<b+1;u++)f.FDSelect.push(o.readUshort(i,r),i[r+2]),r+=3}return f.Encoding&&(f.Encoding=e.CFF.readEncoding(i,f.Encoding,f.CharStrings.length)),f.charset&&(f.charset=e.CFF.readCharset(i,f.charset,f.CharStrings.length)),e.CFF._readFDict(i,f,g),f},e.CFF._readFDict=function(i,r,a){var o;for(var l in r.Private&&(o=r.Private[1],r.Private=e.CFF.readDict(i,o,o+r.Private[0]),r.Private.Subrs&&e.CFF.readSubrs(i,o+r.Private.Subrs,r.Private)),r)["FamilyName","FontName","FullName","Notice","version","Copyright"].indexOf(l)!=-1&&(r[l]=a[r[l]-426+35])},e.CFF.readSubrs=function(i,r,a){var o=e._bin,l=[];r=e.CFF.readIndex(i,r,l);var c,u=l.length;c=u<1240?107:u<33900?1131:32768,a.Bias=c,a.Subrs=[];for(var h=0;h<l.length-1;h++)a.Subrs.push(o.readBytes(i,r+l[h],l[h+1]-l[h]))},e.CFF.tableSE=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,0,111,112,113,114,0,115,116,117,118,119,120,121,122,0,123,0,124,125,126,127,128,129,130,131,0,132,133,0,134,135,136,137,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,138,0,139,0,0,0,0,140,141,142,143,0,0,0,0,0,144,0,0,0,145,0,0,146,147,148,149,0,0,0,0],e.CFF.glyphByUnicode=function(i,r){for(var a=0;a<i.charset.length;a++)if(i.charset[a]==r)return a;return-1},e.CFF.glyphBySE=function(i,r){return r<0||r>255?-1:e.CFF.glyphByUnicode(i,e.CFF.tableSE[r])},e.CFF.readEncoding=function(i,r,a){e._bin;var o=[".notdef"],l=i[r];if(r++,l!=0)throw"error: unknown encoding format: "+l;var c=i[r];r++;for(var u=0;u<c;u++)o.push(i[r+u]);return o},e.CFF.readCharset=function(i,r,a){var o=e._bin,l=[".notdef"],c=i[r];if(r++,c==0)for(var u=0;u<a;u++){var h=o.readUshort(i,r);r+=2,l.push(h)}else{if(c!=1&&c!=2)throw"error: format: "+c;for(;l.length<a;){h=o.readUshort(i,r),r+=2;var d=0;for(c==1?(d=i[r],r++):(d=o.readUshort(i,r),r+=2),u=0;u<=d;u++)l.push(h),h++}}return l},e.CFF.readIndex=function(i,r,a){var o=e._bin,l=o.readUshort(i,r)+1,c=i[r+=2];if(r++,c==1)for(var u=0;u<l;u++)a.push(i[r+u]);else if(c==2)for(u=0;u<l;u++)a.push(o.readUshort(i,r+2*u));else if(c==3)for(u=0;u<l;u++)a.push(16777215&o.readUint(i,r+3*u-1));else if(l!=1)throw"unsupported offset size: "+c+", count: "+l;return(r+=l*c)-1},e.CFF.getCharString=function(i,r,a){var o=e._bin,l=i[r],c=i[r+1];i[r+2],i[r+3],i[r+4];var u=1,h=null,d=null;l<=20&&(h=l,u=1),l==12&&(h=100*l+c,u=2),21<=l&&l<=27&&(h=l,u=1),l==28&&(d=o.readShort(i,r+1),u=3),29<=l&&l<=31&&(h=l,u=1),32<=l&&l<=246&&(d=l-139,u=1),247<=l&&l<=250&&(d=256*(l-247)+c+108,u=2),251<=l&&l<=254&&(d=256*-(l-251)-c-108,u=2),l==255&&(d=o.readInt(i,r+1)/65535,u=5),a.val=d??"o"+h,a.size=u},e.CFF.readCharString=function(i,r,a){for(var o=r+a,l=e._bin,c=[];r<o;){var u=i[r],h=i[r+1];i[r+2],i[r+3],i[r+4];var d=1,f=null,v=null;u<=20&&(f=u,d=1),u==12&&(f=100*u+h,d=2),u!=19&&u!=20||(f=u,d=2),21<=u&&u<=27&&(f=u,d=1),u==28&&(v=l.readShort(i,r+1),d=3),29<=u&&u<=31&&(f=u,d=1),32<=u&&u<=246&&(v=u-139,d=1),247<=u&&u<=250&&(v=256*(u-247)+h+108,d=2),251<=u&&u<=254&&(v=256*-(u-251)-h-108,d=2),u==255&&(v=l.readInt(i,r+1)/65535,d=5),c.push(v??"o"+f),r+=d}return c},e.CFF.readDict=function(i,r,a){for(var o=e._bin,l={},c=[];r<a;){var u=i[r],h=i[r+1];i[r+2],i[r+3],i[r+4];var d=1,f=null,v=null;if(u==28&&(v=o.readShort(i,r+1),d=3),u==29&&(v=o.readInt(i,r+1),d=5),32<=u&&u<=246&&(v=u-139,d=1),247<=u&&u<=250&&(v=256*(u-247)+h+108,d=2),251<=u&&u<=254&&(v=256*-(u-251)-h-108,d=2),u==255)throw v=o.readInt(i,r+1)/65535,d=5,"unknown number";if(u==30){var g=[];for(d=1;;){var m=i[r+d];d++;var x=m>>4,w=15&m;if(x!=15&&g.push(x),w!=15&&g.push(w),w==15)break}for(var S="",b=[0,1,2,3,4,5,6,7,8,9,".","e","e-","reserved","-","endOfNumber"],E=0;E<g.length;E++)S+=b[g[E]];v=parseFloat(S)}u<=21&&(f=["version","Notice","FullName","FamilyName","Weight","FontBBox","BlueValues","OtherBlues","FamilyBlues","FamilyOtherBlues","StdHW","StdVW","escape","UniqueID","XUID","charset","Encoding","CharStrings","Private","Subrs","defaultWidthX","nominalWidthX"][u],d=1,u==12&&(f=["Copyright","isFixedPitch","ItalicAngle","UnderlinePosition","UnderlineThickness","PaintType","CharstringType","FontMatrix","StrokeWidth","BlueScale","BlueShift","BlueFuzz","StemSnapH","StemSnapV","ForceBold",0,0,"LanguageGroup","ExpansionFactor","initialRandomSeed","SyntheticBase","PostScript","BaseFontName","BaseFontBlend",0,0,0,0,0,0,"ROS","CIDFontVersion","CIDFontRevision","CIDFontType","CIDCount","UIDBase","FDArray","FDSelect","FontName"][h],d=2)),f!=null?(l[f]=c.length==1?c[0]:c,c=[]):c.push(v),r+=d}return l},e.cmap={},e.cmap.parse=function(i,r,a){i=new Uint8Array(i.buffer,r,a),r=0;var o=e._bin,l={};o.readUshort(i,r),r+=2;var c=o.readUshort(i,r);r+=2;var u=[];l.tables=[];for(var h=0;h<c;h++){var d=o.readUshort(i,r);r+=2;var f=o.readUshort(i,r);r+=2;var v=o.readUint(i,r);r+=4;var g="p"+d+"e"+f,m=u.indexOf(v);if(m==-1){var x;m=l.tables.length,u.push(v);var w=o.readUshort(i,v);w==0?x=e.cmap.parse0(i,v):w==4?x=e.cmap.parse4(i,v):w==6?x=e.cmap.parse6(i,v):w==12?x=e.cmap.parse12(i,v):console.debug("unknown format: "+w,d,f,v),l.tables.push(x)}if(l[g]!=null)throw"multiple tables for one platform+encoding";l[g]=m}return l},e.cmap.parse0=function(i,r){var a=e._bin,o={};o.format=a.readUshort(i,r),r+=2;var l=a.readUshort(i,r);r+=2,a.readUshort(i,r),r+=2,o.map=[];for(var c=0;c<l-6;c++)o.map.push(i[r+c]);return o},e.cmap.parse4=function(i,r){var a=e._bin,o=r,l={};l.format=a.readUshort(i,r),r+=2;var c=a.readUshort(i,r);r+=2,a.readUshort(i,r),r+=2;var u=a.readUshort(i,r);r+=2;var h=u/2;l.searchRange=a.readUshort(i,r),r+=2,l.entrySelector=a.readUshort(i,r),r+=2,l.rangeShift=a.readUshort(i,r),r+=2,l.endCount=a.readUshorts(i,r,h),r+=2*h,r+=2,l.startCount=a.readUshorts(i,r,h),r+=2*h,l.idDelta=[];for(var d=0;d<h;d++)l.idDelta.push(a.readShort(i,r)),r+=2;for(l.idRangeOffset=a.readUshorts(i,r,h),r+=2*h,l.glyphIdArray=[];r<o+c;)l.glyphIdArray.push(a.readUshort(i,r)),r+=2;return l},e.cmap.parse6=function(i,r){var a=e._bin,o={};o.format=a.readUshort(i,r),r+=2,a.readUshort(i,r),r+=2,a.readUshort(i,r),r+=2,o.firstCode=a.readUshort(i,r),r+=2;var l=a.readUshort(i,r);r+=2,o.glyphIdArray=[];for(var c=0;c<l;c++)o.glyphIdArray.push(a.readUshort(i,r)),r+=2;return o},e.cmap.parse12=function(i,r){var a=e._bin,o={};o.format=a.readUshort(i,r),r+=2,r+=2,a.readUint(i,r),r+=4,a.readUint(i,r),r+=4;var l=a.readUint(i,r);r+=4,o.groups=[];for(var c=0;c<l;c++){var u=r+12*c,h=a.readUint(i,u+0),d=a.readUint(i,u+4),f=a.readUint(i,u+8);o.groups.push([h,d,f])}return o},e.glyf={},e.glyf.parse=function(i,r,a,o){for(var l=[],c=0;c<o.maxp.numGlyphs;c++)l.push(null);return l},e.glyf._parseGlyf=function(i,r){var a=e._bin,o=i._data,l=e._tabOffset(o,"glyf",i._offset)+i.loca[r];if(i.loca[r]==i.loca[r+1])return null;var c={};if(c.noc=a.readShort(o,l),l+=2,c.xMin=a.readShort(o,l),l+=2,c.yMin=a.readShort(o,l),l+=2,c.xMax=a.readShort(o,l),l+=2,c.yMax=a.readShort(o,l),l+=2,c.xMin>=c.xMax||c.yMin>=c.yMax)return null;if(c.noc>0){c.endPts=[];for(var u=0;u<c.noc;u++)c.endPts.push(a.readUshort(o,l)),l+=2;var h=a.readUshort(o,l);if(l+=2,o.length-l<h)return null;c.instructions=a.readBytes(o,l,h),l+=h;var d=c.endPts[c.noc-1]+1;for(c.flags=[],u=0;u<d;u++){var f=o[l];if(l++,c.flags.push(f),(8&f)!=0){var v=o[l];l++;for(var g=0;g<v;g++)c.flags.push(f),u++}}for(c.xs=[],u=0;u<d;u++){var m=(2&c.flags[u])!=0,x=(16&c.flags[u])!=0;m?(c.xs.push(x?o[l]:-o[l]),l++):x?c.xs.push(0):(c.xs.push(a.readShort(o,l)),l+=2)}for(c.ys=[],u=0;u<d;u++)m=(4&c.flags[u])!=0,x=(32&c.flags[u])!=0,m?(c.ys.push(x?o[l]:-o[l]),l++):x?c.ys.push(0):(c.ys.push(a.readShort(o,l)),l+=2);var w=0,S=0;for(u=0;u<d;u++)w+=c.xs[u],S+=c.ys[u],c.xs[u]=w,c.ys[u]=S}else{var b;c.parts=[];do{b=a.readUshort(o,l),l+=2;var E={m:{a:1,b:0,c:0,d:1,tx:0,ty:0},p1:-1,p2:-1};if(c.parts.push(E),E.glyphIndex=a.readUshort(o,l),l+=2,1&b){var C=a.readShort(o,l);l+=2;var P=a.readShort(o,l);l+=2}else C=a.readInt8(o,l),l++,P=a.readInt8(o,l),l++;2&b?(E.m.tx=C,E.m.ty=P):(E.p1=C,E.p2=P),8&b?(E.m.a=E.m.d=a.readF2dot14(o,l),l+=2):64&b?(E.m.a=a.readF2dot14(o,l),l+=2,E.m.d=a.readF2dot14(o,l),l+=2):128&b&&(E.m.a=a.readF2dot14(o,l),l+=2,E.m.b=a.readF2dot14(o,l),l+=2,E.m.c=a.readF2dot14(o,l),l+=2,E.m.d=a.readF2dot14(o,l),l+=2)}while(32&b);if(256&b){var M=a.readUshort(o,l);for(l+=2,c.instr=[],u=0;u<M;u++)c.instr.push(o[l]),l++}}return c},e.GPOS={},e.GPOS.parse=function(i,r,a,o){return e._lctf.parse(i,r,a,o,e.GPOS.subt)},e.GPOS.subt=function(i,r,a,o){var l=e._bin,c=a,u={};if(u.fmt=l.readUshort(i,a),a+=2,r==1||r==2||r==3||r==7||r==8&&u.fmt<=2){var h=l.readUshort(i,a);a+=2,u.coverage=e._lctf.readCoverage(i,h+c)}if(r==1&&u.fmt==1){var d=l.readUshort(i,a);a+=2;var f=e._lctf.numOfOnes(d);d!=0&&(u.pos=e.GPOS.readValueRecord(i,a,d))}else if(r==2&&u.fmt>=1&&u.fmt<=2){d=l.readUshort(i,a),a+=2;var v=l.readUshort(i,a);a+=2,f=e._lctf.numOfOnes(d);var g=e._lctf.numOfOnes(v);if(u.fmt==1){u.pairsets=[];var m=l.readUshort(i,a);a+=2;for(var x=0;x<m;x++){var w=c+l.readUshort(i,a);a+=2;var S=l.readUshort(i,w);w+=2;for(var b=[],E=0;E<S;E++){var C=l.readUshort(i,w);w+=2,d!=0&&(U=e.GPOS.readValueRecord(i,w,d),w+=2*f),v!=0&&(j=e.GPOS.readValueRecord(i,w,v),w+=2*g),b.push({gid2:C,val1:U,val2:j})}u.pairsets.push(b)}}if(u.fmt==2){var P=l.readUshort(i,a);a+=2;var M=l.readUshort(i,a);a+=2;var L=l.readUshort(i,a);a+=2;var z=l.readUshort(i,a);for(a+=2,u.classDef1=e._lctf.readClassDef(i,c+P),u.classDef2=e._lctf.readClassDef(i,c+M),u.matrix=[],x=0;x<L;x++){var V=[];for(E=0;E<z;E++){var U=null,j=null;d!=0&&(U=e.GPOS.readValueRecord(i,a,d),a+=2*f),v!=0&&(j=e.GPOS.readValueRecord(i,a,v),a+=2*g),V.push({val1:U,val2:j})}u.matrix.push(V)}}}else{if(r==9&&u.fmt==1){var F=l.readUshort(i,a);a+=2;var K=l.readUint(i,a);if(a+=4,o.ltype==9)o.ltype=F;else if(o.ltype!=F)throw"invalid extension substitution";return e.GPOS.subt(i,o.ltype,c+K)}console.debug("unsupported GPOS table LookupType",r,"format",u.fmt)}return u},e.GPOS.readValueRecord=function(i,r,a){var o=e._bin,l=[];return l.push(1&a?o.readShort(i,r):0),r+=1&a?2:0,l.push(2&a?o.readShort(i,r):0),r+=2&a?2:0,l.push(4&a?o.readShort(i,r):0),r+=4&a?2:0,l.push(8&a?o.readShort(i,r):0),r+=8&a?2:0,l},e.GSUB={},e.GSUB.parse=function(i,r,a,o){return e._lctf.parse(i,r,a,o,e.GSUB.subt)},e.GSUB.subt=function(i,r,a,o){var l=e._bin,c=a,u={};if(u.fmt=l.readUshort(i,a),a+=2,r!=1&&r!=4&&r!=5&&r!=6)return null;if(r==1||r==4||r==5&&u.fmt<=2||r==6&&u.fmt<=2){var h=l.readUshort(i,a);a+=2,u.coverage=e._lctf.readCoverage(i,c+h)}if(r==1&&u.fmt>=1&&u.fmt<=2){if(u.fmt==1)u.delta=l.readShort(i,a),a+=2;else if(u.fmt==2){var d=l.readUshort(i,a);a+=2,u.newg=l.readUshorts(i,a,d),a+=2*u.newg.length}}else if(r==4){u.vals=[],d=l.readUshort(i,a),a+=2;for(var f=0;f<d;f++){var v=l.readUshort(i,a);a+=2,u.vals.push(e.GSUB.readLigatureSet(i,c+v))}}else if(r==5&&u.fmt==2){if(u.fmt==2){var g=l.readUshort(i,a);a+=2,u.cDef=e._lctf.readClassDef(i,c+g),u.scset=[];var m=l.readUshort(i,a);for(a+=2,f=0;f<m;f++){var x=l.readUshort(i,a);a+=2,u.scset.push(x==0?null:e.GSUB.readSubClassSet(i,c+x))}}}else if(r==6&&u.fmt==3){if(u.fmt==3){for(f=0;f<3;f++){d=l.readUshort(i,a),a+=2;for(var w=[],S=0;S<d;S++)w.push(e._lctf.readCoverage(i,c+l.readUshort(i,a+2*S)));a+=2*d,f==0&&(u.backCvg=w),f==1&&(u.inptCvg=w),f==2&&(u.ahedCvg=w)}d=l.readUshort(i,a),a+=2,u.lookupRec=e.GSUB.readSubstLookupRecords(i,a,d)}}else{if(r==7&&u.fmt==1){var b=l.readUshort(i,a);a+=2;var E=l.readUint(i,a);if(a+=4,o.ltype==9)o.ltype=b;else if(o.ltype!=b)throw"invalid extension substitution";return e.GSUB.subt(i,o.ltype,c+E)}console.debug("unsupported GSUB table LookupType",r,"format",u.fmt)}return u},e.GSUB.readSubClassSet=function(i,r){var a=e._bin.readUshort,o=r,l=[],c=a(i,r);r+=2;for(var u=0;u<c;u++){var h=a(i,r);r+=2,l.push(e.GSUB.readSubClassRule(i,o+h))}return l},e.GSUB.readSubClassRule=function(i,r){var a=e._bin.readUshort,o={},l=a(i,r),c=a(i,r+=2);r+=2,o.input=[];for(var u=0;u<l-1;u++)o.input.push(a(i,r)),r+=2;return o.substLookupRecords=e.GSUB.readSubstLookupRecords(i,r,c),o},e.GSUB.readSubstLookupRecords=function(i,r,a){for(var o=e._bin.readUshort,l=[],c=0;c<a;c++)l.push(o(i,r),o(i,r+2)),r+=4;return l},e.GSUB.readChainSubClassSet=function(i,r){var a=e._bin,o=r,l=[],c=a.readUshort(i,r);r+=2;for(var u=0;u<c;u++){var h=a.readUshort(i,r);r+=2,l.push(e.GSUB.readChainSubClassRule(i,o+h))}return l},e.GSUB.readChainSubClassRule=function(i,r){for(var a=e._bin,o={},l=["backtrack","input","lookahead"],c=0;c<l.length;c++){var u=a.readUshort(i,r);r+=2,c==1&&u--,o[l[c]]=a.readUshorts(i,r,u),r+=2*o[l[c]].length}return u=a.readUshort(i,r),r+=2,o.subst=a.readUshorts(i,r,2*u),r+=2*o.subst.length,o},e.GSUB.readLigatureSet=function(i,r){var a=e._bin,o=r,l=[],c=a.readUshort(i,r);r+=2;for(var u=0;u<c;u++){var h=a.readUshort(i,r);r+=2,l.push(e.GSUB.readLigature(i,o+h))}return l},e.GSUB.readLigature=function(i,r){var a=e._bin,o={chain:[]};o.nglyph=a.readUshort(i,r),r+=2;var l=a.readUshort(i,r);r+=2;for(var c=0;c<l-1;c++)o.chain.push(a.readUshort(i,r)),r+=2;return o},e.head={},e.head.parse=function(i,r,a){var o=e._bin,l={};return o.readFixed(i,r),r+=4,l.fontRevision=o.readFixed(i,r),r+=4,o.readUint(i,r),r+=4,o.readUint(i,r),r+=4,l.flags=o.readUshort(i,r),r+=2,l.unitsPerEm=o.readUshort(i,r),r+=2,l.created=o.readUint64(i,r),r+=8,l.modified=o.readUint64(i,r),r+=8,l.xMin=o.readShort(i,r),r+=2,l.yMin=o.readShort(i,r),r+=2,l.xMax=o.readShort(i,r),r+=2,l.yMax=o.readShort(i,r),r+=2,l.macStyle=o.readUshort(i,r),r+=2,l.lowestRecPPEM=o.readUshort(i,r),r+=2,l.fontDirectionHint=o.readShort(i,r),r+=2,l.indexToLocFormat=o.readShort(i,r),r+=2,l.glyphDataFormat=o.readShort(i,r),r+=2,l},e.hhea={},e.hhea.parse=function(i,r,a){var o=e._bin,l={};return o.readFixed(i,r),r+=4,l.ascender=o.readShort(i,r),r+=2,l.descender=o.readShort(i,r),r+=2,l.lineGap=o.readShort(i,r),r+=2,l.advanceWidthMax=o.readUshort(i,r),r+=2,l.minLeftSideBearing=o.readShort(i,r),r+=2,l.minRightSideBearing=o.readShort(i,r),r+=2,l.xMaxExtent=o.readShort(i,r),r+=2,l.caretSlopeRise=o.readShort(i,r),r+=2,l.caretSlopeRun=o.readShort(i,r),r+=2,l.caretOffset=o.readShort(i,r),r+=2,r+=8,l.metricDataFormat=o.readShort(i,r),r+=2,l.numberOfHMetrics=o.readUshort(i,r),r+=2,l},e.hmtx={},e.hmtx.parse=function(i,r,a,o){for(var l=e._bin,c={aWidth:[],lsBearing:[]},u=0,h=0,d=0;d<o.maxp.numGlyphs;d++)d<o.hhea.numberOfHMetrics&&(u=l.readUshort(i,r),r+=2,h=l.readShort(i,r),r+=2),c.aWidth.push(u),c.lsBearing.push(h);return c},e.kern={},e.kern.parse=function(i,r,a,o){var l=e._bin,c=l.readUshort(i,r);if(r+=2,c==1)return e.kern.parseV1(i,r-2,a,o);var u=l.readUshort(i,r);r+=2;for(var h={glyph1:[],rval:[]},d=0;d<u;d++){r+=2,a=l.readUshort(i,r),r+=2;var f=l.readUshort(i,r);r+=2;var v=f>>>8;if((v&=15)!=0)throw"unknown kern table format: "+v;r=e.kern.readFormat0(i,r,h)}return h},e.kern.parseV1=function(i,r,a,o){var l=e._bin;l.readFixed(i,r),r+=4;var c=l.readUint(i,r);r+=4;for(var u={glyph1:[],rval:[]},h=0;h<c;h++){l.readUint(i,r),r+=4;var d=l.readUshort(i,r);r+=2,l.readUshort(i,r),r+=2;var f=d>>>8;if((f&=15)!=0)throw"unknown kern table format: "+f;r=e.kern.readFormat0(i,r,u)}return u},e.kern.readFormat0=function(i,r,a){var o=e._bin,l=-1,c=o.readUshort(i,r);r+=2,o.readUshort(i,r),r+=2,o.readUshort(i,r),r+=2,o.readUshort(i,r),r+=2;for(var u=0;u<c;u++){var h=o.readUshort(i,r);r+=2;var d=o.readUshort(i,r);r+=2;var f=o.readShort(i,r);r+=2,h!=l&&(a.glyph1.push(h),a.rval.push({glyph2:[],vals:[]}));var v=a.rval[a.rval.length-1];v.glyph2.push(d),v.vals.push(f),l=h}return r},e.loca={},e.loca.parse=function(i,r,a,o){var l=e._bin,c=[],u=o.head.indexToLocFormat,h=o.maxp.numGlyphs+1;if(u==0)for(var d=0;d<h;d++)c.push(l.readUshort(i,r+(d<<1))<<1);if(u==1)for(d=0;d<h;d++)c.push(l.readUint(i,r+(d<<2)));return c},e.maxp={},e.maxp.parse=function(i,r,a){var o=e._bin,l={},c=o.readUint(i,r);return r+=4,l.numGlyphs=o.readUshort(i,r),r+=2,c==65536&&(l.maxPoints=o.readUshort(i,r),r+=2,l.maxContours=o.readUshort(i,r),r+=2,l.maxCompositePoints=o.readUshort(i,r),r+=2,l.maxCompositeContours=o.readUshort(i,r),r+=2,l.maxZones=o.readUshort(i,r),r+=2,l.maxTwilightPoints=o.readUshort(i,r),r+=2,l.maxStorage=o.readUshort(i,r),r+=2,l.maxFunctionDefs=o.readUshort(i,r),r+=2,l.maxInstructionDefs=o.readUshort(i,r),r+=2,l.maxStackElements=o.readUshort(i,r),r+=2,l.maxSizeOfInstructions=o.readUshort(i,r),r+=2,l.maxComponentElements=o.readUshort(i,r),r+=2,l.maxComponentDepth=o.readUshort(i,r),r+=2),l},e.name={},e.name.parse=function(i,r,a){var o=e._bin,l={};o.readUshort(i,r),r+=2;var c=o.readUshort(i,r);r+=2,o.readUshort(i,r);for(var u,h=["copyright","fontFamily","fontSubfamily","ID","fullName","version","postScriptName","trademark","manufacturer","designer","description","urlVendor","urlDesigner","licence","licenceURL","---","typoFamilyName","typoSubfamilyName","compatibleFull","sampleText","postScriptCID","wwsFamilyName","wwsSubfamilyName","lightPalette","darkPalette"],d=r+=2,f=0;f<c;f++){var v=o.readUshort(i,r);r+=2;var g=o.readUshort(i,r);r+=2;var m=o.readUshort(i,r);r+=2;var x=o.readUshort(i,r);r+=2;var w=o.readUshort(i,r);r+=2;var S=o.readUshort(i,r);r+=2;var b,E=h[x],C=d+12*c+S;if(v==0)b=o.readUnicode(i,C,w/2);else if(v==3&&g==0)b=o.readUnicode(i,C,w/2);else if(g==0)b=o.readASCII(i,C,w);else if(g==1)b=o.readUnicode(i,C,w/2);else if(g==3)b=o.readUnicode(i,C,w/2);else{if(v!=1)throw"unknown encoding "+g+", platformID: "+v;b=o.readASCII(i,C,w),console.debug("reading unknown MAC encoding "+g+" as ASCII")}var P="p"+v+","+m.toString(16);l[P]==null&&(l[P]={}),l[P][E!==void 0?E:x]=b,l[P]._lang=m}for(var M in l)if(l[M].postScriptName!=null&&l[M]._lang==1033)return l[M];for(var M in l)if(l[M].postScriptName!=null&&l[M]._lang==0)return l[M];for(var M in l)if(l[M].postScriptName!=null&&l[M]._lang==3084)return l[M];for(var M in l)if(l[M].postScriptName!=null)return l[M];for(var M in l){u=M;break}return console.debug("returning name table with languageID "+l[u]._lang),l[u]},e["OS/2"]={},e["OS/2"].parse=function(i,r,a){var o=e._bin.readUshort(i,r);r+=2;var l={};if(o==0)e["OS/2"].version0(i,r,l);else if(o==1)e["OS/2"].version1(i,r,l);else if(o==2||o==3||o==4)e["OS/2"].version2(i,r,l);else{if(o!=5)throw"unknown OS/2 table version: "+o;e["OS/2"].version5(i,r,l)}return l},e["OS/2"].version0=function(i,r,a){var o=e._bin;return a.xAvgCharWidth=o.readShort(i,r),r+=2,a.usWeightClass=o.readUshort(i,r),r+=2,a.usWidthClass=o.readUshort(i,r),r+=2,a.fsType=o.readUshort(i,r),r+=2,a.ySubscriptXSize=o.readShort(i,r),r+=2,a.ySubscriptYSize=o.readShort(i,r),r+=2,a.ySubscriptXOffset=o.readShort(i,r),r+=2,a.ySubscriptYOffset=o.readShort(i,r),r+=2,a.ySuperscriptXSize=o.readShort(i,r),r+=2,a.ySuperscriptYSize=o.readShort(i,r),r+=2,a.ySuperscriptXOffset=o.readShort(i,r),r+=2,a.ySuperscriptYOffset=o.readShort(i,r),r+=2,a.yStrikeoutSize=o.readShort(i,r),r+=2,a.yStrikeoutPosition=o.readShort(i,r),r+=2,a.sFamilyClass=o.readShort(i,r),r+=2,a.panose=o.readBytes(i,r,10),r+=10,a.ulUnicodeRange1=o.readUint(i,r),r+=4,a.ulUnicodeRange2=o.readUint(i,r),r+=4,a.ulUnicodeRange3=o.readUint(i,r),r+=4,a.ulUnicodeRange4=o.readUint(i,r),r+=4,a.achVendID=[o.readInt8(i,r),o.readInt8(i,r+1),o.readInt8(i,r+2),o.readInt8(i,r+3)],r+=4,a.fsSelection=o.readUshort(i,r),r+=2,a.usFirstCharIndex=o.readUshort(i,r),r+=2,a.usLastCharIndex=o.readUshort(i,r),r+=2,a.sTypoAscender=o.readShort(i,r),r+=2,a.sTypoDescender=o.readShort(i,r),r+=2,a.sTypoLineGap=o.readShort(i,r),r+=2,a.usWinAscent=o.readUshort(i,r),r+=2,a.usWinDescent=o.readUshort(i,r),r+=2},e["OS/2"].version1=function(i,r,a){var o=e._bin;return r=e["OS/2"].version0(i,r,a),a.ulCodePageRange1=o.readUint(i,r),r+=4,a.ulCodePageRange2=o.readUint(i,r),r+=4},e["OS/2"].version2=function(i,r,a){var o=e._bin;return r=e["OS/2"].version1(i,r,a),a.sxHeight=o.readShort(i,r),r+=2,a.sCapHeight=o.readShort(i,r),r+=2,a.usDefault=o.readUshort(i,r),r+=2,a.usBreak=o.readUshort(i,r),r+=2,a.usMaxContext=o.readUshort(i,r),r+=2},e["OS/2"].version5=function(i,r,a){var o=e._bin;return r=e["OS/2"].version2(i,r,a),a.usLowerOpticalPointSize=o.readUshort(i,r),r+=2,a.usUpperOpticalPointSize=o.readUshort(i,r),r+=2},e.post={},e.post.parse=function(i,r,a){var o=e._bin,l={};return l.version=o.readFixed(i,r),r+=4,l.italicAngle=o.readFixed(i,r),r+=4,l.underlinePosition=o.readShort(i,r),r+=2,l.underlineThickness=o.readShort(i,r),r+=2,l},e==null&&(e={}),e.U==null&&(e.U={}),e.U.codeToGlyph=function(i,r){var a=i.cmap,o=-1;if(a.p0e4!=null?o=a.p0e4:a.p3e1!=null?o=a.p3e1:a.p1e0!=null?o=a.p1e0:a.p0e3!=null&&(o=a.p0e3),o==-1)throw"no familiar platform and encoding!";var l=a.tables[o];if(l.format==0)return r>=l.map.length?0:l.map[r];if(l.format==4){for(var c=-1,u=0;u<l.endCount.length;u++)if(r<=l.endCount[u]){c=u;break}return c==-1||l.startCount[c]>r?0:65535&(l.idRangeOffset[c]!=0?l.glyphIdArray[r-l.startCount[c]+(l.idRangeOffset[c]>>1)-(l.idRangeOffset.length-c)]:r+l.idDelta[c])}if(l.format==12){if(r>l.groups[l.groups.length-1][1])return 0;for(u=0;u<l.groups.length;u++){var h=l.groups[u];if(h[0]<=r&&r<=h[1])return h[2]+(r-h[0])}return 0}throw"unknown cmap table format "+l.format},e.U.glyphToPath=function(i,r){var a={cmds:[],crds:[]};if(i.SVG&&i.SVG.entries[r]){var o=i.SVG.entries[r];return o==null?a:(typeof o=="string"&&(o=e.SVG.toPath(o),i.SVG.entries[r]=o),o)}if(i.CFF){var l={x:0,y:0,stack:[],nStems:0,haveWidth:!1,width:i.CFF.Private?i.CFF.Private.defaultWidthX:0,open:!1},c=i.CFF,u=i.CFF.Private;if(c.ROS){for(var h=0;c.FDSelect[h+2]<=r;)h+=2;u=c.FDArray[c.FDSelect[h+1]].Private}e.U._drawCFF(i.CFF.CharStrings[r],l,c,u,a)}else i.glyf&&e.U._drawGlyf(r,i,a);return a},e.U._drawGlyf=function(i,r,a){var o=r.glyf[i];o==null&&(o=r.glyf[i]=e.glyf._parseGlyf(r,i)),o!=null&&(o.noc>-1?e.U._simpleGlyph(o,a):e.U._compoGlyph(o,r,a))},e.U._simpleGlyph=function(i,r){for(var a=0;a<i.noc;a++){for(var o=a==0?0:i.endPts[a-1]+1,l=i.endPts[a],c=o;c<=l;c++){var u=c==o?l:c-1,h=c==l?o:c+1,d=1&i.flags[c],f=1&i.flags[u],v=1&i.flags[h],g=i.xs[c],m=i.ys[c];if(c==o)if(d){if(!f){e.U.P.moveTo(r,g,m);continue}e.U.P.moveTo(r,i.xs[u],i.ys[u])}else f?e.U.P.moveTo(r,i.xs[u],i.ys[u]):e.U.P.moveTo(r,(i.xs[u]+g)/2,(i.ys[u]+m)/2);d?f&&e.U.P.lineTo(r,g,m):v?e.U.P.qcurveTo(r,g,m,i.xs[h],i.ys[h]):e.U.P.qcurveTo(r,g,m,(g+i.xs[h])/2,(m+i.ys[h])/2)}e.U.P.closePath(r)}},e.U._compoGlyph=function(i,r,a){for(var o=0;o<i.parts.length;o++){var l={cmds:[],crds:[]},c=i.parts[o];e.U._drawGlyf(c.glyphIndex,r,l);for(var u=c.m,h=0;h<l.crds.length;h+=2){var d=l.crds[h],f=l.crds[h+1];a.crds.push(d*u.a+f*u.b+u.tx),a.crds.push(d*u.c+f*u.d+u.ty)}for(h=0;h<l.cmds.length;h++)a.cmds.push(l.cmds[h])}},e.U._getGlyphClass=function(i,r){var a=e._lctf.getInterval(r,i);return a==-1?0:r[a+2]},e.U.getPairAdjustment=function(i,r,a){var o=!1;if(i.GPOS)for(var l=i.GPOS,c=l.lookupList,u=l.featureList,h=[],d=0;d<u.length;d++){var f=u[d];if(f.tag=="kern"){o=!0;for(var v=0;v<f.tab.length;v++)if(!h[f.tab[v]]){h[f.tab[v]]=!0;for(var g=c[f.tab[v]],m=0;m<g.tabs.length;m++)if(g.tabs[m]!=null){var x,w=g.tabs[m];if((!w.coverage||(x=e._lctf.coverageIndex(w.coverage,r))!=-1)&&g.ltype!=1){if(g.ltype==2){var S=null;if(w.fmt==1){var b=w.pairsets[x];for(d=0;d<b.length;d++)b[d].gid2==a&&(S=b[d])}else if(w.fmt==2){var E=e.U._getGlyphClass(r,w.classDef1),C=e.U._getGlyphClass(a,w.classDef2);S=w.matrix[E][C]}if(S){var P=0;return S.val1&&S.val1[2]&&(P+=S.val1[2]),S.val2&&S.val2[0]&&(P+=S.val2[0]),P}}}}}}}if(i.kern&&!o){var M=i.kern.glyph1.indexOf(r);if(M!=-1){var L=i.kern.rval[M].glyph2.indexOf(a);if(L!=-1)return i.kern.rval[M].vals[L]}}return 0},e.U._applySubs=function(i,r,a,o){for(var l=i.length-r-1,c=0;c<a.tabs.length;c++)if(a.tabs[c]!=null){var u,h=a.tabs[c];if(!h.coverage||(u=e._lctf.coverageIndex(h.coverage,i[r]))!=-1){if(a.ltype==1)i[r],h.fmt==1?i[r]=i[r]+h.delta:i[r]=h.newg[u];else if(a.ltype==4)for(var d=h.vals[u],f=0;f<d.length;f++){var v=d[f],g=v.chain.length;if(!(g>l)){for(var m=!0,x=0,w=0;w<g;w++){for(;i[r+x+(1+w)]==-1;)x++;v.chain[w]!=i[r+x+(1+w)]&&(m=!1)}if(m){for(i[r]=v.nglyph,w=0;w<g+x;w++)i[r+w+1]=-1;break}}}else if(a.ltype==5&&h.fmt==2)for(var S=e._lctf.getInterval(h.cDef,i[r]),b=h.cDef[S+2],E=h.scset[b],C=0;C<E.length;C++){var P=E[C],M=P.input;if(!(M.length>l)){for(m=!0,w=0;w<M.length;w++){var L=e._lctf.getInterval(h.cDef,i[r+1+w]);if(S==-1&&h.cDef[L+2]!=M[w]){m=!1;break}}if(m){var z=P.substLookupRecords;for(f=0;f<z.length;f+=2)z[f],z[f+1]}}}else if(a.ltype==6&&h.fmt==3){if(!e.U._glsCovered(i,h.backCvg,r-h.backCvg.length)||!e.U._glsCovered(i,h.inptCvg,r)||!e.U._glsCovered(i,h.ahedCvg,r+h.inptCvg.length))continue;var V=h.lookupRec;for(C=0;C<V.length;C+=2){S=V[C];var U=o[V[C+1]];e.U._applySubs(i,r+S,U,o)}}}}},e.U._glsCovered=function(i,r,a){for(var o=0;o<r.length;o++)if(e._lctf.coverageIndex(r[o],i[a+o])==-1)return!1;return!0},e.U.glyphsToPath=function(i,r,a){for(var o={cmds:[],crds:[]},l=0,c=0;c<r.length;c++){var u=r[c];if(u!=-1){for(var h=c<r.length-1&&r[c+1]!=-1?r[c+1]:0,d=e.U.glyphToPath(i,u),f=0;f<d.crds.length;f+=2)o.crds.push(d.crds[f]+l),o.crds.push(d.crds[f+1]);for(a&&o.cmds.push(a),f=0;f<d.cmds.length;f++)o.cmds.push(d.cmds[f]);a&&o.cmds.push("X"),l+=i.hmtx.aWidth[u],c<r.length-1&&(l+=e.U.getPairAdjustment(i,u,h))}}return o},e.U.P={},e.U.P.moveTo=function(i,r,a){i.cmds.push("M"),i.crds.push(r,a)},e.U.P.lineTo=function(i,r,a){i.cmds.push("L"),i.crds.push(r,a)},e.U.P.curveTo=function(i,r,a,o,l,c,u){i.cmds.push("C"),i.crds.push(r,a,o,l,c,u)},e.U.P.qcurveTo=function(i,r,a,o,l){i.cmds.push("Q"),i.crds.push(r,a,o,l)},e.U.P.closePath=function(i){i.cmds.push("Z")},e.U._drawCFF=function(i,r,a,o,l){for(var c=r.stack,u=r.nStems,h=r.haveWidth,d=r.width,f=r.open,v=0,g=r.x,m=r.y,x=0,w=0,S=0,b=0,E=0,C=0,P=0,M=0,L=0,z=0,V={val:0,size:0};v<i.length;){e.CFF.getCharString(i,v,V);var U=V.val;if(v+=V.size,U=="o1"||U=="o18")c.length%2!=0&&!h&&(d=c.shift()+o.nominalWidthX),u+=c.length>>1,c.length=0,h=!0;else if(U=="o3"||U=="o23")c.length%2!=0&&!h&&(d=c.shift()+o.nominalWidthX),u+=c.length>>1,c.length=0,h=!0;else if(U=="o4")c.length>1&&!h&&(d=c.shift()+o.nominalWidthX,h=!0),f&&e.U.P.closePath(l),m+=c.pop(),e.U.P.moveTo(l,g,m),f=!0;else if(U=="o5")for(;c.length>0;)g+=c.shift(),m+=c.shift(),e.U.P.lineTo(l,g,m);else if(U=="o6"||U=="o7")for(var j=c.length,F=U=="o6",K=0;K<j;K++){var J=c.shift();F?g+=J:m+=J,F=!F,e.U.P.lineTo(l,g,m)}else if(U=="o8"||U=="o24"){j=c.length;for(var se=0;se+6<=j;)x=g+c.shift(),w=m+c.shift(),S=x+c.shift(),b=w+c.shift(),g=S+c.shift(),m=b+c.shift(),e.U.P.curveTo(l,x,w,S,b,g,m),se+=6;U=="o24"&&(g+=c.shift(),m+=c.shift(),e.U.P.lineTo(l,g,m))}else{if(U=="o11")break;if(U=="o1234"||U=="o1235"||U=="o1236"||U=="o1237")U=="o1234"&&(w=m,S=(x=g+c.shift())+c.shift(),z=b=w+c.shift(),C=b,M=m,g=(P=(E=(L=S+c.shift())+c.shift())+c.shift())+c.shift(),e.U.P.curveTo(l,x,w,S,b,L,z),e.U.P.curveTo(l,E,C,P,M,g,m)),U=="o1235"&&(x=g+c.shift(),w=m+c.shift(),S=x+c.shift(),b=w+c.shift(),L=S+c.shift(),z=b+c.shift(),E=L+c.shift(),C=z+c.shift(),P=E+c.shift(),M=C+c.shift(),g=P+c.shift(),m=M+c.shift(),c.shift(),e.U.P.curveTo(l,x,w,S,b,L,z),e.U.P.curveTo(l,E,C,P,M,g,m)),U=="o1236"&&(x=g+c.shift(),w=m+c.shift(),S=x+c.shift(),z=b=w+c.shift(),C=b,P=(E=(L=S+c.shift())+c.shift())+c.shift(),M=C+c.shift(),g=P+c.shift(),e.U.P.curveTo(l,x,w,S,b,L,z),e.U.P.curveTo(l,E,C,P,M,g,m)),U=="o1237"&&(x=g+c.shift(),w=m+c.shift(),S=x+c.shift(),b=w+c.shift(),L=S+c.shift(),z=b+c.shift(),E=L+c.shift(),C=z+c.shift(),P=E+c.shift(),M=C+c.shift(),Math.abs(P-g)>Math.abs(M-m)?g=P+c.shift():m=M+c.shift(),e.U.P.curveTo(l,x,w,S,b,L,z),e.U.P.curveTo(l,E,C,P,M,g,m));else if(U=="o14"){if(c.length>0&&!h&&(d=c.shift()+a.nominalWidthX,h=!0),c.length==4){var le=c.shift(),q=c.shift(),te=c.shift(),H=c.shift(),$=e.CFF.glyphBySE(a,te),ce=e.CFF.glyphBySE(a,H);e.U._drawCFF(a.CharStrings[$],r,a,o,l),r.x=le,r.y=q,e.U._drawCFF(a.CharStrings[ce],r,a,o,l)}f&&(e.U.P.closePath(l),f=!1)}else if(U=="o19"||U=="o20")c.length%2!=0&&!h&&(d=c.shift()+o.nominalWidthX),u+=c.length>>1,c.length=0,h=!0,v+=u+7>>3;else if(U=="o21")c.length>2&&!h&&(d=c.shift()+o.nominalWidthX,h=!0),m+=c.pop(),g+=c.pop(),f&&e.U.P.closePath(l),e.U.P.moveTo(l,g,m),f=!0;else if(U=="o22")c.length>1&&!h&&(d=c.shift()+o.nominalWidthX,h=!0),g+=c.pop(),f&&e.U.P.closePath(l),e.U.P.moveTo(l,g,m),f=!0;else if(U=="o25"){for(;c.length>6;)g+=c.shift(),m+=c.shift(),e.U.P.lineTo(l,g,m);x=g+c.shift(),w=m+c.shift(),S=x+c.shift(),b=w+c.shift(),g=S+c.shift(),m=b+c.shift(),e.U.P.curveTo(l,x,w,S,b,g,m)}else if(U=="o26")for(c.length%2&&(g+=c.shift());c.length>0;)x=g,w=m+c.shift(),g=S=x+c.shift(),m=(b=w+c.shift())+c.shift(),e.U.P.curveTo(l,x,w,S,b,g,m);else if(U=="o27")for(c.length%2&&(m+=c.shift());c.length>0;)w=m,S=(x=g+c.shift())+c.shift(),b=w+c.shift(),g=S+c.shift(),m=b,e.U.P.curveTo(l,x,w,S,b,g,m);else if(U=="o10"||U=="o29"){var xe=U=="o10"?o:a;if(c.length==0)console.debug("error: empty stack");else{var pe=c.pop(),Y=xe.Subrs[pe+xe.Bias];r.x=g,r.y=m,r.nStems=u,r.haveWidth=h,r.width=d,r.open=f,e.U._drawCFF(Y,r,a,o,l),g=r.x,m=r.y,u=r.nStems,h=r.haveWidth,d=r.width,f=r.open}}else if(U=="o30"||U=="o31"){var Ie=c.length,re=(se=0,U=="o31");for(se+=Ie-(j=-3&Ie);se<j;)re?(w=m,S=(x=g+c.shift())+c.shift(),m=(b=w+c.shift())+c.shift(),j-se==5?(g=S+c.shift(),se++):g=S,re=!1):(x=g,w=m+c.shift(),S=x+c.shift(),b=w+c.shift(),g=S+c.shift(),j-se==5?(m=b+c.shift(),se++):m=b,re=!0),e.U.P.curveTo(l,x,w,S,b,g,m),se+=4}else{if((U+"").charAt(0)=="o")throw console.debug("Unknown operation: "+U,i),U;c.push(U)}}}r.x=g,r.y=m,r.nStems=u,r.haveWidth=h,r.width=d,r.open=f};var t=e,n={Typr:t};return s.Typr=t,s.default=n,Object.defineProperty(s,"__esModule",{value:!0}),s}({}).Typr}/*!
Custom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate
(https://github.com/101arrowz/fflate) for use in Troika text rendering. 
Original licenses apply: 
- fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)
- woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)
*/function TB(){return function(s){var e=Uint8Array,t=Uint16Array,n=Uint32Array,i=new e([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),r=new e([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),a=new e([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),o=function(U,j){for(var F=new t(31),K=0;K<31;++K)F[K]=j+=1<<U[K-1];var J=new n(F[30]);for(K=1;K<30;++K)for(var se=F[K];se<F[K+1];++se)J[se]=se-F[K]<<5|K;return[F,J]},l=o(i,2),c=l[0],u=l[1];c[28]=258,u[258]=28;for(var h=o(r,0)[0],d=new t(32768),f=0;f<32768;++f){var v=(43690&f)>>>1|(21845&f)<<1;v=(61680&(v=(52428&v)>>>2|(13107&v)<<2))>>>4|(3855&v)<<4,d[f]=((65280&v)>>>8|(255&v)<<8)>>>1}var g=function(U,j,F){for(var K=U.length,J=0,se=new t(j);J<K;++J)++se[U[J]-1];var le,q=new t(j);for(J=0;J<j;++J)q[J]=q[J-1]+se[J-1]<<1;{le=new t(1<<j);var te=15-j;for(J=0;J<K;++J)if(U[J])for(var H=J<<4|U[J],$=j-U[J],ce=q[U[J]-1]++<<$,xe=ce|(1<<$)-1;ce<=xe;++ce)le[d[ce]>>>te]=H}return le},m=new e(288);for(f=0;f<144;++f)m[f]=8;for(f=144;f<256;++f)m[f]=9;for(f=256;f<280;++f)m[f]=7;for(f=280;f<288;++f)m[f]=8;var x=new e(32);for(f=0;f<32;++f)x[f]=5;var w=g(m,9),S=g(x,5),b=function(U){for(var j=U[0],F=1;F<U.length;++F)U[F]>j&&(j=U[F]);return j},E=function(U,j,F){var K=j/8|0;return(U[K]|U[K+1]<<8)>>(7&j)&F},C=function(U,j){var F=j/8|0;return(U[F]|U[F+1]<<8|U[F+2]<<16)>>(7&j)},P=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],M=function(U,j,F){var K=new Error(j||P[U]);if(K.code=U,Error.captureStackTrace&&Error.captureStackTrace(K,M),!F)throw K;return K},L=function(U,j,F){var K=U.length;if(!K||F&&!F.l&&K<5)return j||new e(0);var J=!j||F,se=!F||F.i;F||(F={}),j||(j=new e(3*K));var le,q=function(Fe){var Oe=j.length;if(Fe>Oe){var nt=new e(Math.max(2*Oe,Fe));nt.set(j),j=nt}},te=F.f||0,H=F.p||0,$=F.b||0,ce=F.l,xe=F.d,pe=F.m,Y=F.n,Ie=8*K;do{if(!ce){F.f=te=E(U,H,1);var re=E(U,H+1,3);if(H+=3,!re){var oe=U[(rt=((le=H)/8|0)+(7&le&&1)+4)-4]|U[rt-3]<<8,ye=rt+oe;if(ye>K){se&&M(0);break}J&&q($+oe),j.set(U.subarray(rt,ye),$),F.b=$+=oe,F.p=H=8*ye;continue}if(re==1)ce=w,xe=S,pe=9,Y=5;else if(re==2){var ke=E(U,H,31)+257,X=E(U,H+10,15)+4,Se=ke+E(U,H+5,31)+1;H+=14;for(var qe=new e(Se),Qe=new e(19),Ke=0;Ke<X;++Ke)Qe[a[Ke]]=E(U,H+3*Ke,7);H+=3*X;var pt=b(Qe),He=(1<<pt)-1,ze=g(Qe,pt);for(Ke=0;Ke<Se;){var rt,Le=ze[E(U,H,He)];if(H+=15&Le,(rt=Le>>>4)<16)qe[Ke++]=rt;else{var k=0,B=0;for(rt==16?(B=3+E(U,H,3),H+=2,k=qe[Ke-1]):rt==17?(B=3+E(U,H,7),H+=3):rt==18&&(B=11+E(U,H,127),H+=7);B--;)qe[Ke++]=k}}var G=qe.subarray(0,ke),ne=qe.subarray(ke);pe=b(G),Y=b(ne),ce=g(G,pe),xe=g(ne,Y)}else M(1);if(H>Ie){se&&M(0);break}}J&&q($+131072);for(var _e=(1<<pe)-1,Ye=(1<<Y)-1,et=H;;et=H){var we=(k=ce[C(U,H)&_e])>>>4;if((H+=15&k)>Ie){se&&M(0);break}if(k||M(2),we<256)j[$++]=we;else{if(we==256){et=H,ce=null;break}var bt=we-254;if(we>264){var wt=i[Ke=we-257];bt=E(U,H,(1<<wt)-1)+c[Ke],H+=wt}var tt=xe[C(U,H)&Ye],ee=tt>>>4;if(tt||M(3),H+=15&tt,ne=h[ee],ee>3&&(wt=r[ee],ne+=C(U,H)&(1<<wt)-1,H+=wt),H>Ie){se&&M(0);break}J&&q($+131072);for(var We=$+bt;$<We;$+=4)j[$]=j[$-ne],j[$+1]=j[$+1-ne],j[$+2]=j[$+2-ne],j[$+3]=j[$+3-ne];$=We}}F.l=ce,F.p=et,F.b=$,ce&&(te=1,F.m=pe,F.d=xe,F.n=Y)}while(!te);return $==j.length?j:function(Fe,Oe,nt){(nt==null||nt>Fe.length)&&(nt=Fe.length);var st=new(Fe instanceof t?t:Fe instanceof n?n:e)(nt-Oe);return st.set(Fe.subarray(Oe,nt)),st}(j,0,$)},z=new e(0),V=typeof TextDecoder<"u"&&new TextDecoder;try{V.decode(z,{stream:!0})}catch{}return s.convert_streams=function(U){var j=new DataView(U),F=0;function K(){var ke=j.getUint16(F);return F+=2,ke}function J(){var ke=j.getUint32(F);return F+=4,ke}function se(ke){oe.setUint16(ye,ke),ye+=2}function le(ke){oe.setUint32(ye,ke),ye+=4}for(var q={signature:J(),flavor:J(),length:J(),numTables:K(),reserved:K(),totalSfntSize:J(),majorVersion:K(),minorVersion:K(),metaOffset:J(),metaLength:J(),metaOrigLength:J(),privOffset:J(),privLength:J()},te=0;Math.pow(2,te)<=q.numTables;)te++;te--;for(var H=16*Math.pow(2,te),$=16*q.numTables-H,ce=12,xe=[],pe=0;pe<q.numTables;pe++)xe.push({tag:J(),offset:J(),compLength:J(),origLength:J(),origChecksum:J()}),ce+=16;var Y,Ie=new Uint8Array(12+16*xe.length+xe.reduce(function(ke,X){return ke+X.origLength+4},0)),re=Ie.buffer,oe=new DataView(re),ye=0;return le(q.flavor),se(q.numTables),se(H),se(te),se($),xe.forEach(function(ke){le(ke.tag),le(ke.origChecksum),le(ce),le(ke.origLength),ke.outOffset=ce,(ce+=ke.origLength)%4!=0&&(ce+=4-ce%4)}),xe.forEach(function(ke){var X,Se=U.slice(ke.offset,ke.offset+ke.compLength);if(ke.compLength!=ke.origLength){var qe=new Uint8Array(ke.origLength);X=new Uint8Array(Se,2),L(X,qe)}else qe=new Uint8Array(Se);Ie.set(qe,ke.outOffset);var Qe=0;(ce=ke.outOffset+ke.origLength)%4!=0&&(Qe=4-ce%4),Ie.set(new Uint8Array(Qe).buffer,ke.outOffset+ke.origLength),Y=ce+Qe}),re.slice(0,Y)},Object.defineProperty(s,"__esModule",{value:!0}),s}({}).convert_streams}function EB(s,e){const t={M:2,L:2,Q:4,C:6,Z:0},n={C:"18g,ca,368,1kz",D:"17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v",R:"17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6",L:"x9u,jff,a,fd,jv",T:"4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n"},i=1,r=2,a=4,o=8,l=16,c=32;let u;function h(E){if(!u){const C={R:r,L:i,D:a,C:l,U:c,T:o};u=new Map;for(let P in n){let M=0;n[P].split(",").forEach(L=>{let[z,V]=L.split("+");z=parseInt(z,36),V=V?parseInt(V,36):0,u.set(M+=z,C[P]);for(let U=V;U--;)u.set(++M,C[P])})}}return u.get(E)||c}const d=1,f=2,v=3,g=4,m=[null,"isol","init","fina","medi"];function x(E){const C=new Uint8Array(E.length);let P=c,M=d,L=-1;for(let z=0;z<E.length;z++){const V=E.codePointAt(z);let U=h(V)|0,j=d;U&o||(P&(i|a|l)?U&(r|a|l)?(j=v,(M===d||M===v)&&C[L]++):U&(i|c)&&(M===f||M===g)&&C[L]--:P&(r|c)&&(M===f||M===g)&&C[L]--,M=C[z]=j,P=U,L=z,V>65535&&z++)}return C}function w(E,C){const P=[];for(let L=0;L<C.length;L++){const z=C.codePointAt(L);z>65535&&L++,P.push(s.U.codeToGlyph(E,z))}const M=E.GSUB;if(M){const{lookupList:L,featureList:z}=M;let V;const U=/^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws)$/,j=[];z.forEach(F=>{if(U.test(F.tag))for(let K=0;K<F.tab.length;K++){if(j[F.tab[K]])continue;j[F.tab[K]]=!0;const J=L[F.tab[K]],se=/^(isol|init|fina|medi)$/.test(F.tag);se&&!V&&(V=x(C));for(let le=0;le<P.length;le++)(!V||!se||m[V[le]]===F.tag)&&s.U._applySubs(P,le,J,L)}})}return P}function S(...E){for(let C=0;C<E.length;C++)if(typeof E[C]=="number")return E[C]}function b(E){const C=Object.create(null),P=E["OS/2"],M=E.hhea,L=E.head.unitsPerEm,z=S(P&&P.sTypoAscender,M&&M.ascender,L),V={unitsPerEm:L,ascender:z,descender:S(P&&P.sTypoDescender,M&&M.descender,0),capHeight:S(P&&P.sCapHeight,z),xHeight:S(P&&P.sxHeight,z),lineGap:S(P&&P.sTypoLineGap,M&&M.lineGap),forEachGlyph(U,j,F,K){let J=0;const se=1/V.unitsPerEm*j,le=w(E,U);let q=0,te=-1;return le.forEach((H,$)=>{if(H!==-1){let ce=C[H];if(!ce){const{cmds:xe,crds:pe}=s.U.glyphToPath(E,H);let Y="",Ie=0;for(let X=0,Se=xe.length;X<Se;X++){const qe=t[xe[X]];Y+=xe[X];for(let Qe=1;Qe<=qe;Qe++)Y+=(Qe>1?",":"")+pe[Ie++]}let re,oe,ye,ke;if(pe.length){re=oe=1/0,ye=ke=-1/0;for(let X=0,Se=pe.length;X<Se;X+=2){let qe=pe[X],Qe=pe[X+1];qe<re&&(re=qe),Qe<oe&&(oe=Qe),qe>ye&&(ye=qe),Qe>ke&&(ke=Qe)}}else re=ye=oe=ke=0;ce=C[H]={index:H,advanceWidth:E.hmtx.aWidth[H],xMin:re,yMin:oe,xMax:ye,yMax:ke,path:Y,pathCommandCount:xe.length}}te!==-1&&(J+=s.U.getPairAdjustment(E,te,H)*se),K.call(null,ce,J,q),ce.advanceWidth&&(J+=ce.advanceWidth*se),F&&(J+=F*j),te=H}q+=U.codePointAt(q)>65535?2:1}),J}};return V}return function(C){const P=new Uint8Array(C,0,4),M=s._bin.readASCII(P,0,4);if(M==="wOFF")C=e(C);else if(M==="wOF2")throw new Error("woff2 fonts not supported");return b(s.parse(C)[0])}}const MB=Lh({name:"Typr Font Parser",dependencies:[AB,TB,EB],init(s,e,t){const n=s(),i=e();return t(n,i)}}),jl={defaultFontURL:"https://fonts.gstatic.com/s/roboto/v18/KFOmCnqEu92Fr1Mu4mxM.woff",sdfGlyphSize:64,sdfMargin:1/16,sdfExponent:9,textureWidth:2048},CB=new ot;function Cl(){return(self.performance||Date).now()}const aw=Object.create(null);function RB(s,e){s=PB({},s);const t=Cl();if(s.font=DB(s.font||jl.defaultFontURL),s.text=""+s.text,s.sdfGlyphSize=s.sdfGlyphSize||jl.sdfGlyphSize,s.colorRanges!=null){let h={};for(let d in s.colorRanges)if(s.colorRanges.hasOwnProperty(d)){let f=s.colorRanges[d];typeof f!="number"&&(f=CB.set(f).getHex()),h[d]=f}s.colorRanges=h}Object.freeze(s);const{textureWidth:n,sdfExponent:i}=jl,{sdfGlyphSize:r}=s,a=n/r*4;let o=aw[r];if(!o){const h=document.createElement("canvas");h.width=n,h.height=r*256/a,o=aw[r]={glyphCount:0,sdfGlyphSize:r,sdfCanvas:h,sdfTexture:new hi(h,void 0,void 0,void 0,cn,cn),contextLost:!1,glyphsByFont:new Map},o.sdfTexture.generateMipmaps=!1,IB(o)}const{sdfTexture:l,sdfCanvas:c}=o;let u=o.glyphsByFont.get(s.font);u||o.glyphsByFont.set(s.font,u=new Map),BB(s).then(h=>{const{glyphIds:d,glyphPositions:f,fontSize:v,unitsPerEm:g,timings:m}=h,x=[],w=new Float32Array(d.length*4),S=v/g;let b=0,E=0;const C=Cl();d.forEach((V,U)=>{let j=u.get(V);if(!j){const{path:se,pathBounds:le}=h.glyphData[V],q=Math.max(le[2]-le[0],le[3]-le[1])/r*(jl.sdfMargin*r+.5),te=o.glyphCount++,H=[le[0]-q,le[1]-q,le[2]+q,le[3]+q];u.set(V,j={path:se,atlasIndex:te,sdfViewBox:H}),x.push(j)}const{sdfViewBox:F}=j,K=f[E++],J=f[E++];w[b++]=K+F[0]*S,w[b++]=J+F[1]*S,w[b++]=K+F[2]*S,w[b++]=J+F[3]*S,d[U]=j.atlasIndex}),m.quads=(m.quads||0)+(Cl()-C);const P=Cl();m.sdf={};const M=c.height,L=Math.ceil(o.glyphCount/a),z=Math.pow(2,Math.ceil(Math.log2(L*r)));z>M&&(console.info(`Increasing SDF texture size ${M}->${z}`),bB(c,n,z),l.dispose()),Promise.all(x.map(V=>H1(V,o,s.gpuAccelerateSDF).then(({timing:U})=>{m.sdf[V.atlasIndex]=U}))).then(()=>{x.length&&!o.contextLost&&(W1(o),l.needsUpdate=!0),m.sdfTotal=Cl()-P,m.total=Cl()-t,e(Object.freeze({parameters:s,sdfTexture:l,sdfGlyphSize:r,sdfExponent:i,glyphBounds:w,glyphAtlasIndices:d,glyphColors:h.glyphColors,caretPositions:h.caretPositions,caretHeight:h.caretHeight,chunkedBounds:h.chunkedBounds,ascender:h.ascender,descender:h.descender,lineHeight:h.lineHeight,capHeight:h.capHeight,xHeight:h.xHeight,topBaseline:h.topBaseline,blockBounds:h.blockBounds,visibleBounds:h.visibleBounds,timings:h.timings}))})}),Promise.resolve().then(()=>{o.contextLost||SB(c)})}function H1({path:s,atlasIndex:e,sdfViewBox:t},{sdfGlyphSize:n,sdfCanvas:i,contextLost:r},a){if(r)return Promise.resolve({timing:-1});const{textureWidth:o,sdfExponent:l}=jl,c=Math.max(t[2]-t[0],t[3]-t[1]),u=Math.floor(e/4),h=u%(o/n)*n,d=Math.floor(u/(o/n))*n,f=e%4;return mB(n,n,s,t,c,l,i,h,d,f,a)}function IB(s){const e=s.sdfCanvas;e.addEventListener("webglcontextlost",t=>{console.log("Context Lost",t),t.preventDefault(),s.contextLost=!0}),e.addEventListener("webglcontextrestored",t=>{console.log("Context Restored",t),s.contextLost=!1;const n=[];s.glyphsByFont.forEach(i=>{i.forEach(r=>{n.push(H1(r,s,!0))})}),Promise.all(n).then(()=>{W1(s),s.sdfTexture.needsUpdate=!0})})}function PB(s,e){for(let t in e)e.hasOwnProperty(t)&&(s[t]=e[t]);return s}let Od;function DB(s){return Od||(Od=typeof document>"u"?{}:document.createElement("a")),Od.href=s,Od.href}function W1(s){if(typeof createImageBitmap!="function"){console.info("Safari<15: applying SDF canvas workaround");const{sdfCanvas:e,sdfTexture:t}=s,{width:n,height:i}=e,r=s.sdfCanvas.getContext("webgl");let a=t.image.data;(!a||a.length!==n*i*4)&&(a=new Uint8Array(n*i*4),t.image={width:n,height:i,data:a},t.flipY=!1,t.isDataTexture=!0),r.readPixels(0,0,n,i,r.RGBA,r.UNSIGNED_BYTE,a)}}const LB=Lh({name:"Typesetter",dependencies:[jl,MB,pB,aB],init(s,e,t,n){const{defaultFontURL:i}=s;return t(e,n(),{defaultFontURL:i})}}),BB=Lh({name:"Typesetter",dependencies:[LB],init(s){return function(e){return new Promise(t=>{s.typeset(e,t)})}},getTransferables(s){const e=[s.glyphPositions.buffer,s.glyphIds.buffer];return s.caretPositions&&e.push(s.caretPositions.buffer),s.glyphColors&&e.push(s.glyphColors.buffer),e}}),ow={};function OB(s){let e=ow[s];if(!e){const t=new Ks(1,1,s,s),n=t.clone(),i=t.attributes,r=n.attributes,a=new Xt,o=i.uv.count;for(let l=0;l<o;l++)r.position.array[l*3]*=-1,r.normal.array[l*3+2]*=-1;["position","normal","uv"].forEach(l=>{a.setAttribute(l,new Vt([...i[l].array,...r[l].array],i[l].itemSize))}),a.setIndex([...t.index.array,...n.index.array.map(l=>l+o)]),a.translate(.5,.5,0),e=ow[s]=a}return e}const NB="aTroikaGlyphBounds",lw="aTroikaGlyphIndex",zB="aTroikaGlyphColor";class FB extends e0{constructor(){super(),this.detail=1,this.curveRadius=0,this.groups=[{start:0,count:1/0,materialIndex:0},{start:0,count:1/0,materialIndex:1}],this.boundingSphere=new Zn,this.boundingBox=new Tt}computeBoundingSphere(){}computeBoundingBox(){}setSide(e){const t=this.getIndex().count;this.setDrawRange(e===er?t/2:0,e===Qt?t:t/2)}set detail(e){if(e!==this._detail){this._detail=e,(typeof e!="number"||e<1)&&(e=1);let t=OB(e);["position","normal","uv"].forEach(n=>{this.attributes[n]=t.attributes[n].clone()}),this.setIndex(t.getIndex().clone())}}get detail(){return this._detail}set curveRadius(e){e!==this._curveRadius&&(this._curveRadius=e,this._updateBounds())}get curveRadius(){return this._curveRadius}updateGlyphs(e,t,n,i,r){Zm(this,NB,e,4),Zm(this,lw,t,1),Zm(this,zB,r,3),this._blockBounds=n,this._chunkedBounds=i,this.instanceCount=t.length,this._updateBounds()}_updateBounds(){const e=this._blockBounds;if(e){const{curveRadius:t,boundingBox:n}=this;if(t){const{PI:i,floor:r,min:a,max:o,sin:l,cos:c}=Math,u=i/2,h=i*2,d=Math.abs(t),f=e[0]/d,v=e[2]/d,g=r((f+u)/h)!==r((v+u)/h)?-d:a(l(f)*d,l(v)*d),m=r((f-u)/h)!==r((v-u)/h)?d:o(l(f)*d,l(v)*d),x=r((f+i)/h)!==r((v+i)/h)?d*2:o(d-c(f)*d,d-c(v)*d);n.min.set(g,e[1],t<0?-x:0),n.max.set(m,e[3],t<0?0:x)}else n.min.set(e[0],e[1],0),n.max.set(e[2],e[3],0);n.getBoundingSphere(this.boundingSphere)}}applyClipRect(e){let t=this.getAttribute(lw).count,n=this._chunkedBounds;if(n)for(let i=n.length;i--;){t=n[i].end;let r=n[i].rect;if(r[1]<e.w&&r[3]>e.y&&r[0]<e.z&&r[2]>e.x)break}this.instanceCount=t}}function Zm(s,e,t,n){const i=s.getAttribute(e);t?i&&i.array.length===t.length?(i.array.set(t),i.needsUpdate=!0):(s.setAttribute(e,new ko(t,n)),delete s._maxInstanceCount,s.dispose()):i&&s.deleteAttribute(e)}const UB=`
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform vec4 uTroikaTotalBounds;
uniform vec4 uTroikaClipRect;
uniform mat3 uTroikaOrient;
uniform bool uTroikaUseGlyphColors;
uniform float uTroikaDistanceOffset;
uniform float uTroikaBlurRadius;
uniform vec2 uTroikaPositionOffset;
uniform float uTroikaCurveRadius;
attribute vec4 aTroikaGlyphBounds;
attribute float aTroikaGlyphIndex;
attribute vec3 aTroikaGlyphColor;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec3 vTroikaGlyphColor;
varying vec2 vTroikaGlyphDimensions;
`,kB=`
vec4 bounds = aTroikaGlyphBounds;
bounds.xz += uTroikaPositionOffset.x;
bounds.yw -= uTroikaPositionOffset.y;

vec4 outlineBounds = vec4(
  bounds.xy - uTroikaDistanceOffset - uTroikaBlurRadius,
  bounds.zw + uTroikaDistanceOffset + uTroikaBlurRadius
);
vec4 clippedBounds = vec4(
  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),
  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)
);

vec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);

position.xy = mix(bounds.xy, bounds.zw, clippedXY);

uv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);

float rad = uTroikaCurveRadius;
if (rad != 0.0) {
  float angle = position.x / rad;
  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);
  normal.xz = vec2(sin(angle), cos(angle));
}
  
position = uTroikaOrient * position;
normal = uTroikaOrient * normal;

vTroikaGlyphUV = clippedXY.xy;
vTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);


float txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;
vec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;
vec2 txStartUV = txUvPerSquare * vec2(
  mod(floor(aTroikaGlyphIndex / 4.0), txCols),
  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)
);
vTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);
vTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);
`,_B=`
uniform sampler2D uTroikaSDFTexture;
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform float uTroikaSDFExponent;
uniform float uTroikaDistanceOffset;
uniform float uTroikaFillOpacity;
uniform float uTroikaOutlineOpacity;
uniform float uTroikaBlurRadius;
uniform vec3 uTroikaStrokeColor;
uniform float uTroikaStrokeWidth;
uniform float uTroikaStrokeOpacity;
uniform bool uTroikaSDFDebug;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec2 vTroikaGlyphDimensions;

float troikaSdfValueToSignedDistance(float alpha) {
  // Inverse of exponential encoding in webgl-sdf-generator
  
  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);
  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;
  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);
  return signedDist;
}

float troikaGlyphUvToSdfValue(vec2 glyphUV) {
  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);
  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);
  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1
  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;
}

float troikaGlyphUvToDistance(vec2 uv) {
  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));
}

float troikaGetAADist() {
  
  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300
  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;
  #else
  return vTroikaGlyphDimensions.x / 64.0;
  #endif
}

float troikaGetFragDistValue() {
  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);
  float distance = troikaGlyphUvToDistance(clampedGlyphUV);
 
  // Extrapolate distance when outside bounds:
  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : 
    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);

  

  return distance;
}

float troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {
  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)
  float alpha = step(-distanceOffset, -distance);
  #else

  float alpha = smoothstep(
    distanceOffset + aaDist,
    distanceOffset - aaDist,
    distance
  );
  #endif

  return alpha;
}
`,VB=`
float aaDist = troikaGetAADist();
float fragDistance = troikaGetFragDistValue();
float edgeAlpha = uTroikaSDFDebug ?
  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :
  troikaGetEdgeAlpha(fragDistance, uTroikaDistanceOffset, max(aaDist, uTroikaBlurRadius));

#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)
vec4 fillRGBA = gl_FragColor;
fillRGBA.a *= uTroikaFillOpacity;
vec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);
if (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;
gl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(
  -uTroikaStrokeWidth - aaDist,
  -uTroikaStrokeWidth + aaDist,
  fragDistance
));
gl_FragColor.a *= edgeAlpha;
#endif

if (edgeAlpha == 0.0) {
  discard;
}
`;function q1(s){const e=lv(s,{chained:!0,extensions:{derivatives:!0},uniforms:{uTroikaSDFTexture:{value:null},uTroikaSDFTextureSize:{value:new Me},uTroikaSDFGlyphSize:{value:0},uTroikaSDFExponent:{value:0},uTroikaTotalBounds:{value:new Ft(0,0,0,0)},uTroikaClipRect:{value:new Ft(0,0,0,0)},uTroikaDistanceOffset:{value:0},uTroikaOutlineOpacity:{value:0},uTroikaFillOpacity:{value:1},uTroikaPositionOffset:{value:new Me},uTroikaCurveRadius:{value:0},uTroikaBlurRadius:{value:0},uTroikaStrokeWidth:{value:0},uTroikaStrokeColor:{value:new ot},uTroikaStrokeOpacity:{value:1},uTroikaOrient:{value:new Hn},uTroikaUseGlyphColors:{value:!0},uTroikaSDFDebug:{value:!1}},vertexDefs:UB,vertexTransform:kB,fragmentDefs:_B,fragmentColorTransform:VB,customRewriter({vertexShader:t,fragmentShader:n}){let i=/\buniform\s+vec3\s+diffuse\b/;return i.test(n)&&(n=n.replace(i,"varying vec3 vTroikaGlyphColor").replace(/\bdiffuse\b/g,"vTroikaGlyphColor"),i.test(t)||(t=t.replace(V1,`uniform vec3 diffuse;
$&
vTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;
`))),{vertexShader:t,fragmentShader:n}}});return e.transparent=!0,Object.defineProperties(e,{isTroikaTextMaterial:{value:!0},shadowSide:{get(){return this.side},set(){}}}),e}const C0=new Ja({color:16777215,side:Qt,transparent:!0}),cw=8421504,uw=new Ne,Nd=new T,$m=new T,su=[],GB=new T,eg="+x+y";function hw(s){return Array.isArray(s)?s[0]:s}let j1=()=>{const s=new gn(new Ks(1,1),C0);return j1=()=>s,s},Q1=()=>{const s=new gn(new Ks(1,1,32,1),C0);return Q1=()=>s,s};const HB={type:"syncstart"},WB={type:"synccomplete"},X1=["font","fontSize","letterSpacing","lineHeight","maxWidth","overflowWrap","text","direction","textAlign","textIndent","whiteSpace","anchorX","anchorY","colorRanges","sdfGlyphSize"],qB=X1.concat("material","color","depthOffset","clipRect","curveRadius","orientation","glyphGeometryDetail");class J1 extends gn{constructor(){const e=new FB;super(e,null),this.text="",this.anchorX=0,this.anchorY=0,this.curveRadius=0,this.direction="auto",this.font=null,this.fontSize=.1,this.letterSpacing=0,this.lineHeight="normal",this.maxWidth=1/0,this.overflowWrap="normal",this.textAlign="left",this.textIndent=0,this.whiteSpace="normal",this.material=null,this.color=null,this.colorRanges=null,this.outlineWidth=0,this.outlineColor=0,this.outlineOpacity=1,this.outlineBlur=0,this.outlineOffsetX=0,this.outlineOffsetY=0,this.strokeWidth=0,this.strokeColor=cw,this.strokeOpacity=1,this.fillOpacity=1,this.depthOffset=0,this.clipRect=null,this.orientation=eg,this.glyphGeometryDetail=1,this.sdfGlyphSize=null,this.gpuAccelerateSDF=!0,this.debugSDF=!1}sync(e){this._needsSync&&(this._needsSync=!1,this._isSyncing?(this._queuedSyncs||(this._queuedSyncs=[])).push(e):(this._isSyncing=!0,this.dispatchEvent(HB),RB({text:this.text,font:this.font,fontSize:this.fontSize||.1,letterSpacing:this.letterSpacing||0,lineHeight:this.lineHeight||"normal",maxWidth:this.maxWidth,direction:this.direction||"auto",textAlign:this.textAlign,textIndent:this.textIndent,whiteSpace:this.whiteSpace,overflowWrap:this.overflowWrap,anchorX:this.anchorX,anchorY:this.anchorY,colorRanges:this.colorRanges,includeCaretPositions:!0,sdfGlyphSize:this.sdfGlyphSize,gpuAccelerateSDF:this.gpuAccelerateSDF},t=>{this._isSyncing=!1,this._textRenderInfo=t,this.geometry.updateGlyphs(t.glyphBounds,t.glyphAtlasIndices,t.blockBounds,t.chunkedBounds,t.glyphColors);const n=this._queuedSyncs;n&&(this._queuedSyncs=null,this._needsSync=!0,this.sync(()=>{n.forEach(i=>i&&i())})),this.dispatchEvent(WB),e&&e()})))}onBeforeRender(e,t,n,i,r,a){this.sync(),r.isTroikaTextMaterial&&this._prepareForRender(r),r._hadOwnSide=r.hasOwnProperty("side"),this.geometry.setSide(r._actualSide=r.side),r.side=gr}onAfterRender(e,t,n,i,r,a){r._hadOwnSide?r.side=r._actualSide:delete r.side}dispose(){this.geometry.dispose()}get textRenderInfo(){return this._textRenderInfo||null}get material(){let e=this._derivedMaterial;const t=this._baseMaterial||this._defaultMaterial||(this._defaultMaterial=C0.clone());if((!e||e.baseMaterial!==t)&&(e=this._derivedMaterial=q1(t),t.addEventListener("dispose",function n(){t.removeEventListener("dispose",n),e.dispose()})),this.outlineWidth||this.outlineBlur||this.outlineOffsetX||this.outlineOffsetY){let n=e._outlineMtl;return n||(n=e._outlineMtl=Object.create(e,{id:{value:e.id+.1}}),n.isTextOutlineMaterial=!0,n.depthWrite=!1,n.map=null,e.addEventListener("dispose",function i(){e.removeEventListener("dispose",i),n.dispose()})),[n,e]}else return e}set material(e){e&&e.isTroikaTextMaterial?(this._derivedMaterial=e,this._baseMaterial=e.baseMaterial):this._baseMaterial=e}get glyphGeometryDetail(){return this.geometry.detail}set glyphGeometryDetail(e){this.geometry.detail=e}get curveRadius(){return this.geometry.curveRadius}set curveRadius(e){this.geometry.curveRadius=e}get customDepthMaterial(){return hw(this.material).getDepthMaterial()}get customDistanceMaterial(){return hw(this.material).getDistanceMaterial()}_prepareForRender(e){const t=e.isTextOutlineMaterial,n=e.uniforms,i=this.textRenderInfo;if(i){const{sdfTexture:o,blockBounds:l}=i;n.uTroikaSDFTexture.value=o,n.uTroikaSDFTextureSize.value.set(o.image.width,o.image.height),n.uTroikaSDFGlyphSize.value=i.sdfGlyphSize,n.uTroikaSDFExponent.value=i.sdfExponent,n.uTroikaTotalBounds.value.fromArray(l),n.uTroikaUseGlyphColors.value=!t&&!!i.glyphColors;let c=0,u=0,h=0,d,f,v,g=0,m=0;if(t){let{outlineWidth:w,outlineOffsetX:S,outlineOffsetY:b,outlineBlur:E,outlineOpacity:C}=this;c=this._parsePercent(w)||0,u=Math.max(0,this._parsePercent(E)||0),d=C,g=this._parsePercent(S)||0,m=this._parsePercent(b)||0}else h=Math.max(0,this._parsePercent(this.strokeWidth)||0),h&&(v=this.strokeColor,n.uTroikaStrokeColor.value.set(v??cw),f=this.strokeOpacity,f==null&&(f=1)),d=this.fillOpacity;n.uTroikaDistanceOffset.value=c,n.uTroikaPositionOffset.value.set(g,m),n.uTroikaBlurRadius.value=u,n.uTroikaStrokeWidth.value=h,n.uTroikaStrokeOpacity.value=f,n.uTroikaFillOpacity.value=d??1,n.uTroikaCurveRadius.value=this.curveRadius||0;let x=this.clipRect;if(x&&Array.isArray(x)&&x.length===4)n.uTroikaClipRect.value.fromArray(x);else{const w=(this.fontSize||.1)*100;n.uTroikaClipRect.value.set(l[0]-w,l[1]-w,l[2]+w,l[3]+w)}this.geometry.applyClipRect(n.uTroikaClipRect.value)}n.uTroikaSDFDebug.value=!!this.debugSDF,e.polygonOffset=!!this.depthOffset,e.polygonOffsetFactor=e.polygonOffsetUnits=this.depthOffset||0;const r=t?this.outlineColor||0:this.color;if(r==null)delete e.color;else{const o=e.hasOwnProperty("color")?e.color:e.color=new ot;(r!==o._input||typeof r=="object")&&o.set(o._input=r)}let a=this.orientation||eg;if(a!==e._orientation){let o=n.uTroikaOrient.value;a=a.replace(/[^-+xyz]/g,"");let l=a!==eg&&a.match(/^([-+])([xyz])([-+])([xyz])$/);if(l){let[,c,u,h,d]=l;Nd.set(0,0,0)[u]=c==="-"?1:-1,$m.set(0,0,0)[d]=h==="-"?-1:1,uw.lookAt(GB,Nd.cross($m),$m),o.setFromMatrix4(uw)}else o.identity();e._orientation=a}}_parsePercent(e){if(typeof e=="string"){let t=e.match(/^(-?[\d.]+)%$/),n=t?parseFloat(t[1]):NaN;e=(isNaN(n)?0:n/100)*this.fontSize}return e}localPositionToTextCoords(e,t=new Me){t.copy(e);const n=this.curveRadius;return n&&(t.x=Math.atan2(e.x,Math.abs(n)-Math.abs(e.z))*Math.abs(n)),t}worldPositionToTextCoords(e,t=new Me){return Nd.copy(e),this.localPositionToTextCoords(this.worldToLocal(Nd),t)}raycast(e,t){const{textRenderInfo:n,curveRadius:i}=this;if(n){const r=n.blockBounds,a=i?Q1():j1(),o=a.geometry,{position:l,uv:c}=o.attributes;for(let u=0;u<c.count;u++){let h=r[0]+c.getX(u)*(r[2]-r[0]);const d=r[1]+c.getY(u)*(r[3]-r[1]);let f=0;i&&(f=i-Math.cos(h/i)*i,h=Math.sin(h/i)*i),l.setXYZ(u,h,d,f)}o.boundingSphere=this.geometry.boundingSphere,o.boundingBox=this.geometry.boundingBox,a.matrixWorld=this.matrixWorld,a.material.side=this.material.side,su.length=0,a.raycast(e,su);for(let u=0;u<su.length;u++)su[u].object=this,t.push(su[u])}}copy(e){const t=this.geometry;return super.copy(e),this.geometry=t,qB.forEach(n=>{this[n]=e[n]}),this}clone(){return new this.constructor().copy(this)}}X1.forEach(s=>{const e="_private_"+s;Object.defineProperty(J1.prototype,s,{get(){return this[e]},set(t){t!==this[e]&&(this[e]=t,this._needsSync=!0)}})});for(let s=0;s<256;s++)(s<16?"0":"")+s.toString(16);const jB=Math.PI/180;function QB(s,e,t){return(1-t)*s+t*e}function XB(s,e,t=2){const n=s.length;let i=JB(s,0,n,t,!0);const r=[];if(!i||i.next===i.prev)return r;let a,o,l;if(s.length>80*t){a=1/0,o=1/0;let c=-1/0,u=-1/0;for(let h=t;h<n;h+=t){const d=s[h],f=s[h+1];d<a&&(a=d),f<o&&(o=f),d>c&&(c=d),f>u&&(u=f)}l=Math.max(c-a,u-o),l=l!==0?32767/l:0}return Wu(i,r,t,a,o,l,0),r}function JB(s,e,t,n,i){let r;if(i===oO(s,e,t,n)>0)for(let a=e;a<t;a+=n)r=dw(a/n|0,s[a],s[a+1],r);else for(let a=t-n;a>=e;a-=n)r=dw(a/n|0,s[a],s[a+1],r);return r&&Wp(r,r.next)&&(qu(r),r=r.next),r}function Hu(s,e){if(!s)return s;e||(e=s);let t=s,n;do if(n=!1,!t.steiner&&(Wp(t,t.next)||Kn(t.prev,t,t.next)===0)){if(qu(t),t=e=t.prev,t===t.next)break;n=!0}else t=t.next;while(n||t!==e);return e}function Wu(s,e,t,n,i,r,a){if(!s)return;!a&&r&&eO(s,n,i,r);let o=s;for(;s.prev!==s.next;){const l=s.prev,c=s.next;if(r?YB(s,n,i,r):KB(s)){e.push(l.i,s.i,c.i),qu(s),s=c.next,o=c.next;continue}if(s=c,s===o){a?a===1?(s=ZB(Hu(s),e),Wu(s,e,t,n,i,r,2)):a===2&&$B(s,e,t,n,i,r):Wu(Hu(s),e,t,n,i,r,1);break}}}function KB(s){const e=s.prev,t=s,n=s.next;if(Kn(e,t,n)>=0)return!1;const i=e.x,r=t.x,a=n.x,o=e.y,l=t.y,c=n.y,u=Math.min(i,r,a),h=Math.min(o,l,c),d=Math.max(i,r,a),f=Math.max(o,l,c);let v=n.next;for(;v!==e;){if(v.x>=u&&v.x<=d&&v.y>=h&&v.y<=f&&du(i,o,r,l,a,c,v.x,v.y)&&Kn(v.prev,v,v.next)>=0)return!1;v=v.next}return!0}function YB(s,e,t,n){const i=s.prev,r=s,a=s.next;if(Kn(i,r,a)>=0)return!1;const o=i.x,l=r.x,c=a.x,u=i.y,h=r.y,d=a.y,f=Math.min(o,l,c),v=Math.min(u,h,d),g=Math.max(o,l,c),m=Math.max(u,h,d),x=uv(f,v,e,t,n),w=uv(g,m,e,t,n);let S=s.prevZ,b=s.nextZ;for(;S&&S.z>=x&&b&&b.z<=w;){if(S.x>=f&&S.x<=g&&S.y>=v&&S.y<=m&&S!==i&&S!==a&&du(o,u,l,h,c,d,S.x,S.y)&&Kn(S.prev,S,S.next)>=0||(S=S.prevZ,b.x>=f&&b.x<=g&&b.y>=v&&b.y<=m&&b!==i&&b!==a&&du(o,u,l,h,c,d,b.x,b.y)&&Kn(b.prev,b,b.next)>=0))return!1;b=b.nextZ}for(;S&&S.z>=x;){if(S.x>=f&&S.x<=g&&S.y>=v&&S.y<=m&&S!==i&&S!==a&&du(o,u,l,h,c,d,S.x,S.y)&&Kn(S.prev,S,S.next)>=0)return!1;S=S.prevZ}for(;b&&b.z<=w;){if(b.x>=f&&b.x<=g&&b.y>=v&&b.y<=m&&b!==i&&b!==a&&du(o,u,l,h,c,d,b.x,b.y)&&Kn(b.prev,b,b.next)>=0)return!1;b=b.nextZ}return!0}function ZB(s,e){let t=s;do{const n=t.prev,i=t.next.next;!Wp(n,i)&&K1(n,t,t.next,i)&&up(n,i)&&up(i,n)&&(e.push(n.i,t.i,i.i),qu(t),qu(t.next),t=s=i),t=t.next}while(t!==s);return Hu(t)}function $B(s,e,t,n,i,r){let a=s;do{let o=a.next.next;for(;o!==a.prev;){if(a.i!==o.i&&iO(a,o)){let l=aO(a,o);a=Hu(a,a.next),l=Hu(l,l.next),Wu(a,e,t,n,i,r,0),Wu(l,e,t,n,i,r,0);return}o=o.next}a=a.next}while(a!==s)}function eO(s,e,t,n){let i=s;do i.z===0&&(i.z=uv(i.x,i.y,e,t,n)),i.prevZ=i.prev,i.nextZ=i.next,i=i.next;while(i!==s);i.prevZ.nextZ=null,i.prevZ=null,tO(i)}function tO(s){let e,t=1;do{let n=s,i;s=null;let r=null;for(e=0;n;){e++;let a=n,o=0;for(let c=0;c<t&&(o++,a=a.nextZ,!!a);c++);let l=t;for(;o>0||l>0&&a;)o!==0&&(l===0||!a||n.z<=a.z)?(i=n,n=n.nextZ,o--):(i=a,a=a.nextZ,l--),r?r.nextZ=i:s=i,i.prevZ=r,r=i;n=a}r.nextZ=null,t*=2}while(e>1);return s}function uv(s,e,t,n,i){return s=(s-t)*i|0,e=(e-n)*i|0,s=(s|s<<8)&16711935,s=(s|s<<4)&252645135,s=(s|s<<2)&858993459,s=(s|s<<1)&1431655765,e=(e|e<<8)&16711935,e=(e|e<<4)&252645135,e=(e|e<<2)&858993459,e=(e|e<<1)&1431655765,s|e<<1}function nO(s,e,t,n,i,r,a,o){return(i-a)*(e-o)>=(s-a)*(r-o)&&(s-a)*(n-o)>=(t-a)*(e-o)&&(t-a)*(r-o)>=(i-a)*(n-o)}function du(s,e,t,n,i,r,a,o){return!(s===a&&e===o)&&nO(s,e,t,n,i,r,a,o)}function iO(s,e){return s.next.i!==e.i&&s.prev.i!==e.i&&!rO(s,e)&&(up(s,e)&&up(e,s)&&sO(s,e)&&(Kn(s.prev,s,e.prev)||Kn(s,e.prev,e))||Wp(s,e)&&Kn(s.prev,s,s.next)>0&&Kn(e.prev,e,e.next)>0)}function Kn(s,e,t){return(e.y-s.y)*(t.x-e.x)-(e.x-s.x)*(t.y-e.y)}function Wp(s,e){return s.x===e.x&&s.y===e.y}function K1(s,e,t,n){const i=Fd(Kn(s,e,t)),r=Fd(Kn(s,e,n)),a=Fd(Kn(t,n,s)),o=Fd(Kn(t,n,e));return!!(i!==r&&a!==o||i===0&&zd(s,t,e)||r===0&&zd(s,n,e)||a===0&&zd(t,s,n)||o===0&&zd(t,e,n))}function zd(s,e,t){return e.x<=Math.max(s.x,t.x)&&e.x>=Math.min(s.x,t.x)&&e.y<=Math.max(s.y,t.y)&&e.y>=Math.min(s.y,t.y)}function Fd(s){return s>0?1:s<0?-1:0}function rO(s,e){let t=s;do{if(t.i!==s.i&&t.next.i!==s.i&&t.i!==e.i&&t.next.i!==e.i&&K1(t,t.next,s,e))return!0;t=t.next}while(t!==s);return!1}function up(s,e){return Kn(s.prev,s,s.next)<0?Kn(s,e,s.next)>=0&&Kn(s,s.prev,e)>=0:Kn(s,e,s.prev)<0||Kn(s,s.next,e)<0}function sO(s,e){let t=s,n=!1;const i=(s.x+e.x)/2,r=(s.y+e.y)/2;do t.y>r!=t.next.y>r&&t.next.y!==t.y&&i<(t.next.x-t.x)*(r-t.y)/(t.next.y-t.y)+t.x&&(n=!n),t=t.next;while(t!==s);return n}function aO(s,e){const t=hv(s.i,s.x,s.y),n=hv(e.i,e.x,e.y),i=s.next,r=e.prev;return s.next=e,e.prev=s,t.next=i,i.prev=t,n.next=t,t.prev=n,r.next=n,n.prev=r,n}function dw(s,e,t,n){const i=hv(s,e,t);return n?(i.next=n.next,i.prev=n,n.next.prev=i,n.next=i):(i.prev=i,i.next=i),i}function qu(s){s.next.prev=s.prev,s.prev.next=s.next,s.prevZ&&(s.prevZ.nextZ=s.nextZ),s.nextZ&&(s.nextZ.prevZ=s.prevZ)}function hv(s,e,t){return{i:s,x:e,y:t,prev:null,next:null,z:0,prevZ:null,nextZ:null,steiner:!1}}function oO(s,e,t,n){let i=0;for(let r=e,a=t-n;r<t;r+=n)i+=(s[a]-s[r])*(s[r+1]+s[a+1]),a=r;return i}const fw=new Tt,Ud=new T;class Xo extends e0{constructor(){super(),this.type="LineSegmentsGeometry";const e=[-1,2,0,1,2,0,-1,1,0,1,1,0,-1,0,0,1,0,0,-1,-1,0,1,-1,0],t=[-1,2,1,2,-1,1,1,1,-1,-1,1,-1,-1,-2,1,-2],n=[0,2,1,2,3,1,2,4,3,4,5,3,4,6,5,6,7,5];this.setIndex(n),this.setAttribute("position",new Vt(e,3)),this.setAttribute("uv",new Vt(t,2))}applyMatrix4(e){const t=this.attributes.instanceStart,n=this.attributes.instanceEnd;return t!==void 0&&(t.applyMatrix4(e),n.applyMatrix4(e),t.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}setPositions(e){let t;e instanceof Float32Array?t=e:Array.isArray(e)&&(t=new Float32Array(e));const n=new wc(t,6,1);return this.setAttribute("instanceStart",new $i(n,3,0)),this.setAttribute("instanceEnd",new $i(n,3,3)),this.computeBoundingBox(),this.computeBoundingSphere(),this}setColors(e){let t;e instanceof Float32Array?t=e:Array.isArray(e)&&(t=new Float32Array(e));const n=new wc(t,6,1);return this.setAttribute("instanceColorStart",new $i(n,3,0)),this.setAttribute("instanceColorEnd",new $i(n,3,3)),this}fromWireframeGeometry(e){return this.setPositions(e.attributes.position.array),this}fromEdgesGeometry(e){return this.setPositions(e.attributes.position.array),this}fromMesh(e){return this.fromWireframeGeometry(new uI(e.geometry)),this}fromLineSegments(e){const t=e.geometry;if(t.isGeometry){console.error("THREE.LineSegmentsGeometry no longer supports Geometry. Use THREE.BufferGeometry instead.");return}else t.isBufferGeometry&&this.setPositions(t.attributes.position.array);return this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Tt);const e=this.attributes.instanceStart,t=this.attributes.instanceEnd;e!==void 0&&t!==void 0&&(this.boundingBox.setFromBufferAttribute(e),fw.setFromBufferAttribute(t),this.boundingBox.union(fw))}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Zn),this.boundingBox===null&&this.computeBoundingBox();const e=this.attributes.instanceStart,t=this.attributes.instanceEnd;if(e!==void 0&&t!==void 0){const n=this.boundingSphere.center;this.boundingBox.getCenter(n);let i=0;for(let r=0,a=e.count;r<a;r++)Ud.fromBufferAttribute(e,r),i=Math.max(i,n.distanceToSquared(Ud)),Ud.fromBufferAttribute(t,r),i=Math.max(i,n.distanceToSquared(Ud));this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.",this)}}toJSON(){}applyMatrix(e){return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."),this.applyMatrix4(e)}}Xo.prototype.isLineSegmentsGeometry=!0;const pw=new T,mw=new T,Mi=new Ft,Ci=new Ft,Kr=new Ft,tg=new T,ng=new Ne,Hi=new Mr,gw=new T,kd=new Tt,_d=new Zn,Yr=new Ft;let ss,dv,Y1,Vo;function vw(s,e,t){return Yr.set(0,0,-e,1).applyMatrix4(s.projectionMatrix),Yr.multiplyScalar(1/Yr.w),Yr.x=Vo/t.width,Yr.y=Vo/t.height,Yr.applyMatrix4(s.projectionMatrixInverse),Yr.multiplyScalar(1/Yr.w),Math.abs(Math.max(Yr.x,Yr.y))}function lO(s,e){for(let t=0,n=dv.count;t<n;t++){Hi.start.fromBufferAttribute(dv,t),Hi.end.fromBufferAttribute(Y1,t);const i=new T,r=new T;ss.distanceSqToSegment(Hi.start,Hi.end,r,i),r.distanceTo(i)<Vo*.5&&e.push({point:r,pointOnLine:i,distance:ss.origin.distanceTo(r),object:s,face:null,faceIndex:t,uv:null,uv2:null})}}function cO(s,e,t){const n=e.projectionMatrix,r=s.material.resolution,a=s.matrixWorld,o=s.geometry,l=o.attributes.instanceStart,c=o.attributes.instanceEnd,u=-e.near;ss.at(1,Kr),Kr.w=1,Kr.applyMatrix4(e.matrixWorldInverse),Kr.applyMatrix4(n),Kr.multiplyScalar(1/Kr.w),Kr.x*=r.x/2,Kr.y*=r.y/2,Kr.z=0,tg.copy(Kr),ng.multiplyMatrices(e.matrixWorldInverse,a);for(let h=0,d=l.count;h<d;h++){if(Mi.fromBufferAttribute(l,h),Ci.fromBufferAttribute(c,h),Mi.w=1,Ci.w=1,Mi.applyMatrix4(ng),Ci.applyMatrix4(ng),Mi.z>u&&Ci.z>u)continue;if(Mi.z>u){const w=Mi.z-Ci.z,S=(Mi.z-u)/w;Mi.lerp(Ci,S)}else if(Ci.z>u){const w=Ci.z-Mi.z,S=(Ci.z-u)/w;Ci.lerp(Mi,S)}Mi.applyMatrix4(n),Ci.applyMatrix4(n),Mi.multiplyScalar(1/Mi.w),Ci.multiplyScalar(1/Ci.w),Mi.x*=r.x/2,Mi.y*=r.y/2,Ci.x*=r.x/2,Ci.y*=r.y/2,Hi.start.copy(Mi),Hi.start.z=0,Hi.end.copy(Ci),Hi.end.z=0;const v=Hi.closestPointToPointParameter(tg,!0);Hi.at(v,gw);const g=ci.lerp(Mi.z,Ci.z,v),m=g>=-1&&g<=1,x=tg.distanceTo(gw)<Vo*.5;if(m&&x){Hi.start.fromBufferAttribute(l,h),Hi.end.fromBufferAttribute(c,h),Hi.start.applyMatrix4(a),Hi.end.applyMatrix4(a);const w=new T,S=new T;ss.distanceSqToSegment(Hi.start,Hi.end,S,w),t.push({point:S,pointOnLine:w,distance:ss.origin.distanceTo(S),object:s,face:null,faceIndex:h,uv:null,uv2:null})}}}class Tc extends gn{constructor(e=new Xo,t=new M0({color:Math.random()*16777215})){super(e,t),this.type="LineSegments2"}computeLineDistances(){const e=this.geometry,t=e.attributes.instanceStart,n=e.attributes.instanceEnd,i=new Float32Array(2*t.count);for(let a=0,o=0,l=t.count;a<l;a++,o+=2)pw.fromBufferAttribute(t,a),mw.fromBufferAttribute(n,a),i[o]=o===0?0:i[o-1],i[o+1]=i[o]+pw.distanceTo(mw);const r=new wc(i,2,1);return e.setAttribute("instanceDistanceStart",new $i(r,1,0)),e.setAttribute("instanceDistanceEnd",new $i(r,1,1)),this}raycast(e,t){const n=this.material.worldUnits,i=e.camera;i===null&&!n&&console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');const r=e.params.Line2!==void 0&&e.params.Line2.threshold||0;ss=e.ray;const a=this.matrixWorld,o=this.geometry,l=this.material;Vo=l.linewidth+r,dv=o.attributes.instanceStart,Y1=o.attributes.instanceEnd,o.boundingSphere===null&&o.computeBoundingSphere(),_d.copy(o.boundingSphere).applyMatrix4(a);let c;if(n)c=Vo*.5;else{const h=Math.max(i.near,_d.distanceToPoint(ss.origin));c=vw(i,h,l.resolution)}if(_d.radius+=c,ss.intersectsSphere(_d)===!1)return;o.boundingBox===null&&o.computeBoundingBox(),kd.copy(o.boundingBox).applyMatrix4(a);let u;if(n)u=Vo*.5;else{const h=Math.max(i.near,kd.distanceToPoint(ss.origin));u=vw(i,h,l.resolution)}kd.expandByScalar(u),ss.intersectsBox(kd)!==!1&&(n?lO(this,t):cO(this,i,t))}}Tc.prototype.isLineSegments2=!0;const R0=0,uO=1,hO=2,yw=2,ig=1.25,xw=1,Tf=6*4+4+4,fv=65535,dO=Math.pow(2,-24);class Vd{constructor(){}}function Wr(s,e,t){return t.min.x=e[s],t.min.y=e[s+1],t.min.z=e[s+2],t.max.x=e[s+3],t.max.y=e[s+4],t.max.z=e[s+5],t}function ww(s){let e=-1,t=-1/0;for(let n=0;n<3;n++){const i=s[n+3]-s[n];i>t&&(t=i,e=n)}return e}function Sw(s,e){e.set(s)}function bw(s,e,t){let n,i;for(let r=0;r<3;r++){const a=r+3;n=s[r],i=e[r],t[r]=n<i?n:i,n=s[a],i=e[a],t[a]=n>i?n:i}}function Gd(s,e,t){for(let n=0;n<3;n++){const i=e[s+2*n],r=e[s+2*n+1],a=i-r,o=i+r;a<t[n]&&(t[n]=a),o>t[n+3]&&(t[n+3]=o)}}function au(s){const e=s[3]-s[0],t=s[4]-s[1],n=s[5]-s[2];return 2*(e*t+t*n+n*e)}function fO(s,e){if(!s.index){const t=s.attributes.position.count,n=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;let i;t>65535?i=new Uint32Array(new n(4*t)):i=new Uint16Array(new n(2*t)),s.setIndex(new Sn(i,1));for(let r=0;r<t;r++)i[r]=r}}function pO(s){if(!s.groups||!s.groups.length)return[{offset:0,count:s.index.count/3}];const e=[],t=new Set;for(const i of s.groups)t.add(i.start),t.add(i.start+i.count);const n=Array.from(t.values()).sort((i,r)=>i-r);for(let i=0;i<n.length-1;i++){const r=n[i],a=n[i+1];e.push({offset:r/3,count:(a-r)/3})}return e}function rg(s,e,t,n,i=null){let r=1/0,a=1/0,o=1/0,l=-1/0,c=-1/0,u=-1/0,h=1/0,d=1/0,f=1/0,v=-1/0,g=-1/0,m=-1/0;const x=i!==null;for(let w=e*6,S=(e+t)*6;w<S;w+=6){const b=s[w+0],E=s[w+1],C=b-E,P=b+E;C<r&&(r=C),P>l&&(l=P),x&&b<h&&(h=b),x&&b>v&&(v=b);const M=s[w+2],L=s[w+3],z=M-L,V=M+L;z<a&&(a=z),V>c&&(c=V),x&&M<d&&(d=M),x&&M>g&&(g=M);const U=s[w+4],j=s[w+5],F=U-j,K=U+j;F<o&&(o=F),K>u&&(u=K),x&&U<f&&(f=U),x&&U>m&&(m=U)}n[0]=r,n[1]=a,n[2]=o,n[3]=l,n[4]=c,n[5]=u,x&&(i[0]=h,i[1]=d,i[2]=f,i[3]=v,i[4]=g,i[5]=m)}function mO(s,e,t,n){let i=1/0,r=1/0,a=1/0,o=-1/0,l=-1/0,c=-1/0;for(let u=e*6,h=(e+t)*6;u<h;u+=6){const d=s[u+0];d<i&&(i=d),d>o&&(o=d);const f=s[u+2];f<r&&(r=f),f>l&&(l=f);const v=s[u+4];v<a&&(a=v),v>c&&(c=v)}n[0]=i,n[1]=r,n[2]=a,n[3]=o,n[4]=l,n[5]=c}function gO(s,e,t,n,i){let r=t,a=t+n-1;const o=i.pos,l=i.axis*2;for(;;){for(;r<=a&&e[r*6+l]<o;)r++;for(;r<=a&&e[a*6+l]>=o;)a--;if(r<a){for(let c=0;c<3;c++){let u=s[r*3+c];s[r*3+c]=s[a*3+c],s[a*3+c]=u;let h=e[r*6+c*2+0];e[r*6+c*2+0]=e[a*6+c*2+0],e[a*6+c*2+0]=h;let d=e[r*6+c*2+1];e[r*6+c*2+1]=e[a*6+c*2+1],e[a*6+c*2+1]=d}r++,a--}else return r}}const Fs=32,vO=(s,e)=>s.candidate-e.candidate,Sa=new Array(Fs).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),Hd=new Float32Array(6);function yO(s,e,t,n,i,r){let a=-1,o=0;if(r===R0)a=ww(e),a!==-1&&(o=(e[a]+e[a+3])/2);else if(r===uO)a=ww(s),a!==-1&&(o=xO(t,n,i,a));else if(r===hO){const l=au(s);let c=ig*i;const u=n*6,h=(n+i)*6;for(let d=0;d<3;d++){const f=e[d],m=(e[d+3]-f)/Fs;if(i<Fs/4){const x=[...Sa];x.length=i;let w=0;for(let b=u;b<h;b+=6,w++){const E=x[w];E.candidate=t[b+2*d],E.count=0;const{bounds:C,leftCacheBounds:P,rightCacheBounds:M}=E;for(let L=0;L<3;L++)M[L]=1/0,M[L+3]=-1/0,P[L]=1/0,P[L+3]=-1/0,C[L]=1/0,C[L+3]=-1/0;Gd(b,t,C)}x.sort(vO);let S=i;for(let b=0;b<S;b++){const E=x[b];for(;b+1<S&&x[b+1].candidate===E.candidate;)x.splice(b+1,1),S--}for(let b=u;b<h;b+=6){const E=t[b+2*d];for(let C=0;C<S;C++){const P=x[C];E>=P.candidate?Gd(b,t,P.rightCacheBounds):(Gd(b,t,P.leftCacheBounds),P.count++)}}for(let b=0;b<S;b++){const E=x[b],C=E.count,P=i-E.count,M=E.leftCacheBounds,L=E.rightCacheBounds;let z=0;C!==0&&(z=au(M)/l);let V=0;P!==0&&(V=au(L)/l);const U=xw+ig*(z*C+V*P);U<c&&(a=d,c=U,o=E.candidate)}}else{for(let S=0;S<Fs;S++){const b=Sa[S];b.count=0,b.candidate=f+m+S*m;const E=b.bounds;for(let C=0;C<3;C++)E[C]=1/0,E[C+3]=-1/0}for(let S=u;S<h;S+=6){let C=~~((t[S+2*d]-f)/m);C>=Fs&&(C=Fs-1);const P=Sa[C];P.count++,Gd(S,t,P.bounds)}const x=Sa[Fs-1];Sw(x.bounds,x.rightCacheBounds);for(let S=Fs-2;S>=0;S--){const b=Sa[S],E=Sa[S+1];bw(b.bounds,E.rightCacheBounds,b.rightCacheBounds)}let w=0;for(let S=0;S<Fs-1;S++){const b=Sa[S],E=b.count,C=b.bounds,M=Sa[S+1].rightCacheBounds;E!==0&&(w===0?Sw(C,Hd):bw(C,Hd,Hd)),w+=E;let L=0,z=0;w!==0&&(L=au(Hd)/l);const V=i-w;V!==0&&(z=au(M)/l);const U=xw+ig*(L*w+z*V);U<c&&(a=d,c=U,o=b.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${r} used.`);return{axis:a,pos:o}}function xO(s,e,t,n){let i=0;for(let r=e,a=e+t;r<a;r++)i+=s[r*6+n*2];return i/t}function wO(s,e){const t=s.attributes.position,n=s.index.array,i=n.length/3,r=new Float32Array(i*6),a=t.normalized,o=t.array,l=t.offset||0;let c=3;t.isInterleavedBufferAttribute&&(c=t.data.stride);const u=["getX","getY","getZ"];for(let h=0;h<i;h++){const d=h*3,f=h*6;let v,g,m;a?(v=n[d+0],g=n[d+1],m=n[d+2]):(v=n[d+0]*c+l,g=n[d+1]*c+l,m=n[d+2]*c+l);for(let x=0;x<3;x++){let w,S,b;a?(w=t[u[x]](v),S=t[u[x]](g),b=t[u[x]](m)):(w=o[v+x],S=o[g+x],b=o[m+x]);let E=w;S<E&&(E=S),b<E&&(E=b);let C=w;S>C&&(C=S),b>C&&(C=b);const P=(C-E)/2,M=x*2;r[f+M+0]=E+P,r[f+M+1]=P+(Math.abs(E)+P)*dO,E<e[x]&&(e[x]=E),C>e[x+3]&&(e[x+3]=C)}}return r}function SO(s,e){function t(x){d&&d(x/f)}function n(x,w,S,b=null,E=0){if(!v&&E>=l&&(v=!0,c&&(console.warn(`MeshBVH: Max depth of ${l} reached when generating BVH. Consider increasing maxDepth.`),console.warn(s))),S<=u||E>=l)return t(w+S),x.offset=w,x.count=S,x;const C=yO(x.boundingData,b,a,w,S,h);if(C.axis===-1)return t(w+S),x.offset=w,x.count=S,x;const P=gO(o,a,w,S,C);if(P===w||P===w+S)t(w+S),x.offset=w,x.count=S;else{x.splitAxis=C.axis;const M=new Vd,L=w,z=P-w;x.left=M,M.boundingData=new Float32Array(6),rg(a,L,z,M.boundingData,r),n(M,L,z,r,E+1);const V=new Vd,U=P,j=S-z;x.right=V,V.boundingData=new Float32Array(6),rg(a,U,j,V.boundingData,r),n(V,U,j,r,E+1)}return x}fO(s,e);const i=new Float32Array(6),r=new Float32Array(6),a=wO(s,i),o=s.index.array,l=e.maxDepth,c=e.verbose,u=e.maxLeafTris,h=e.strategy,d=e.onProgress,f=s.index.count/3;let v=!1;const g=[],m=pO(s);if(m.length===1){const x=m[0],w=new Vd;w.boundingData=i,mO(a,x.offset,x.count,r),n(w,x.offset,x.count,r),g.push(w)}else for(let x of m){const w=new Vd;w.boundingData=new Float32Array(6),rg(a,x.offset,x.count,w.boundingData,r),n(w,x.offset,x.count,r),g.push(w)}return g}function bO(s,e){const t=SO(s,e);let n,i,r;const a=[],o=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;for(let u=0;u<t.length;u++){const h=t[u];let d=l(h);const f=new o(Tf*d);n=new Float32Array(f),i=new Uint32Array(f),r=new Uint16Array(f),c(0,h),a.push(f)}return a;function l(u){return u.count?1:1+l(u.left)+l(u.right)}function c(u,h){const d=u/4,f=u/2,v=!!h.count,g=h.boundingData;for(let m=0;m<6;m++)n[d+m]=g[m];if(v){const m=h.offset,x=h.count;return i[d+6]=m,r[f+14]=x,r[f+15]=fv,u+Tf}else{const m=h.left,x=h.right,w=h.splitAxis;let S;if(S=c(u+Tf,m),S/4>Math.pow(2,32))throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return i[d+6]=S/4,S=c(S,x),i[d+7]=w,S}}}class ea{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(e,t){let n=1/0,i=-1/0;for(let r=0,a=e.length;r<a;r++){const l=e[r][t];n=l<n?l:n,i=l>i?l:i}this.min=n,this.max=i}setFromPoints(e,t){let n=1/0,i=-1/0;for(let r=0,a=t.length;r<a;r++){const o=t[r],l=e.dot(o);n=l<n?l:n,i=l>i?l:i}this.min=n,this.max=i}isSeparated(e){return this.min>e.max||e.min>this.max}}ea.prototype.setFromBox=function(){const s=new T;return function(t,n){const i=n.min,r=n.max;let a=1/0,o=-1/0;for(let l=0;l<=1;l++)for(let c=0;c<=1;c++)for(let u=0;u<=1;u++){s.x=i.x*l+r.x*(1-l),s.y=i.y*c+r.y*(1-c),s.z=i.z*u+r.z*(1-u);const h=t.dot(s);a=Math.min(h,a),o=Math.max(h,o)}this.min=a,this.max=o}}();const AO=function(){const s=new T,e=new T,t=new T;return function(i,r,a){const o=i.start,l=s,c=r.start,u=e;t.subVectors(o,c),s.subVectors(i.end,i.start),e.subVectors(r.end,r.start);const h=t.dot(u),d=u.dot(l),f=u.dot(u),v=t.dot(l),m=l.dot(l)*f-d*d;let x,w;m!==0?x=(h*d-v*f)/m:x=0,w=(h+x*d)/f,a.x=x,a.y=w}}(),I0=function(){const s=new Me,e=new T,t=new T;return function(i,r,a,o){AO(i,r,s);let l=s.x,c=s.y;if(l>=0&&l<=1&&c>=0&&c<=1){i.at(l,a),r.at(c,o);return}else if(l>=0&&l<=1){c<0?r.at(0,o):r.at(1,o),i.closestPointToPoint(o,!0,a);return}else if(c>=0&&c<=1){l<0?i.at(0,a):i.at(1,a),r.closestPointToPoint(a,!0,o);return}else{let u;l<0?u=i.start:u=i.end;let h;c<0?h=r.start:h=r.end;const d=e,f=t;if(i.closestPointToPoint(h,!0,e),r.closestPointToPoint(u,!0,t),d.distanceToSquared(h)<=f.distanceToSquared(u)){a.copy(d),o.copy(h);return}else{a.copy(u),o.copy(f);return}}}}(),TO=function(){const s=new T,e=new T,t=new vi,n=new Mr;return function(r,a){const{radius:o,center:l}=r,{a:c,b:u,c:h}=a;if(n.start=c,n.end=u,n.closestPointToPoint(l,!0,s).distanceTo(l)<=o||(n.start=c,n.end=h,n.closestPointToPoint(l,!0,s).distanceTo(l)<=o)||(n.start=u,n.end=h,n.closestPointToPoint(l,!0,s).distanceTo(l)<=o))return!0;const g=a.getPlane(t);if(Math.abs(g.distanceToPoint(l))<=o){const x=g.projectPoint(l,e);if(a.containsPoint(x))return!0}return!1}}(),EO=1e-15;function Rl(s){return Math.abs(s)<EO}class cs extends Cn{constructor(...e){super(...e),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new T),this.satBounds=new Array(4).fill().map(()=>new ea),this.points=[this.a,this.b,this.c],this.sphere=new Zn,this.plane=new vi,this.needsUpdate=!0}intersectsSphere(e){return TO(e,this)}update(){const e=this.a,t=this.b,n=this.c,i=this.points,r=this.satAxes,a=this.satBounds,o=r[0],l=a[0];this.getNormal(o),l.setFromPoints(o,i);const c=r[1],u=a[1];c.subVectors(e,t),u.setFromPoints(c,i);const h=r[2],d=a[2];h.subVectors(t,n),d.setFromPoints(h,i);const f=r[3],v=a[3];f.subVectors(n,e),v.setFromPoints(f,i),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(o,e),this.needsUpdate=!1}}cs.prototype.closestPointToSegment=function(){const s=new T,e=new T,t=new Mr;return function(i,r=null,a=null){const{start:o,end:l}=i,c=this.points;let u,h=1/0;for(let d=0;d<3;d++){const f=(d+1)%3;t.start.copy(c[d]),t.end.copy(c[f]),I0(t,i,s,e),u=s.distanceToSquared(e),u<h&&(h=u,r&&r.copy(s),a&&a.copy(e))}return this.closestPointToPoint(o,s),u=o.distanceToSquared(s),u<h&&(h=u,r&&r.copy(s),a&&a.copy(o)),this.closestPointToPoint(l,s),u=l.distanceToSquared(s),u<h&&(h=u,r&&r.copy(s),a&&a.copy(l)),Math.sqrt(h)}}();cs.prototype.intersectsTriangle=function(){const s=new cs,e=new Array(3),t=new Array(3),n=new ea,i=new ea,r=new T,a=new T,o=new T,l=new T,c=new Mr,u=new Mr,h=new Mr;return function(f,v=null){this.needsUpdate&&this.update(),f.isExtendedTriangle?f.needsUpdate&&f.update():(s.copy(f),s.update(),f=s);const g=this.plane,m=f.plane;if(Math.abs(g.normal.dot(m.normal))>1-1e-10){const x=this.satBounds,w=this.satAxes;t[0]=f.a,t[1]=f.b,t[2]=f.c;for(let E=0;E<4;E++){const C=x[E],P=w[E];if(n.setFromPoints(P,t),C.isSeparated(n))return!1}const S=f.satBounds,b=f.satAxes;e[0]=this.a,e[1]=this.b,e[2]=this.c;for(let E=0;E<4;E++){const C=S[E],P=b[E];if(n.setFromPoints(P,e),C.isSeparated(n))return!1}for(let E=0;E<4;E++){const C=w[E];for(let P=0;P<4;P++){const M=b[P];if(r.crossVectors(C,M),n.setFromPoints(r,e),i.setFromPoints(r,t),n.isSeparated(i))return!1}}return v&&(console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),v.start.set(0,0,0),v.end.set(0,0,0)),!0}else{const x=this.points;let w=!1,S=0;for(let j=0;j<3;j++){const F=x[j],K=x[(j+1)%3];c.start.copy(F),c.end.copy(K),c.delta(a);const J=w?u.start:u.end,se=Rl(m.distanceToPoint(F));if(Rl(m.normal.dot(a))&&se){u.copy(c),S=2;break}if((m.intersectLine(c,J)||se)&&!Rl(J.distanceTo(K))){if(S++,w)break;w=!0}}if(S===1&&this.containsPoint(u.end))return v&&(v.start.copy(u.end),v.end.copy(u.end)),!0;if(S!==2)return!1;const b=f.points;let E=!1,C=0;for(let j=0;j<3;j++){const F=b[j],K=b[(j+1)%3];c.start.copy(F),c.end.copy(K),c.delta(o);const J=E?h.start:h.end,se=Rl(g.distanceToPoint(F));if(Rl(g.normal.dot(o))&&se){h.copy(c),C=2;break}if((g.intersectLine(c,J)||se)&&!Rl(J.distanceTo(K))){if(C++,E)break;E=!0}}if(C===1&&this.containsPoint(h.end))return v&&(v.start.copy(h.end),v.end.copy(h.end)),!0;if(C!==2)return!1;if(u.delta(a),h.delta(o),a.dot(o)<0){let j=h.start;h.start=h.end,h.end=j}const P=u.start.dot(a),M=u.end.dot(a),L=h.start.dot(a),z=h.end.dot(a),V=M<L,U=P<z;return P!==z&&L!==M&&V===U?!1:(v&&(l.subVectors(u.start,h.start),l.dot(a)>0?v.start.copy(u.start):v.start.copy(h.start),l.subVectors(u.end,h.end),l.dot(a)<0?v.end.copy(u.end):v.end.copy(h.end)),!0)}}}();cs.prototype.distanceToPoint=function(){const s=new T;return function(t){return this.closestPointToPoint(t,s),t.distanceTo(s)}}();cs.prototype.distanceToTriangle=function(){const s=new T,e=new T,t=["a","b","c"],n=new Mr,i=new Mr;return function(a,o=null,l=null){const c=o||l?n:null;if(this.intersectsTriangle(a,c))return(o||l)&&(o&&c.getCenter(o),l&&c.getCenter(l)),0;let u=1/0;for(let h=0;h<3;h++){let d;const f=t[h],v=a[f];this.closestPointToPoint(v,s),d=v.distanceToSquared(s),d<u&&(u=d,o&&o.copy(s),l&&l.copy(v));const g=this[f];a.closestPointToPoint(g,s),d=g.distanceToSquared(s),d<u&&(u=d,o&&o.copy(g),l&&l.copy(s))}for(let h=0;h<3;h++){const d=t[h],f=t[(h+1)%3];n.set(this[d],this[f]);for(let v=0;v<3;v++){const g=t[v],m=t[(v+1)%3];i.set(a[g],a[m]),I0(n,i,s,e);const x=s.distanceToSquared(e);x<u&&(u=x,o&&o.copy(s),l&&l.copy(e))}}return Math.sqrt(u)}}();class us{constructor(e,t,n){this.isOrientedBox=!0,this.min=new T,this.max=new T,this.matrix=new Ne,this.invMatrix=new Ne,this.points=new Array(8).fill().map(()=>new T),this.satAxes=new Array(3).fill().map(()=>new T),this.satBounds=new Array(3).fill().map(()=>new ea),this.alignedSatBounds=new Array(3).fill().map(()=>new ea),this.needsUpdate=!1,e&&this.min.copy(e),t&&this.max.copy(t),n&&this.matrix.copy(n)}set(e,t,n){this.min.copy(e),this.max.copy(t),this.matrix.copy(n),this.needsUpdate=!0}copy(e){this.min.copy(e.min),this.max.copy(e.max),this.matrix.copy(e.matrix),this.needsUpdate=!0}}us.prototype.update=function(){return function(){const e=this.matrix,t=this.min,n=this.max,i=this.points;for(let c=0;c<=1;c++)for(let u=0;u<=1;u++)for(let h=0;h<=1;h++){const d=1*c|2*u|4*h,f=i[d];f.x=c?n.x:t.x,f.y=u?n.y:t.y,f.z=h?n.z:t.z,f.applyMatrix4(e)}const r=this.satBounds,a=this.satAxes,o=i[0];for(let c=0;c<3;c++){const u=a[c],h=r[c],d=1<<c,f=i[d];u.subVectors(o,f),h.setFromPoints(u,i)}const l=this.alignedSatBounds;l[0].setFromPointsField(i,"x"),l[1].setFromPointsField(i,"y"),l[2].setFromPointsField(i,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();us.prototype.intersectsBox=function(){const s=new ea;return function(t){this.needsUpdate&&this.update();const n=t.min,i=t.max,r=this.satBounds,a=this.satAxes,o=this.alignedSatBounds;if(s.min=n.x,s.max=i.x,o[0].isSeparated(s)||(s.min=n.y,s.max=i.y,o[1].isSeparated(s))||(s.min=n.z,s.max=i.z,o[2].isSeparated(s)))return!1;for(let l=0;l<3;l++){const c=a[l],u=r[l];if(s.setFromBox(c,t),u.isSeparated(s))return!1}return!0}}();us.prototype.intersectsTriangle=function(){const s=new cs,e=new Array(3),t=new ea,n=new ea,i=new T;return function(a){this.needsUpdate&&this.update(),a.isExtendedTriangle?a.needsUpdate&&a.update():(s.copy(a),s.update(),a=s);const o=this.satBounds,l=this.satAxes;e[0]=a.a,e[1]=a.b,e[2]=a.c;for(let d=0;d<3;d++){const f=o[d],v=l[d];if(t.setFromPoints(v,e),f.isSeparated(t))return!1}const c=a.satBounds,u=a.satAxes,h=this.points;for(let d=0;d<3;d++){const f=c[d],v=u[d];if(t.setFromPoints(v,h),f.isSeparated(t))return!1}for(let d=0;d<3;d++){const f=l[d];for(let v=0;v<4;v++){const g=u[v];if(i.crossVectors(f,g),t.setFromPoints(i,e),n.setFromPoints(i,h),t.isSeparated(n))return!1}}return!0}}();us.prototype.closestPointToPoint=function(){return function(e,t){return this.needsUpdate&&this.update(),t.copy(e).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),t}}();us.prototype.distanceToPoint=function(){const s=new T;return function(t){return this.closestPointToPoint(t,s),t.distanceTo(s)}}();us.prototype.distanceToBox=function(){const s=["x","y","z"],e=new Array(12).fill().map(()=>new Mr),t=new Array(12).fill().map(()=>new Mr),n=new T,i=new T;return function(a,o=0,l=null,c=null){if(this.needsUpdate&&this.update(),this.intersectsBox(a))return(l||c)&&(a.getCenter(i),this.closestPointToPoint(i,n),a.closestPointToPoint(n,i),l&&l.copy(n),c&&c.copy(i)),0;const u=o*o,h=a.min,d=a.max,f=this.points;let v=1/0;for(let m=0;m<8;m++){const x=f[m];i.copy(x).clamp(h,d);const w=x.distanceToSquared(i);if(w<v&&(v=w,l&&l.copy(x),c&&c.copy(i),w<u))return Math.sqrt(w)}let g=0;for(let m=0;m<3;m++)for(let x=0;x<=1;x++)for(let w=0;w<=1;w++){const S=(m+1)%3,b=(m+2)%3,E=x<<S|w<<b,C=1<<m|x<<S|w<<b,P=f[E],M=f[C];e[g].set(P,M);const z=s[m],V=s[S],U=s[b],j=t[g],F=j.start,K=j.end;F[z]=h[z],F[V]=x?h[V]:d[V],F[U]=w?h[U]:d[V],K[z]=d[z],K[V]=x?h[V]:d[V],K[U]=w?h[U]:d[V],g++}for(let m=0;m<=1;m++)for(let x=0;x<=1;x++)for(let w=0;w<=1;w++){i.x=m?d.x:h.x,i.y=x?d.y:h.y,i.z=w?d.z:h.z,this.closestPointToPoint(i,n);const S=i.distanceToSquared(n);if(S<v&&(v=S,l&&l.copy(n),c&&c.copy(i),S<u))return Math.sqrt(S)}for(let m=0;m<12;m++){const x=e[m];for(let w=0;w<12;w++){const S=t[w];I0(x,S,n,i);const b=n.distanceToSquared(i);if(b<v&&(v=b,l&&l.copy(n),c&&c.copy(i),b<u))return Math.sqrt(b)}}return Math.sqrt(v)}}();const Wd=new T,qd=new T,jd=new T,Aw=new Me,Tw=new Me,Ew=new Me,Mw=new T;function MO(s,e,t,n,i,r){let a;return r===er?a=s.intersectTriangle(n,t,e,!0,i):a=s.intersectTriangle(e,t,n,r!==Qt,i),a===null?null:{distance:s.origin.distanceTo(i),point:i.clone()}}function CO(s,e,t,n,i,r,a){Wd.fromBufferAttribute(e,n),qd.fromBufferAttribute(e,i),jd.fromBufferAttribute(e,r);const o=MO(s,Wd,qd,jd,Mw,a);if(o){t&&(Aw.fromBufferAttribute(t,n),Tw.fromBufferAttribute(t,i),Ew.fromBufferAttribute(t,r),o.uv=Cn.getUV(Mw,Wd,qd,jd,Aw,Tw,Ew,new Me));const l={a:n,b:i,c:r,normal:new T,materialIndex:0};Cn.getNormal(Wd,qd,jd,l.normal),o.face=l,o.faceIndex=n}return o}function Z1(s,e,t,n,i){const r=n*3,a=s.index.getX(r),o=s.index.getX(r+1),l=s.index.getX(r+2),c=CO(t,s.attributes.position,s.attributes.uv,a,o,l,e);return c?(c.faceIndex=n,i&&i.push(c),c):null}function RO(s,e,t,n,i,r){for(let a=n,o=n+i;a<o;a++)Z1(s,e,t,a,r)}function IO(s,e,t,n,i){let r=1/0,a=null;for(let o=n,l=n+i;o<l;o++){const c=Z1(s,e,t,o);c&&c.distance<r&&(a=c,r=c.distance)}return a}function is(s,e,t,n){const i=s.a,r=s.b,a=s.c;let o=e,l=e+1,c=e+2;t&&(o=t.getX(e),l=t.getX(e+1),c=t.getX(e+2)),i.x=n.getX(o),i.y=n.getY(o),i.z=n.getZ(o),r.x=n.getX(l),r.y=n.getY(l),r.z=n.getZ(l),a.x=n.getX(c),a.y=n.getY(c),a.z=n.getZ(c)}function Cw(s,e,t,n,i,r,a){const o=t.index,l=t.attributes.position;for(let c=s,u=e+s;c<u;c++)if(is(a,c*3,o,l),a.needsUpdate=!0,n(a,c,i,r))return!0;return!1}class $1{constructor(e){this._getNewPrimitive=e,this._primitives=[]}getPrimitive(){const e=this._primitives;return e.length===0?this._getNewPrimitive():e.pop()}releasePrimitive(e){this._primitives.push(e)}}function Ma(s,e){return e[s+15]===65535}function nc(s,e){return e[s+6]}function ju(s,e){return e[s+14]}function Qu(s){return s+8}function Xu(s,e){return e[s+6]}function PO(s,e){return e[s+7]}const Ql=new Tt,hp=new T,DO=["x","y","z"];function pv(s,e,t,n,i){let r=s*2,a=Gc,o=_a,l=Va;if(Ma(r,o)){const u=nc(s,l),h=ju(r,o);RO(e,t,n,u,h,i)}else{const u=Qu(s);dp(u,a,n,hp)&&pv(u,e,t,n,i);const h=Xu(s,l);dp(h,a,n,hp)&&pv(h,e,t,n,i)}}function mv(s,e,t,n){let i=s*2,r=Gc,a=_a,o=Va;if(Ma(i,a)){const c=nc(s,o),u=ju(i,a);return IO(e,t,n,c,u)}else{const c=PO(s,o),u=DO[c],d=n.direction[u]>=0;let f,v;d?(f=Qu(s),v=Xu(s,o)):(f=Xu(s,o),v=Qu(s));const m=dp(f,r,n,hp)?mv(f,e,t,n):null;if(m){const S=m.point[u];if(d?S<=r[v+c]:S>=r[v+c+3])return m}const w=dp(v,r,n,hp)?mv(v,e,t,n):null;return m&&w?m.distance<=w.distance?m:w:m||w||null}}const LO=function(){let s,e;const t=[],n=new $1(()=>new Tt);return function(...a){s=n.getPrimitive(),e=n.getPrimitive(),t.push(s,e);const o=i(...a);n.releasePrimitive(s),n.releasePrimitive(e),t.pop(),t.pop();const l=t.length;return l>0&&(e=t[l-1],s=t[l-2]),o};function i(r,a,o,l,c=null,u=0,h=0){function d(S){let b=S*2,E=_a,C=Va;for(;!Ma(b,E);)S=Qu(S),b=S*2;return nc(S,C)}function f(S){let b=S*2,E=_a,C=Va;for(;!Ma(b,E);)S=Xu(S,C),b=S*2;return nc(S,C)+ju(b,E)}let v=r*2,g=Gc,m=_a,x=Va;if(Ma(v,m)){const S=nc(r,x),b=ju(v,m);return Wr(r,g,s),l(S,b,!1,h,u+r,s)}else{const S=Qu(r),b=Xu(r,x);let E=S,C=b,P,M,L,z;if(c&&(L=s,z=e,Wr(E,g,L),Wr(C,g,z),P=c(L),M=c(z),M<P)){E=b,C=S;const se=P;P=M,M=se,L=z}L||(L=s,Wr(E,g,L));const V=Ma(E*2,m),U=o(L,V,P,h+1,u+E);let j;if(U===yw){const se=d(E),q=f(E)-se;j=l(se,q,!0,h+1,u+E,L)}else j=U&&i(E,a,o,l,c,u,h+1);if(j)return!0;z=e,Wr(C,g,z);const F=Ma(C*2,m),K=o(z,F,M,h+1,u+C);let J;if(K===yw){const se=d(C),q=f(C)-se;J=l(se,q,!0,h+1,u+C,z)}else J=K&&i(C,a,o,l,c,u,h+1);return!!J}}}(),BO=function(){const s=new cs,e=new cs,t=new Ne,n=new us,i=new us;return function r(a,o,l,c,u=null){let h=a*2,d=Gc,f=_a,v=Va;if(u===null&&(l.boundingBox||l.computeBoundingBox(),n.set(l.boundingBox.min,l.boundingBox.max,c),u=n),Ma(h,f)){const m=o,x=m.index,w=m.attributes.position,S=l.index,b=l.attributes.position,E=nc(a,v),C=ju(h,f);if(t.copy(c).invert(),l.boundsTree)return Wr(a,d,i),i.matrix.copy(t),i.needsUpdate=!0,l.boundsTree.shapecast({intersectsBounds:M=>i.intersectsBox(M),intersectsTriangle:M=>{M.a.applyMatrix4(c),M.b.applyMatrix4(c),M.c.applyMatrix4(c),M.needsUpdate=!0;for(let L=E*3,z=(C+E)*3;L<z;L+=3)if(is(e,L,x,w),e.needsUpdate=!0,M.intersectsTriangle(e))return!0;return!1}});for(let P=E*3,M=C+E*3;P<M;P+=3){is(s,P,x,w),s.a.applyMatrix4(t),s.b.applyMatrix4(t),s.c.applyMatrix4(t),s.needsUpdate=!0;for(let L=0,z=S.count;L<z;L+=3)if(is(e,L,S,b),e.needsUpdate=!0,s.intersectsTriangle(e))return!0}}else{const m=a+8,x=v[a+6];return Wr(m,d,Ql),!!(u.intersectsBox(Ql)&&r(m,o,l,c,u)||(Wr(x,d,Ql),u.intersectsBox(Ql)&&r(x,o,l,c,u)))}}}();function dp(s,e,t,n){return Wr(s,e,Ql),t.intersectBox(Ql,n)}const gv=[];let Ef,Gc,_a,Va;function fu(s){Ef&&gv.push(Ef),Ef=s,Gc=new Float32Array(s),_a=new Uint16Array(s),Va=new Uint32Array(s)}function Qd(){Ef=null,Gc=null,_a=null,Va=null,gv.length&&fu(gv.pop())}const sg=Symbol("skip tree generation"),ag=new Tt,og=new Tt,Il=new Ne,vo=new us,ou=new us,lu=new T,Xd=new T,OO=new T,NO=new T,zO=new T,Rw=new Tt,Zr=new $1(()=>new cs);class Eu{static serialize(e,t={}){if(t.isBufferGeometry)return console.warn("MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature."),Eu.serialize(arguments[0],{cloneBuffers:arguments[2]===void 0?!0:arguments[2]});t={cloneBuffers:!0,...t};const n=e.geometry,i=e._roots,r=n.getIndex();let a;return t.cloneBuffers?a={roots:i.map(o=>o.slice()),index:r.array.slice()}:a={roots:i,index:r.array},a}static deserialize(e,t,n={}){if(typeof n=="boolean")return console.warn("MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature."),Eu.deserialize(arguments[0],arguments[1],{setIndex:arguments[2]===void 0?!0:arguments[2]});n={setIndex:!0,...n};const{index:i,roots:r}=e,a=new Eu(t,{...n,[sg]:!0});if(a._roots=r,n.setIndex){const o=t.getIndex();if(o===null){const l=new Sn(e.index,1,!1);t.setIndex(l)}else o.array!==i&&(o.array.set(i),o.needsUpdate=!0)}return a}constructor(e,t={}){if(e.isBufferGeometry){if(e.index&&e.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(t=Object.assign({strategy:R0,maxDepth:40,maxLeafTris:10,verbose:!0,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,[sg]:!1},t),t.useSharedArrayBuffer&&typeof SharedArrayBuffer>"u")throw new Error("MeshBVH: SharedArrayBuffer is not available.");this._roots=null,t[sg]||(this._roots=bO(e,t),!e.boundingBox&&t.setBoundingBox&&(e.boundingBox=this.getBoundingBox(new Tt))),this.geometry=e}refit(e=null){e&&Array.isArray(e)&&(e=new Set(e));const t=this.geometry,n=t.index.array,i=t.attributes.position;let r,a,o,l,c=0;const u=this._roots;for(let d=0,f=u.length;d<f;d++)r=u[d],a=new Uint32Array(r),o=new Uint16Array(r),l=new Float32Array(r),h(0,c),c+=r.byteLength;function h(d,f,v=!1){const g=d*2;if(o[g+15]===fv){const x=a[d+6],w=o[g+14];let S=1/0,b=1/0,E=1/0,C=-1/0,P=-1/0,M=-1/0;for(let L=3*x,z=3*(x+w);L<z;L++){const V=n[L],U=i.getX(V),j=i.getY(V),F=i.getZ(V);U<S&&(S=U),U>C&&(C=U),j<b&&(b=j),j>P&&(P=j),F<E&&(E=F),F>M&&(M=F)}return l[d+0]!==S||l[d+1]!==b||l[d+2]!==E||l[d+3]!==C||l[d+4]!==P||l[d+5]!==M?(l[d+0]=S,l[d+1]=b,l[d+2]=E,l[d+3]=C,l[d+4]=P,l[d+5]=M,!0):!1}else{const x=d+8,w=a[d+6],S=x+f,b=w+f;let E=v,C=!1,P=!1;e?E||(C=e.has(S),P=e.has(b),E=!C&&!P):(C=!0,P=!0);const M=E||C,L=E||P;let z=!1;M&&(z=h(x,f,E));let V=!1;L&&(V=h(w,f,E));const U=z||V;if(U)for(let j=0;j<3;j++){const F=x+j,K=w+j,J=l[F],se=l[F+3],le=l[K],q=l[K+3];l[d+j]=J<le?J:le,l[d+j+3]=se>q?se:q}return U}}}traverse(e,t=0){const n=this._roots[t],i=new Uint32Array(n),r=new Uint16Array(n);a(0);function a(o,l=0){const c=o*2,u=r[c+15]===fv;if(u){const h=i[o+6],d=r[c+14];e(l,u,new Float32Array(n,o*4,6),h,d)}else{const h=o+Tf/4,d=i[o+6],f=i[o+7];e(l,u,new Float32Array(n,o*4,6),f)||(a(h,l+1),a(d,l+1))}}}raycast(e,t=gr){const n=this._roots,i=this.geometry,r=[],a=t.isMaterial,o=Array.isArray(t),l=i.groups,c=a?t.side:t;for(let u=0,h=n.length;u<h;u++){const d=o?t[l[u].materialIndex].side:c,f=r.length;if(fu(n[u]),pv(0,i,d,e,r),Qd(),o){const v=l[u].materialIndex;for(let g=f,m=r.length;g<m;g++)r[g].face.materialIndex=v}}return r}raycastFirst(e,t=gr){const n=this._roots,i=this.geometry,r=t.isMaterial,a=Array.isArray(t);let o=null;const l=i.groups,c=r?t.side:t;for(let u=0,h=n.length;u<h;u++){const d=a?t[l[u].materialIndex].side:c;fu(n[u]);const f=mv(0,i,d,e);Qd(),f!=null&&(o==null||f.distance<o.distance)&&(o=f,a&&(f.face.materialIndex=l[u].materialIndex))}return o}intersectsGeometry(e,t){const n=this.geometry;let i=!1;for(const r of this._roots)if(fu(r),i=BO(0,n,e,t),Qd(),i)break;return i}shapecast(e,t,n){const i=this.geometry;if(e instanceof Function){if(t){const d=t;t=(f,v,g,m)=>{const x=v*3;return d(f,x,x+1,x+2,g,m)}}e={boundsTraverseOrder:n,intersectsBounds:e,intersectsTriangle:t,intersectsRange:null},console.warn("MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.")}const r=Zr.getPrimitive();let{boundsTraverseOrder:a,intersectsBounds:o,intersectsRange:l,intersectsTriangle:c}=e;if(l&&c){const d=l;l=(f,v,g,m,x)=>d(f,v,g,m,x)?!0:Cw(f,v,i,c,g,m,r)}else l||(c?l=(d,f,v,g)=>Cw(d,f,i,c,v,g,r):l=(d,f,v)=>v);let u=!1,h=0;for(const d of this._roots){if(fu(d),u=LO(0,i,o,l,a,h),Qd(),u)break;h+=d.byteLength}return Zr.releasePrimitive(r),u}bvhcast(e,t,n){let{intersectsRanges:i,intersectsTriangles:r}=n;const a=this.geometry.index,o=this.geometry.attributes.position,l=e.geometry.index,c=e.geometry.attributes.position;Il.copy(t).invert();const u=Zr.getPrimitive(),h=Zr.getPrimitive();if(r){let v=function(g,m,x,w,S,b,E,C){for(let P=x,M=x+w;P<M;P++){is(h,P*3,l,c),h.a.applyMatrix4(t),h.b.applyMatrix4(t),h.c.applyMatrix4(t),h.needsUpdate=!0;for(let L=g,z=g+m;L<z;L++)if(is(u,L*3,a,o),u.needsUpdate=!0,r(u,h,L,P,S,b,E,C))return!0}return!1};var f=v;if(i){const g=i;i=function(m,x,w,S,b,E,C,P){return g(m,x,w,S,b,E,C,P)?!0:v(m,x,w,S,b,E,C,P)}}else i=v}e.getBoundingBox(og),og.applyMatrix4(t);const d=this.shapecast({intersectsBounds:v=>og.intersectsBox(v),intersectsRange:(v,g,m,x,w,S)=>(ag.copy(S),ag.applyMatrix4(Il),e.shapecast({intersectsBounds:b=>ag.intersectsBox(b),intersectsRange:(b,E,C,P,M)=>i(v,g,b,E,x,w,P,M)}))});return Zr.releasePrimitive(u),Zr.releasePrimitive(h),d}intersectsBox(e,t){return vo.set(e.min,e.max,t),vo.needsUpdate=!0,this.shapecast({intersectsBounds:n=>vo.intersectsBox(n),intersectsTriangle:n=>vo.intersectsTriangle(n)})}intersectsSphere(e){return this.shapecast({intersectsBounds:t=>e.intersectsBox(t),intersectsTriangle:t=>t.intersectsSphere(e)})}closestPointToGeometry(e,t,n={},i={},r=0,a=1/0){e.boundingBox||e.computeBoundingBox(),vo.set(e.boundingBox.min,e.boundingBox.max,t),vo.needsUpdate=!0;const o=this.geometry,l=o.attributes.position,c=o.index,u=e.attributes.position,h=e.index,d=Zr.getPrimitive(),f=Zr.getPrimitive();let v=Xd,g=OO,m=null,x=null;i&&(m=NO,x=zO);let w=1/0,S=null,b=null;return Il.copy(t).invert(),ou.matrix.copy(Il),this.shapecast({boundsTraverseOrder:E=>vo.distanceToBox(E),intersectsBounds:(E,C,P)=>P<w&&P<a?(C&&(ou.min.copy(E.min),ou.max.copy(E.max),ou.needsUpdate=!0),!0):!1,intersectsRange:(E,C)=>{if(e.boundsTree)return e.boundsTree.shapecast({boundsTraverseOrder:P=>ou.distanceToBox(P),intersectsBounds:(P,M,L)=>L<w&&L<a,intersectsRange:(P,M)=>{for(let L=P*3,z=(P+M)*3;L<z;L+=3){is(f,L,h,u),f.a.applyMatrix4(t),f.b.applyMatrix4(t),f.c.applyMatrix4(t),f.needsUpdate=!0;for(let V=E*3,U=(E+C)*3;V<U;V+=3){is(d,V,c,l),d.needsUpdate=!0;const j=d.distanceToTriangle(f,v,m);if(j<w&&(g.copy(v),x&&x.copy(m),w=j,S=V/3,b=L/3),j<r)return!0}}}});{const P=h?h.count:u.count;for(let M=0,L=P;M<L;M+=3){is(f,M,h,u),f.a.applyMatrix4(t),f.b.applyMatrix4(t),f.c.applyMatrix4(t),f.needsUpdate=!0;for(let z=E*3,V=(E+C)*3;z<V;z+=3){is(d,z,c,l),d.needsUpdate=!0;const U=d.distanceToTriangle(f,v,m);if(U<w&&(g.copy(v),x&&x.copy(m),w=U,S=z/3,b=M/3),U<r)return!0}}}}}),Zr.releasePrimitive(d),Zr.releasePrimitive(f),w===1/0?null:(n.point?n.point.copy(g):n.point=g.clone(),n.distance=w,n.faceIndex=S,i&&(i.point?i.point.copy(x):i.point=x.clone(),i.point.applyMatrix4(Il),g.applyMatrix4(Il),i.distance=g.sub(i.point).length(),i.faceIndex=b),n)}closestPointToPoint(e,t={},n=0,i=1/0){const r=n*n,a=i*i;let o=1/0,l=null;if(this.shapecast({boundsTraverseOrder:u=>(lu.copy(e).clamp(u.min,u.max),lu.distanceToSquared(e)),intersectsBounds:(u,h,d)=>d<o&&d<a,intersectsTriangle:(u,h)=>{u.closestPointToPoint(e,lu);const d=e.distanceToSquared(lu);return d<o&&(Xd.copy(lu),o=d,l=h),d<r}}),o===1/0)return null;const c=Math.sqrt(o);return t.point?t.point.copy(Xd):t.point=Xd.clone(),t.distance=c,t.faceIndex=l,t}getBoundingBox(e){return e.makeEmpty(),this._roots.forEach(n=>{Wr(0,new Float32Array(n),Rw),e.union(Rw)}),e}}const Iw=new Tt;class FO extends fn{get isMesh(){return!this.displayEdges}get isLineSegments(){return this.displayEdges}get isLine(){return this.displayEdges}constructor(e,t,n=10,i=0){super(),this.material=t,this.geometry=new Xt,this.name="MeshBVHRootVisualizer",this.depth=n,this.displayParents=!1,this.mesh=e,this.displayEdges=!0,this._group=i}raycast(){}update(){const e=this.geometry,t=this.mesh.geometry.boundsTree,n=this._group;if(e.dispose(),this.visible=!1,t){const i=this.depth-1,r=this.displayParents;let a=0;t.traverse((d,f)=>{if(d===i||f)return a++,!0;r&&a++},n);let o=0;const l=new Float32Array(8*3*a);t.traverse((d,f,v)=>{const g=d===i||f;if(g||r){Wr(0,v,Iw);const{min:m,max:x}=Iw;for(let w=-1;w<=1;w+=2){const S=w<0?m.x:x.x;for(let b=-1;b<=1;b+=2){const E=b<0?m.y:x.y;for(let C=-1;C<=1;C+=2){const P=C<0?m.z:x.z;l[o+0]=S,l[o+1]=E,l[o+2]=P,o+=3}}}return g}},n);let c,u;this.displayEdges?u=new Uint8Array([0,4,1,5,2,6,3,7,0,2,1,3,4,6,5,7,0,1,2,3,4,5,6,7]):u=new Uint8Array([0,1,2,2,1,3,4,6,5,6,7,5,1,4,5,0,4,1,2,3,6,3,7,6,0,2,4,2,6,4,1,5,3,3,5,7]),l.length>65535?c=new Uint32Array(u.length*a):c=new Uint16Array(u.length*a);const h=u.length;for(let d=0;d<a;d++){const f=d*8,v=d*h;for(let g=0;g<h;g++)c[v+g]=f+u[g]}e.setIndex(new Sn(c,1,!1)),e.setAttribute("position",new Sn(l,3,!1)),this.visible=!0}}}class P0 extends Er{get color(){return this.edgeMaterial.color}get opacity(){return this.edgeMaterial.opacity}set opacity(e){this.edgeMaterial.opacity=e,this.meshMaterial.opacity=e}constructor(e,t=10){super(),this.name="MeshBVHVisualizer",this.depth=t,this.mesh=e,this.displayParents=!1,this.displayEdges=!0,this._roots=[];const n=new na({color:65416,transparent:!0,opacity:.3,depthWrite:!1}),i=new Ja({color:65416,transparent:!0,opacity:.3,depthWrite:!1});i.color=n.color,this.edgeMaterial=n,this.meshMaterial=i,this.update()}update(){const e=this.mesh.geometry.boundsTree,t=e?e._roots.length:0;for(;this._roots.length>t;){const n=this._roots.pop();n.geometry.dispose(),this.remove(n)}for(let n=0;n<t;n++){if(n>=this._roots.length){const r=new FO(this.mesh,this.edgeMaterial,this.depth,n);this.add(r),this._roots.push(r)}const i=this._roots[n];i.depth=this.depth,i.mesh=this.mesh,i.displayParents=this.displayParents,i.displayEdges=this.displayEdges,i.material=this.displayEdges?this.edgeMaterial:this.meshMaterial,i.update()}}updateMatrixWorld(...e){this.position.copy(this.mesh.position),this.rotation.copy(this.mesh.rotation),this.scale.copy(this.mesh.scale),super.updateMatrixWorld(...e)}copy(e){this.depth=e.depth,this.mesh=e.mesh}clone(){return new P0(this.mesh,this.depth)}dispose(){this.edgeMaterial.dispose(),this.meshMaterial.dispose();const e=this.children;for(let t=0,n=e.length;t<n;t++)e[t].geometry.dispose()}}const UO=new Xr(-1,1,1,-1,0,1),D0=new Xt;D0.setAttribute("position",new Vt([-1,3,0,-1,-1,0,3,-1,0],3));D0.setAttribute("uv",new Vt([0,2,0,0,2,0],2));class Bh{constructor(e){this._mesh=new gn(D0,e)}dispose(){this._mesh.geometry.dispose()}render(e){e.render(this._mesh,UO)}get material(){return this._mesh.material}set material(e){this._mesh.material=e}}const ba={defines:{KERNEL_RADIUS:4,DEPTH_PACKING:1,PERSPECTIVE_CAMERA:1},uniforms:{tDiffuse:{value:null},size:{value:new Me(512,512)},sampleUvOffsets:{value:[new Me(0,0)]},sampleWeights:{value:[1]},tDepth:{value:null},cameraNear:{value:10},cameraFar:{value:1e3},depthCutoff:{value:10}},vertexShader:`

		#include <common>

		uniform vec2 size;

		varying vec2 vUv;
		varying vec2 vInvSize;

		void main() {
			vUv = uv;
			vInvSize = 1.0 / size;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
		}`,fragmentShader:`

		#include <common>
		#include <packing>

		uniform sampler2D tDiffuse;
		uniform sampler2D tDepth;

		uniform float cameraNear;
		uniform float cameraFar;
		uniform float depthCutoff;

		uniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];
		uniform float sampleWeights[ KERNEL_RADIUS + 1 ];

		varying vec2 vUv;
		varying vec2 vInvSize;

		float getDepth( const in vec2 screenPosition ) {
			#if DEPTH_PACKING == 1
			return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );
			#else
			return texture2D( tDepth, screenPosition ).x;
			#endif
		}

		float getViewZ( const in float depth ) {
			#if PERSPECTIVE_CAMERA == 1
			return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );
			#else
			return orthographicDepthToViewZ( depth, cameraNear, cameraFar );
			#endif
		}

		void main() {
			float depth = getDepth( vUv );
			if( depth >= ( 1.0 - EPSILON ) ) {
				discard;
			}

			float centerViewZ = -getViewZ( depth );
			bool rBreak = false, lBreak = false;

			float weightSum = sampleWeights[0];
			vec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;

			for( int i = 1; i <= KERNEL_RADIUS; i ++ ) {

				float sampleWeight = sampleWeights[i];
				vec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;

				vec2 sampleUv = vUv + sampleUvOffset;
				float viewZ = -getViewZ( getDepth( sampleUv ) );

				if( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;

				if( ! rBreak ) {
					diffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;
					weightSum += sampleWeight;
				}

				sampleUv = vUv - sampleUvOffset;
				viewZ = -getViewZ( getDepth( sampleUv ) );

				if( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;

				if( ! lBreak ) {
					diffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;
					weightSum += sampleWeight;
				}

			}

			gl_FragColor = diffuseSum / weightSum;
		}`},fp={createSampleWeights:function(s,e){const t=[];for(let n=0;n<=s;n++)t.push(kO(n,e));return t},createSampleOffsets:function(s,e){const t=[];for(let n=0;n<=s;n++)t.push(e.clone().multiplyScalar(n));return t},configure:function(s,e,t,n){s.defines.KERNEL_RADIUS=e,s.uniforms.sampleUvOffsets.value=fp.createSampleOffsets(e,n),s.uniforms.sampleWeights.value=fp.createSampleWeights(e,t),s.needsUpdate=!0}};function kO(s,e){return Math.exp(-(s*s)/(2*(e*e)))/(Math.sqrt(2*Math.PI)*e)}class Pw{constructor(e=Math){this.grad3=[[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],[1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],[0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]],this.grad4=[[0,1,1,1],[0,1,1,-1],[0,1,-1,1],[0,1,-1,-1],[0,-1,1,1],[0,-1,1,-1],[0,-1,-1,1],[0,-1,-1,-1],[1,0,1,1],[1,0,1,-1],[1,0,-1,1],[1,0,-1,-1],[-1,0,1,1],[-1,0,1,-1],[-1,0,-1,1],[-1,0,-1,-1],[1,1,0,1],[1,1,0,-1],[1,-1,0,1],[1,-1,0,-1],[-1,1,0,1],[-1,1,0,-1],[-1,-1,0,1],[-1,-1,0,-1],[1,1,1,0],[1,1,-1,0],[1,-1,1,0],[1,-1,-1,0],[-1,1,1,0],[-1,1,-1,0],[-1,-1,1,0],[-1,-1,-1,0]],this.p=[];for(let t=0;t<256;t++)this.p[t]=Math.floor(e.random()*256);this.perm=[];for(let t=0;t<512;t++)this.perm[t]=this.p[t&255];this.simplex=[[0,1,2,3],[0,1,3,2],[0,0,0,0],[0,2,3,1],[0,0,0,0],[0,0,0,0],[0,0,0,0],[1,2,3,0],[0,2,1,3],[0,0,0,0],[0,3,1,2],[0,3,2,1],[0,0,0,0],[0,0,0,0],[0,0,0,0],[1,3,2,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[1,2,0,3],[0,0,0,0],[1,3,0,2],[0,0,0,0],[0,0,0,0],[0,0,0,0],[2,3,0,1],[2,3,1,0],[1,0,2,3],[1,0,3,2],[0,0,0,0],[0,0,0,0],[0,0,0,0],[2,0,3,1],[0,0,0,0],[2,1,3,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[2,0,1,3],[0,0,0,0],[0,0,0,0],[0,0,0,0],[3,0,1,2],[3,0,2,1],[0,0,0,0],[3,1,2,0],[2,1,0,3],[0,0,0,0],[0,0,0,0],[0,0,0,0],[3,1,0,2],[0,0,0,0],[3,2,0,1],[3,2,1,0]]}dot(e,t,n){return e[0]*t+e[1]*n}dot3(e,t,n,i){return e[0]*t+e[1]*n+e[2]*i}dot4(e,t,n,i,r){return e[0]*t+e[1]*n+e[2]*i+e[3]*r}noise(e,t){let n,i,r;const a=.5*(Math.sqrt(3)-1),o=(e+t)*a,l=Math.floor(e+o),c=Math.floor(t+o),u=(3-Math.sqrt(3))/6,h=(l+c)*u,d=l-h,f=c-h,v=e-d,g=t-f;let m,x;v>g?(m=1,x=0):(m=0,x=1);const w=v-m+u,S=g-x+u,b=v-1+2*u,E=g-1+2*u,C=l&255,P=c&255,M=this.perm[C+this.perm[P]]%12,L=this.perm[C+m+this.perm[P+x]]%12,z=this.perm[C+1+this.perm[P+1]]%12;let V=.5-v*v-g*g;V<0?n=0:(V*=V,n=V*V*this.dot(this.grad3[M],v,g));let U=.5-w*w-S*S;U<0?i=0:(U*=U,i=U*U*this.dot(this.grad3[L],w,S));let j=.5-b*b-E*E;return j<0?r=0:(j*=j,r=j*j*this.dot(this.grad3[z],b,E)),70*(n+i+r)}noise3d(e,t,n){let i,r,a,o;const c=(e+t+n)*.3333333333333333,u=Math.floor(e+c),h=Math.floor(t+c),d=Math.floor(n+c),f=1/6,v=(u+h+d)*f,g=u-v,m=h-v,x=d-v,w=e-g,S=t-m,b=n-x;let E,C,P,M,L,z;w>=S?S>=b?(E=1,C=0,P=0,M=1,L=1,z=0):w>=b?(E=1,C=0,P=0,M=1,L=0,z=1):(E=0,C=0,P=1,M=1,L=0,z=1):S<b?(E=0,C=0,P=1,M=0,L=1,z=1):w<b?(E=0,C=1,P=0,M=0,L=1,z=1):(E=0,C=1,P=0,M=1,L=1,z=0);const V=w-E+f,U=S-C+f,j=b-P+f,F=w-M+2*f,K=S-L+2*f,J=b-z+2*f,se=w-1+3*f,le=S-1+3*f,q=b-1+3*f,te=u&255,H=h&255,$=d&255,ce=this.perm[te+this.perm[H+this.perm[$]]]%12,xe=this.perm[te+E+this.perm[H+C+this.perm[$+P]]]%12,pe=this.perm[te+M+this.perm[H+L+this.perm[$+z]]]%12,Y=this.perm[te+1+this.perm[H+1+this.perm[$+1]]]%12;let Ie=.6-w*w-S*S-b*b;Ie<0?i=0:(Ie*=Ie,i=Ie*Ie*this.dot3(this.grad3[ce],w,S,b));let re=.6-V*V-U*U-j*j;re<0?r=0:(re*=re,r=re*re*this.dot3(this.grad3[xe],V,U,j));let oe=.6-F*F-K*K-J*J;oe<0?a=0:(oe*=oe,a=oe*oe*this.dot3(this.grad3[pe],F,K,J));let ye=.6-se*se-le*le-q*q;return ye<0?o=0:(ye*=ye,o=ye*ye*this.dot3(this.grad3[Y],se,le,q)),32*(i+r+a+o)}noise4d(e,t,n,i){const r=this.grad4,a=this.simplex,o=this.perm,l=(Math.sqrt(5)-1)/4,c=(5-Math.sqrt(5))/20;let u,h,d,f,v;const g=(e+t+n+i)*l,m=Math.floor(e+g),x=Math.floor(t+g),w=Math.floor(n+g),S=Math.floor(i+g),b=(m+x+w+S)*c,E=m-b,C=x-b,P=w-b,M=S-b,L=e-E,z=t-C,V=n-P,U=i-M,j=L>z?32:0,F=L>V?16:0,K=z>V?8:0,J=L>U?4:0,se=z>U?2:0,le=V>U?1:0,q=j+F+K+J+se+le,te=a[q][0]>=3?1:0,H=a[q][1]>=3?1:0,$=a[q][2]>=3?1:0,ce=a[q][3]>=3?1:0,xe=a[q][0]>=2?1:0,pe=a[q][1]>=2?1:0,Y=a[q][2]>=2?1:0,Ie=a[q][3]>=2?1:0,re=a[q][0]>=1?1:0,oe=a[q][1]>=1?1:0,ye=a[q][2]>=1?1:0,ke=a[q][3]>=1?1:0,X=L-te+c,Se=z-H+c,qe=V-$+c,Qe=U-ce+c,Ke=L-xe+2*c,pt=z-pe+2*c,He=V-Y+2*c,ze=U-Ie+2*c,rt=L-re+3*c,Le=z-oe+3*c,k=V-ye+3*c,B=U-ke+3*c,G=L-1+4*c,ne=z-1+4*c,_e=V-1+4*c,Ye=U-1+4*c,et=m&255,we=x&255,bt=w&255,wt=S&255,tt=o[et+o[we+o[bt+o[wt]]]]%32,ee=o[et+te+o[we+H+o[bt+$+o[wt+ce]]]]%32,We=o[et+xe+o[we+pe+o[bt+Y+o[wt+Ie]]]]%32,Fe=o[et+re+o[we+oe+o[bt+ye+o[wt+ke]]]]%32,Oe=o[et+1+o[we+1+o[bt+1+o[wt+1]]]]%32;let nt=.6-L*L-z*z-V*V-U*U;nt<0?u=0:(nt*=nt,u=nt*nt*this.dot4(r[tt],L,z,V,U));let st=.6-X*X-Se*Se-qe*qe-Qe*Qe;st<0?h=0:(st*=st,h=st*st*this.dot4(r[ee],X,Se,qe,Qe));let Je=.6-Ke*Ke-pt*pt-He*He-ze*ze;Je<0?d=0:(Je*=Je,d=Je*Je*this.dot4(r[We],Ke,pt,He,ze));let ae=.6-rt*rt-Le*Le-k*k-B*B;ae<0?f=0:(ae*=ae,f=ae*ae*this.dot4(r[Fe],rt,Le,k,B));let Ot=.6-G*G-ne*ne-_e*_e-Ye*Ye;return Ot<0?v=0:(Ot*=Ot,v=Ot*Ot*this.dot4(r[Oe],G,ne,_e,Ye)),27*(u+h+d+f+v)}}const lg={uniforms:{tDiffuse:{value:null},opacity:{value:1}},vertexShader:`

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,fragmentShader:`

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			gl_FragColor = texture2D( tDiffuse, vUv );
			gl_FragColor.a *= opacity;


		}`};var ta;(function(s){s.Model="Model",s.Object="Object",s.ModelFolder="ModelFolder",s.AllModels="all-models"})(ta||(ta={}));class _O{constructor(){Mn(this,"type",ta.AllModels)}toString(){return"all"}}class Dw{constructor(e,t){Mn(this,"type");Mn(this,"modelId");Mn(this,"versionId");this.type=ta.Model,this.modelId=e,this.versionId=t}toString(){return(this.versionId?`${this.modelId}@${this.versionId}`:this.modelId).toLowerCase()}}class VO{constructor(e){Mn(this,"type");Mn(this,"objectId");this.type=ta.Object,this.objectId=e}toString(){return this.objectId.toLowerCase()}}class GO{constructor(e){Mn(this,"type");Mn(this,"folderName");this.type=ta.ModelFolder,this.folderName=e}toString(){return("$"+this.folderName).toLowerCase()}}function HO(s){if(!(s!=null&&s.length))return[];const e=s.toLowerCase().split(",").sort(),t=[];for(const n of e)if(n==="all")t.push(new _O);else if(n.includes("@")){const[i,r]=n.split("@");t.push(new Dw(i,r))}else n.startsWith("$")?t.push(new GO(n.substring(1))):n.length===32?t.push(new VO(n)):t.push(new Dw(n));return XL(t,n=>n.toString())}const WO=s=>s.type===ta.AllModels,qO=s=>s.type===ta.Model,jO=s=>s.type===ta.Object,eA={second:1,minute:60,hour:60*60,day:24*60*60,week:7*24*60*60,month:28*24*60*60},Oh=HL(eA,s=>s*1e3);var Lw;(function(s){s.Windows="win",s.Mac="mac",s.Linux="linux",s.Android="android",s.iOS="ios",s.Other="other"})(Lw||(Lw={}));function QO(){if(!globalThis||!globalThis.navigator||!("userAgent"in globalThis.navigator))return!1;const s=globalThis.navigator.userAgent;return/^((?!chrome|android).)*safari/i.test(s)}var Mu=function(){var s=0,e=document.createElement("div");e.style.cssText="position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000",e.addEventListener("click",function(u){u.preventDefault(),n(++s%e.children.length)},!1);function t(u){return e.appendChild(u.dom),u}function n(u){for(var h=0;h<e.children.length;h++)e.children[h].style.display=h===u?"block":"none";s=u}var i=(performance||Date).now(),r=i,a=0,o=t(new Mu.Panel("FPS","#0ff","#002")),l=t(new Mu.Panel("MS","#0f0","#020"));if(self.performance&&self.performance.memory)var c=t(new Mu.Panel("MB","#f08","#201"));return n(0),{REVISION:16,dom:e,addPanel:t,showPanel:n,begin:function(){i=(performance||Date).now()},end:function(){a++;var u=(performance||Date).now();if(l.update(u-i,200),u>=r+1e3&&(o.update(a*1e3/(u-r),100),r=u,a=0,c)){var h=performance.memory;c.update(h.usedJSHeapSize/1048576,h.jsHeapSizeLimit/1048576)}return u},update:function(){i=this.end()},domElement:e,setMode:n}};Mu.Panel=function(s,e,t){var n=1/0,i=0,r=Math.round,a=r(window.devicePixelRatio||1),o=80*a,l=48*a,c=3*a,u=2*a,h=3*a,d=15*a,f=74*a,v=30*a,g=document.createElement("canvas");g.width=o,g.height=l,g.style.cssText="width:80px;height:48px";var m=g.getContext("2d");return m.font="bold "+9*a+"px Helvetica,Arial,sans-serif",m.textBaseline="top",m.fillStyle=t,m.fillRect(0,0,o,l),m.fillStyle=e,m.fillText(s,c,u),m.fillRect(h,d,f,v),m.fillStyle=t,m.globalAlpha=.9,m.fillRect(h,d,f,v),{dom:g,update:function(x,w){n=Math.min(n,x),i=Math.max(i,x),m.fillStyle=t,m.globalAlpha=1,m.fillRect(0,0,o,d),m.fillStyle=e,m.fillText(r(x)+" "+s+" ("+r(n)+"-"+r(i)+")",c,u),m.drawImage(g,h+a,d,f-a,v,h,d,f-a,v),m.fillRect(h+f-a,d,a,v),m.fillStyle=t,m.globalAlpha=.9,m.fillRect(h+f-a,d,a,r((1-x/w)*v))}}};class XO{constructor(e=[],t=(n,i)=>n<i?-1:n>i?1:0){if(this.data=e,this.length=this.data.length,this.compare=t,this.length>0)for(let n=(this.length>>1)-1;n>=0;n--)this._down(n)}push(e){this.data.push(e),this._up(this.length++)}pop(){if(this.length===0)return;const e=this.data[0],t=this.data.pop();return--this.length>0&&(this.data[0]=t,this._down(0)),e}peek(){return this.data[0]}_up(e){const{data:t,compare:n}=this,i=t[e];for(;e>0;){const r=e-1>>1,a=t[r];if(n(i,a)>=0)break;t[e]=a,e=r}t[e]=i}_down(e){const{data:t,compare:n}=this,i=this.length>>1,r=t[e];for(;e<i;){let a=(e<<1)+1;const o=a+1;if(o<this.length&&n(t[o],t[a])<0&&(a=o),n(t[a],r)>=0)break;t[e]=t[a],e=a}t[e]=r}}function JO(s,e=1,t=!1){let n=1/0,i=1/0,r=-1/0,a=-1/0;for(const[x,w]of s[0])x<n&&(n=x),w<i&&(i=w),x>r&&(r=x),w>a&&(a=w);const o=r-n,l=a-i,c=Math.max(e,Math.min(o,l));if(c===e){const x=[n,i];return x.distance=0,x}const u=new XO([],(x,w)=>w.max-x.max);let h=YO(s);const d=new pp(n+o/2,i+l/2,0,s);d.d>h.d&&(h=d);let f=2;function v(x,w,S){const b=new pp(x,w,S,s);f++,b.max>h.d+e&&u.push(b),b.d>h.d&&(h=b,t&&console.log(`found best ${Math.round(1e4*b.d)/1e4} after ${f} probes`))}let g=c/2;for(let x=n;x<r;x+=c)for(let w=i;w<a;w+=c)v(x+g,w+g,g);for(;u.length;){const{max:x,x:w,y:S,h:b}=u.pop();if(x-h.d<=e)break;g=b/2,v(w-g,S-g,g),v(w+g,S-g,g),v(w-g,S+g,g),v(w+g,S+g,g)}t&&console.log(`num probes: ${f}
best distance: ${h.d}`);const m=[h.x,h.y];return m.distance=h.d,m}function pp(s,e,t,n){this.x=s,this.y=e,this.h=t,this.d=KO(s,e,n),this.max=this.d+this.h*Math.SQRT2}function KO(s,e,t){let n=!1,i=1/0;for(const r of t)for(let a=0,o=r.length,l=o-1;a<o;l=a++){const c=r[a],u=r[l];c[1]>e!=u[1]>e&&s<(u[0]-c[0])*(e-c[1])/(u[1]-c[1])+c[0]&&(n=!n),i=Math.min(i,ZO(s,e,c,u))}return i===0?0:(n?1:-1)*Math.sqrt(i)}function YO(s){let e=0,t=0,n=0;const i=s[0];for(let a=0,o=i.length,l=o-1;a<o;l=a++){const c=i[a],u=i[l],h=c[0]*u[1]-u[0]*c[1];t+=(c[0]+u[0])*h,n+=(c[1]+u[1])*h,e+=h*3}const r=new pp(t/e,n/e,0,s);return e===0||r.d<0?new pp(i[0][0],i[0][1],0,s):r}function ZO(s,e,t,n){let i=t[0],r=t[1],a=n[0]-i,o=n[1]-r;if(a!==0||o!==0){const l=((s-i)*a+(e-r)*o)/(a*a+o*o);l>1?(i=n[0],r=n[1]):l>0&&(i+=a*l,r+=o*l)}return a=s-i,o=e-r,a*a+o*o}var cg={exports:{}},ug,Bw;function $O(){return Bw||(Bw=1,ug=[{value:"#B0171F",name:"indian red"},{value:"#DC143C",css:!0,name:"crimson"},{value:"#FFB6C1",css:!0,name:"lightpink"},{value:"#FFAEB9",name:"lightpink 1"},{value:"#EEA2AD",name:"lightpink 2"},{value:"#CD8C95",name:"lightpink 3"},{value:"#8B5F65",name:"lightpink 4"},{value:"#FFC0CB",css:!0,name:"pink"},{value:"#FFB5C5",name:"pink 1"},{value:"#EEA9B8",name:"pink 2"},{value:"#CD919E",name:"pink 3"},{value:"#8B636C",name:"pink 4"},{value:"#DB7093",css:!0,name:"palevioletred"},{value:"#FF82AB",name:"palevioletred 1"},{value:"#EE799F",name:"palevioletred 2"},{value:"#CD6889",name:"palevioletred 3"},{value:"#8B475D",name:"palevioletred 4"},{value:"#FFF0F5",name:"lavenderblush 1"},{value:"#FFF0F5",css:!0,name:"lavenderblush"},{value:"#EEE0E5",name:"lavenderblush 2"},{value:"#CDC1C5",name:"lavenderblush 3"},{value:"#8B8386",name:"lavenderblush 4"},{value:"#FF3E96",name:"violetred 1"},{value:"#EE3A8C",name:"violetred 2"},{value:"#CD3278",name:"violetred 3"},{value:"#8B2252",name:"violetred 4"},{value:"#FF69B4",css:!0,name:"hotpink"},{value:"#FF6EB4",name:"hotpink 1"},{value:"#EE6AA7",name:"hotpink 2"},{value:"#CD6090",name:"hotpink 3"},{value:"#8B3A62",name:"hotpink 4"},{value:"#872657",name:"raspberry"},{value:"#FF1493",name:"deeppink 1"},{value:"#FF1493",css:!0,name:"deeppink"},{value:"#EE1289",name:"deeppink 2"},{value:"#CD1076",name:"deeppink 3"},{value:"#8B0A50",name:"deeppink 4"},{value:"#FF34B3",name:"maroon 1"},{value:"#EE30A7",name:"maroon 2"},{value:"#CD2990",name:"maroon 3"},{value:"#8B1C62",name:"maroon 4"},{value:"#C71585",css:!0,name:"mediumvioletred"},{value:"#D02090",name:"violetred"},{value:"#DA70D6",css:!0,name:"orchid"},{value:"#FF83FA",name:"orchid 1"},{value:"#EE7AE9",name:"orchid 2"},{value:"#CD69C9",name:"orchid 3"},{value:"#8B4789",name:"orchid 4"},{value:"#D8BFD8",css:!0,name:"thistle"},{value:"#FFE1FF",name:"thistle 1"},{value:"#EED2EE",name:"thistle 2"},{value:"#CDB5CD",name:"thistle 3"},{value:"#8B7B8B",name:"thistle 4"},{value:"#FFBBFF",name:"plum 1"},{value:"#EEAEEE",name:"plum 2"},{value:"#CD96CD",name:"plum 3"},{value:"#8B668B",name:"plum 4"},{value:"#DDA0DD",css:!0,name:"plum"},{value:"#EE82EE",css:!0,name:"violet"},{value:"#FF00FF",vga:!0,name:"magenta"},{value:"#FF00FF",vga:!0,css:!0,name:"fuchsia"},{value:"#EE00EE",name:"magenta 2"},{value:"#CD00CD",name:"magenta 3"},{value:"#8B008B",name:"magenta 4"},{value:"#8B008B",css:!0,name:"darkmagenta"},{value:"#800080",vga:!0,css:!0,name:"purple"},{value:"#BA55D3",css:!0,name:"mediumorchid"},{value:"#E066FF",name:"mediumorchid 1"},{value:"#D15FEE",name:"mediumorchid 2"},{value:"#B452CD",name:"mediumorchid 3"},{value:"#7A378B",name:"mediumorchid 4"},{value:"#9400D3",css:!0,name:"darkviolet"},{value:"#9932CC",css:!0,name:"darkorchid"},{value:"#BF3EFF",name:"darkorchid 1"},{value:"#B23AEE",name:"darkorchid 2"},{value:"#9A32CD",name:"darkorchid 3"},{value:"#68228B",name:"darkorchid 4"},{value:"#4B0082",css:!0,name:"indigo"},{value:"#8A2BE2",css:!0,name:"blueviolet"},{value:"#9B30FF",name:"purple 1"},{value:"#912CEE",name:"purple 2"},{value:"#7D26CD",name:"purple 3"},{value:"#551A8B",name:"purple 4"},{value:"#9370DB",css:!0,name:"mediumpurple"},{value:"#AB82FF",name:"mediumpurple 1"},{value:"#9F79EE",name:"mediumpurple 2"},{value:"#8968CD",name:"mediumpurple 3"},{value:"#5D478B",name:"mediumpurple 4"},{value:"#483D8B",css:!0,name:"darkslateblue"},{value:"#8470FF",name:"lightslateblue"},{value:"#7B68EE",css:!0,name:"mediumslateblue"},{value:"#6A5ACD",css:!0,name:"slateblue"},{value:"#836FFF",name:"slateblue 1"},{value:"#7A67EE",name:"slateblue 2"},{value:"#6959CD",name:"slateblue 3"},{value:"#473C8B",name:"slateblue 4"},{value:"#F8F8FF",css:!0,name:"ghostwhite"},{value:"#E6E6FA",css:!0,name:"lavender"},{value:"#0000FF",vga:!0,css:!0,name:"blue"},{value:"#0000EE",name:"blue 2"},{value:"#0000CD",name:"blue 3"},{value:"#0000CD",css:!0,name:"mediumblue"},{value:"#00008B",name:"blue 4"},{value:"#00008B",css:!0,name:"darkblue"},{value:"#000080",vga:!0,css:!0,name:"navy"},{value:"#191970",css:!0,name:"midnightblue"},{value:"#3D59AB",name:"cobalt"},{value:"#4169E1",css:!0,name:"royalblue"},{value:"#4876FF",name:"royalblue 1"},{value:"#436EEE",name:"royalblue 2"},{value:"#3A5FCD",name:"royalblue 3"},{value:"#27408B",name:"royalblue 4"},{value:"#6495ED",css:!0,name:"cornflowerblue"},{value:"#B0C4DE",css:!0,name:"lightsteelblue"},{value:"#CAE1FF",name:"lightsteelblue 1"},{value:"#BCD2EE",name:"lightsteelblue 2"},{value:"#A2B5CD",name:"lightsteelblue 3"},{value:"#6E7B8B",name:"lightsteelblue 4"},{value:"#778899",css:!0,name:"lightslategray"},{value:"#708090",css:!0,name:"slategray"},{value:"#C6E2FF",name:"slategray 1"},{value:"#B9D3EE",name:"slategray 2"},{value:"#9FB6CD",name:"slategray 3"},{value:"#6C7B8B",name:"slategray 4"},{value:"#1E90FF",name:"dodgerblue 1"},{value:"#1E90FF",css:!0,name:"dodgerblue"},{value:"#1C86EE",name:"dodgerblue 2"},{value:"#1874CD",name:"dodgerblue 3"},{value:"#104E8B",name:"dodgerblue 4"},{value:"#F0F8FF",css:!0,name:"aliceblue"},{value:"#4682B4",css:!0,name:"steelblue"},{value:"#63B8FF",name:"steelblue 1"},{value:"#5CACEE",name:"steelblue 2"},{value:"#4F94CD",name:"steelblue 3"},{value:"#36648B",name:"steelblue 4"},{value:"#87CEFA",css:!0,name:"lightskyblue"},{value:"#B0E2FF",name:"lightskyblue 1"},{value:"#A4D3EE",name:"lightskyblue 2"},{value:"#8DB6CD",name:"lightskyblue 3"},{value:"#607B8B",name:"lightskyblue 4"},{value:"#87CEFF",name:"skyblue 1"},{value:"#7EC0EE",name:"skyblue 2"},{value:"#6CA6CD",name:"skyblue 3"},{value:"#4A708B",name:"skyblue 4"},{value:"#87CEEB",css:!0,name:"skyblue"},{value:"#00BFFF",name:"deepskyblue 1"},{value:"#00BFFF",css:!0,name:"deepskyblue"},{value:"#00B2EE",name:"deepskyblue 2"},{value:"#009ACD",name:"deepskyblue 3"},{value:"#00688B",name:"deepskyblue 4"},{value:"#33A1C9",name:"peacock"},{value:"#ADD8E6",css:!0,name:"lightblue"},{value:"#BFEFFF",name:"lightblue 1"},{value:"#B2DFEE",name:"lightblue 2"},{value:"#9AC0CD",name:"lightblue 3"},{value:"#68838B",name:"lightblue 4"},{value:"#B0E0E6",css:!0,name:"powderblue"},{value:"#98F5FF",name:"cadetblue 1"},{value:"#8EE5EE",name:"cadetblue 2"},{value:"#7AC5CD",name:"cadetblue 3"},{value:"#53868B",name:"cadetblue 4"},{value:"#00F5FF",name:"turquoise 1"},{value:"#00E5EE",name:"turquoise 2"},{value:"#00C5CD",name:"turquoise 3"},{value:"#00868B",name:"turquoise 4"},{value:"#5F9EA0",css:!0,name:"cadetblue"},{value:"#00CED1",css:!0,name:"darkturquoise"},{value:"#F0FFFF",name:"azure 1"},{value:"#F0FFFF",css:!0,name:"azure"},{value:"#E0EEEE",name:"azure 2"},{value:"#C1CDCD",name:"azure 3"},{value:"#838B8B",name:"azure 4"},{value:"#E0FFFF",name:"lightcyan 1"},{value:"#E0FFFF",css:!0,name:"lightcyan"},{value:"#D1EEEE",name:"lightcyan 2"},{value:"#B4CDCD",name:"lightcyan 3"},{value:"#7A8B8B",name:"lightcyan 4"},{value:"#BBFFFF",name:"paleturquoise 1"},{value:"#AEEEEE",name:"paleturquoise 2"},{value:"#AEEEEE",css:!0,name:"paleturquoise"},{value:"#96CDCD",name:"paleturquoise 3"},{value:"#668B8B",name:"paleturquoise 4"},{value:"#2F4F4F",css:!0,name:"darkslategray"},{value:"#97FFFF",name:"darkslategray 1"},{value:"#8DEEEE",name:"darkslategray 2"},{value:"#79CDCD",name:"darkslategray 3"},{value:"#528B8B",name:"darkslategray 4"},{value:"#00FFFF",name:"cyan"},{value:"#00FFFF",css:!0,name:"aqua"},{value:"#00EEEE",name:"cyan 2"},{value:"#00CDCD",name:"cyan 3"},{value:"#008B8B",name:"cyan 4"},{value:"#008B8B",css:!0,name:"darkcyan"},{value:"#008080",vga:!0,css:!0,name:"teal"},{value:"#48D1CC",css:!0,name:"mediumturquoise"},{value:"#20B2AA",css:!0,name:"lightseagreen"},{value:"#03A89E",name:"manganeseblue"},{value:"#40E0D0",css:!0,name:"turquoise"},{value:"#808A87",name:"coldgrey"},{value:"#00C78C",name:"turquoiseblue"},{value:"#7FFFD4",name:"aquamarine 1"},{value:"#7FFFD4",css:!0,name:"aquamarine"},{value:"#76EEC6",name:"aquamarine 2"},{value:"#66CDAA",name:"aquamarine 3"},{value:"#66CDAA",css:!0,name:"mediumaquamarine"},{value:"#458B74",name:"aquamarine 4"},{value:"#00FA9A",css:!0,name:"mediumspringgreen"},{value:"#F5FFFA",css:!0,name:"mintcream"},{value:"#00FF7F",css:!0,name:"springgreen"},{value:"#00EE76",name:"springgreen 1"},{value:"#00CD66",name:"springgreen 2"},{value:"#008B45",name:"springgreen 3"},{value:"#3CB371",css:!0,name:"mediumseagreen"},{value:"#54FF9F",name:"seagreen 1"},{value:"#4EEE94",name:"seagreen 2"},{value:"#43CD80",name:"seagreen 3"},{value:"#2E8B57",name:"seagreen 4"},{value:"#2E8B57",css:!0,name:"seagreen"},{value:"#00C957",name:"emeraldgreen"},{value:"#BDFCC9",name:"mint"},{value:"#3D9140",name:"cobaltgreen"},{value:"#F0FFF0",name:"honeydew 1"},{value:"#F0FFF0",css:!0,name:"honeydew"},{value:"#E0EEE0",name:"honeydew 2"},{value:"#C1CDC1",name:"honeydew 3"},{value:"#838B83",name:"honeydew 4"},{value:"#8FBC8F",css:!0,name:"darkseagreen"},{value:"#C1FFC1",name:"darkseagreen 1"},{value:"#B4EEB4",name:"darkseagreen 2"},{value:"#9BCD9B",name:"darkseagreen 3"},{value:"#698B69",name:"darkseagreen 4"},{value:"#98FB98",css:!0,name:"palegreen"},{value:"#9AFF9A",name:"palegreen 1"},{value:"#90EE90",name:"palegreen 2"},{value:"#90EE90",css:!0,name:"lightgreen"},{value:"#7CCD7C",name:"palegreen 3"},{value:"#548B54",name:"palegreen 4"},{value:"#32CD32",css:!0,name:"limegreen"},{value:"#228B22",css:!0,name:"forestgreen"},{value:"#00FF00",vga:!0,name:"green 1"},{value:"#00FF00",vga:!0,css:!0,name:"lime"},{value:"#00EE00",name:"green 2"},{value:"#00CD00",name:"green 3"},{value:"#008B00",name:"green 4"},{value:"#008000",vga:!0,css:!0,name:"green"},{value:"#006400",css:!0,name:"darkgreen"},{value:"#308014",name:"sapgreen"},{value:"#7CFC00",css:!0,name:"lawngreen"},{value:"#7FFF00",name:"chartreuse 1"},{value:"#7FFF00",css:!0,name:"chartreuse"},{value:"#76EE00",name:"chartreuse 2"},{value:"#66CD00",name:"chartreuse 3"},{value:"#458B00",name:"chartreuse 4"},{value:"#ADFF2F",css:!0,name:"greenyellow"},{value:"#CAFF70",name:"darkolivegreen 1"},{value:"#BCEE68",name:"darkolivegreen 2"},{value:"#A2CD5A",name:"darkolivegreen 3"},{value:"#6E8B3D",name:"darkolivegreen 4"},{value:"#556B2F",css:!0,name:"darkolivegreen"},{value:"#6B8E23",css:!0,name:"olivedrab"},{value:"#C0FF3E",name:"olivedrab 1"},{value:"#B3EE3A",name:"olivedrab 2"},{value:"#9ACD32",name:"olivedrab 3"},{value:"#9ACD32",css:!0,name:"yellowgreen"},{value:"#698B22",name:"olivedrab 4"},{value:"#FFFFF0",name:"ivory 1"},{value:"#FFFFF0",css:!0,name:"ivory"},{value:"#EEEEE0",name:"ivory 2"},{value:"#CDCDC1",name:"ivory 3"},{value:"#8B8B83",name:"ivory 4"},{value:"#F5F5DC",css:!0,name:"beige"},{value:"#FFFFE0",name:"lightyellow 1"},{value:"#FFFFE0",css:!0,name:"lightyellow"},{value:"#EEEED1",name:"lightyellow 2"},{value:"#CDCDB4",name:"lightyellow 3"},{value:"#8B8B7A",name:"lightyellow 4"},{value:"#FAFAD2",css:!0,name:"lightgoldenrodyellow"},{value:"#FFFF00",vga:!0,name:"yellow 1"},{value:"#FFFF00",vga:!0,css:!0,name:"yellow"},{value:"#EEEE00",name:"yellow 2"},{value:"#CDCD00",name:"yellow 3"},{value:"#8B8B00",name:"yellow 4"},{value:"#808069",name:"warmgrey"},{value:"#808000",vga:!0,css:!0,name:"olive"},{value:"#BDB76B",css:!0,name:"darkkhaki"},{value:"#FFF68F",name:"khaki 1"},{value:"#EEE685",name:"khaki 2"},{value:"#CDC673",name:"khaki 3"},{value:"#8B864E",name:"khaki 4"},{value:"#F0E68C",css:!0,name:"khaki"},{value:"#EEE8AA",css:!0,name:"palegoldenrod"},{value:"#FFFACD",name:"lemonchiffon 1"},{value:"#FFFACD",css:!0,name:"lemonchiffon"},{value:"#EEE9BF",name:"lemonchiffon 2"},{value:"#CDC9A5",name:"lemonchiffon 3"},{value:"#8B8970",name:"lemonchiffon 4"},{value:"#FFEC8B",name:"lightgoldenrod 1"},{value:"#EEDC82",name:"lightgoldenrod 2"},{value:"#CDBE70",name:"lightgoldenrod 3"},{value:"#8B814C",name:"lightgoldenrod 4"},{value:"#E3CF57",name:"banana"},{value:"#FFD700",name:"gold 1"},{value:"#FFD700",css:!0,name:"gold"},{value:"#EEC900",name:"gold 2"},{value:"#CDAD00",name:"gold 3"},{value:"#8B7500",name:"gold 4"},{value:"#FFF8DC",name:"cornsilk 1"},{value:"#FFF8DC",css:!0,name:"cornsilk"},{value:"#EEE8CD",name:"cornsilk 2"},{value:"#CDC8B1",name:"cornsilk 3"},{value:"#8B8878",name:"cornsilk 4"},{value:"#DAA520",css:!0,name:"goldenrod"},{value:"#FFC125",name:"goldenrod 1"},{value:"#EEB422",name:"goldenrod 2"},{value:"#CD9B1D",name:"goldenrod 3"},{value:"#8B6914",name:"goldenrod 4"},{value:"#B8860B",css:!0,name:"darkgoldenrod"},{value:"#FFB90F",name:"darkgoldenrod 1"},{value:"#EEAD0E",name:"darkgoldenrod 2"},{value:"#CD950C",name:"darkgoldenrod 3"},{value:"#8B6508",name:"darkgoldenrod 4"},{value:"#FFA500",name:"orange 1"},{value:"#FF8000",css:!0,name:"orange"},{value:"#EE9A00",name:"orange 2"},{value:"#CD8500",name:"orange 3"},{value:"#8B5A00",name:"orange 4"},{value:"#FFFAF0",css:!0,name:"floralwhite"},{value:"#FDF5E6",css:!0,name:"oldlace"},{value:"#F5DEB3",css:!0,name:"wheat"},{value:"#FFE7BA",name:"wheat 1"},{value:"#EED8AE",name:"wheat 2"},{value:"#CDBA96",name:"wheat 3"},{value:"#8B7E66",name:"wheat 4"},{value:"#FFE4B5",css:!0,name:"moccasin"},{value:"#FFEFD5",css:!0,name:"papayawhip"},{value:"#FFEBCD",css:!0,name:"blanchedalmond"},{value:"#FFDEAD",name:"navajowhite 1"},{value:"#FFDEAD",css:!0,name:"navajowhite"},{value:"#EECFA1",name:"navajowhite 2"},{value:"#CDB38B",name:"navajowhite 3"},{value:"#8B795E",name:"navajowhite 4"},{value:"#FCE6C9",name:"eggshell"},{value:"#D2B48C",css:!0,name:"tan"},{value:"#9C661F",name:"brick"},{value:"#FF9912",name:"cadmiumyellow"},{value:"#FAEBD7",css:!0,name:"antiquewhite"},{value:"#FFEFDB",name:"antiquewhite 1"},{value:"#EEDFCC",name:"antiquewhite 2"},{value:"#CDC0B0",name:"antiquewhite 3"},{value:"#8B8378",name:"antiquewhite 4"},{value:"#DEB887",css:!0,name:"burlywood"},{value:"#FFD39B",name:"burlywood 1"},{value:"#EEC591",name:"burlywood 2"},{value:"#CDAA7D",name:"burlywood 3"},{value:"#8B7355",name:"burlywood 4"},{value:"#FFE4C4",name:"bisque 1"},{value:"#FFE4C4",css:!0,name:"bisque"},{value:"#EED5B7",name:"bisque 2"},{value:"#CDB79E",name:"bisque 3"},{value:"#8B7D6B",name:"bisque 4"},{value:"#E3A869",name:"melon"},{value:"#ED9121",name:"carrot"},{value:"#FF8C00",css:!0,name:"darkorange"},{value:"#FF7F00",name:"darkorange 1"},{value:"#EE7600",name:"darkorange 2"},{value:"#CD6600",name:"darkorange 3"},{value:"#8B4500",name:"darkorange 4"},{value:"#FFA54F",name:"tan 1"},{value:"#EE9A49",name:"tan 2"},{value:"#CD853F",name:"tan 3"},{value:"#CD853F",css:!0,name:"peru"},{value:"#8B5A2B",name:"tan 4"},{value:"#FAF0E6",css:!0,name:"linen"},{value:"#FFDAB9",name:"peachpuff 1"},{value:"#FFDAB9",css:!0,name:"peachpuff"},{value:"#EECBAD",name:"peachpuff 2"},{value:"#CDAF95",name:"peachpuff 3"},{value:"#8B7765",name:"peachpuff 4"},{value:"#FFF5EE",name:"seashell 1"},{value:"#FFF5EE",css:!0,name:"seashell"},{value:"#EEE5DE",name:"seashell 2"},{value:"#CDC5BF",name:"seashell 3"},{value:"#8B8682",name:"seashell 4"},{value:"#F4A460",css:!0,name:"sandybrown"},{value:"#C76114",name:"rawsienna"},{value:"#D2691E",css:!0,name:"chocolate"},{value:"#FF7F24",name:"chocolate 1"},{value:"#EE7621",name:"chocolate 2"},{value:"#CD661D",name:"chocolate 3"},{value:"#8B4513",name:"chocolate 4"},{value:"#8B4513",css:!0,name:"saddlebrown"},{value:"#292421",name:"ivoryblack"},{value:"#FF7D40",name:"flesh"},{value:"#FF6103",name:"cadmiumorange"},{value:"#8A360F",name:"burntsienna"},{value:"#A0522D",css:!0,name:"sienna"},{value:"#FF8247",name:"sienna 1"},{value:"#EE7942",name:"sienna 2"},{value:"#CD6839",name:"sienna 3"},{value:"#8B4726",name:"sienna 4"},{value:"#FFA07A",name:"lightsalmon 1"},{value:"#FFA07A",css:!0,name:"lightsalmon"},{value:"#EE9572",name:"lightsalmon 2"},{value:"#CD8162",name:"lightsalmon 3"},{value:"#8B5742",name:"lightsalmon 4"},{value:"#FF7F50",css:!0,name:"coral"},{value:"#FF4500",name:"orangered 1"},{value:"#FF4500",css:!0,name:"orangered"},{value:"#EE4000",name:"orangered 2"},{value:"#CD3700",name:"orangered 3"},{value:"#8B2500",name:"orangered 4"},{value:"#5E2612",name:"sepia"},{value:"#E9967A",css:!0,name:"darksalmon"},{value:"#FF8C69",name:"salmon 1"},{value:"#EE8262",name:"salmon 2"},{value:"#CD7054",name:"salmon 3"},{value:"#8B4C39",name:"salmon 4"},{value:"#FF7256",name:"coral 1"},{value:"#EE6A50",name:"coral 2"},{value:"#CD5B45",name:"coral 3"},{value:"#8B3E2F",name:"coral 4"},{value:"#8A3324",name:"burntumber"},{value:"#FF6347",name:"tomato 1"},{value:"#FF6347",css:!0,name:"tomato"},{value:"#EE5C42",name:"tomato 2"},{value:"#CD4F39",name:"tomato 3"},{value:"#8B3626",name:"tomato 4"},{value:"#FA8072",css:!0,name:"salmon"},{value:"#FFE4E1",name:"mistyrose 1"},{value:"#FFE4E1",css:!0,name:"mistyrose"},{value:"#EED5D2",name:"mistyrose 2"},{value:"#CDB7B5",name:"mistyrose 3"},{value:"#8B7D7B",name:"mistyrose 4"},{value:"#FFFAFA",name:"snow 1"},{value:"#FFFAFA",css:!0,name:"snow"},{value:"#EEE9E9",name:"snow 2"},{value:"#CDC9C9",name:"snow 3"},{value:"#8B8989",name:"snow 4"},{value:"#BC8F8F",css:!0,name:"rosybrown"},{value:"#FFC1C1",name:"rosybrown 1"},{value:"#EEB4B4",name:"rosybrown 2"},{value:"#CD9B9B",name:"rosybrown 3"},{value:"#8B6969",name:"rosybrown 4"},{value:"#F08080",css:!0,name:"lightcoral"},{value:"#CD5C5C",css:!0,name:"indianred"},{value:"#FF6A6A",name:"indianred 1"},{value:"#EE6363",name:"indianred 2"},{value:"#8B3A3A",name:"indianred 4"},{value:"#CD5555",name:"indianred 3"},{value:"#A52A2A",css:!0,name:"brown"},{value:"#FF4040",name:"brown 1"},{value:"#EE3B3B",name:"brown 2"},{value:"#CD3333",name:"brown 3"},{value:"#8B2323",name:"brown 4"},{value:"#B22222",css:!0,name:"firebrick"},{value:"#FF3030",name:"firebrick 1"},{value:"#EE2C2C",name:"firebrick 2"},{value:"#CD2626",name:"firebrick 3"},{value:"#8B1A1A",name:"firebrick 4"},{value:"#FF0000",vga:!0,name:"red 1"},{value:"#FF0000",vga:!0,css:!0,name:"red"},{value:"#EE0000",name:"red 2"},{value:"#CD0000",name:"red 3"},{value:"#8B0000",name:"red 4"},{value:"#8B0000",css:!0,name:"darkred"},{value:"#800000",vga:!0,css:!0,name:"maroon"},{value:"#8E388E",name:"sgi beet"},{value:"#7171C6",name:"sgi slateblue"},{value:"#7D9EC0",name:"sgi lightblue"},{value:"#388E8E",name:"sgi teal"},{value:"#71C671",name:"sgi chartreuse"},{value:"#8E8E38",name:"sgi olivedrab"},{value:"#C5C1AA",name:"sgi brightgray"},{value:"#C67171",name:"sgi salmon"},{value:"#555555",name:"sgi darkgray"},{value:"#1E1E1E",name:"sgi gray 12"},{value:"#282828",name:"sgi gray 16"},{value:"#515151",name:"sgi gray 32"},{value:"#5B5B5B",name:"sgi gray 36"},{value:"#848484",name:"sgi gray 52"},{value:"#8E8E8E",name:"sgi gray 56"},{value:"#AAAAAA",name:"sgi lightgray"},{value:"#B7B7B7",name:"sgi gray 72"},{value:"#C1C1C1",name:"sgi gray 76"},{value:"#EAEAEA",name:"sgi gray 92"},{value:"#F4F4F4",name:"sgi gray 96"},{value:"#FFFFFF",vga:!0,css:!0,name:"white"},{value:"#F5F5F5",name:"white smoke"},{value:"#F5F5F5",name:"gray 96"},{value:"#DCDCDC",css:!0,name:"gainsboro"},{value:"#D3D3D3",css:!0,name:"lightgrey"},{value:"#C0C0C0",vga:!0,css:!0,name:"silver"},{value:"#A9A9A9",css:!0,name:"darkgray"},{value:"#808080",vga:!0,css:!0,name:"gray"},{value:"#696969",css:!0,name:"dimgray"},{value:"#696969",name:"gray 42"},{value:"#000000",vga:!0,css:!0,name:"black"},{value:"#FCFCFC",name:"gray 99"},{value:"#FAFAFA",name:"gray 98"},{value:"#F7F7F7",name:"gray 97"},{value:"#F2F2F2",name:"gray 95"},{value:"#F0F0F0",name:"gray 94"},{value:"#EDEDED",name:"gray 93"},{value:"#EBEBEB",name:"gray 92"},{value:"#E8E8E8",name:"gray 91"},{value:"#E5E5E5",name:"gray 90"},{value:"#E3E3E3",name:"gray 89"},{value:"#E0E0E0",name:"gray 88"},{value:"#DEDEDE",name:"gray 87"},{value:"#DBDBDB",name:"gray 86"},{value:"#D9D9D9",name:"gray 85"},{value:"#D6D6D6",name:"gray 84"},{value:"#D4D4D4",name:"gray 83"},{value:"#D1D1D1",name:"gray 82"},{value:"#CFCFCF",name:"gray 81"},{value:"#CCCCCC",name:"gray 80"},{value:"#C9C9C9",name:"gray 79"},{value:"#C7C7C7",name:"gray 78"},{value:"#C4C4C4",name:"gray 77"},{value:"#C2C2C2",name:"gray 76"},{value:"#BFBFBF",name:"gray 75"},{value:"#BDBDBD",name:"gray 74"},{value:"#BABABA",name:"gray 73"},{value:"#B8B8B8",name:"gray 72"},{value:"#B5B5B5",name:"gray 71"},{value:"#B3B3B3",name:"gray 70"},{value:"#B0B0B0",name:"gray 69"},{value:"#ADADAD",name:"gray 68"},{value:"#ABABAB",name:"gray 67"},{value:"#A8A8A8",name:"gray 66"},{value:"#A6A6A6",name:"gray 65"},{value:"#A3A3A3",name:"gray 64"},{value:"#A1A1A1",name:"gray 63"},{value:"#9E9E9E",name:"gray 62"},{value:"#9C9C9C",name:"gray 61"},{value:"#999999",name:"gray 60"},{value:"#969696",name:"gray 59"},{value:"#949494",name:"gray 58"},{value:"#919191",name:"gray 57"},{value:"#8F8F8F",name:"gray 56"},{value:"#8C8C8C",name:"gray 55"},{value:"#8A8A8A",name:"gray 54"},{value:"#878787",name:"gray 53"},{value:"#858585",name:"gray 52"},{value:"#828282",name:"gray 51"},{value:"#7F7F7F",name:"gray 50"},{value:"#7D7D7D",name:"gray 49"},{value:"#7A7A7A",name:"gray 48"},{value:"#787878",name:"gray 47"},{value:"#757575",name:"gray 46"},{value:"#737373",name:"gray 45"},{value:"#707070",name:"gray 44"},{value:"#6E6E6E",name:"gray 43"},{value:"#666666",name:"gray 40"},{value:"#636363",name:"gray 39"},{value:"#616161",name:"gray 38"},{value:"#5E5E5E",name:"gray 37"},{value:"#5C5C5C",name:"gray 36"},{value:"#595959",name:"gray 35"},{value:"#575757",name:"gray 34"},{value:"#545454",name:"gray 33"},{value:"#525252",name:"gray 32"},{value:"#4F4F4F",name:"gray 31"},{value:"#4D4D4D",name:"gray 30"},{value:"#4A4A4A",name:"gray 29"},{value:"#474747",name:"gray 28"},{value:"#454545",name:"gray 27"},{value:"#424242",name:"gray 26"},{value:"#404040",name:"gray 25"},{value:"#3D3D3D",name:"gray 24"},{value:"#3B3B3B",name:"gray 23"},{value:"#383838",name:"gray 22"},{value:"#363636",name:"gray 21"},{value:"#333333",name:"gray 20"},{value:"#303030",name:"gray 19"},{value:"#2E2E2E",name:"gray 18"},{value:"#2B2B2B",name:"gray 17"},{value:"#292929",name:"gray 16"},{value:"#262626",name:"gray 15"},{value:"#242424",name:"gray 14"},{value:"#212121",name:"gray 13"},{value:"#1F1F1F",name:"gray 12"},{value:"#1C1C1C",name:"gray 11"},{value:"#1A1A1A",name:"gray 10"},{value:"#171717",name:"gray 9"},{value:"#141414",name:"gray 8"},{value:"#121212",name:"gray 7"},{value:"#0F0F0F",name:"gray 6"},{value:"#0D0D0D",name:"gray 5"},{value:"#0A0A0A",name:"gray 4"},{value:"#080808",name:"gray 3"},{value:"#050505",name:"gray 2"},{value:"#030303",name:"gray 1"},{value:"#F5F5F5",css:!0,name:"whitesmoke"}]),ug}var Ow;function eN(){return Ow||(Ow=1,function(s){var e=$O(),t=e.filter(function(i){return!!i.css}),n=e.filter(function(i){return!!i.vga});s.exports=function(i){var r=s.exports.get(i);return r&&r.value},s.exports.get=function(i){return i=i||"",i=i.trim().toLowerCase(),e.filter(function(r){return r.name.toLowerCase()===i}).pop()},s.exports.all=s.exports.get.all=function(){return e},s.exports.get.css=function(i){return i?(i=i||"",i=i.trim().toLowerCase(),t.filter(function(r){return r.name.toLowerCase()===i}).pop()):t},s.exports.get.vga=function(i){return i?(i=i||"",i=i.trim().toLowerCase(),n.filter(function(r){return r.name.toLowerCase()===i}).pop()):n}}(cg)),cg.exports}var hg,Nw;function tN(){if(Nw)return hg;Nw=1;var s="[object Symbol]",e=/[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,t="\\ud800-\\udfff",n="\\u0300-\\u036f\\ufe20-\\ufe23",i="\\u20d0-\\u20f0",r="\\u2700-\\u27bf",a="a-z\\xdf-\\xf6\\xf8-\\xff",o="\\xac\\xb1\\xd7\\xf7",l="\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf",c="\\u2000-\\u206f",u=" \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",h="A-Z\\xc0-\\xd6\\xd8-\\xde",d="\\ufe0e\\ufe0f",f=o+l+c+u,v="['’]",g="["+f+"]",m="["+n+i+"]",x="\\d+",w="["+r+"]",S="["+a+"]",b="[^"+t+f+x+r+a+h+"]",E="\\ud83c[\\udffb-\\udfff]",C="(?:"+m+"|"+E+")",P="[^"+t+"]",M="(?:\\ud83c[\\udde6-\\uddff]){2}",L="[\\ud800-\\udbff][\\udc00-\\udfff]",z="["+h+"]",V="\\u200d",U="(?:"+S+"|"+b+")",j="(?:"+z+"|"+b+")",F="(?:"+v+"(?:d|ll|m|re|s|t|ve))?",K="(?:"+v+"(?:D|LL|M|RE|S|T|VE))?",J=C+"?",se="["+d+"]?",le="(?:"+V+"(?:"+[P,M,L].join("|")+")"+se+J+")*",q=se+J+le,te="(?:"+[w,M,L].join("|")+")"+q,H=RegExp([z+"?"+S+"+"+F+"(?="+[g,z,"$"].join("|")+")",j+"+"+K+"(?="+[g,z+U,"$"].join("|")+")",z+"?"+U+"+"+F,z+"+"+K,x,te].join("|"),"g"),$=/[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,ce=typeof mr=="object"&&mr&&mr.Object===Object&&mr,xe=typeof self=="object"&&self&&self.Object===Object&&self,pe=ce||xe||Function("return this")();function Y(ze){return ze.match(e)||[]}function Ie(ze){return $.test(ze)}function re(ze){return ze.match(H)||[]}var oe=Object.prototype,ye=oe.toString,ke=pe.Symbol,X=ke?ke.prototype:void 0,Se=X?X.toString:void 0;function qe(ze){if(typeof ze=="string")return ze;if(Ke(ze))return Se?Se.call(ze):"";var rt=ze+"";return rt=="0"&&1/ze==-1/0?"-0":rt}function Qe(ze){return!!ze&&typeof ze=="object"}function Ke(ze){return typeof ze=="symbol"||Qe(ze)&&ye.call(ze)==s}function pt(ze){return ze==null?"":qe(ze)}function He(ze,rt,Le){return ze=pt(ze),rt=Le?void 0:rt,rt===void 0?Ie(ze)?re(ze):Y(ze):ze.match(rt)||[]}return hg=He,hg}var dg,zw;function nN(){if(zw)return dg;zw=1;var s="[object Symbol]",e=/^\s+/,t="\\ud800-\\udfff",n="\\u0300-\\u036f\\ufe20-\\ufe23",i="\\u20d0-\\u20f0",r="\\ufe0e\\ufe0f",a="["+t+"]",o="["+n+i+"]",l="\\ud83c[\\udffb-\\udfff]",c="(?:"+o+"|"+l+")",u="[^"+t+"]",h="(?:\\ud83c[\\udde6-\\uddff]){2}",d="[\\ud800-\\udbff][\\udc00-\\udfff]",f="\\u200d",v=c+"?",g="["+r+"]?",m="(?:"+f+"(?:"+[u,h,d].join("|")+")"+g+v+")*",x=g+v+m,w="(?:"+[u+o+"?",o,h,d,a].join("|")+")",S=RegExp(l+"(?="+l+")|"+w+x,"g"),b=RegExp("["+f+t+n+i+r+"]"),E=typeof mr=="object"&&mr&&mr.Object===Object&&mr,C=typeof self=="object"&&self&&self.Object===Object&&self,P=E||C||Function("return this")();function M(re){return re.split("")}function L(re,oe,ye,ke){for(var X=re.length,Se=ye+-1;++Se<X;)if(oe(re[Se],Se,re))return Se;return-1}function z(re,oe,ye){if(oe!==oe)return L(re,V,ye);for(var ke=ye-1,X=re.length;++ke<X;)if(re[ke]===oe)return ke;return-1}function V(re){return re!==re}function U(re,oe){for(var ye=-1,ke=re.length;++ye<ke&&z(oe,re[ye],0)>-1;);return ye}function j(re){return b.test(re)}function F(re){return j(re)?K(re):M(re)}function K(re){return re.match(S)||[]}var J=Object.prototype,se=J.toString,le=P.Symbol,q=le?le.prototype:void 0,te=q?q.toString:void 0;function H(re,oe,ye){var ke=-1,X=re.length;oe<0&&(oe=-oe>X?0:X+oe),ye=ye>X?X:ye,ye<0&&(ye+=X),X=oe>ye?0:ye-oe>>>0,oe>>>=0;for(var Se=Array(X);++ke<X;)Se[ke]=re[ke+oe];return Se}function $(re){if(typeof re=="string")return re;if(pe(re))return te?te.call(re):"";var oe=re+"";return oe=="0"&&1/re==-1/0?"-0":oe}function ce(re,oe,ye){var ke=re.length;return ye=ye===void 0?ke:ye,!oe&&ye>=ke?re:H(re,oe,ye)}function xe(re){return!!re&&typeof re=="object"}function pe(re){return typeof re=="symbol"||xe(re)&&se.call(re)==s}function Y(re){return re==null?"":$(re)}function Ie(re,oe,ye){if(re=Y(re),re&&(ye||oe===void 0))return re.replace(e,"");if(!re||!(oe=$(oe)))return re;var ke=F(re),X=U(ke,F(oe));return ce(ke,X).join("")}return dg=Ie,dg}var fg,Fw;function iN(){if(Fw)return fg;Fw=1;var s=1/0,e=9007199254740991,t=17976931348623157e292,n=NaN,i="[object Symbol]",r=/^\s+|\s+$/g,a=/^[-+]0x[0-9a-f]+$/i,o=/^0b[01]+$/i,l=/^0o[0-7]+$/i,c="\\ud800-\\udfff",u="\\u0300-\\u036f\\ufe20-\\ufe23",h="\\u20d0-\\u20f0",d="\\ufe0e\\ufe0f",f="["+c+"]",v="["+u+h+"]",g="\\ud83c[\\udffb-\\udfff]",m="(?:"+v+"|"+g+")",x="[^"+c+"]",w="(?:\\ud83c[\\udde6-\\uddff]){2}",S="[\\ud800-\\udbff][\\udc00-\\udfff]",b="\\u200d",E=m+"?",C="["+d+"]?",P="(?:"+b+"(?:"+[x,w,S].join("|")+")"+C+E+")*",M=C+E+P,L="(?:"+[x+v+"?",v,w,S,f].join("|")+")",z=RegExp(g+"(?="+g+")|"+L+M,"g"),V=RegExp("["+b+c+u+h+d+"]"),U=parseInt,j=typeof mr=="object"&&mr&&mr.Object===Object&&mr,F=typeof self=="object"&&self&&self.Object===Object&&self,K=j||F||Function("return this")(),J=le("length");function se(G){return G.split("")}function le(G){return function(ne){return ne==null?void 0:ne[G]}}function q(G){return V.test(G)}function te(G){return q(G)?$(G):J(G)}function H(G){return q(G)?ce(G):se(G)}function $(G){for(var ne=z.lastIndex=0;z.test(G);)ne++;return ne}function ce(G){return G.match(z)||[]}var xe=Object.prototype,pe=xe.toString,Y=K.Symbol,Ie=Math.ceil,re=Math.floor,oe=Y?Y.prototype:void 0,ye=oe?oe.toString:void 0;function ke(G,ne){var _e="";if(!G||ne<1||ne>e)return _e;do ne%2&&(_e+=G),ne=re(ne/2),ne&&(G+=G);while(ne);return _e}function X(G,ne,_e){var Ye=-1,et=G.length;ne<0&&(ne=-ne>et?0:et+ne),_e=_e>et?et:_e,_e<0&&(_e+=et),et=ne>_e?0:_e-ne>>>0,ne>>>=0;for(var we=Array(et);++Ye<et;)we[Ye]=G[Ye+ne];return we}function Se(G){if(typeof G=="string")return G;if(He(G))return ye?ye.call(G):"";var ne=G+"";return ne=="0"&&1/G==-s?"-0":ne}function qe(G,ne,_e){var Ye=G.length;return _e=_e===void 0?Ye:_e,!ne&&_e>=Ye?G:X(G,ne,_e)}function Qe(G,ne){ne=ne===void 0?" ":Se(ne);var _e=ne.length;if(_e<2)return _e?ke(ne,G):ne;var Ye=ke(ne,Ie(G/te(ne)));return q(ne)?qe(H(Ye),0,G).join(""):Ye.slice(0,G)}function Ke(G){var ne=typeof G;return!!G&&(ne=="object"||ne=="function")}function pt(G){return!!G&&typeof G=="object"}function He(G){return typeof G=="symbol"||pt(G)&&pe.call(G)==i}function ze(G){if(!G)return G===0?G:0;if(G=Le(G),G===s||G===-s){var ne=G<0?-1:1;return ne*t}return G===G?G:0}function rt(G){var ne=ze(G),_e=ne%1;return ne===ne?_e?ne-_e:ne:0}function Le(G){if(typeof G=="number")return G;if(He(G))return n;if(Ke(G)){var ne=typeof G.valueOf=="function"?G.valueOf():G;G=Ke(ne)?ne+"":ne}if(typeof G!="string")return G===0?G:+G;G=G.replace(r,"");var _e=o.test(G);return _e||l.test(G)?U(G.slice(2),_e?2:8):a.test(G)?n:+G}function k(G){return G==null?"":Se(G)}function B(G,ne,_e){G=k(G),ne=rt(ne);var Ye=ne?te(G):0;return ne&&Ye<ne?G+Qe(ne-Ye,_e):G}return fg=B,fg}var pg,Uw;function rN(){return Uw||(Uw=1,pg=(s,e,t,n)=>{const i=(s+(n||"")).toString().includes("%");if(typeof s=="string"?[s,e,t,n]=s.match(/(0?\.?\d{1,3})%?\b/g).map(Number):n!==void 0&&(n=parseFloat(n)),typeof s!="number"||typeof e!="number"||typeof t!="number"||s>255||e>255||t>255)throw new TypeError("Expected three numbers below 256");if(typeof n=="number"){if(!i&&n>=0&&n<=1)n=Math.round(255*n);else if(i&&n>=0&&n<=100)n=Math.round(255*n/100);else throw new TypeError(`Expected alpha value (${n}) as a fraction or percentage`);n=(n|256).toString(16).slice(1)}else n="";return(t|e<<8|s<<16|1<<24).toString(16).slice(1)+n}),pg}var mg,kw;function sN(){if(kw)return mg;kw=1;const s="a-f\\d",e=`#?[${s}]{3}[${s}]?`,t=`#?[${s}]{6}([${s}]{2})?`,n=new RegExp(`[^#${s}]`,"gi"),i=new RegExp(`^${e}$|^${t}$`,"i");return mg=(r,a={})=>{if(typeof r!="string"||n.test(r)||!i.test(r))throw new TypeError("Expected a valid hex string");r=r.replace(/^#/,"");let o=1;r.length===8&&(o=Number.parseInt(r.slice(6,8),16)/255,r=r.slice(0,6)),r.length===4&&(o=Number.parseInt(r.slice(3,4).repeat(2),16)/255,r=r.slice(0,3)),r.length===3&&(r=r[0]+r[0]+r[1]+r[1]+r[2]+r[2]);const l=Number.parseInt(r,16),c=l>>16,u=l>>8&255,h=l&255,d=typeof a.alpha=="number"?a.alpha:o;if(a.format==="array")return[c,u,h,d];if(a.format==="css"){const f=d===1?"":` / ${Number((d*100).toFixed(2))}%`;return`rgb(${c} ${u} ${h}${f})`}return{red:c,green:u,blue:h,alpha:d}},mg}var gg,_w;function aN(){if(_w)return gg;_w=1;var s=eN(),e=tN(),t=nN(),n=iN(),i=rN(),r=sN();const a=.75,o=.25,l=16777215,c=49979693;gg=function(f){return"#"+d(String(JSON.stringify(f)))};function u(f){var v=e(f),g=[];return v.forEach(function(m){var x=s(m);x&&g.push(r(t(x,"#"),{format:"array"}))}),g}function h(f){var v=[0,0,0];return f.forEach(function(g){for(var m=0;m<3;m++)v[m]+=g[m]}),[v[0]/f.length,v[1]/f.length,v[2]/f.length]}function d(f){var v,g=u(f);g.length>0&&(v=h(g));var m=1,x=0,w=1;if(f.length>0)for(var S=0;S<f.length;S++)f[S].charCodeAt(0)>x&&(x=f[S].charCodeAt(0)),w=parseInt(l/x),m=(m+f[S].charCodeAt(0)*w*c)%l;var b=(m*f.length%l).toString(16);b=n(b,6,b);var E=r(b,{format:"array"});return v?i(o*E[0]+a*v[0],o*E[1]+a*v[1],o*E[2]+a*v[2]):b}return gg}aN();class oN{constructor(e){Mn(this,"items");this.items=(e==null?void 0:e.items)||new Map}getAll(e){const t=[];for(const n of e){const i=this.items.get(n);i?t.push({baseId:n,base:i}):t.push(void 0)}return Promise.resolve(t)}cacheSaveBatch({batch:e}){for(const t of e)this.items.set(t.baseId,t.base);return Promise.resolve()}getItem(e){const t=this.items.get(e.id);return t?Promise.resolve({baseId:e.id,base:t}):Promise.resolve(void 0)}disposeAsync(){return Promise.resolve()}}var Co,Ro,eh;class lN{constructor(){Lt(this,Co,[]);Lt(this,Ro,[]);Lt(this,eh,!1)}add(e){Ge(this,Ro).length>0?Ge(this,Ro).shift()(e):Ge(this,Co).push(e)}async*consume(){for(;!Ge(this,eh)||Ge(this,Ro).length>0||Ge(this,Co).length>0;)Ge(this,Co).length>0?yield Ge(this,Co).shift():yield await new Promise(e=>Ge(this,Ro).push(e))}dispose(){Ut(this,eh,!0)}}Co=new WeakMap,Ro=new WeakMap,eh=new WeakMap;class Vw{constructor(e,t,n){Mn(this,"promise");Mn(this,"resolve");Mn(this,"reject");Mn(this,"item");Mn(this,"id");Mn(this,"expiresAt");Mn(this,"ttl");this.expiresAt=n,this.ttl=e,this.id=t,this.promise=new Promise((i,r)=>{this.resolve=i,this.reject=r})}getId(){return this.id}getItem(){return this.item}getPromise(){return this.promise}isExpired(e){return this.item!==void 0&&e>this.expiresAt}setAccess(e){this.expiresAt=e+this.ttl}found(e){this.item=e,this.resolve(e.base)}done(e){return this.item&&this.resolve(this.item.base),!!this.isExpired(e)}}class cN{constructor(e){Mn(this,"options");Mn(this,"deferments",new Map);Mn(this,"timer");Mn(this,"logger");Mn(this,"currentSize",0);Mn(this,"disposed",!1);this.options=e,this.resetGlobalTimer(),this.logger=e.logger||(()=>{})}now(){return Date.now()}isDeferred(e){return this.deferments.has(e)}get(e){if(this.disposed)throw new Error("DefermentManager is disposed");return this.deferments.get(e)}async defer(e){if(this.disposed)throw new Error("DefermentManager is disposed");const t=this.now(),n=this.deferments.get(e.id);if(n)return n.setAccess(t),n.getPromise();const i=new Vw(this.options.ttlms,e.id,t+this.options.ttlms);return this.deferments.set(e.id,i),i.getPromise()}undefer(e){if(this.disposed)throw new Error("DefermentManager is disposed");const t=this.now();this.currentSize+=e.size||0;const n=this.deferments.get(e.baseId);if(n)n.found(e),n.setAccess(t);else{const i=new Vw(this.options.ttlms,e.baseId,t);i.found(e),this.deferments.set(e.baseId,i)}}resetGlobalTimer(){const e=()=>{this.cleanDeferments(),this.timer=setTimeout(e,this.options.ttlms)};this.timer=setTimeout(e,this.options.ttlms)}dispose(){this.disposed||(this.disposed=!0,this.timer&&(clearTimeout(this.timer),this.timer=void 0),this.clearDeferments())}clearDeferments(){let e=0;for(const t of this.deferments.values())t.done(0),t.getItem()===void 0&&e++;this.currentSize=0,this.deferments.clear(),this.logger("cleared deferments, left",e)}cleanDeferments(){var r;const e=this.options.maxSizeInMb*1024*1024;if(this.currentSize<e){this.logger("deferments size is ok, no need to clean",this.currentSize,e);return}const t=this.now();let n=0;const i=performance.now();for(const a of Array.from(this.deferments.values()).filter(o=>o.isExpired(t)).sort((o,l)=>this.compareMaybeBasesBySize(o.getItem(),l.getItem())))if(a.done(t)&&(this.currentSize-=((r=a.getItem())==null?void 0:r.size)||0,this.deferments.delete(a.getId()),n++,this.currentSize<e))break;this.logger("cleaned deferments, cleaned, left",n,this.deferments.size,performance.now()-i)}compareMaybeBasesBySize(e,t){return e===void 0&&t===void 0?0:e===void 0?-1:t===void 0?1:this.compareMaybe(e.size,t.size)}compareMaybe(e,t){return e===void 0&&t===void 0?0:e===void 0?-1:t===void 0?1:e-t}}class uN{constructor(){Mn(this,"_map");Mn(this,"_order");this._map=new Map,this._order=[]}enqueue(e,t){return this._map.has(e)?!1:(this._map.set(e,t),this._order.push(e),!0)}get(e){return this._map.get(e)}has(e){return this._map.has(e)}get size(){return this._order.length}spliceValues(e,t){const n=this._order.splice(e,t),i=[];for(const r of n){const a=this._map.get(r);a!==void 0&&(i.push(a),this._map.delete(r))}return i}}var Hr,rc,th,nh,ih,rh,sh,sc,Qa,nA,iA,rA;class tA{constructor(e){Lt(this,Qa);Lt(this,Hr,new uN);Lt(this,rc);Lt(this,th);Lt(this,nh);Lt(this,ih);Lt(this,rh);Lt(this,sh);Lt(this,sc,!1);Ut(this,rc,e.batchSize),Ut(this,nh,Math.min(e.maxWaitTime??200,200)),Ut(this,ih,Math.min(e.maxWaitTime??100,100)),Ut(this,rh,Math.min(e.maxWaitTime??3e3,3e3)),Ut(this,th,e.processFunction),Ut(this,sh,ri(this,Qa,iA).call(this))}async disposeAsync(){Ut(this,sc,!0),await Ge(this,sh)}add(e,t){Ge(this,Hr).enqueue(e,t)}get(e){return Ge(this,Hr).get(e)}count(){return Ge(this,Hr).size}isDisposed(){return Ge(this,sc)}}Hr=new WeakMap,rc=new WeakMap,th=new WeakMap,nh=new WeakMap,ih=new WeakMap,rh=new WeakMap,sh=new WeakMap,sc=new WeakMap,Qa=new WeakSet,nA=function(e){return Ge(this,Hr).spliceValues(0,Math.min(e,Ge(this,Hr).size))},iA=async function(){let e=Ge(this,nh);for(;!Ge(this,sc)||Ge(this,Hr).size>0;){const t=performance.now();if(Ge(this,Hr).size>0){const n=ri(this,Qa,nA).call(this,Ge(this,rc));await Ge(this,th).call(this,n)}Ge(this,Hr).size<Ge(this,rc)/2&&(performance.now()-t>e?e=Math.min(e*1.5,Ge(this,rh)):e=Math.max(e*.8,Ge(this,ih)),await ri(this,Qa,rA).call(this,e))}},rA=function(e){return new Promise(t=>setTimeout(t,e))};var ac,Io,Sp,oc,Ra,bp,sA,Ap;class hN{constructor(e,t,n){Lt(this,bp);Lt(this,ac);Lt(this,Io);Lt(this,Sp);Lt(this,oc);Lt(this,Ra);Lt(this,Ap,async e=>{const t=await Ge(this,ac).getAll(e);for(let n=0;n<t.length;n++)t[n]&&Ge(this,Io).undefer(t[n])});Ut(this,ac,e),Ut(this,Io,t),Ut(this,oc,n),Ut(this,Sp,n.logger||(()=>{}))}async getObject(e){return Ge(this,Io).isDeferred(e.id)||ri(this,bp,sA).call(this,e.id),await Ge(this,Io).defer({id:e.id})}async getAll(e){return Ge(this,ac).getAll(e)}async disposeAsync(){var e;await((e=Ge(this,Ra))==null?void 0:e.disposeAsync())}}ac=new WeakMap,Io=new WeakMap,Sp=new WeakMap,oc=new WeakMap,Ra=new WeakMap,bp=new WeakSet,sA=function(e){Ge(this,Ra)||Ut(this,Ra,new tA({batchSize:Ge(this,oc).maxCacheReadSize,maxWaitTime:Ge(this,oc).maxCacheBatchReadWait,processFunction:Ge(this,Ap)})),Ge(this,Ra).get(e)||Ge(this,Ra).add(e,e)},Ap=new WeakMap;var ns,lc,ah,oh,Po,Ia;class dN{constructor(e,t,n,i){Lt(this,ns);Lt(this,lc);Lt(this,ah);Lt(this,oh);Lt(this,Po);Lt(this,Ia);Ut(this,lc,e),Ut(this,Po,t),Ut(this,oh,n),Ut(this,Ia,i),Ut(this,ah,i.logger||(()=>{}))}add(e){Ge(this,ns)||Ut(this,ns,new tA({batchSize:Ge(this,Ia).maxCacheWriteSize,maxWaitTime:Ge(this,Ia).maxCacheBatchWriteWait,processFunction:t=>Ge(this,lc).cacheSaveBatch({batch:t})})),Ge(this,ns).add(e.baseId,e)}async disposeAsync(){var e;await((e=Ge(this,ns))==null?void 0:e.disposeAsync())}async pumpItems(e){var a,o,l;const{ids:t,foundItems:n,notFoundItems:i}=e,r=Ge(this,Ia).maxCacheReadSize;for(let c=0;c<t.length&&!((a=Ge(this,ns))!=null&&a.isDisposed());){if((((o=Ge(this,ns))==null?void 0:o.count())??0)>Ge(this,Ia).maxWriteQueueSize){Ge(this,ah).call(this,"pausing reads (# in write queue: "+((l=Ge(this,ns))==null?void 0:l.count())+")"),await new Promise(d=>setTimeout(d,eA.second));continue}const u=t.slice(c,c+r),h=await Ge(this,lc).getAll(u);for(let d=0;d<h.length;d++)h[d]?n.add(h[d]):i.add(u[d]);c+=r}}async*gather(e,t){const n=e.length,i=this.pumpItems({ids:e,foundItems:Ge(this,Po),notFoundItems:t});let r=0;for await(const a of Ge(this,Po).consume())Ge(this,oh).undefer(a),yield a,r++,r>=n&&Ge(this,Po).dispose();await i}}ns=new WeakMap,lc=new WeakMap,ah=new WeakMap,oh=new WeakMap,Po=new WeakMap,Ia=new WeakMap;var lh,ch;class fN{constructor(e,t){Lt(this,lh);Lt(this,ch);Ut(this,lh,e),Ut(this,ch,t)}add(e){Ge(this,lh).add(e),Ge(this,ch).add(e)}values(){throw new Error("Not implemented")}}lh=new WeakMap,ch=new WeakMap;var Mf={exports:{}},pN=Mf.exports,Gw;function mN(){return Gw||(Gw=1,function(s,e){(function(t,n){s.exports=n()})(pN,function(){var t=function(p,y){return(t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(A,R){A.__proto__=R}||function(A,R){for(var D in R)Object.prototype.hasOwnProperty.call(R,D)&&(A[D]=R[D])})(p,y)},n=function(){return(n=Object.assign||function(p){for(var y,A=1,R=arguments.length;A<R;A++)for(var D in y=arguments[A])Object.prototype.hasOwnProperty.call(y,D)&&(p[D]=y[D]);return p}).apply(this,arguments)};function i(p,y,A){for(var R,D=0,O=y.length;D<O;D++)!R&&D in y||((R=R||Array.prototype.slice.call(y,0,D))[D]=y[D]);return p.concat(R||Array.prototype.slice.call(y))}var r=typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof window<"u"?window:mr,a=Object.keys,o=Array.isArray;function l(p,y){return typeof y!="object"||a(y).forEach(function(A){p[A]=y[A]}),p}typeof Promise>"u"||r.Promise||(r.Promise=Promise);var c=Object.getPrototypeOf,u={}.hasOwnProperty;function h(p,y){return u.call(p,y)}function d(p,y){typeof y=="function"&&(y=y(c(p))),(typeof Reflect>"u"?a:Reflect.ownKeys)(y).forEach(function(A){v(p,A,y[A])})}var f=Object.defineProperty;function v(p,y,A,R){f(p,y,l(A&&h(A,"get")&&typeof A.get=="function"?{get:A.get,set:A.set,configurable:!0}:{value:A,configurable:!0,writable:!0},R))}function g(p){return{from:function(y){return p.prototype=Object.create(y.prototype),v(p.prototype,"constructor",p),{extend:d.bind(null,p.prototype)}}}}var m=Object.getOwnPropertyDescriptor,x=[].slice;function w(p,y,A){return x.call(p,y,A)}function S(p,y){return y(p)}function b(p){if(!p)throw new Error("Assertion Failed")}function E(p){r.setImmediate?setImmediate(p):setTimeout(p,0)}function C(p,y){if(typeof y=="string"&&h(p,y))return p[y];if(!y)return p;if(typeof y!="string"){for(var A=[],R=0,D=y.length;R<D;++R){var O=C(p,y[R]);A.push(O)}return A}var W=y.indexOf(".");if(W!==-1){var Z=p[y.substr(0,W)];return Z==null?void 0:C(Z,y.substr(W+1))}}function P(p,y,A){if(p&&y!==void 0&&!("isFrozen"in Object&&Object.isFrozen(p)))if(typeof y!="string"&&"length"in y){b(typeof A!="string"&&"length"in A);for(var R=0,D=y.length;R<D;++R)P(p,y[R],A[R])}else{var O,W,Z=y.indexOf(".");Z!==-1?(O=y.substr(0,Z),(W=y.substr(Z+1))===""?A===void 0?o(p)&&!isNaN(parseInt(O))?p.splice(O,1):delete p[O]:p[O]=A:P(Z=!(Z=p[O])||!h(p,O)?p[O]={}:Z,W,A)):A===void 0?o(p)&&!isNaN(parseInt(y))?p.splice(y,1):delete p[y]:p[y]=A}}function M(p){var y,A={};for(y in p)h(p,y)&&(A[y]=p[y]);return A}var L=[].concat;function z(p){return L.apply([],p)}var _e="BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(z([8,16,32,64].map(function(p){return["Int","Uint","Float"].map(function(y){return y+p+"Array"})}))).filter(function(p){return r[p]}),V=new Set(_e.map(function(p){return r[p]})),U=null;function j(p){return U=new WeakMap,p=function y(A){if(!A||typeof A!="object")return A;var R=U.get(A);if(R)return R;if(o(A)){R=[],U.set(A,R);for(var D=0,O=A.length;D<O;++D)R.push(y(A[D]))}else if(V.has(A.constructor))R=A;else{var W,Z=c(A);for(W in R=Z===Object.prototype?{}:Object.create(Z),U.set(A,R),A)h(A,W)&&(R[W]=y(A[W]))}return R}(p),U=null,p}var F={}.toString;function K(p){return F.call(p).slice(8,-1)}var J=typeof Symbol<"u"?Symbol.iterator:"@@iterator",se=typeof J=="symbol"?function(p){var y;return p!=null&&(y=p[J])&&y.apply(p)}:function(){return null};function le(p,y){return y=p.indexOf(y),0<=y&&p.splice(y,1),0<=y}var q={};function te(p){var y,A,R,D;if(arguments.length===1){if(o(p))return p.slice();if(this===q&&typeof p=="string")return[p];if(D=se(p)){for(A=[];!(R=D.next()).done;)A.push(R.value);return A}if(p==null)return[p];if(typeof(y=p.length)!="number")return[p];for(A=new Array(y);y--;)A[y]=p[y];return A}for(y=arguments.length,A=new Array(y);y--;)A[y]=arguments[y];return A}var H=typeof Symbol<"u"?function(p){return p[Symbol.toStringTag]==="AsyncFunction"}:function(){return!1},ne=["Unknown","Constraint","Data","TransactionInactive","ReadOnly","Version","NotFound","InvalidState","InvalidAccess","Abort","Timeout","QuotaExceeded","Syntax","DataClone"],xr=["Modify","Bulk","OpenFailed","VersionChange","Schema","Upgrade","InvalidTable","MissingAPI","NoSuchDatabase","InvalidArgument","SubTransaction","Unsupported","Internal","DatabaseClosed","PrematureCommit","ForeignAwait"].concat(ne),$={VersionChanged:"Database version changed by other database connection",DatabaseClosed:"Database has been closed",Abort:"Transaction aborted",TransactionInactive:"Transaction has already completed or failed",MissingAPI:"IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb"};function ce(p,y){this.name=p,this.message=y}function xe(p,y){return p+". Errors: "+Object.keys(y).map(function(A){return y[A].toString()}).filter(function(A,R,D){return D.indexOf(A)===R}).join(`
`)}function pe(p,y,A,R){this.failures=y,this.failedKeys=R,this.successCount=A,this.message=xe(p,y)}function Y(p,y){this.name="BulkError",this.failures=Object.keys(y).map(function(A){return y[A]}),this.failuresByPos=y,this.message=xe(p,this.failures)}g(ce).from(Error).extend({toString:function(){return this.name+": "+this.message}}),g(pe).from(ce),g(Y).from(ce);var Ie=xr.reduce(function(p,y){return p[y]=y+"Error",p},{}),re=ce,oe=xr.reduce(function(p,y){var A=y+"Error";function R(D,O){this.name=A,D?typeof D=="string"?(this.message="".concat(D).concat(O?`
 `+O:""),this.inner=O||null):typeof D=="object"&&(this.message="".concat(D.name," ").concat(D.message),this.inner=D):(this.message=$[y]||A,this.inner=null)}return g(R).from(re),p[y]=R,p},{});oe.Syntax=SyntaxError,oe.Type=TypeError,oe.Range=RangeError;var ye=ne.reduce(function(p,y){return p[y+"Error"]=oe[y],p},{}),ke=xr.reduce(function(p,y){return["Syntax","Type","Range"].indexOf(y)===-1&&(p[y+"Error"]=oe[y]),p},{});function X(){}function Se(p){return p}function qe(p,y){return p==null||p===Se?y:function(A){return y(p(A))}}function Qe(p,y){return function(){p.apply(this,arguments),y.apply(this,arguments)}}function Ke(p,y){return p===X?y:function(){var A=p.apply(this,arguments);A!==void 0&&(arguments[0]=A);var R=this.onsuccess,D=this.onerror;this.onsuccess=null,this.onerror=null;var O=y.apply(this,arguments);return R&&(this.onsuccess=this.onsuccess?Qe(R,this.onsuccess):R),D&&(this.onerror=this.onerror?Qe(D,this.onerror):D),O!==void 0?O:A}}function pt(p,y){return p===X?y:function(){p.apply(this,arguments);var A=this.onsuccess,R=this.onerror;this.onsuccess=this.onerror=null,y.apply(this,arguments),A&&(this.onsuccess=this.onsuccess?Qe(A,this.onsuccess):A),R&&(this.onerror=this.onerror?Qe(R,this.onerror):R)}}function He(p,y){return p===X?y:function(A){var R=p.apply(this,arguments);l(A,R);var D=this.onsuccess,O=this.onerror;return this.onsuccess=null,this.onerror=null,A=y.apply(this,arguments),D&&(this.onsuccess=this.onsuccess?Qe(D,this.onsuccess):D),O&&(this.onerror=this.onerror?Qe(O,this.onerror):O),R===void 0?A===void 0?void 0:A:l(R,A)}}function ze(p,y){return p===X?y:function(){return y.apply(this,arguments)!==!1&&p.apply(this,arguments)}}function rt(p,y){return p===X?y:function(){var A=p.apply(this,arguments);if(A&&typeof A.then=="function"){for(var R=this,D=arguments.length,O=new Array(D);D--;)O[D]=arguments[D];return A.then(function(){return y.apply(R,O)})}return y.apply(this,arguments)}}ke.ModifyError=pe,ke.DexieError=ce,ke.BulkError=Y;var Le=typeof location<"u"&&/^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);function k(p){Le=p}var B={},G=100,_e=typeof Promise>"u"?[]:function(){var p=Promise.resolve();if(typeof crypto>"u"||!crypto.subtle)return[p,c(p),p];var y=crypto.subtle.digest("SHA-512",new Uint8Array([0]));return[y,c(y),p]}(),ne=_e[0],xr=_e[1],_e=_e[2],xr=xr&&xr.then,Ye=ne&&ne.constructor,et=!!_e,we=function(p,y){nt.push([p,y]),wt&&(queueMicrotask(En),wt=!1)},bt=!0,wt=!0,tt=[],ee=[],We=Se,Fe={id:"global",global:!0,ref:0,unhandleds:[],onunhandled:X,pgp:!1,env:{},finalize:X},Oe=Fe,nt=[],st=0,Je=[];function ae(p){if(typeof this!="object")throw new TypeError("Promises must be constructed via new");this._listeners=[],this._lib=!1;var y=this._PSD=Oe;if(typeof p!="function"){if(p!==B)throw new TypeError("Not a function");return this._state=arguments[1],this._value=arguments[2],void(this._state===!1&&Bn(this,this._value))}this._state=null,this._value=null,++y.ref,function A(R,D){try{D(function(O){if(R._state===null){if(O===R)throw new TypeError("A promise cannot be resolved with itself.");var W=R._lib&&yi();O&&typeof O.then=="function"?A(R,function(Z,ue){O instanceof ae?O._then(Z,ue):O.then(Z,ue)}):(R._state=!0,R._value=O,On(R)),W&&dn()}},Bn.bind(null,R))}catch(O){Bn(R,O)}}(this,p)}var Ot={get:function(){var p=Oe,y=Ee;function A(R,D){var O=this,W=!p.global&&(p!==Oe||y!==Ee),Z=W&&!N(),ue=new ae(function(fe,ve){ei(O,new _t(at(R,p,W,Z),at(D,p,W,Z),fe,ve,p))});return this._consoleTask&&(ue._consoleTask=this._consoleTask),ue}return A.prototype=B,A},set:function(p){v(this,"then",p&&p.prototype===B?Ot:{get:function(){return p},set:Ot.set})}};function _t(p,y,A,R,D){this.onFulfilled=typeof p=="function"?p:null,this.onRejected=typeof y=="function"?y:null,this.resolve=A,this.reject=R,this.psd=D}function Bn(p,y){var A,R;ee.push(y),p._state===null&&(A=p._lib&&yi(),y=We(y),p._state=!1,p._value=y,R=p,tt.some(function(D){return D._value===R._value})||tt.push(R),On(p),A&&dn())}function On(p){var y=p._listeners;p._listeners=[];for(var A=0,R=y.length;A<R;++A)ei(p,y[A]);var D=p._PSD;--D.ref||D.finalize(),st===0&&(++st,we(function(){--st==0&&vn()},[]))}function ei(p,y){if(p._state!==null){var A=p._state?y.onFulfilled:y.onRejected;if(A===null)return(p._state?y.resolve:y.reject)(p._value);++y.psd.ref,++st,we(Vn,[A,p,y])}else p._listeners.push(y)}function Vn(p,y,A){try{var R,D=y._value;!y._state&&ee.length&&(ee=[]),R=Le&&y._consoleTask?y._consoleTask.run(function(){return p(D)}):p(D),y._state||ee.indexOf(D)!==-1||function(O){for(var W=tt.length;W;)if(tt[--W]._value===O._value)return tt.splice(W,1)}(y),A.resolve(R)}catch(O){A.reject(O)}finally{--st==0&&vn(),--A.psd.ref||A.psd.finalize()}}function En(){it(Fe,function(){yi()&&dn()})}function yi(){var p=bt;return wt=bt=!1,p}function dn(){var p,y,A;do for(;0<nt.length;)for(p=nt,nt=[],A=p.length,y=0;y<A;++y){var R=p[y];R[0].apply(null,R[1])}while(0<nt.length);wt=bt=!0}function vn(){var p=tt;tt=[],p.forEach(function(R){R._PSD.onunhandled.call(null,R._value,R)});for(var y=Je.slice(0),A=y.length;A;)y[--A]()}function ti(p){return new ae(B,!1,p)}function qt(p,y){var A=Oe;return function(){var R=yi(),D=Oe;try{return Re(A,!0),p.apply(this,arguments)}catch(O){y&&y(O)}finally{Re(D,!1),R&&dn()}}}d(ae.prototype,{then:Ot,_then:function(p,y){ei(this,new _t(null,null,p,y,Oe))},catch:function(p){if(arguments.length===1)return this.then(null,p);var y=p,A=arguments[1];return typeof y=="function"?this.then(null,function(R){return(R instanceof y?A:ti)(R)}):this.then(null,function(R){return(R&&R.name===y?A:ti)(R)})},finally:function(p){return this.then(function(y){return ae.resolve(p()).then(function(){return y})},function(y){return ae.resolve(p()).then(function(){return ti(y)})})},timeout:function(p,y){var A=this;return p<1/0?new ae(function(R,D){var O=setTimeout(function(){return D(new oe.Timeout(y))},p);A.then(R,D).finally(clearTimeout.bind(null,O))}):this}}),typeof Symbol<"u"&&Symbol.toStringTag&&v(ae.prototype,Symbol.toStringTag,"Dexie.Promise"),Fe.env=Pe(),d(ae,{all:function(){var p=te.apply(null,arguments).map(Q);return new ae(function(y,A){p.length===0&&y([]);var R=p.length;p.forEach(function(D,O){return ae.resolve(D).then(function(W){p[O]=W,--R||y(p)},A)})})},resolve:function(p){return p instanceof ae?p:p&&typeof p.then=="function"?new ae(function(y,A){p.then(y,A)}):new ae(B,!0,p)},reject:ti,race:function(){var p=te.apply(null,arguments).map(Q);return new ae(function(y,A){p.map(function(R){return ae.resolve(R).then(y,A)})})},PSD:{get:function(){return Oe},set:function(p){return Oe=p}},totalEchoes:{get:function(){return Ee}},newPSD:Nt,usePSD:it,scheduler:{get:function(){return we},set:function(p){we=p}},rejectionMapper:{get:function(){return We},set:function(p){We=p}},follow:function(p,y){return new ae(function(A,R){return Nt(function(D,O){var W=Oe;W.unhandleds=[],W.onunhandled=O,W.finalize=Qe(function(){var Z,ue=this;Z=function(){ue.unhandleds.length===0?D():O(ue.unhandleds[0])},Je.push(function fe(){Z(),Je.splice(Je.indexOf(fe),1)}),++st,we(function(){--st==0&&vn()},[])},W.finalize),p()},y,A,R)})}}),Ye&&(Ye.allSettled&&v(ae,"allSettled",function(){var p=te.apply(null,arguments).map(Q);return new ae(function(y){p.length===0&&y([]);var A=p.length,R=new Array(A);p.forEach(function(D,O){return ae.resolve(D).then(function(W){return R[O]={status:"fulfilled",value:W}},function(W){return R[O]={status:"rejected",reason:W}}).then(function(){return--A||y(R)})})})}),Ye.any&&typeof AggregateError<"u"&&v(ae,"any",function(){var p=te.apply(null,arguments).map(Q);return new ae(function(y,A){p.length===0&&A(new AggregateError([]));var R=p.length,D=new Array(R);p.forEach(function(O,W){return ae.resolve(O).then(function(Z){return y(Z)},function(Z){D[W]=Z,--R||A(new AggregateError(D))})})})}),Ye.withResolvers&&(ae.withResolvers=Ye.withResolvers));var _={awaits:0,echoes:0,id:0},Ae=0,Be=[],Ce=0,Ee=0,Ct=0;function Nt(p,y,A,R){var D=Oe,O=Object.create(D);return O.parent=D,O.ref=0,O.global=!1,O.id=++Ct,Fe.env,O.env=et?{Promise:ae,PromiseProp:{value:ae,configurable:!0,writable:!0},all:ae.all,race:ae.race,allSettled:ae.allSettled,any:ae.any,resolve:ae.resolve,reject:ae.reject}:{},y&&l(O,y),++D.ref,O.finalize=function(){--this.parent.ref||this.parent.finalize()},R=it(O,p,A,R),O.ref===0&&O.finalize(),R}function I(){return _.id||(_.id=++Ae),++_.awaits,_.echoes+=G,_.id}function N(){return!!_.awaits&&(--_.awaits==0&&(_.id=0),_.echoes=_.awaits*G,!0)}function Q(p){return _.echoes&&p&&p.constructor===Ye?(I(),p.then(function(y){return N(),y},function(y){return N(),je(y)})):p}function de(){var p=Be[Be.length-1];Be.pop(),Re(p,!1)}function Re(p,y){var A,R=Oe;(y?!_.echoes||Ce++&&p===Oe:!Ce||--Ce&&p===Oe)||queueMicrotask(y?(function(D){++Ee,_.echoes&&--_.echoes!=0||(_.echoes=_.awaits=_.id=0),Be.push(Oe),Re(D,!0)}).bind(null,p):de),p!==Oe&&(Oe=p,R===Fe&&(Fe.env=Pe()),et&&(A=Fe.env.Promise,y=p.env,(R.global||p.global)&&(Object.defineProperty(r,"Promise",y.PromiseProp),A.all=y.all,A.race=y.race,A.resolve=y.resolve,A.reject=y.reject,y.allSettled&&(A.allSettled=y.allSettled),y.any&&(A.any=y.any))))}function Pe(){var p=r.Promise;return et?{Promise:p,PromiseProp:Object.getOwnPropertyDescriptor(r,"Promise"),all:p.all,race:p.race,allSettled:p.allSettled,any:p.any,resolve:p.resolve,reject:p.reject}:{}}function it(p,y,A,R,D){var O=Oe;try{return Re(p,!0),y(A,R,D)}finally{Re(O,!1)}}function at(p,y,A,R){return typeof p!="function"?p:function(){var D=Oe;A&&I(),Re(y,!0);try{return p.apply(this,arguments)}finally{Re(D,!1),R&&queueMicrotask(N)}}}function lt(p){Promise===Ye&&_.echoes===0?Ce===0?p():enqueueNativeMicroTask(p):setTimeout(p,0)}(""+xr).indexOf("[native code]")===-1&&(I=N=X);var je=ae.reject,Ze="￿",Xe="Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.",ct="String expected.",Et=[],zt="__dbnames",At="readonly",Pt="readwrite";function Dt(p,y){return p?y?function(){return p.apply(this,arguments)&&y.apply(this,arguments)}:p:y}var rn={type:3,lower:-1/0,lowerOpen:!1,upper:[[]],upperOpen:!1};function on(p){return typeof p!="string"||/\./.test(p)?function(y){return y}:function(y){return y[p]===void 0&&p in y&&delete(y=j(y))[p],y}}function yn(){throw oe.Type()}function Rt(p,y){try{var A=Jt(p),R=Jt(y);if(A!==R)return A==="Array"?1:R==="Array"?-1:A==="binary"?1:R==="binary"?-1:A==="string"?1:R==="string"?-1:A==="Date"?1:R!=="Date"?NaN:-1;switch(A){case"number":case"Date":case"string":return y<p?1:p<y?-1:0;case"binary":return function(D,O){for(var W=D.length,Z=O.length,ue=W<Z?W:Z,fe=0;fe<ue;++fe)if(D[fe]!==O[fe])return D[fe]<O[fe]?-1:1;return W===Z?0:W<Z?-1:1}(Rn(p),Rn(y));case"Array":return function(D,O){for(var W=D.length,Z=O.length,ue=W<Z?W:Z,fe=0;fe<ue;++fe){var ve=Rt(D[fe],O[fe]);if(ve!==0)return ve}return W===Z?0:W<Z?-1:1}(p,y)}}catch{}return NaN}function Jt(p){var y=typeof p;return y!="object"?y:ArrayBuffer.isView(p)?"binary":(p=K(p),p==="ArrayBuffer"?"binary":p)}function Rn(p){return p instanceof Uint8Array?p:ArrayBuffer.isView(p)?new Uint8Array(p.buffer,p.byteOffset,p.byteLength):new Uint8Array(p)}var xi=(kt.prototype._trans=function(p,y,A){var R=this._tx||Oe.trans,D=this.name,O=Le&&typeof console<"u"&&console.createTask&&console.createTask("Dexie: ".concat(p==="readonly"?"read":"write"," ").concat(this.name));function W(fe,ve,ie){if(!ie.schema[D])throw new oe.NotFound("Table "+D+" not part of transaction");return y(ie.idbtrans,ie)}var Z=yi();try{var ue=R&&R.db._novip===this.db._novip?R===Oe.trans?R._promise(p,W,A):Nt(function(){return R._promise(p,W,A)},{trans:R,transless:Oe.transless||Oe}):function fe(ve,ie,Te,he){if(ve.idbdb&&(ve._state.openComplete||Oe.letThrough||ve._vip)){var ge=ve._createTransaction(ie,Te,ve._dbSchema);try{ge.create(),ve._state.PR1398_maxLoop=3}catch(be){return be.name===Ie.InvalidState&&ve.isOpen()&&0<--ve._state.PR1398_maxLoop?(console.warn("Dexie: Need to reopen db"),ve.close({disableAutoOpen:!1}),ve.open().then(function(){return fe(ve,ie,Te,he)})):je(be)}return ge._promise(ie,function(be,me){return Nt(function(){return Oe.trans=ge,he(be,me,ge)})}).then(function(be){if(ie==="readwrite")try{ge.idbtrans.commit()}catch{}return ie==="readonly"?be:ge._completion.then(function(){return be})})}if(ve._state.openComplete)return je(new oe.DatabaseClosed(ve._state.dbOpenError));if(!ve._state.isBeingOpened){if(!ve._state.autoOpen)return je(new oe.DatabaseClosed);ve.open().catch(X)}return ve._state.dbReadyPromise.then(function(){return fe(ve,ie,Te,he)})}(this.db,p,[this.name],W);return O&&(ue._consoleTask=O,ue=ue.catch(function(fe){return console.trace(fe),je(fe)})),ue}finally{Z&&dn()}},kt.prototype.get=function(p,y){var A=this;return p&&p.constructor===Object?this.where(p).first(y):p==null?je(new oe.Type("Invalid argument to Table.get()")):this._trans("readonly",function(R){return A.core.get({trans:R,key:p}).then(function(D){return A.hook.reading.fire(D)})}).then(y)},kt.prototype.where=function(p){if(typeof p=="string")return new this.db.WhereClause(this,p);if(o(p))return new this.db.WhereClause(this,"[".concat(p.join("+"),"]"));var y=a(p);if(y.length===1)return this.where(y[0]).equals(p[y[0]]);var A=this.schema.indexes.concat(this.schema.primKey).filter(function(Z){if(Z.compound&&y.every(function(fe){return 0<=Z.keyPath.indexOf(fe)})){for(var ue=0;ue<y.length;++ue)if(y.indexOf(Z.keyPath[ue])===-1)return!1;return!0}return!1}).sort(function(Z,ue){return Z.keyPath.length-ue.keyPath.length})[0];if(A&&this.db._maxKey!==Ze){var O=A.keyPath.slice(0,y.length);return this.where(O).equals(O.map(function(ue){return p[ue]}))}!A&&Le&&console.warn("The query ".concat(JSON.stringify(p)," on ").concat(this.name," would benefit from a ")+"compound index [".concat(y.join("+"),"]"));var R=this.schema.idxByName;function D(Z,ue){return Rt(Z,ue)===0}var W=y.reduce(function(ie,ue){var fe=ie[0],ve=ie[1],ie=R[ue],Te=p[ue];return[fe||ie,fe||!ie?Dt(ve,ie&&ie.multi?function(he){return he=C(he,ue),o(he)&&he.some(function(ge){return D(Te,ge)})}:function(he){return D(Te,C(he,ue))}):ve]},[null,null]),O=W[0],W=W[1];return O?this.where(O.name).equals(p[O.keyPath]).filter(W):A?this.filter(W):this.where(y).equals("")},kt.prototype.filter=function(p){return this.toCollection().and(p)},kt.prototype.count=function(p){return this.toCollection().count(p)},kt.prototype.offset=function(p){return this.toCollection().offset(p)},kt.prototype.limit=function(p){return this.toCollection().limit(p)},kt.prototype.each=function(p){return this.toCollection().each(p)},kt.prototype.toArray=function(p){return this.toCollection().toArray(p)},kt.prototype.toCollection=function(){return new this.db.Collection(new this.db.WhereClause(this))},kt.prototype.orderBy=function(p){return new this.db.Collection(new this.db.WhereClause(this,o(p)?"[".concat(p.join("+"),"]"):p))},kt.prototype.reverse=function(){return this.toCollection().reverse()},kt.prototype.mapToClass=function(p){var y,A=this.db,R=this.name;function D(){return y!==null&&y.apply(this,arguments)||this}(this.schema.mappedClass=p).prototype instanceof yn&&(function(ue,fe){if(typeof fe!="function"&&fe!==null)throw new TypeError("Class extends value "+String(fe)+" is not a constructor or null");function ve(){this.constructor=ue}t(ue,fe),ue.prototype=fe===null?Object.create(fe):(ve.prototype=fe.prototype,new ve)}(D,y=p),Object.defineProperty(D.prototype,"db",{get:function(){return A},enumerable:!1,configurable:!0}),D.prototype.table=function(){return R},p=D);for(var O=new Set,W=p.prototype;W;W=c(W))Object.getOwnPropertyNames(W).forEach(function(ue){return O.add(ue)});function Z(ue){if(!ue)return ue;var fe,ve=Object.create(p.prototype);for(fe in ue)if(!O.has(fe))try{ve[fe]=ue[fe]}catch{}return ve}return this.schema.readHook&&this.hook.reading.unsubscribe(this.schema.readHook),this.schema.readHook=Z,this.hook("reading",Z),p},kt.prototype.defineClass=function(){return this.mapToClass(function(p){l(this,p)})},kt.prototype.add=function(p,y){var A=this,R=this.schema.primKey,D=R.auto,O=R.keyPath,W=p;return O&&D&&(W=on(O)(p)),this._trans("readwrite",function(Z){return A.core.mutate({trans:Z,type:"add",keys:y!=null?[y]:null,values:[W]})}).then(function(Z){return Z.numFailures?ae.reject(Z.failures[0]):Z.lastResult}).then(function(Z){if(O)try{P(p,O,Z)}catch{}return Z})},kt.prototype.update=function(p,y){return typeof p!="object"||o(p)?this.where(":id").equals(p).modify(y):(p=C(p,this.schema.primKey.keyPath),p===void 0?je(new oe.InvalidArgument("Given object does not contain its primary key")):this.where(":id").equals(p).modify(y))},kt.prototype.put=function(p,y){var A=this,R=this.schema.primKey,D=R.auto,O=R.keyPath,W=p;return O&&D&&(W=on(O)(p)),this._trans("readwrite",function(Z){return A.core.mutate({trans:Z,type:"put",values:[W],keys:y!=null?[y]:null})}).then(function(Z){return Z.numFailures?ae.reject(Z.failures[0]):Z.lastResult}).then(function(Z){if(O)try{P(p,O,Z)}catch{}return Z})},kt.prototype.delete=function(p){var y=this;return this._trans("readwrite",function(A){return y.core.mutate({trans:A,type:"delete",keys:[p]})}).then(function(A){return A.numFailures?ae.reject(A.failures[0]):void 0})},kt.prototype.clear=function(){var p=this;return this._trans("readwrite",function(y){return p.core.mutate({trans:y,type:"deleteRange",range:rn})}).then(function(y){return y.numFailures?ae.reject(y.failures[0]):void 0})},kt.prototype.bulkGet=function(p){var y=this;return this._trans("readonly",function(A){return y.core.getMany({keys:p,trans:A}).then(function(R){return R.map(function(D){return y.hook.reading.fire(D)})})})},kt.prototype.bulkAdd=function(p,y,A){var R=this,D=Array.isArray(y)?y:void 0,O=(A=A||(D?void 0:y))?A.allKeys:void 0;return this._trans("readwrite",function(W){var fe=R.schema.primKey,Z=fe.auto,fe=fe.keyPath;if(fe&&D)throw new oe.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");if(D&&D.length!==p.length)throw new oe.InvalidArgument("Arguments objects and keys must have the same length");var ue=p.length,fe=fe&&Z?p.map(on(fe)):p;return R.core.mutate({trans:W,type:"add",keys:D,values:fe,wantResults:O}).then(function(ge){var ie=ge.numFailures,Te=ge.results,he=ge.lastResult,ge=ge.failures;if(ie===0)return O?Te:he;throw new Y("".concat(R.name,".bulkAdd(): ").concat(ie," of ").concat(ue," operations failed"),ge)})})},kt.prototype.bulkPut=function(p,y,A){var R=this,D=Array.isArray(y)?y:void 0,O=(A=A||(D?void 0:y))?A.allKeys:void 0;return this._trans("readwrite",function(W){var fe=R.schema.primKey,Z=fe.auto,fe=fe.keyPath;if(fe&&D)throw new oe.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");if(D&&D.length!==p.length)throw new oe.InvalidArgument("Arguments objects and keys must have the same length");var ue=p.length,fe=fe&&Z?p.map(on(fe)):p;return R.core.mutate({trans:W,type:"put",keys:D,values:fe,wantResults:O}).then(function(ge){var ie=ge.numFailures,Te=ge.results,he=ge.lastResult,ge=ge.failures;if(ie===0)return O?Te:he;throw new Y("".concat(R.name,".bulkPut(): ").concat(ie," of ").concat(ue," operations failed"),ge)})})},kt.prototype.bulkUpdate=function(p){var y=this,A=this.core,R=p.map(function(W){return W.key}),D=p.map(function(W){return W.changes}),O=[];return this._trans("readwrite",function(W){return A.getMany({trans:W,keys:R,cache:"clone"}).then(function(Z){var ue=[],fe=[];p.forEach(function(ie,Te){var he=ie.key,ge=ie.changes,be=Z[Te];if(be){for(var me=0,De=Object.keys(ge);me<De.length;me++){var Ue=De[me],Ve=ge[Ue];if(Ue===y.schema.primKey.keyPath){if(Rt(Ve,he)!==0)throw new oe.Constraint("Cannot update primary key in bulkUpdate()")}else P(be,Ue,Ve)}O.push(Te),ue.push(he),fe.push(be)}});var ve=ue.length;return A.mutate({trans:W,type:"put",keys:ue,values:fe,updates:{keys:R,changeSpecs:D}}).then(function(ie){var Te=ie.numFailures,he=ie.failures;if(Te===0)return ve;for(var ge=0,be=Object.keys(he);ge<be.length;ge++){var me,De=be[ge],Ue=O[Number(De)];Ue!=null&&(me=he[De],delete he[De],he[Ue]=me)}throw new Y("".concat(y.name,".bulkUpdate(): ").concat(Te," of ").concat(ve," operations failed"),he)})})})},kt.prototype.bulkDelete=function(p){var y=this,A=p.length;return this._trans("readwrite",function(R){return y.core.mutate({trans:R,type:"delete",keys:p})}).then(function(W){var D=W.numFailures,O=W.lastResult,W=W.failures;if(D===0)return O;throw new Y("".concat(y.name,".bulkDelete(): ").concat(D," of ").concat(A," operations failed"),W)})},kt);function kt(){}function Kt(p){function y(W,Z){if(Z){for(var ue=arguments.length,fe=new Array(ue-1);--ue;)fe[ue-1]=arguments[ue];return A[W].subscribe.apply(null,fe),p}if(typeof W=="string")return A[W]}var A={};y.addEventType=O;for(var R=1,D=arguments.length;R<D;++R)O(arguments[R]);return y;function O(W,Z,ue){if(typeof W!="object"){var fe;Z=Z||ze;var ve={subscribers:[],fire:ue=ue||X,subscribe:function(ie){ve.subscribers.indexOf(ie)===-1&&(ve.subscribers.push(ie),ve.fire=Z(ve.fire,ie))},unsubscribe:function(ie){ve.subscribers=ve.subscribers.filter(function(Te){return Te!==ie}),ve.fire=ve.subscribers.reduce(Z,ue)}};return A[W]=y[W]=ve}a(fe=W).forEach(function(ie){var Te=fe[ie];if(o(Te))O(ie,fe[ie][0],fe[ie][1]);else{if(Te!=="asap")throw new oe.InvalidArgument("Invalid event config");var he=O(ie,Se,function(){for(var ge=arguments.length,be=new Array(ge);ge--;)be[ge]=arguments[ge];he.subscribers.forEach(function(me){E(function(){me.apply(null,be)})})})}})}}function Yt(p,y){return g(y).from({prototype:p}),y}function ni(p,y){return!(p.filter||p.algorithm||p.or)&&(y?p.justLimit:!p.replayFilter)}function sr(p,y){p.filter=Dt(p.filter,y)}function wi(p,y,A){var R=p.replayFilter;p.replayFilter=R?function(){return Dt(R(),y())}:y,p.justLimit=A&&!R}function ii(p,y){if(p.isPrimKey)return y.primaryKey;var A=y.getIndexByKeyPath(p.index);if(!A)throw new oe.Schema("KeyPath "+p.index+" on object store "+y.name+" is not indexed");return A}function Fh(p,y,A){var R=ii(p,y.schema);return y.openCursor({trans:A,values:!p.keysOnly,reverse:p.dir==="prev",unique:!!p.unique,query:{index:R,range:p.range}})}function fs(p,y,A,R){var D=p.replayFilter?Dt(p.filter,p.replayFilter()):p.filter;if(p.or){var O={},W=function(Z,ue,fe){var ve,ie;D&&!D(ue,fe,function(Te){return ue.stop(Te)},function(Te){return ue.fail(Te)})||((ie=""+(ve=ue.primaryKey))=="[object ArrayBuffer]"&&(ie=""+new Uint8Array(ve)),h(O,ie)||(O[ie]=!0,y(Z,ue,fe)))};return Promise.all([p.or._iterate(W,A),aa(Fh(p,R,A),p.algorithm,W,!p.keysOnly&&p.valueMapper)])}return aa(Fh(p,R,A),Dt(p.algorithm,D),y,!p.keysOnly&&p.valueMapper)}function aa(p,y,A,R){var D=qt(R?function(O,W,Z){return A(R(O),W,Z)}:A);return p.then(function(O){if(O)return O.start(function(){var W=function(){return O.continue()};y&&!y(O,function(Z){return W=Z},function(Z){O.stop(Z),W=X},function(Z){O.fail(Z),W=X})||D(O.value,O,function(Z){return W=Z}),W()})})}var oa=(Ya.prototype.execute=function(p){var y=this["@@propmod"];if(y.add!==void 0){var A=y.add;if(o(A))return i(i([],o(p)?p:[],!0),A).sort();if(typeof A=="number")return(Number(p)||0)+A;if(typeof A=="bigint")try{return BigInt(p)+A}catch{return BigInt(0)+A}throw new TypeError("Invalid term ".concat(A))}if(y.remove!==void 0){var R=y.remove;if(o(R))return o(p)?p.filter(function(D){return!R.includes(D)}).sort():[];if(typeof R=="number")return Number(p)-R;if(typeof R=="bigint")try{return BigInt(p)-R}catch{return BigInt(0)-R}throw new TypeError("Invalid subtrahend ".concat(R))}return A=(A=y.replacePrefix)===null||A===void 0?void 0:A[0],A&&typeof p=="string"&&p.startsWith(A)?y.replacePrefix[1]+p.substring(A.length):p},Ya);function Ya(p){this["@@propmod"]=p}var nl=(sn.prototype._read=function(p,y){var A=this._ctx;return A.error?A.table._trans(null,je.bind(null,A.error)):A.table._trans("readonly",p).then(y)},sn.prototype._write=function(p){var y=this._ctx;return y.error?y.table._trans(null,je.bind(null,y.error)):y.table._trans("readwrite",p,"locked")},sn.prototype._addAlgorithm=function(p){var y=this._ctx;y.algorithm=Dt(y.algorithm,p)},sn.prototype._iterate=function(p,y){return fs(this._ctx,p,y,this._ctx.table.core)},sn.prototype.clone=function(p){var y=Object.create(this.constructor.prototype),A=Object.create(this._ctx);return p&&l(A,p),y._ctx=A,y},sn.prototype.raw=function(){return this._ctx.valueMapper=null,this},sn.prototype.each=function(p){var y=this._ctx;return this._read(function(A){return fs(y,p,A,y.table.core)})},sn.prototype.count=function(p){var y=this;return this._read(function(A){var R=y._ctx,D=R.table.core;if(ni(R,!0))return D.count({trans:A,query:{index:ii(R,D.schema),range:R.range}}).then(function(W){return Math.min(W,R.limit)});var O=0;return fs(R,function(){return++O,!1},A,D).then(function(){return O})}).then(p)},sn.prototype.sortBy=function(p,y){var A=p.split(".").reverse(),R=A[0],D=A.length-1;function O(ue,fe){return fe?O(ue[A[fe]],fe-1):ue[R]}var W=this._ctx.dir==="next"?1:-1;function Z(ue,fe){return Rt(O(ue,D),O(fe,D))*W}return this.toArray(function(ue){return ue.sort(Z)}).then(y)},sn.prototype.toArray=function(p){var y=this;return this._read(function(A){var R=y._ctx;if(R.dir==="next"&&ni(R,!0)&&0<R.limit){var D=R.valueMapper,O=ii(R,R.table.core.schema);return R.table.core.query({trans:A,limit:R.limit,values:!0,query:{index:O,range:R.range}}).then(function(Z){return Z=Z.result,D?Z.map(D):Z})}var W=[];return fs(R,function(Z){return W.push(Z)},A,R.table.core).then(function(){return W})},p)},sn.prototype.offset=function(p){var y=this._ctx;return p<=0||(y.offset+=p,ni(y)?wi(y,function(){var A=p;return function(R,D){return A===0||(A===1?--A:D(function(){R.advance(A),A=0}),!1)}}):wi(y,function(){var A=p;return function(){return--A<0}})),this},sn.prototype.limit=function(p){return this._ctx.limit=Math.min(this._ctx.limit,p),wi(this._ctx,function(){var y=p;return function(A,R,D){return--y<=0&&R(D),0<=y}},!0),this},sn.prototype.until=function(p,y){return sr(this._ctx,function(A,R,D){return!p(A.value)||(R(D),y)}),this},sn.prototype.first=function(p){return this.limit(1).toArray(function(y){return y[0]}).then(p)},sn.prototype.last=function(p){return this.reverse().first(p)},sn.prototype.filter=function(p){var y;return sr(this._ctx,function(A){return p(A.value)}),(y=this._ctx).isMatch=Dt(y.isMatch,p),this},sn.prototype.and=function(p){return this.filter(p)},sn.prototype.or=function(p){return new this.db.WhereClause(this._ctx.table,p,this)},sn.prototype.reverse=function(){return this._ctx.dir=this._ctx.dir==="prev"?"next":"prev",this._ondirectionchange&&this._ondirectionchange(this._ctx.dir),this},sn.prototype.desc=function(){return this.reverse()},sn.prototype.eachKey=function(p){var y=this._ctx;return y.keysOnly=!y.isMatch,this.each(function(A,R){p(R.key,R)})},sn.prototype.eachUniqueKey=function(p){return this._ctx.unique="unique",this.eachKey(p)},sn.prototype.eachPrimaryKey=function(p){var y=this._ctx;return y.keysOnly=!y.isMatch,this.each(function(A,R){p(R.primaryKey,R)})},sn.prototype.keys=function(p){var y=this._ctx;y.keysOnly=!y.isMatch;var A=[];return this.each(function(R,D){A.push(D.key)}).then(function(){return A}).then(p)},sn.prototype.primaryKeys=function(p){var y=this._ctx;if(y.dir==="next"&&ni(y,!0)&&0<y.limit)return this._read(function(R){var D=ii(y,y.table.core.schema);return y.table.core.query({trans:R,values:!1,limit:y.limit,query:{index:D,range:y.range}})}).then(function(R){return R.result}).then(p);y.keysOnly=!y.isMatch;var A=[];return this.each(function(R,D){A.push(D.primaryKey)}).then(function(){return A}).then(p)},sn.prototype.uniqueKeys=function(p){return this._ctx.unique="unique",this.keys(p)},sn.prototype.firstKey=function(p){return this.limit(1).keys(function(y){return y[0]}).then(p)},sn.prototype.lastKey=function(p){return this.reverse().firstKey(p)},sn.prototype.distinct=function(){var p=this._ctx,p=p.index&&p.table.schema.idxByName[p.index];if(!p||!p.multi)return this;var y={};return sr(this._ctx,function(D){var R=D.primaryKey.toString(),D=h(y,R);return y[R]=!0,!D}),this},sn.prototype.modify=function(p){var y=this,A=this._ctx;return this._write(function(R){var D,O,W;W=typeof p=="function"?p:(D=a(p),O=D.length,function(me){for(var De=!1,Ue=0;Ue<O;++Ue){var Ve=D[Ue],$e=p[Ve],ut=C(me,Ve);$e instanceof oa?(P(me,Ve,$e.execute(ut)),De=!0):ut!==$e&&(P(me,Ve,$e),De=!0)}return De});var Z=A.table.core,ie=Z.schema.primaryKey,ue=ie.outbound,fe=ie.extractKey,ve=200,ie=y.db._options.modifyChunkSize;ie&&(ve=typeof ie=="object"?ie[Z.name]||ie["*"]||200:ie);function Te(me,Ve){var Ue=Ve.failures,Ve=Ve.numFailures;ge+=me-Ve;for(var $e=0,ut=a(Ue);$e<ut.length;$e++){var yt=ut[$e];he.push(Ue[yt])}}var he=[],ge=0,be=[];return y.clone().primaryKeys().then(function(me){function De(Ve){var $e=Math.min(ve,me.length-Ve);return Z.getMany({trans:R,keys:me.slice(Ve,Ve+$e),cache:"immutable"}).then(function(ut){for(var yt=[],ht=[],ft=ue?[]:null,St=[],gt=0;gt<$e;++gt){var Mt=ut[gt],jt={value:j(Mt),primKey:me[Ve+gt]};W.call(jt,jt.value,jt)!==!1&&(jt.value==null?St.push(me[Ve+gt]):ue||Rt(fe(Mt),fe(jt.value))===0?(ht.push(jt.value),ue&&ft.push(me[Ve+gt])):(St.push(me[Ve+gt]),yt.push(jt.value)))}return Promise.resolve(0<yt.length&&Z.mutate({trans:R,type:"add",values:yt}).then(function($t){for(var en in $t.failures)St.splice(parseInt(en),1);Te(yt.length,$t)})).then(function(){return(0<ht.length||Ue&&typeof p=="object")&&Z.mutate({trans:R,type:"put",keys:ft,values:ht,criteria:Ue,changeSpec:typeof p!="function"&&p,isAdditionalChunk:0<Ve}).then(function($t){return Te(ht.length,$t)})}).then(function(){return(0<St.length||Ue&&p===il)&&Z.mutate({trans:R,type:"delete",keys:St,criteria:Ue,isAdditionalChunk:0<Ve}).then(function($t){return Te(St.length,$t)})}).then(function(){return me.length>Ve+$e&&De(Ve+ve)})})}var Ue=ni(A)&&A.limit===1/0&&(typeof p!="function"||p===il)&&{index:A.index,range:A.range};return De(0).then(function(){if(0<he.length)throw new pe("Error modifying one or more objects",he,ge,be);return me.length})})})},sn.prototype.delete=function(){var p=this._ctx,y=p.range;return ni(p)&&(p.isPrimKey||y.type===3)?this._write(function(A){var R=p.table.core.schema.primaryKey,D=y;return p.table.core.count({trans:A,query:{index:R,range:D}}).then(function(O){return p.table.core.mutate({trans:A,type:"deleteRange",range:D}).then(function(W){var Z=W.failures;if(W.lastResult,W.results,W=W.numFailures,W)throw new pe("Could not delete some values",Object.keys(Z).map(function(ue){return Z[ue]}),O-W);return O-W})})}):this.modify(il)},sn);function sn(){}var il=function(p,y){return y.value=null};function Uh(p,y){return p<y?-1:p===y?0:1}function qc(p,y){return y<p?-1:p===y?0:1}function fi(p,y,A){return p=p instanceof la?new p.Collection(p):p,p._ctx.error=new(A||TypeError)(y),p}function ps(p){return new p.Collection(p,function(){return gs("")}).limit(0)}function ms(p,y,A,R){var D,O,W,Z,ue,fe,ve,ie=A.length;if(!A.every(function(ge){return typeof ge=="string"}))return fi(p,ct);function Te(ge){D=ge==="next"?function(me){return me.toUpperCase()}:function(me){return me.toLowerCase()},O=ge==="next"?function(me){return me.toLowerCase()}:function(me){return me.toUpperCase()},W=ge==="next"?Uh:qc;var be=A.map(function(me){return{lower:O(me),upper:D(me)}}).sort(function(me,De){return W(me.lower,De.lower)});Z=be.map(function(me){return me.upper}),ue=be.map(function(me){return me.lower}),ve=(fe=ge)==="next"?"":R}Te("next"),p=new p.Collection(p,function(){return ji(Z[0],ue[ie-1]+R)}),p._ondirectionchange=function(ge){Te(ge)};var he=0;return p._addAlgorithm(function(ge,be,me){var De=ge.key;if(typeof De!="string")return!1;var Ue=O(De);if(y(Ue,ue,he))return!0;for(var Ve=null,$e=he;$e<ie;++$e){var ut=function(yt,ht,ft,St,gt,Mt){for(var jt=Math.min(yt.length,St.length),$t=-1,en=0;en<jt;++en){var lr=ht[en];if(lr!==St[en])return gt(yt[en],ft[en])<0?yt.substr(0,en)+ft[en]+ft.substr(en+1):gt(yt[en],St[en])<0?yt.substr(0,en)+St[en]+ft.substr(en+1):0<=$t?yt.substr(0,$t)+ht[$t]+ft.substr($t+1):null;gt(yt[en],lr)<0&&($t=en)}return jt<St.length&&Mt==="next"?yt+ft.substr(yt.length):jt<yt.length&&Mt==="prev"?yt.substr(0,ft.length):$t<0?null:yt.substr(0,$t)+St[$t]+ft.substr($t+1)}(De,Ue,Z[$e],ue[$e],W,fe);ut===null&&Ve===null?he=$e+1:(Ve===null||0<W(Ve,ut))&&(Ve=ut)}return be(Ve!==null?function(){ge.continue(Ve+ve)}:me),!1}),p}function ji(p,y,A,R){return{type:2,lower:p,upper:y,lowerOpen:A,upperOpen:R}}function gs(p){return{type:1,lower:p,upper:p}}var la=(Object.defineProperty(Wn.prototype,"Collection",{get:function(){return this._ctx.table.db.Collection},enumerable:!1,configurable:!0}),Wn.prototype.between=function(p,y,A,R){A=A!==!1,R=R===!0;try{return 0<this._cmp(p,y)||this._cmp(p,y)===0&&(A||R)&&(!A||!R)?ps(this):new this.Collection(this,function(){return ji(p,y,!A,!R)})}catch{return fi(this,Xe)}},Wn.prototype.equals=function(p){return p==null?fi(this,Xe):new this.Collection(this,function(){return gs(p)})},Wn.prototype.above=function(p){return p==null?fi(this,Xe):new this.Collection(this,function(){return ji(p,void 0,!0)})},Wn.prototype.aboveOrEqual=function(p){return p==null?fi(this,Xe):new this.Collection(this,function(){return ji(p,void 0,!1)})},Wn.prototype.below=function(p){return p==null?fi(this,Xe):new this.Collection(this,function(){return ji(void 0,p,!1,!0)})},Wn.prototype.belowOrEqual=function(p){return p==null?fi(this,Xe):new this.Collection(this,function(){return ji(void 0,p)})},Wn.prototype.startsWith=function(p){return typeof p!="string"?fi(this,ct):this.between(p,p+Ze,!0,!0)},Wn.prototype.startsWithIgnoreCase=function(p){return p===""?this.startsWith(p):ms(this,function(y,A){return y.indexOf(A[0])===0},[p],Ze)},Wn.prototype.equalsIgnoreCase=function(p){return ms(this,function(y,A){return y===A[0]},[p],"")},Wn.prototype.anyOfIgnoreCase=function(){var p=te.apply(q,arguments);return p.length===0?ps(this):ms(this,function(y,A){return A.indexOf(y)!==-1},p,"")},Wn.prototype.startsWithAnyOfIgnoreCase=function(){var p=te.apply(q,arguments);return p.length===0?ps(this):ms(this,function(y,A){return A.some(function(R){return y.indexOf(R)===0})},p,Ze)},Wn.prototype.anyOf=function(){var p=this,y=te.apply(q,arguments),A=this._cmp;try{y.sort(A)}catch{return fi(this,Xe)}if(y.length===0)return ps(this);var R=new this.Collection(this,function(){return ji(y[0],y[y.length-1])});R._ondirectionchange=function(O){A=O==="next"?p._ascending:p._descending,y.sort(A)};var D=0;return R._addAlgorithm(function(O,W,Z){for(var ue=O.key;0<A(ue,y[D]);)if(++D===y.length)return W(Z),!1;return A(ue,y[D])===0||(W(function(){O.continue(y[D])}),!1)}),R},Wn.prototype.notEqual=function(p){return this.inAnyRange([[-1/0,p],[p,this.db._maxKey]],{includeLowers:!1,includeUppers:!1})},Wn.prototype.noneOf=function(){var p=te.apply(q,arguments);if(p.length===0)return new this.Collection(this);try{p.sort(this._ascending)}catch{return fi(this,Xe)}var y=p.reduce(function(A,R){return A?A.concat([[A[A.length-1][1],R]]):[[-1/0,R]]},null);return y.push([p[p.length-1],this.db._maxKey]),this.inAnyRange(y,{includeLowers:!1,includeUppers:!1})},Wn.prototype.inAnyRange=function(De,y){var A=this,R=this._cmp,D=this._ascending,O=this._descending,W=this._min,Z=this._max;if(De.length===0)return ps(this);if(!De.every(function(Ue){return Ue[0]!==void 0&&Ue[1]!==void 0&&D(Ue[0],Ue[1])<=0}))return fi(this,"First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower",oe.InvalidArgument);var ue=!y||y.includeLowers!==!1,fe=y&&y.includeUppers===!0,ve,ie=D;function Te(Ue,Ve){return ie(Ue[0],Ve[0])}try{(ve=De.reduce(function(Ue,Ve){for(var $e=0,ut=Ue.length;$e<ut;++$e){var yt=Ue[$e];if(R(Ve[0],yt[1])<0&&0<R(Ve[1],yt[0])){yt[0]=W(yt[0],Ve[0]),yt[1]=Z(yt[1],Ve[1]);break}}return $e===ut&&Ue.push(Ve),Ue},[])).sort(Te)}catch{return fi(this,Xe)}var he=0,ge=fe?function(Ue){return 0<D(Ue,ve[he][1])}:function(Ue){return 0<=D(Ue,ve[he][1])},be=ue?function(Ue){return 0<O(Ue,ve[he][0])}:function(Ue){return 0<=O(Ue,ve[he][0])},me=ge,De=new this.Collection(this,function(){return ji(ve[0][0],ve[ve.length-1][1],!ue,!fe)});return De._ondirectionchange=function(Ue){ie=Ue==="next"?(me=ge,D):(me=be,O),ve.sort(Te)},De._addAlgorithm(function(Ue,Ve,$e){for(var ut,yt=Ue.key;me(yt);)if(++he===ve.length)return Ve($e),!1;return!ge(ut=yt)&&!be(ut)||(A._cmp(yt,ve[he][1])===0||A._cmp(yt,ve[he][0])===0||Ve(function(){ie===D?Ue.continue(ve[he][0]):Ue.continue(ve[he][1])}),!1)}),De},Wn.prototype.startsWithAnyOf=function(){var p=te.apply(q,arguments);return p.every(function(y){return typeof y=="string"})?p.length===0?ps(this):this.inAnyRange(p.map(function(y){return[y,y+Ze]})):fi(this,"startsWithAnyOf() only works with strings")},Wn);function Wn(){}function Ni(p){return qt(function(y){return vs(y),p(y.target.error),!1})}function vs(p){p.stopPropagation&&p.stopPropagation(),p.preventDefault&&p.preventDefault()}var ys="storagemutated",rl="x-storagemutated-1",ar=Kt(null,ys),jc=(or.prototype._lock=function(){return b(!Oe.global),++this._reculock,this._reculock!==1||Oe.global||(Oe.lockOwnerFor=this),this},or.prototype._unlock=function(){if(b(!Oe.global),--this._reculock==0)for(Oe.global||(Oe.lockOwnerFor=null);0<this._blockedFuncs.length&&!this._locked();){var p=this._blockedFuncs.shift();try{it(p[1],p[0])}catch{}}return this},or.prototype._locked=function(){return this._reculock&&Oe.lockOwnerFor!==this},or.prototype.create=function(p){var y=this;if(!this.mode)return this;var A=this.db.idbdb,R=this.db._state.dbOpenError;if(b(!this.idbtrans),!p&&!A)switch(R&&R.name){case"DatabaseClosedError":throw new oe.DatabaseClosed(R);case"MissingAPIError":throw new oe.MissingAPI(R.message,R);default:throw new oe.OpenFailed(R)}if(!this.active)throw new oe.TransactionInactive;return b(this._completion._state===null),(p=this.idbtrans=p||(this.db.core||A).transaction(this.storeNames,this.mode,{durability:this.chromeTransactionDurability})).onerror=qt(function(D){vs(D),y._reject(p.error)}),p.onabort=qt(function(D){vs(D),y.active&&y._reject(new oe.Abort(p.error)),y.active=!1,y.on("abort").fire(D)}),p.oncomplete=qt(function(){y.active=!1,y._resolve(),"mutatedParts"in p&&ar.storagemutated.fire(p.mutatedParts)}),this},or.prototype._promise=function(p,y,A){var R=this;if(p==="readwrite"&&this.mode!=="readwrite")return je(new oe.ReadOnly("Transaction is readonly"));if(!this.active)return je(new oe.TransactionInactive);if(this._locked())return new ae(function(O,W){R._blockedFuncs.push([function(){R._promise(p,y,A).then(O,W)},Oe])});if(A)return Nt(function(){var O=new ae(function(W,Z){R._lock();var ue=y(W,Z,R);ue&&ue.then&&ue.then(W,Z)});return O.finally(function(){return R._unlock()}),O._lib=!0,O});var D=new ae(function(O,W){var Z=y(O,W,R);Z&&Z.then&&Z.then(O,W)});return D._lib=!0,D},or.prototype._root=function(){return this.parent?this.parent._root():this},or.prototype.waitFor=function(p){var y,A=this._root(),R=ae.resolve(p);A._waitingFor?A._waitingFor=A._waitingFor.then(function(){return R}):(A._waitingFor=R,A._waitingQueue=[],y=A.idbtrans.objectStore(A.storeNames[0]),function O(){for(++A._spinCount;A._waitingQueue.length;)A._waitingQueue.shift()();A._waitingFor&&(y.get(-1/0).onsuccess=O)}());var D=A._waitingFor;return new ae(function(O,W){R.then(function(Z){return A._waitingQueue.push(qt(O.bind(null,Z)))},function(Z){return A._waitingQueue.push(qt(W.bind(null,Z)))}).finally(function(){A._waitingFor===D&&(A._waitingFor=null)})})},or.prototype.abort=function(){this.active&&(this.active=!1,this.idbtrans&&this.idbtrans.abort(),this._reject(new oe.Abort))},or.prototype.table=function(p){var y=this._memoizedTables||(this._memoizedTables={});if(h(y,p))return y[p];var A=this.schema[p];if(!A)throw new oe.NotFound("Table "+p+" not part of transaction");return A=new this.db.Table(p,A,this),A.core=this.db.core.table(p),y[p]=A},or);function or(){}function Qi(p,y,A,R,D,O,W){return{name:p,keyPath:y,unique:A,multi:R,auto:D,compound:O,src:(A&&!W?"&":"")+(R?"*":"")+(D?"++":"")+sl(y)}}function sl(p){return typeof p=="string"?p:p?"["+[].join.call(p,"+")+"]":""}function al(p,y,A){return{name:p,primKey:y,indexes:A,mappedClass:null,idxByName:(R=function(D){return[D.name,D]},A.reduce(function(D,O,W){return W=R(O,W),W&&(D[W[0]]=W[1]),D},{}))};var R}var ca=function(p){try{return p.only([[]]),ca=function(){return[[]]},[[]]}catch{return ca=function(){return Ze},Ze}};function Za(p){return p==null?function(){}:typeof p=="string"?(y=p).split(".").length===1?function(A){return A[y]}:function(A){return C(A,y)}:function(A){return C(A,p)};var y}function Qc(p){return[].slice.call(p)}var kh=0;function Or(p){return p==null?":id":typeof p=="string"?p:"[".concat(p.join("+"),"]")}function $a(p,y,ue){function R(me){if(me.type===3)return null;if(me.type===4)throw new Error("Cannot convert never type to IDBKeyRange");var he=me.lower,ge=me.upper,be=me.lowerOpen,me=me.upperOpen;return he===void 0?ge===void 0?null:y.upperBound(ge,!!me):ge===void 0?y.lowerBound(he,!!be):y.bound(he,ge,!!be,!!me)}function D(Te){var he,ge=Te.name;return{name:ge,schema:Te,mutate:function(be){var me=be.trans,De=be.type,Ue=be.keys,Ve=be.values,$e=be.range;return new Promise(function(ut,yt){ut=qt(ut);var ht=me.objectStore(ge),ft=ht.keyPath==null,St=De==="put"||De==="add";if(!St&&De!=="delete"&&De!=="deleteRange")throw new Error("Invalid operation type: "+De);var gt,Mt=(Ue||Ve||{length:1}).length;if(Ue&&Ve&&Ue.length!==Ve.length)throw new Error("Given keys array must have same length as given values array.");if(Mt===0)return ut({numFailures:0,failures:{},results:[],lastResult:void 0});function jt(Xi){++lr,vs(Xi)}var $t=[],en=[],lr=0;if(De==="deleteRange"){if($e.type===4)return ut({numFailures:lr,failures:en,results:[],lastResult:void 0});$e.type===3?$t.push(gt=ht.clear()):$t.push(gt=ht.delete(R($e)))}else{var ft=St?ft?[Ve,Ue]:[Ve,null]:[Ue,null],Gt=ft[0],ki=ft[1];if(St)for(var _i=0;_i<Mt;++_i)$t.push(gt=ki&&ki[_i]!==void 0?ht[De](Gt[_i],ki[_i]):ht[De](Gt[_i])),gt.onerror=jt;else for(_i=0;_i<Mt;++_i)$t.push(gt=ht[De](Gt[_i])),gt.onerror=jt}function Jh(Xi){Xi=Xi.target.result,$t.forEach(function(lo,am){return lo.error!=null&&(en[am]=lo.error)}),ut({numFailures:lr,failures:en,results:De==="delete"?Ue:$t.map(function(lo){return lo.result}),lastResult:Xi})}gt.onerror=function(Xi){jt(Xi),Jh(Xi)},gt.onsuccess=Jh})},getMany:function(be){var me=be.trans,De=be.keys;return new Promise(function(Ue,Ve){Ue=qt(Ue);for(var $e,ut=me.objectStore(ge),yt=De.length,ht=new Array(yt),ft=0,St=0,gt=function($t){$t=$t.target,ht[$t._pos]=$t.result,++St===ft&&Ue(ht)},Mt=Ni(Ve),jt=0;jt<yt;++jt)De[jt]!=null&&(($e=ut.get(De[jt]))._pos=jt,$e.onsuccess=gt,$e.onerror=Mt,++ft);ft===0&&Ue(ht)})},get:function(be){var me=be.trans,De=be.key;return new Promise(function(Ue,Ve){Ue=qt(Ue);var $e=me.objectStore(ge).get(De);$e.onsuccess=function(ut){return Ue(ut.target.result)},$e.onerror=Ni(Ve)})},query:(he=fe,function(be){return new Promise(function(me,De){me=qt(me);var Ue,Ve,$e,ft=be.trans,ut=be.values,yt=be.limit,gt=be.query,ht=yt===1/0?void 0:yt,St=gt.index,gt=gt.range,ft=ft.objectStore(ge),St=St.isPrimaryKey?ft:ft.index(St.name),gt=R(gt);if(yt===0)return me({result:[]});he?((ht=ut?St.getAll(gt,ht):St.getAllKeys(gt,ht)).onsuccess=function(Mt){return me({result:Mt.target.result})},ht.onerror=Ni(De)):(Ue=0,Ve=!ut&&"openKeyCursor"in St?St.openKeyCursor(gt):St.openCursor(gt),$e=[],Ve.onsuccess=function(Mt){var jt=Ve.result;return jt?($e.push(ut?jt.value:jt.primaryKey),++Ue===yt?me({result:$e}):void jt.continue()):me({result:$e})},Ve.onerror=Ni(De))})}),openCursor:function(be){var me=be.trans,De=be.values,Ue=be.query,Ve=be.reverse,$e=be.unique;return new Promise(function(ut,yt){ut=qt(ut);var St=Ue.index,ht=Ue.range,ft=me.objectStore(ge),ft=St.isPrimaryKey?ft:ft.index(St.name),St=Ve?$e?"prevunique":"prev":$e?"nextunique":"next",gt=!De&&"openKeyCursor"in ft?ft.openKeyCursor(R(ht),St):ft.openCursor(R(ht),St);gt.onerror=Ni(yt),gt.onsuccess=qt(function(Mt){var jt,$t,en,lr,Gt=gt.result;Gt?(Gt.___id=++kh,Gt.done=!1,jt=Gt.continue.bind(Gt),$t=($t=Gt.continuePrimaryKey)&&$t.bind(Gt),en=Gt.advance.bind(Gt),lr=function(){throw new Error("Cursor not stopped")},Gt.trans=me,Gt.stop=Gt.continue=Gt.continuePrimaryKey=Gt.advance=function(){throw new Error("Cursor not started")},Gt.fail=qt(yt),Gt.next=function(){var ki=this,_i=1;return this.start(function(){return _i--?ki.continue():ki.stop()}).then(function(){return ki})},Gt.start=function(ki){function _i(){if(gt.result)try{ki()}catch(Xi){Gt.fail(Xi)}else Gt.done=!0,Gt.start=function(){throw new Error("Cursor behind last entry")},Gt.stop()}var Jh=new Promise(function(Xi,lo){Xi=qt(Xi),gt.onerror=Ni(lo),Gt.fail=lo,Gt.stop=function(am){Gt.stop=Gt.continue=Gt.continuePrimaryKey=Gt.advance=lr,Xi(am)}});return gt.onsuccess=qt(function(Xi){gt.onsuccess=_i,_i()}),Gt.continue=jt,Gt.continuePrimaryKey=$t,Gt.advance=en,_i(),Jh},ut(Gt)):ut(null)},yt)})},count:function(be){var me=be.query,De=be.trans,Ue=me.index,Ve=me.range;return new Promise(function($e,ut){var yt=De.objectStore(ge),ht=Ue.isPrimaryKey?yt:yt.index(Ue.name),yt=R(Ve),ht=yt?ht.count(yt):ht.count();ht.onsuccess=qt(function(ft){return $e(ft.target.result)}),ht.onerror=Ni(ut)})}}}var O,W,Z,ve=(W=ue,Z=Qc((O=p).objectStoreNames),{schema:{name:O.name,tables:Z.map(function(Te){return W.objectStore(Te)}).map(function(Te){var he=Te.keyPath,me=Te.autoIncrement,ge=o(he),be={},me={name:Te.name,primaryKey:{name:null,isPrimaryKey:!0,outbound:he==null,compound:ge,keyPath:he,autoIncrement:me,unique:!0,extractKey:Za(he)},indexes:Qc(Te.indexNames).map(function(De){return Te.index(De)}).map(function($e){var Ue=$e.name,Ve=$e.unique,ut=$e.multiEntry,$e=$e.keyPath,ut={name:Ue,compound:o($e),keyPath:$e,unique:Ve,multiEntry:ut,extractKey:Za($e)};return be[Or($e)]=ut}),getIndexByKeyPath:function(De){return be[Or(De)]}};return be[":id"]=me.primaryKey,he!=null&&(be[Or(he)]=me.primaryKey),me})},hasGetAll:0<Z.length&&"getAll"in W.objectStore(Z[0])&&!(typeof navigator<"u"&&/Safari/.test(navigator.userAgent)&&!/(Chrome\/|Edge\/)/.test(navigator.userAgent)&&[].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1]<604)}),ue=ve.schema,fe=ve.hasGetAll,ve=ue.tables.map(D),ie={};return ve.forEach(function(Te){return ie[Te.name]=Te}),{stack:"dbcore",transaction:p.transaction.bind(p),table:function(Te){if(!ie[Te])throw new Error("Table '".concat(Te,"' not found"));return ie[Te]},MIN_KEY:-1/0,MAX_KEY:ca(y),schema:ue}}function Jr(p,y,A,R){var D=A.IDBKeyRange;return A.indexedDB,{dbcore:(R=$a(y,D,R),p.dbcore.reduce(function(O,W){return W=W.create,n(n({},O),W(O))},R))}}function eo(p,R){var A=R.db,R=Jr(p._middlewares,A,p._deps,R);p.core=R.dbcore,p.tables.forEach(function(D){var O=D.name;p.core.schema.tables.some(function(W){return W.name===O})&&(D.core=p.core.table(O),p[O]instanceof p.Table&&(p[O].core=D.core))})}function ua(p,y,A,R){A.forEach(function(D){var O=R[D];y.forEach(function(W){var Z=function ue(fe,ve){return m(fe,ve)||(fe=c(fe))&&ue(fe,ve)}(W,D);(!Z||"value"in Z&&Z.value===void 0)&&(W===p.Transaction.prototype||W instanceof p.Transaction?v(W,D,{get:function(){return this.table(D)},set:function(ue){f(this,D,{value:ue,writable:!0,configurable:!0,enumerable:!0})}}):W[D]=new p.Table(D,O))})})}function to(p,y){y.forEach(function(A){for(var R in A)A[R]instanceof p.Table&&delete A[R]})}function no(p,y){return p._cfg.version-y._cfg.version}function _h(p,y,A,R){var D=p._dbSchema;A.objectStoreNames.contains("$meta")&&!D.$meta&&(D.$meta=al("$meta",Gh("")[0],[]),p._storeNames.push("$meta"));var O=p._createTransaction("readwrite",p._storeNames,D);O.create(A),O._completion.catch(R);var W=O._reject.bind(O),Z=Oe.transless||Oe;Nt(function(){return Oe.trans=O,Oe.transless=Z,y!==0?(eo(p,A),fe=y,((ue=O).storeNames.includes("$meta")?ue.table("$meta").get("version").then(function(ve){return ve??fe}):ae.resolve(fe)).then(function(ve){return Te=ve,he=O,ge=A,be=[],ve=(ie=p)._versions,me=ie._dbSchema=ws(0,ie.idbdb,ge),(ve=ve.filter(function(De){return De._cfg.version>=Te})).length!==0?(ve.forEach(function(De){be.push(function(){var Ue=me,Ve=De._cfg.dbschema;so(ie,Ue,ge),so(ie,Ve,ge),me=ie._dbSchema=Ve;var $e=ro(Ue,Ve);$e.add.forEach(function(St){Ei(ge,St[0],St[1].primKey,St[1].indexes)}),$e.change.forEach(function(St){if(St.recreate)throw new oe.Upgrade("Not yet support for changing primary key");var gt=ge.objectStore(St.name);St.add.forEach(function(Mt){return xs(gt,Mt)}),St.change.forEach(function(Mt){gt.deleteIndex(Mt.name),xs(gt,Mt)}),St.del.forEach(function(Mt){return gt.deleteIndex(Mt)})});var ut=De._cfg.contentUpgrade;if(ut&&De._cfg.version>Te){eo(ie,ge),he._memoizedTables={};var yt=M(Ve);$e.del.forEach(function(St){yt[St]=Ue[St]}),to(ie,[ie.Transaction.prototype]),ua(ie,[ie.Transaction.prototype],a(yt),yt),he.schema=yt;var ht,ft=H(ut);return ft&&I(),$e=ae.follow(function(){var St;(ht=ut(he))&&ft&&(St=N.bind(null,null),ht.then(St,St))}),ht&&typeof ht.then=="function"?ae.resolve(ht):$e.then(function(){return ht})}}),be.push(function(Ue){var Ve,$e,ut=De._cfg.dbschema;Ve=ut,$e=Ue,[].slice.call($e.db.objectStoreNames).forEach(function(yt){return Ve[yt]==null&&$e.db.deleteObjectStore(yt)}),to(ie,[ie.Transaction.prototype]),ua(ie,[ie.Transaction.prototype],ie._storeNames,ie._dbSchema),he.schema=ie._dbSchema}),be.push(function(Ue){ie.idbdb.objectStoreNames.contains("$meta")&&(Math.ceil(ie.idbdb.version/10)===De._cfg.version?(ie.idbdb.deleteObjectStore("$meta"),delete ie._dbSchema.$meta,ie._storeNames=ie._storeNames.filter(function(Ve){return Ve!=="$meta"})):Ue.objectStore("$meta").put(De._cfg.version,"version"))})}),function De(){return be.length?ae.resolve(be.shift()(he.idbtrans)).then(De):ae.resolve()}().then(function(){Vh(me,ge)})):ae.resolve();var ie,Te,he,ge,be,me}).catch(W)):(a(D).forEach(function(ve){Ei(A,ve,D[ve].primKey,D[ve].indexes)}),eo(p,A),void ae.follow(function(){return p.on.populate.fire(O)}).catch(W));var ue,fe})}function io(p,y){Vh(p._dbSchema,y),y.db.version%10!=0||y.objectStoreNames.contains("$meta")||y.db.createObjectStore("$meta").add(Math.ceil(y.db.version/10-1),"version");var A=ws(0,p.idbdb,y);so(p,p._dbSchema,y);for(var R=0,D=ro(A,p._dbSchema).change;R<D.length;R++){var O=function(W){if(W.change.length||W.recreate)return console.warn("Unable to patch indexes of table ".concat(W.name," because it has changes on the type of index or primary key.")),{value:void 0};var Z=y.objectStore(W.name);W.add.forEach(function(ue){Le&&console.debug("Dexie upgrade patch: Creating missing index ".concat(W.name,".").concat(ue.src)),xs(Z,ue)})}(D[R]);if(typeof O=="object")return O.value}}function ro(p,y){var A,R={del:[],add:[],change:[]};for(A in p)y[A]||R.del.push(A);for(A in y){var D=p[A],O=y[A];if(D){var W={name:A,def:O,recreate:!1,del:[],add:[],change:[]};if(""+(D.primKey.keyPath||"")!=""+(O.primKey.keyPath||"")||D.primKey.auto!==O.primKey.auto)W.recreate=!0,R.change.push(W);else{var Z=D.idxByName,ue=O.idxByName,fe=void 0;for(fe in Z)ue[fe]||W.del.push(fe);for(fe in ue){var ve=Z[fe],ie=ue[fe];ve?ve.src!==ie.src&&W.change.push(ie):W.add.push(ie)}(0<W.del.length||0<W.add.length||0<W.change.length)&&R.change.push(W)}}else R.add.push([A,O])}return R}function Ei(p,y,A,R){var D=p.db.createObjectStore(y,A.keyPath?{keyPath:A.keyPath,autoIncrement:A.auto}:{autoIncrement:A.auto});return R.forEach(function(O){return xs(D,O)}),D}function Vh(p,y){a(p).forEach(function(A){y.db.objectStoreNames.contains(A)||(Le&&console.debug("Dexie: Creating missing table",A),Ei(y,A,p[A].primKey,p[A].indexes))})}function xs(p,y){p.createIndex(y.name,y.keyPath,{unique:y.unique,multiEntry:y.multi})}function ws(p,y,A){var R={};return w(y.objectStoreNames,0).forEach(function(D){for(var O=A.objectStore(D),W=Qi(sl(fe=O.keyPath),fe||"",!0,!1,!!O.autoIncrement,fe&&typeof fe!="string",!0),Z=[],ue=0;ue<O.indexNames.length;++ue){var ve=O.index(O.indexNames[ue]),fe=ve.keyPath,ve=Qi(ve.name,fe,!!ve.unique,!!ve.multiEntry,!1,fe&&typeof fe!="string",!1);Z.push(ve)}R[D]=al(D,W,Z)}),R}function so(p,y,A){for(var R=A.db.objectStoreNames,D=0;D<R.length;++D){var O=R[D],W=A.objectStore(O);p._hasGetAll="getAll"in W;for(var Z=0;Z<W.indexNames.length;++Z){var ue=W.indexNames[Z],fe=W.index(ue).keyPath,ve=typeof fe=="string"?fe:"["+w(fe).join("+")+"]";!y[O]||(fe=y[O].idxByName[ve])&&(fe.name=ue,delete y[O].idxByName[ve],y[O].idxByName[ue]=fe)}}typeof navigator<"u"&&/Safari/.test(navigator.userAgent)&&!/(Chrome\/|Edge\/)/.test(navigator.userAgent)&&r.WorkerGlobalScope&&r instanceof r.WorkerGlobalScope&&[].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1]<604&&(p._hasGetAll=!1)}function Gh(p){return p.split(",").map(function(y,A){var R=(y=y.trim()).replace(/([&*]|\+\+)/g,""),D=/^\[/.test(R)?R.match(/^\[(.*)\]$/)[1].split("+"):R;return Qi(R,D||null,/\&/.test(y),/\*/.test(y),/\+\+/.test(y),o(D),A===0)})}var zi=(Fi.prototype._parseStoresSpec=function(p,y){a(p).forEach(function(A){if(p[A]!==null){var R=Gh(p[A]),D=R.shift();if(D.unique=!0,D.multi)throw new oe.Schema("Primary key cannot be multi-valued");R.forEach(function(O){if(O.auto)throw new oe.Schema("Only primary key can be marked as autoIncrement (++)");if(!O.keyPath)throw new oe.Schema("Index must have a name and cannot be an empty string")}),y[A]=al(A,D,R)}})},Fi.prototype.stores=function(A){var y=this.db;this._cfg.storesSource=this._cfg.storesSource?l(this._cfg.storesSource,A):A;var A=y._versions,R={},D={};return A.forEach(function(O){l(R,O._cfg.storesSource),D=O._cfg.dbschema={},O._parseStoresSpec(R,D)}),y._dbSchema=D,to(y,[y._allTables,y,y.Transaction.prototype]),ua(y,[y._allTables,y,y.Transaction.prototype,this._cfg.tables],a(D),D),y._storeNames=a(D),this},Fi.prototype.upgrade=function(p){return this._cfg.contentUpgrade=rt(this._cfg.contentUpgrade||X,p),this},Fi);function Fi(){}function Si(p,y){var A=p._dbNamesDB;return A||(A=p._dbNamesDB=new Ss(zt,{addons:[],indexedDB:p,IDBKeyRange:y})).version(1).stores({dbnames:"name"}),A.table("dbnames")}function yr(p){return p&&typeof p.databases=="function"}function ol(p){return Nt(function(){return Oe.letThrough=!0,p()})}function Jp(p){return!("from"in p)}var Ui=function(p,y){if(!this){var A=new Ui;return p&&"d"in p&&l(A,p),A}l(this,arguments.length?{d:1,from:p,to:1<arguments.length?y:p}:{d:0})};function Xc(p,y,A){var R=Rt(y,A);if(!isNaN(R)){if(0<R)throw RangeError();if(Jp(p))return l(p,{from:y,to:A,d:1});var D=p.l,R=p.r;if(Rt(A,p.from)<0)return D?Xc(D,y,A):p.l={from:y,to:A,d:1,l:null,r:null},F0(p);if(0<Rt(y,p.to))return R?Xc(R,y,A):p.r={from:y,to:A,d:1,l:null,r:null},F0(p);Rt(y,p.from)<0&&(p.from=y,p.l=null,p.d=R?R.d+1:1),0<Rt(A,p.to)&&(p.to=A,p.r=null,p.d=p.l?p.l.d+1:1),A=!p.r,D&&!p.l&&Jc(p,D),R&&A&&Jc(p,R)}}function Jc(p,y){Jp(y)||function A(R,ue){var O=ue.from,W=ue.to,Z=ue.l,ue=ue.r;Xc(R,O,W),Z&&A(R,Z),ue&&A(R,ue)}(p,y)}function z0(p,y){var A=Hh(y),R=A.next();if(R.done)return!1;for(var D=R.value,O=Hh(p),W=O.next(D.from),Z=W.value;!R.done&&!W.done;){if(Rt(Z.from,D.to)<=0&&0<=Rt(Z.to,D.from))return!0;Rt(D.from,Z.from)<0?D=(R=A.next(Z.from)).value:Z=(W=O.next(D.from)).value}return!1}function Hh(p){var y=Jp(p)?null:{s:0,n:p};return{next:function(A){for(var R=0<arguments.length;y;)switch(y.s){case 0:if(y.s=1,R)for(;y.n.l&&Rt(A,y.n.from)<0;)y={up:y,n:y.n.l,s:1};else for(;y.n.l;)y={up:y,n:y.n.l,s:1};case 1:if(y.s=2,!R||Rt(A,y.n.to)<=0)return{value:y.n,done:!1};case 2:if(y.n.r){y.s=3,y={up:y,n:y.n.r,s:0};continue}case 3:y=y.up}return{done:!0}}}}function F0(p){var y,A,R=(((y=p.r)===null||y===void 0?void 0:y.d)||0)-(((A=p.l)===null||A===void 0?void 0:A.d)||0),D=1<R?"r":R<-1?"l":"";D&&(y=D=="r"?"l":"r",A=n({},p),R=p[D],p.from=R.from,p.to=R.to,p[D]=R[D],A[D]=R[y],(p[y]=A).d=U0(A)),p.d=U0(p)}function U0(A){var y=A.r,A=A.l;return(y?A?Math.max(y.d,A.d):y.d:A?A.d:0)+1}function Wh(p,y){return a(y).forEach(function(A){p[A]?Jc(p[A],y[A]):p[A]=function R(D){var O,W,Z={};for(O in D)h(D,O)&&(W=D[O],Z[O]=!W||typeof W!="object"||V.has(W.constructor)?W:R(W));return Z}(y[A])}),p}function Kp(p,y){return p.all||y.all||Object.keys(p).some(function(A){return y[A]&&z0(y[A],p[A])})}d(Ui.prototype,((xr={add:function(p){return Jc(this,p),this},addKey:function(p){return Xc(this,p,p),this},addKeys:function(p){var y=this;return p.forEach(function(A){return Xc(y,A,A)}),this},hasKey:function(p){var y=Hh(this).next(p).value;return y&&Rt(y.from,p)<=0&&0<=Rt(y.to,p)}})[J]=function(){return Hh(this)},xr));var ao={},Yp={},Zp=!1;function qh(p){Wh(Yp,p),Zp||(Zp=!0,setTimeout(function(){Zp=!1,$p(Yp,!(Yp={}))},0))}function $p(p,y){y===void 0&&(y=!1);var A=new Set;if(p.all)for(var R=0,D=Object.values(ao);R<D.length;R++)k0(W=D[R],p,A,y);else for(var O in p){var W,Z=/^idb\:\/\/(.*)\/(.*)\//.exec(O);Z&&(O=Z[1],Z=Z[2],(W=ao["idb://".concat(O,"/").concat(Z)])&&k0(W,p,A,y))}A.forEach(function(ue){return ue()})}function k0(p,y,A,R){for(var D=[],O=0,W=Object.entries(p.queries.query);O<W.length;O++){for(var Z=W[O],ue=Z[0],fe=[],ve=0,ie=Z[1];ve<ie.length;ve++){var Te=ie[ve];Kp(y,Te.obsSet)?Te.subscribers.forEach(function(me){return A.add(me)}):R&&fe.push(Te)}R&&D.push([ue,fe])}if(R)for(var he=0,ge=D;he<ge.length;he++){var be=ge[he],ue=be[0],fe=be[1];p.queries.query[ue]=fe}}function UA(p){var y=p._state,A=p._deps.indexedDB;if(y.isBeingOpened||p.idbdb)return y.dbReadyPromise.then(function(){return y.dbOpenError?je(y.dbOpenError):p});y.isBeingOpened=!0,y.dbOpenError=null,y.openComplete=!1;var R=y.openCanceller,D=Math.round(10*p.verno),O=!1;function W(){if(y.openCanceller!==R)throw new oe.DatabaseClosed("db.open() was cancelled")}function Z(){return new ae(function(Te,he){if(W(),!A)throw new oe.MissingAPI;var ge=p.name,be=y.autoSchema||!D?A.open(ge):A.open(ge,D);if(!be)throw new oe.MissingAPI;be.onerror=Ni(he),be.onblocked=qt(p._fireOnBlocked),be.onupgradeneeded=qt(function(me){var De;ve=be.transaction,y.autoSchema&&!p._options.allowEmptyDB?(be.onerror=vs,ve.abort(),be.result.close(),(De=A.deleteDatabase(ge)).onsuccess=De.onerror=qt(function(){he(new oe.NoSuchDatabase("Database ".concat(ge," doesnt exist")))})):(ve.onerror=Ni(he),me=me.oldVersion>Math.pow(2,62)?0:me.oldVersion,ie=me<1,p.idbdb=be.result,O&&io(p,ve),_h(p,me/10,ve,he))},he),be.onsuccess=qt(function(){ve=null;var me,De,Ue,Ve,$e,ut=p.idbdb=be.result,yt=w(ut.objectStoreNames);if(0<yt.length)try{var ht=ut.transaction((Ve=yt).length===1?Ve[0]:Ve,"readonly");if(y.autoSchema)De=ut,Ue=ht,(me=p).verno=De.version/10,Ue=me._dbSchema=ws(0,De,Ue),me._storeNames=w(De.objectStoreNames,0),ua(me,[me._allTables],a(Ue),Ue);else if(so(p,p._dbSchema,ht),(($e=ro(ws(0,($e=p).idbdb,ht),$e._dbSchema)).add.length||$e.change.some(function(ft){return ft.add.length||ft.change.length}))&&!O)return console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this."),ut.close(),D=ut.version+1,O=!0,Te(Z());eo(p,ht)}catch{}Et.push(p),ut.onversionchange=qt(function(ft){y.vcFired=!0,p.on("versionchange").fire(ft)}),ut.onclose=qt(function(ft){p.on("close").fire(ft)}),ie&&($e=p._deps,ht=ge,ut=$e.indexedDB,$e=$e.IDBKeyRange,yr(ut)||ht===zt||Si(ut,$e).put({name:ht}).catch(X)),Te()},he)}).catch(function(Te){switch(Te==null?void 0:Te.name){case"UnknownError":if(0<y.PR1398_maxLoop)return y.PR1398_maxLoop--,console.warn("Dexie: Workaround for Chrome UnknownError on open()"),Z();break;case"VersionError":if(0<D)return D=0,Z()}return ae.reject(Te)})}var ue,fe=y.dbReadyResolve,ve=null,ie=!1;return ae.race([R,(typeof navigator>"u"?ae.resolve():!navigator.userAgentData&&/Safari\//.test(navigator.userAgent)&&!/Chrom(e|ium)\//.test(navigator.userAgent)&&indexedDB.databases?new Promise(function(Te){function he(){return indexedDB.databases().finally(Te)}ue=setInterval(he,100),he()}).finally(function(){return clearInterval(ue)}):Promise.resolve()).then(Z)]).then(function(){return W(),y.onReadyBeingFired=[],ae.resolve(ol(function(){return p.on.ready.fire(p.vip)})).then(function Te(){if(0<y.onReadyBeingFired.length){var he=y.onReadyBeingFired.reduce(rt,X);return y.onReadyBeingFired=[],ae.resolve(ol(function(){return he(p.vip)})).then(Te)}})}).finally(function(){y.openCanceller===R&&(y.onReadyBeingFired=null,y.isBeingOpened=!1)}).catch(function(Te){y.dbOpenError=Te;try{ve&&ve.abort()}catch{}return R===y.openCanceller&&p._close(),je(Te)}).finally(function(){y.openComplete=!0,fe()}).then(function(){var Te;return ie&&(Te={},p.tables.forEach(function(he){he.schema.indexes.forEach(function(ge){ge.name&&(Te["idb://".concat(p.name,"/").concat(he.name,"/").concat(ge.name)]=new Ui(-1/0,[[[]]]))}),Te["idb://".concat(p.name,"/").concat(he.name,"/")]=Te["idb://".concat(p.name,"/").concat(he.name,"/:dels")]=new Ui(-1/0,[[[]]])}),ar(ys).fire(Te),$p(Te,!0)),p})}function em(p){function y(O){return p.next(O)}var A=D(y),R=D(function(O){return p.throw(O)});function D(O){return function(ue){var Z=O(ue),ue=Z.value;return Z.done?ue:ue&&typeof ue.then=="function"?ue.then(A,R):o(ue)?Promise.all(ue).then(A,R):A(ue)}}return D(y)()}function jh(p,y,A){for(var R=o(p)?p.slice():[p],D=0;D<A;++D)R.push(y);return R}var kA={stack:"dbcore",name:"VirtualIndexMiddleware",level:1,create:function(p){return n(n({},p),{table:function(y){var A=p.table(y),R=A.schema,D={},O=[];function W(ie,Te,he){var ge=Or(ie),be=D[ge]=D[ge]||[],me=ie==null?0:typeof ie=="string"?1:ie.length,De=0<Te,De=n(n({},he),{name:De?"".concat(ge,"(virtual-from:").concat(he.name,")"):he.name,lowLevelIndex:he,isVirtual:De,keyTail:Te,keyLength:me,extractKey:Za(ie),unique:!De&&he.unique});return be.push(De),De.isPrimaryKey||O.push(De),1<me&&W(me===2?ie[0]:ie.slice(0,me-1),Te+1,he),be.sort(function(Ue,Ve){return Ue.keyTail-Ve.keyTail}),De}y=W(R.primaryKey.keyPath,0,R.primaryKey),D[":id"]=[y];for(var Z=0,ue=R.indexes;Z<ue.length;Z++){var fe=ue[Z];W(fe.keyPath,0,fe)}function ve(ie){var Te,he=ie.query.index;return he.isVirtual?n(n({},ie),{query:{index:he.lowLevelIndex,range:(Te=ie.query.range,he=he.keyTail,{type:Te.type===1?2:Te.type,lower:jh(Te.lower,Te.lowerOpen?p.MAX_KEY:p.MIN_KEY,he),lowerOpen:!0,upper:jh(Te.upper,Te.upperOpen?p.MIN_KEY:p.MAX_KEY,he),upperOpen:!0})}}):ie}return n(n({},A),{schema:n(n({},R),{primaryKey:y,indexes:O,getIndexByKeyPath:function(ie){return(ie=D[Or(ie)])&&ie[0]}}),count:function(ie){return A.count(ve(ie))},query:function(ie){return A.query(ve(ie))},openCursor:function(ie){var Te=ie.query.index,he=Te.keyTail,ge=Te.isVirtual,be=Te.keyLength;return ge?A.openCursor(ve(ie)).then(function(De){return De&&me(De)}):A.openCursor(ie);function me(De){return Object.create(De,{continue:{value:function(Ue){Ue!=null?De.continue(jh(Ue,ie.reverse?p.MAX_KEY:p.MIN_KEY,he)):ie.unique?De.continue(De.key.slice(0,be).concat(ie.reverse?p.MIN_KEY:p.MAX_KEY,he)):De.continue()}},continuePrimaryKey:{value:function(Ue,Ve){De.continuePrimaryKey(jh(Ue,p.MAX_KEY,he),Ve)}},primaryKey:{get:function(){return De.primaryKey}},key:{get:function(){var Ue=De.key;return be===1?Ue[0]:Ue.slice(0,be)}},value:{get:function(){return De.value}}})}}})}})}};function tm(p,y,A,R){return A=A||{},R=R||"",a(p).forEach(function(D){var O,W,Z;h(y,D)?(O=p[D],W=y[D],typeof O=="object"&&typeof W=="object"&&O&&W?(Z=K(O))!==K(W)?A[R+D]=y[D]:Z==="Object"?tm(O,W,A,R+D+"."):O!==W&&(A[R+D]=y[D]):O!==W&&(A[R+D]=y[D])):A[R+D]=void 0}),a(y).forEach(function(D){h(p,D)||(A[R+D]=y[D])}),A}function nm(p,y){return y.type==="delete"?y.keys:y.keys||y.values.map(p.extractKey)}var _A={stack:"dbcore",name:"HooksMiddleware",level:2,create:function(p){return n(n({},p),{table:function(y){var A=p.table(y),R=A.schema.primaryKey;return n(n({},A),{mutate:function(D){var O=Oe.trans,W=O.table(y).hook,Z=W.deleting,ue=W.creating,fe=W.updating;switch(D.type){case"add":if(ue.fire===X)break;return O._promise("readwrite",function(){return ve(D)},!0);case"put":if(ue.fire===X&&fe.fire===X)break;return O._promise("readwrite",function(){return ve(D)},!0);case"delete":if(Z.fire===X)break;return O._promise("readwrite",function(){return ve(D)},!0);case"deleteRange":if(Z.fire===X)break;return O._promise("readwrite",function(){return function ie(Te,he,ge){return A.query({trans:Te,values:!1,query:{index:R,range:he},limit:ge}).then(function(be){var me=be.result;return ve({type:"delete",keys:me,trans:Te}).then(function(De){return 0<De.numFailures?Promise.reject(De.failures[0]):me.length<ge?{failures:[],numFailures:0,lastResult:void 0}:ie(Te,n(n({},he),{lower:me[me.length-1],lowerOpen:!0}),ge)})})}(D.trans,D.range,1e4)},!0)}return A.mutate(D);function ve(ie){var Te,he,ge,be=Oe.trans,me=ie.keys||nm(R,ie);if(!me)throw new Error("Keys missing");return(ie=ie.type==="add"||ie.type==="put"?n(n({},ie),{keys:me}):n({},ie)).type!=="delete"&&(ie.values=i([],ie.values)),ie.keys&&(ie.keys=i([],ie.keys)),Te=A,ge=me,((he=ie).type==="add"?Promise.resolve([]):Te.getMany({trans:he.trans,keys:ge,cache:"immutable"})).then(function(De){var Ue=me.map(function(Ve,$e){var ut,yt,ht,ft=De[$e],St={onerror:null,onsuccess:null};return ie.type==="delete"?Z.fire.call(St,Ve,ft,be):ie.type==="add"||ft===void 0?(ut=ue.fire.call(St,Ve,ie.values[$e],be),Ve==null&&ut!=null&&(ie.keys[$e]=Ve=ut,R.outbound||P(ie.values[$e],R.keyPath,Ve))):(ut=tm(ft,ie.values[$e]),(yt=fe.fire.call(St,ut,Ve,ft,be))&&(ht=ie.values[$e],Object.keys(yt).forEach(function(gt){h(ht,gt)?ht[gt]=yt[gt]:P(ht,gt,yt[gt])}))),St});return A.mutate(ie).then(function(Ve){for(var $e=Ve.failures,ut=Ve.results,yt=Ve.numFailures,Ve=Ve.lastResult,ht=0;ht<me.length;++ht){var ft=(ut||me)[ht],St=Ue[ht];ft==null?St.onerror&&St.onerror($e[ht]):St.onsuccess&&St.onsuccess(ie.type==="put"&&De[ht]?ie.values[ht]:ft)}return{failures:$e,results:ut,numFailures:yt,lastResult:Ve}}).catch(function(Ve){return Ue.forEach(function($e){return $e.onerror&&$e.onerror(Ve)}),Promise.reject(Ve)})})}}})}})}};function _0(p,y,A){try{if(!y||y.keys.length<p.length)return null;for(var R=[],D=0,O=0;D<y.keys.length&&O<p.length;++D)Rt(y.keys[D],p[O])===0&&(R.push(A?j(y.values[D]):y.values[D]),++O);return R.length===p.length?R:null}catch{return null}}var VA={stack:"dbcore",level:-1,create:function(p){return{table:function(y){var A=p.table(y);return n(n({},A),{getMany:function(R){if(!R.cache)return A.getMany(R);var D=_0(R.keys,R.trans._cache,R.cache==="clone");return D?ae.resolve(D):A.getMany(R).then(function(O){return R.trans._cache={keys:R.keys,values:R.cache==="clone"?j(O):O},O})},mutate:function(R){return R.type!=="add"&&(R.trans._cache=null),A.mutate(R)}})}}}};function V0(p,y){return p.trans.mode==="readonly"&&!!p.subscr&&!p.trans.explicit&&p.trans.db._options.cache!=="disabled"&&!y.schema.primaryKey.outbound}function G0(p,y){switch(p){case"query":return y.values&&!y.unique;case"get":case"getMany":case"count":case"openCursor":return!1}}var GA={stack:"dbcore",level:0,name:"Observability",create:function(p){var y=p.schema.name,A=new Ui(p.MIN_KEY,p.MAX_KEY);return n(n({},p),{transaction:function(R,D,O){if(Oe.subscr&&D!=="readonly")throw new oe.ReadOnly("Readwrite transaction in liveQuery context. Querier source: ".concat(Oe.querier));return p.transaction(R,D,O)},table:function(R){var D=p.table(R),O=D.schema,W=O.primaryKey,ie=O.indexes,Z=W.extractKey,ue=W.outbound,fe=W.autoIncrement&&ie.filter(function(he){return he.compound&&he.keyPath.includes(W.keyPath)}),ve=n(n({},D),{mutate:function(he){function ge(gt){return gt="idb://".concat(y,"/").concat(R,"/").concat(gt),Ve[gt]||(Ve[gt]=new Ui)}var be,me,De,Ue=he.trans,Ve=he.mutatedParts||(he.mutatedParts={}),$e=ge(""),ut=ge(":dels"),yt=he.type,St=he.type==="deleteRange"?[he.range]:he.type==="delete"?[he.keys]:he.values.length<50?[nm(W,he).filter(function(gt){return gt}),he.values]:[],ht=St[0],ft=St[1],St=he.trans._cache;return o(ht)?($e.addKeys(ht),(St=yt==="delete"||ht.length===ft.length?_0(ht,St):null)||ut.addKeys(ht),(St||ft)&&(be=ge,me=St,De=ft,O.indexes.forEach(function(gt){var Mt=be(gt.name||"");function jt(en){return en!=null?gt.extractKey(en):null}function $t(en){return gt.multiEntry&&o(en)?en.forEach(function(lr){return Mt.addKey(lr)}):Mt.addKey(en)}(me||De).forEach(function(en,ki){var Gt=me&&jt(me[ki]),ki=De&&jt(De[ki]);Rt(Gt,ki)!==0&&(Gt!=null&&$t(Gt),ki!=null&&$t(ki))})}))):ht?(ft={from:(ft=ht.lower)!==null&&ft!==void 0?ft:p.MIN_KEY,to:(ft=ht.upper)!==null&&ft!==void 0?ft:p.MAX_KEY},ut.add(ft),$e.add(ft)):($e.add(A),ut.add(A),O.indexes.forEach(function(gt){return ge(gt.name).add(A)})),D.mutate(he).then(function(gt){return!ht||he.type!=="add"&&he.type!=="put"||($e.addKeys(gt.results),fe&&fe.forEach(function(Mt){for(var jt=he.values.map(function(Gt){return Mt.extractKey(Gt)}),$t=Mt.keyPath.findIndex(function(Gt){return Gt===W.keyPath}),en=0,lr=gt.results.length;en<lr;++en)jt[en][$t]=gt.results[en];ge(Mt.name).addKeys(jt)})),Ue.mutatedParts=Wh(Ue.mutatedParts||{},Ve),gt})}}),ie=function(ge){var be=ge.query,ge=be.index,be=be.range;return[ge,new Ui((ge=be.lower)!==null&&ge!==void 0?ge:p.MIN_KEY,(be=be.upper)!==null&&be!==void 0?be:p.MAX_KEY)]},Te={get:function(he){return[W,new Ui(he.key)]},getMany:function(he){return[W,new Ui().addKeys(he.keys)]},count:ie,query:ie,openCursor:ie};return a(Te).forEach(function(he){ve[he]=function(ge){var be=Oe.subscr,me=!!be,De=V0(Oe,D)&&G0(he,ge)?ge.obsSet={}:be;if(me){var Ue=function(ft){return ft="idb://".concat(y,"/").concat(R,"/").concat(ft),De[ft]||(De[ft]=new Ui)},Ve=Ue(""),$e=Ue(":dels"),be=Te[he](ge),me=be[0],be=be[1];if((he==="query"&&me.isPrimaryKey&&!ge.values?$e:Ue(me.name||"")).add(be),!me.isPrimaryKey){if(he!=="count"){var ut=he==="query"&&ue&&ge.values&&D.query(n(n({},ge),{values:!1}));return D[he].apply(this,arguments).then(function(ft){if(he==="query"){if(ue&&ge.values)return ut.then(function(jt){return jt=jt.result,Ve.addKeys(jt),ft});var St=ge.values?ft.result.map(Z):ft.result;(ge.values?Ve:$e).addKeys(St)}else if(he==="openCursor"){var gt=ft,Mt=ge.values;return gt&&Object.create(gt,{key:{get:function(){return $e.addKey(gt.primaryKey),gt.key}},primaryKey:{get:function(){var jt=gt.primaryKey;return $e.addKey(jt),jt}},value:{get:function(){return Mt&&Ve.addKey(gt.primaryKey),gt.value}}})}return ft})}$e.add(A)}}return D[he].apply(this,arguments)}}),ve}})}};function H0(p,y,A){if(A.numFailures===0)return y;if(y.type==="deleteRange")return null;var R=y.keys?y.keys.length:"values"in y&&y.values?y.values.length:1;return A.numFailures===R?null:(y=n({},y),o(y.keys)&&(y.keys=y.keys.filter(function(D,O){return!(O in A.failures)})),"values"in y&&o(y.values)&&(y.values=y.values.filter(function(D,O){return!(O in A.failures)})),y)}function im(p,y){return A=p,((R=y).lower===void 0||(R.lowerOpen?0<Rt(A,R.lower):0<=Rt(A,R.lower)))&&(p=p,(y=y).upper===void 0||(y.upperOpen?Rt(p,y.upper)<0:Rt(p,y.upper)<=0));var A,R}function W0(p,y,Te,R,D,O){if(!Te||Te.length===0)return p;var W=y.query.index,Z=W.multiEntry,ue=y.query.range,fe=R.schema.primaryKey.extractKey,ve=W.extractKey,ie=(W.lowLevelIndex||W).extractKey,Te=Te.reduce(function(he,ge){var be=he,me=[];if(ge.type==="add"||ge.type==="put")for(var De=new Ui,Ue=ge.values.length-1;0<=Ue;--Ue){var Ve,$e=ge.values[Ue],ut=fe($e);De.hasKey(ut)||(Ve=ve($e),(Z&&o(Ve)?Ve.some(function(gt){return im(gt,ue)}):im(Ve,ue))&&(De.addKey(ut),me.push($e)))}switch(ge.type){case"add":var yt=new Ui().addKeys(y.values?he.map(function(Mt){return fe(Mt)}):he),be=he.concat(y.values?me.filter(function(Mt){return Mt=fe(Mt),!yt.hasKey(Mt)&&(yt.addKey(Mt),!0)}):me.map(function(Mt){return fe(Mt)}).filter(function(Mt){return!yt.hasKey(Mt)&&(yt.addKey(Mt),!0)}));break;case"put":var ht=new Ui().addKeys(ge.values.map(function(Mt){return fe(Mt)}));be=he.filter(function(Mt){return!ht.hasKey(y.values?fe(Mt):Mt)}).concat(y.values?me:me.map(function(Mt){return fe(Mt)}));break;case"delete":var ft=new Ui().addKeys(ge.keys);be=he.filter(function(Mt){return!ft.hasKey(y.values?fe(Mt):Mt)});break;case"deleteRange":var St=ge.range;be=he.filter(function(Mt){return!im(fe(Mt),St)})}return be},p);return Te===p?p:(Te.sort(function(he,ge){return Rt(ie(he),ie(ge))||Rt(fe(he),fe(ge))}),y.limit&&y.limit<1/0&&(Te.length>y.limit?Te.length=y.limit:p.length===y.limit&&Te.length<y.limit&&(D.dirty=!0)),O?Object.freeze(Te):Te)}function q0(p,y){return Rt(p.lower,y.lower)===0&&Rt(p.upper,y.upper)===0&&!!p.lowerOpen==!!y.lowerOpen&&!!p.upperOpen==!!y.upperOpen}function HA(p,y){return function(A,R,D,O){if(A===void 0)return R!==void 0?-1:0;if(R===void 0)return 1;if((R=Rt(A,R))===0){if(D&&O)return 0;if(D)return 1;if(O)return-1}return R}(p.lower,y.lower,p.lowerOpen,y.lowerOpen)<=0&&0<=function(A,R,D,O){if(A===void 0)return R!==void 0?1:0;if(R===void 0)return-1;if((R=Rt(A,R))===0){if(D&&O)return 0;if(D)return-1;if(O)return 1}return R}(p.upper,y.upper,p.upperOpen,y.upperOpen)}function WA(p,y,A,R){p.subscribers.add(A),R.addEventListener("abort",function(){var D,O;p.subscribers.delete(A),p.subscribers.size===0&&(D=p,O=y,setTimeout(function(){D.subscribers.size===0&&le(O,D)},3e3))})}var qA={stack:"dbcore",level:0,name:"Cache",create:function(p){var y=p.schema.name;return n(n({},p),{transaction:function(A,R,D){var O,W,Z=p.transaction(A,R,D);return R==="readwrite"&&(W=(O=new AbortController).signal,D=function(ue){return function(){if(O.abort(),R==="readwrite"){for(var fe=new Set,ve=0,ie=A;ve<ie.length;ve++){var Te=ie[ve],he=ao["idb://".concat(y,"/").concat(Te)];if(he){var ge=p.table(Te),be=he.optimisticOps.filter(function(Mt){return Mt.trans===Z});if(Z._explicit&&ue&&Z.mutatedParts)for(var me=0,De=Object.values(he.queries.query);me<De.length;me++)for(var Ue=0,Ve=(yt=De[me]).slice();Ue<Ve.length;Ue++)Kp((ht=Ve[Ue]).obsSet,Z.mutatedParts)&&(le(yt,ht),ht.subscribers.forEach(function(Mt){return fe.add(Mt)}));else if(0<be.length){he.optimisticOps=he.optimisticOps.filter(function(Mt){return Mt.trans!==Z});for(var $e=0,ut=Object.values(he.queries.query);$e<ut.length;$e++)for(var yt,ht,ft,St=0,gt=(yt=ut[$e]).slice();St<gt.length;St++)(ht=gt[St]).res!=null&&Z.mutatedParts&&(ue&&!ht.dirty?(ft=Object.isFrozen(ht.res),ft=W0(ht.res,ht.req,be,ge,ht,ft),ht.dirty?(le(yt,ht),ht.subscribers.forEach(function(Mt){return fe.add(Mt)})):ft!==ht.res&&(ht.res=ft,ht.promise=ae.resolve({result:ft}))):(ht.dirty&&le(yt,ht),ht.subscribers.forEach(function(Mt){return fe.add(Mt)})))}}}fe.forEach(function(Mt){return Mt()})}}},Z.addEventListener("abort",D(!1),{signal:W}),Z.addEventListener("error",D(!1),{signal:W}),Z.addEventListener("complete",D(!0),{signal:W})),Z},table:function(A){var R=p.table(A),D=R.schema.primaryKey;return n(n({},R),{mutate:function(O){var W=Oe.trans;if(D.outbound||W.db._options.cache==="disabled"||W.explicit||W.idbtrans.mode!=="readwrite")return R.mutate(O);var Z=ao["idb://".concat(y,"/").concat(A)];return Z?(W=R.mutate(O),O.type!=="add"&&O.type!=="put"||!(50<=O.values.length||nm(D,O).some(function(ue){return ue==null}))?(Z.optimisticOps.push(O),O.mutatedParts&&qh(O.mutatedParts),W.then(function(ue){0<ue.numFailures&&(le(Z.optimisticOps,O),(ue=H0(0,O,ue))&&Z.optimisticOps.push(ue),O.mutatedParts&&qh(O.mutatedParts))}),W.catch(function(){le(Z.optimisticOps,O),O.mutatedParts&&qh(O.mutatedParts)})):W.then(function(ue){var fe=H0(0,n(n({},O),{values:O.values.map(function(ve,ie){var Te;return ue.failures[ie]?ve:(ve=(Te=D.keyPath)!==null&&Te!==void 0&&Te.includes(".")?j(ve):n({},ve),P(ve,D.keyPath,ue.results[ie]),ve)})}),ue);Z.optimisticOps.push(fe),queueMicrotask(function(){return O.mutatedParts&&qh(O.mutatedParts)})}),W):R.mutate(O)},query:function(O){if(!V0(Oe,R)||!G0("query",O))return R.query(O);var W=((fe=Oe.trans)===null||fe===void 0?void 0:fe.db._options.cache)==="immutable",ie=Oe,Z=ie.requery,ue=ie.signal,fe=function(ge,be,me,De){var Ue=ao["idb://".concat(ge,"/").concat(be)];if(!Ue)return[];if(!(be=Ue.queries[me]))return[null,!1,Ue,null];var Ve=be[(De.query?De.query.index.name:null)||""];if(!Ve)return[null,!1,Ue,null];switch(me){case"query":var $e=Ve.find(function(ut){return ut.req.limit===De.limit&&ut.req.values===De.values&&q0(ut.req.query.range,De.query.range)});return $e?[$e,!0,Ue,Ve]:[Ve.find(function(ut){return("limit"in ut.req?ut.req.limit:1/0)>=De.limit&&(!De.values||ut.req.values)&&HA(ut.req.query.range,De.query.range)}),!1,Ue,Ve];case"count":return $e=Ve.find(function(ut){return q0(ut.req.query.range,De.query.range)}),[$e,!!$e,Ue,Ve]}}(y,A,"query",O),ve=fe[0],ie=fe[1],Te=fe[2],he=fe[3];return ve&&ie?ve.obsSet=O.obsSet:(ie=R.query(O).then(function(ge){var be=ge.result;if(ve&&(ve.res=be),W){for(var me=0,De=be.length;me<De;++me)Object.freeze(be[me]);Object.freeze(be)}else ge.result=j(be);return ge}).catch(function(ge){return he&&ve&&le(he,ve),Promise.reject(ge)}),ve={obsSet:O.obsSet,promise:ie,subscribers:new Set,type:"query",req:O,dirty:!1},he?he.push(ve):(he=[ve],(Te=Te||(ao["idb://".concat(y,"/").concat(A)]={queries:{query:{},count:{}},objs:new Map,optimisticOps:[],unsignaledParts:{}})).queries.query[O.query.index.name||""]=he)),WA(ve,he,Z,ue),ve.promise.then(function(ge){return{result:W0(ge.result,O,Te==null?void 0:Te.optimisticOps,R,ve,W)}})}})}})}};function Qh(p,y){return new Proxy(p,{get:function(A,R,D){return R==="db"?y:Reflect.get(A,R,D)}})}var Ss=(qn.prototype.version=function(p){if(isNaN(p)||p<.1)throw new oe.Type("Given version is not a positive number");if(p=Math.round(10*p)/10,this.idbdb||this._state.isBeingOpened)throw new oe.Schema("Cannot add version when database is open");this.verno=Math.max(this.verno,p);var y=this._versions,A=y.filter(function(R){return R._cfg.version===p})[0];return A||(A=new this.Version(p),y.push(A),y.sort(no),A.stores({}),this._state.autoSchema=!1,A)},qn.prototype._whenReady=function(p){var y=this;return this.idbdb&&(this._state.openComplete||Oe.letThrough||this._vip)?p():new ae(function(A,R){if(y._state.openComplete)return R(new oe.DatabaseClosed(y._state.dbOpenError));if(!y._state.isBeingOpened){if(!y._state.autoOpen)return void R(new oe.DatabaseClosed);y.open().catch(X)}y._state.dbReadyPromise.then(A,R)}).then(p)},qn.prototype.use=function(p){var y=p.stack,A=p.create,R=p.level,D=p.name;return D&&this.unuse({stack:y,name:D}),p=this._middlewares[y]||(this._middlewares[y]=[]),p.push({stack:y,create:A,level:R??10,name:D}),p.sort(function(O,W){return O.level-W.level}),this},qn.prototype.unuse=function(p){var y=p.stack,A=p.name,R=p.create;return y&&this._middlewares[y]&&(this._middlewares[y]=this._middlewares[y].filter(function(D){return R?D.create!==R:!!A&&D.name!==A})),this},qn.prototype.open=function(){var p=this;return it(Fe,function(){return UA(p)})},qn.prototype._close=function(){var p=this._state,y=Et.indexOf(this);if(0<=y&&Et.splice(y,1),this.idbdb){try{this.idbdb.close()}catch{}this.idbdb=null}p.isBeingOpened||(p.dbReadyPromise=new ae(function(A){p.dbReadyResolve=A}),p.openCanceller=new ae(function(A,R){p.cancelOpen=R}))},qn.prototype.close=function(A){var y=(A===void 0?{disableAutoOpen:!0}:A).disableAutoOpen,A=this._state;y?(A.isBeingOpened&&A.cancelOpen(new oe.DatabaseClosed),this._close(),A.autoOpen=!1,A.dbOpenError=new oe.DatabaseClosed):(this._close(),A.autoOpen=this._options.autoOpen||A.isBeingOpened,A.openComplete=!1,A.dbOpenError=null)},qn.prototype.delete=function(p){var y=this;p===void 0&&(p={disableAutoOpen:!0});var A=0<arguments.length&&typeof arguments[0]!="object",R=this._state;return new ae(function(D,O){function W(){y.close(p);var Z=y._deps.indexedDB.deleteDatabase(y.name);Z.onsuccess=qt(function(){var ue,fe,ve;ue=y._deps,fe=y.name,ve=ue.indexedDB,ue=ue.IDBKeyRange,yr(ve)||fe===zt||Si(ve,ue).delete(fe).catch(X),D()}),Z.onerror=Ni(O),Z.onblocked=y._fireOnBlocked}if(A)throw new oe.InvalidArgument("Invalid closeOptions argument to db.delete()");R.isBeingOpened?R.dbReadyPromise.then(W):W()})},qn.prototype.backendDB=function(){return this.idbdb},qn.prototype.isOpen=function(){return this.idbdb!==null},qn.prototype.hasBeenClosed=function(){var p=this._state.dbOpenError;return p&&p.name==="DatabaseClosed"},qn.prototype.hasFailed=function(){return this._state.dbOpenError!==null},qn.prototype.dynamicallyOpened=function(){return this._state.autoSchema},Object.defineProperty(qn.prototype,"tables",{get:function(){var p=this;return a(this._allTables).map(function(y){return p._allTables[y]})},enumerable:!1,configurable:!0}),qn.prototype.transaction=function(){var p=(function(y,A,R){var D=arguments.length;if(D<2)throw new oe.InvalidArgument("Too few arguments");for(var O=new Array(D-1);--D;)O[D-1]=arguments[D];return R=O.pop(),[y,z(O),R]}).apply(this,arguments);return this._transaction.apply(this,p)},qn.prototype._transaction=function(p,y,A){var R=this,D=Oe.trans;D&&D.db===this&&p.indexOf("!")===-1||(D=null);var O,W,Z=p.indexOf("?")!==-1;p=p.replace("!","").replace("?","");try{if(W=y.map(function(fe){if(fe=fe instanceof R.Table?fe.name:fe,typeof fe!="string")throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");return fe}),p=="r"||p===At)O=At;else{if(p!="rw"&&p!=Pt)throw new oe.InvalidArgument("Invalid transaction mode: "+p);O=Pt}if(D){if(D.mode===At&&O===Pt){if(!Z)throw new oe.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");D=null}D&&W.forEach(function(fe){if(D&&D.storeNames.indexOf(fe)===-1){if(!Z)throw new oe.SubTransaction("Table "+fe+" not included in parent transaction.");D=null}}),Z&&D&&!D.active&&(D=null)}}catch(fe){return D?D._promise(null,function(ve,ie){ie(fe)}):je(fe)}var ue=(function fe(ve,ie,Te,he,ge){return ae.resolve().then(function(){var be=Oe.transless||Oe,me=ve._createTransaction(ie,Te,ve._dbSchema,he);if(me.explicit=!0,be={trans:me,transless:be},he)me.idbtrans=he.idbtrans;else try{me.create(),me.idbtrans._explicit=!0,ve._state.PR1398_maxLoop=3}catch(Ve){return Ve.name===Ie.InvalidState&&ve.isOpen()&&0<--ve._state.PR1398_maxLoop?(console.warn("Dexie: Need to reopen db"),ve.close({disableAutoOpen:!1}),ve.open().then(function(){return fe(ve,ie,Te,null,ge)})):je(Ve)}var De,Ue=H(ge);return Ue&&I(),be=ae.follow(function(){var Ve;(De=ge.call(me,me))&&(Ue?(Ve=N.bind(null,null),De.then(Ve,Ve)):typeof De.next=="function"&&typeof De.throw=="function"&&(De=em(De)))},be),(De&&typeof De.then=="function"?ae.resolve(De).then(function(Ve){return me.active?Ve:je(new oe.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"))}):be.then(function(){return De})).then(function(Ve){return he&&me._resolve(),me._completion.then(function(){return Ve})}).catch(function(Ve){return me._reject(Ve),je(Ve)})})}).bind(null,this,O,W,D,A);return D?D._promise(O,ue,"lock"):Oe.trans?it(Oe.transless,function(){return R._whenReady(ue)}):this._whenReady(ue)},qn.prototype.table=function(p){if(!h(this._allTables,p))throw new oe.InvalidTable("Table ".concat(p," does not exist"));return this._allTables[p]},qn);function qn(p,y){var A=this;this._middlewares={},this.verno=0;var R=qn.dependencies;this._options=y=n({addons:qn.addons,autoOpen:!0,indexedDB:R.indexedDB,IDBKeyRange:R.IDBKeyRange,cache:"cloned"},y),this._deps={indexedDB:y.indexedDB,IDBKeyRange:y.IDBKeyRange},R=y.addons,this._dbSchema={},this._versions=[],this._storeNames=[],this._allTables={},this.idbdb=null,this._novip=this;var D,O,W,Z,ue,fe={dbOpenError:null,isBeingOpened:!1,onReadyBeingFired:null,openComplete:!1,dbReadyResolve:X,dbReadyPromise:null,cancelOpen:X,openCanceller:null,autoSchema:!0,PR1398_maxLoop:3,autoOpen:y.autoOpen};fe.dbReadyPromise=new ae(function(ie){fe.dbReadyResolve=ie}),fe.openCanceller=new ae(function(ie,Te){fe.cancelOpen=Te}),this._state=fe,this.name=p,this.on=Kt(this,"populate","blocked","versionchange","close",{ready:[rt,X]}),this.on.ready.subscribe=S(this.on.ready.subscribe,function(ie){return function(Te,he){qn.vip(function(){var ge,be=A._state;be.openComplete?(be.dbOpenError||ae.resolve().then(Te),he&&ie(Te)):be.onReadyBeingFired?(be.onReadyBeingFired.push(Te),he&&ie(Te)):(ie(Te),ge=A,he||ie(function me(){ge.on.ready.unsubscribe(Te),ge.on.ready.unsubscribe(me)}))})}}),this.Collection=(D=this,Yt(nl.prototype,function(De,me){this.db=D;var he=rn,ge=null;if(me)try{he=me()}catch(Ue){ge=Ue}var be=De._ctx,me=be.table,De=me.hook.reading.fire;this._ctx={table:me,index:be.index,isPrimKey:!be.index||me.schema.primKey.keyPath&&be.index===me.schema.primKey.name,range:he,keysOnly:!1,dir:"next",unique:"",algorithm:null,filter:null,replayFilter:null,justLimit:!0,isMatch:null,offset:0,limit:1/0,error:ge,or:be.or,valueMapper:De!==Se?De:null}})),this.Table=(O=this,Yt(xi.prototype,function(ie,Te,he){this.db=O,this._tx=he,this.name=ie,this.schema=Te,this.hook=O._allTables[ie]?O._allTables[ie].hook:Kt(null,{creating:[Ke,X],reading:[qe,Se],updating:[He,X],deleting:[pt,X]})})),this.Transaction=(W=this,Yt(jc.prototype,function(ie,Te,he,ge,be){var me=this;this.db=W,this.mode=ie,this.storeNames=Te,this.schema=he,this.chromeTransactionDurability=ge,this.idbtrans=null,this.on=Kt(this,"complete","error","abort"),this.parent=be||null,this.active=!0,this._reculock=0,this._blockedFuncs=[],this._resolve=null,this._reject=null,this._waitingFor=null,this._waitingQueue=null,this._spinCount=0,this._completion=new ae(function(De,Ue){me._resolve=De,me._reject=Ue}),this._completion.then(function(){me.active=!1,me.on.complete.fire()},function(De){var Ue=me.active;return me.active=!1,me.on.error.fire(De),me.parent?me.parent._reject(De):Ue&&me.idbtrans&&me.idbtrans.abort(),je(De)})})),this.Version=(Z=this,Yt(zi.prototype,function(ie){this.db=Z,this._cfg={version:ie,storesSource:null,dbschema:{},tables:{},contentUpgrade:null}})),this.WhereClause=(ue=this,Yt(la.prototype,function(ie,Te,he){if(this.db=ue,this._ctx={table:ie,index:Te===":id"?null:Te,or:he},this._cmp=this._ascending=Rt,this._descending=function(ge,be){return Rt(be,ge)},this._max=function(ge,be){return 0<Rt(ge,be)?ge:be},this._min=function(ge,be){return Rt(ge,be)<0?ge:be},this._IDBKeyRange=ue._deps.IDBKeyRange,!this._IDBKeyRange)throw new oe.MissingAPI})),this.on("versionchange",function(ie){0<ie.newVersion?console.warn("Another connection wants to upgrade database '".concat(A.name,"'. Closing db now to resume the upgrade.")):console.warn("Another connection wants to delete database '".concat(A.name,"'. Closing db now to resume the delete request.")),A.close({disableAutoOpen:!1})}),this.on("blocked",function(ie){!ie.newVersion||ie.newVersion<ie.oldVersion?console.warn("Dexie.delete('".concat(A.name,"') was blocked")):console.warn("Upgrade '".concat(A.name,"' blocked by other connection holding version ").concat(ie.oldVersion/10))}),this._maxKey=ca(y.IDBKeyRange),this._createTransaction=function(ie,Te,he,ge){return new A.Transaction(ie,Te,he,A._options.chromeTransactionDurability,ge)},this._fireOnBlocked=function(ie){A.on("blocked").fire(ie),Et.filter(function(Te){return Te.name===A.name&&Te!==A&&!Te._state.vcFired}).map(function(Te){return Te.on("versionchange").fire(ie)})},this.use(VA),this.use(qA),this.use(GA),this.use(kA),this.use(_A);var ve=new Proxy(this,{get:function(ie,Te,he){if(Te==="_vip")return!0;if(Te==="table")return function(be){return Qh(A.table(be),ve)};var ge=Reflect.get(ie,Te,he);return ge instanceof xi?Qh(ge,ve):Te==="tables"?ge.map(function(be){return Qh(be,ve)}):Te==="_createTransaction"?function(){return Qh(ge.apply(this,arguments),ve)}:ge}});this.vip=ve,R.forEach(function(ie){return ie(A)})}var Xh,xr=typeof Symbol<"u"&&"observable"in Symbol?Symbol.observable:"@@observable",jA=(rm.prototype.subscribe=function(p,y,A){return this._subscribe(p&&typeof p!="function"?p:{next:p,error:y,complete:A})},rm.prototype[xr]=function(){return this},rm);function rm(p){this._subscribe=p}try{Xh={indexedDB:r.indexedDB||r.mozIndexedDB||r.webkitIndexedDB||r.msIndexedDB,IDBKeyRange:r.IDBKeyRange||r.webkitIDBKeyRange}}catch{Xh={indexedDB:null,IDBKeyRange:null}}function j0(p){var y,A=!1,R=new jA(function(D){var O=H(p),W,Z=!1,ue={},fe={},ve={get closed(){return Z},unsubscribe:function(){Z||(Z=!0,W&&W.abort(),ie&&ar.storagemutated.unsubscribe(he))}};D.start&&D.start(ve);var ie=!1,Te=function(){return lt(ge)},he=function(be){Wh(ue,be),Kp(fe,ue)&&Te()},ge=function(){var be,me,De;!Z&&Xh.indexedDB&&(ue={},be={},W&&W.abort(),W=new AbortController,De=function(Ue){var Ve=yi();try{O&&I();var $e=Nt(p,Ue);return $e=O?$e.finally(N):$e}finally{Ve&&dn()}}(me={subscr:be,signal:W.signal,requery:Te,querier:p,trans:null}),Promise.resolve(De).then(function(Ue){A=!0,y=Ue,Z||me.signal.aborted||(ue={},function(Ve){for(var $e in Ve)if(h(Ve,$e))return;return 1}(fe=be)||ie||(ar(ys,he),ie=!0),lt(function(){return!Z&&D.next&&D.next(Ue)}))},function(Ue){A=!1,["DatabaseClosedError","AbortError"].includes(Ue==null?void 0:Ue.name)||Z||lt(function(){Z||D.error&&D.error(Ue)})}))};return setTimeout(Te,0),ve});return R.hasValue=function(){return A},R.getValue=function(){return y},R}var oo=Ss;function sm(p){var y=ha;try{ha=!0,ar.storagemutated.fire(p),$p(p,!0)}finally{ha=y}}d(oo,n(n({},ke),{delete:function(p){return new oo(p,{addons:[]}).delete()},exists:function(p){return new oo(p,{addons:[]}).open().then(function(y){return y.close(),!0}).catch("NoSuchDatabaseError",function(){return!1})},getDatabaseNames:function(p){try{return y=oo.dependencies,A=y.indexedDB,y=y.IDBKeyRange,(yr(A)?Promise.resolve(A.databases()).then(function(R){return R.map(function(D){return D.name}).filter(function(D){return D!==zt})}):Si(A,y).toCollection().primaryKeys()).then(p)}catch{return je(new oe.MissingAPI)}var y,A},defineClass:function(){return function(p){l(this,p)}},ignoreTransaction:function(p){return Oe.trans?it(Oe.transless,p):p()},vip:ol,async:function(p){return function(){try{var y=em(p.apply(this,arguments));return y&&typeof y.then=="function"?y:ae.resolve(y)}catch(A){return je(A)}}},spawn:function(p,y,A){try{var R=em(p.apply(A,y||[]));return R&&typeof R.then=="function"?R:ae.resolve(R)}catch(D){return je(D)}},currentTransaction:{get:function(){return Oe.trans||null}},waitFor:function(p,y){return y=ae.resolve(typeof p=="function"?oo.ignoreTransaction(p):p).timeout(y||6e4),Oe.trans?Oe.trans.waitFor(y):y},Promise:ae,debug:{get:function(){return Le},set:function(p){k(p)}},derive:g,extend:l,props:d,override:S,Events:Kt,on:ar,liveQuery:j0,extendObservabilitySet:Wh,getByKeyPath:C,setByKeyPath:P,delByKeyPath:function(p,y){typeof y=="string"?P(p,y,void 0):"length"in y&&[].map.call(y,function(A){P(p,A,void 0)})},shallowClone:M,deepClone:j,getObjectDiff:tm,cmp:Rt,asap:E,minKey:-1/0,addons:[],connections:Et,errnames:Ie,dependencies:Xh,cache:ao,semVer:"4.0.11",version:"4.0.11".split(".").map(function(p){return parseInt(p)}).reduce(function(p,y,A){return p+y/Math.pow(10,2*A)})})),oo.maxKey=ca(oo.dependencies.IDBKeyRange),typeof dispatchEvent<"u"&&typeof addEventListener<"u"&&(ar(ys,function(p){ha||(p=new CustomEvent(rl,{detail:p}),ha=!0,dispatchEvent(p),ha=!1)}),addEventListener(rl,function(p){p=p.detail,ha||sm(p)}));var ll,ha=!1,Q0=function(){};return typeof BroadcastChannel<"u"&&((Q0=function(){(ll=new BroadcastChannel(rl)).onmessage=function(p){return p.data&&sm(p.data)}})(),typeof ll.unref=="function"&&ll.unref(),ar(ys,function(p){ha||ll.postMessage(p)})),typeof addEventListener<"u"&&(addEventListener("pagehide",function(p){if(!Ss.disableBfCache&&p.persisted){Le&&console.debug("Dexie: handling persisted pagehide"),ll!=null&&ll.close();for(var y=0,A=Et;y<A.length;y++)A[y].close({disableAutoOpen:!1})}}),addEventListener("pageshow",function(p){!Ss.disableBfCache&&p.persisted&&(Le&&console.debug("Dexie: handling persisted pageshow"),Q0(),sm({all:new Ui(-1/0,[[]])}))})),ae.rejectionMapper=function(p,y){return!p||p instanceof ce||p instanceof TypeError||p instanceof SyntaxError||!p.name||!ye[p.name]?p:(y=new ye[p.name](y||p.message,p),"stack"in p&&v(y,"stack",{get:function(){return this.inner.stack}}),y)},k(Le),n(Ss,Object.freeze({__proto__:null,Dexie:Ss,liveQuery:j0,Entity:yn,cmp:Rt,PropModification:oa,replacePrefix:function(p,y){return new oa({replacePrefix:[p,y]})},add:function(p){return new oa({add:p})},remove:function(p){return new oa({remove:p})},default:Ss,RangeSet:Ui,mergeRanges:Jc,rangesOverlap:z0}),{default:Ss}),Ss})}(Mf)),Mf.exports}var gN=mN();const vv=v0(gN),Hw=Symbol.for("Dexie"),mp=globalThis[Hw]||(globalThis[Hw]=vv);if(vv.semVer!==mp.semVer)throw new Error(`Two different versions of Dexie loaded in the same app: ${vv.semVer} and ${mp.semVer}`);const{liveQuery:Nz,mergeRanges:zz,rangesOverlap:Fz,RangeSet:Uz,cmp:kz,Entity:_z,PropModification:Vz,replacePrefix:Gz,add:Hz,remove:Wz}=mp;var Tp;const Ep=class Ep extends mp{constructor(t){super(Ge(Ep,Tp),t);Mn(this,"objects");this.version(1).stores({objects:"baseId, item"})}};Tp=new WeakMap,Lt(Ep,Tp,"speckle-cache");let yv=Ep;var Pa,Mp,Pi,Do,jr,aA,pu,oA;class vN{constructor(e){Lt(this,jr);Lt(this,Pa);Lt(this,Mp);Lt(this,Pi);Lt(this,Do);Ut(this,Pa,e),Ut(this,Mp,e.logger||(()=>{}))}async getAll(e){await ri(this,jr,pu).call(this);let t=[];return await Ge(this,Pi).transaction("r",Ge(this,Pi).objects,async()=>{const n=e.map(r=>Ge(this,Pi).objects.get(r));t=await Promise.all(n)}),t}async add(e){await ri(this,jr,pu).call(this),await Ge(this,Pi).transaction("rw",Ge(this,Pi).objects,async()=>{var t;return await((t=Ge(this,Pi))==null?void 0:t.objects.add(e))})}async getItem(e){const{id:t}=e;if(await ri(this,jr,pu).call(this),Ge(this,Do)){const n=Ge(this,Do).get(t);if(n)return n}return Ge(this,Pi).transaction("r",Ge(this,Pi).objects,async()=>{var n;return await((n=Ge(this,Pi))==null?void 0:n.objects.get(t))})}async cacheSaveBatch(e){await ri(this,jr,pu).call(this);const{batch:t}=e;await Ge(this,Pi).objects.bulkPut(t)}async disposeAsync(){var e,t;(e=Ge(this,Pi))==null||e.close(),Ut(this,Pi,void 0),await((t=Ge(this,Do))==null?void 0:t.disposeAsync()),Ut(this,Do,void 0)}}Pa=new WeakMap,Mp=new WeakMap,Pi=new WeakMap,Do=new WeakMap,jr=new WeakSet,aA=async function(){const e=new yv({indexedDB:Ge(this,Pa).indexedDB??globalThis.indexedDB,IDBKeyRange:Ge(this,Pa).keyRange??IDBKeyRange,chromeTransactionDurability:"relaxed"});return await e.open(),e},pu=async function(){Ge(this,Pi)===void 0&&(await ri(this,jr,oA).call(this),Ut(this,Pi,await ri(this,jr,aA).call(this)))},oA=async function(){var t;if(!QO()||!((t=Ge(this,Pa).indexedDB)!=null&&t.databases))return Promise.resolve();let e;return new Promise(n=>{const i=()=>{var r;return(r=Ge(this,Pa).indexedDB)==null?void 0:r.databases().finally(n)};e=setInterval(()=>{i()},100),i()}).finally(()=>clearInterval(e))};var cc,uc,uh;class yN{constructor(e,t){Lt(this,cc);Lt(this,uc);Lt(this,uh);Ut(this,uc,e),Ut(this,cc,t)}initializePool(e){Ut(this,uh,e.results)}downloadSingle(){const e=Ge(this,cc).get(Ge(this,uc));if(e)return Promise.resolve({baseId:Ge(this,uc),base:e});throw new Error("Method not implemented.")}disposeAsync(){return Promise.resolve()}add(e){var n;const t=Ge(this,cc).get(e);if(t){(n=Ge(this,uh))==null||n.add({baseId:e,base:t});return}throw new Error("Method not implemented.")}}cc=new WeakMap,uc=new WeakMap,uh=new WeakMap;var Da,hh,dh,fh,ph,mh,Xa,lA,cA,uA;class xN{constructor(e){Lt(this,Xa);Lt(this,Da,[]);Lt(this,hh);Lt(this,dh);Lt(this,fh);Lt(this,ph);Lt(this,mh,!1);Ut(this,hh,e.concurrencyAndSizes),Ut(this,fh,Math.min(e.maxWaitTime??200,200)),Ut(this,dh,e.processFunction),Ut(this,ph,ri(this,Xa,cA).call(this))}add(e){Ge(this,Da).push(e)}getBatch(e){return Ge(this,Da).splice(0,Math.min(e,Ge(this,Da).length))}async disposeAsync(){Ut(this,mh,!0),await Ge(this,ph)}}Da=new WeakMap,hh=new WeakMap,dh=new WeakMap,fh=new WeakMap,ph=new WeakMap,mh=new WeakMap,Xa=new WeakSet,lA=async function(e){for(;!Ge(this,mh)||Ge(this,Da).length>0;){if(Ge(this,Da).length>0){const t=this.getBatch(e);await Ge(this,dh).call(this,t)}await ri(this,Xa,uA).call(this,Ge(this,fh))}},cA=async function(){const e=Array.from(Ge(this,hh),t=>ri(this,Xa,lA).call(this,t));await Promise.all(e)},uA=function(e){return new Promise(t=>setTimeout(t,e))};class hA extends Error{constructor(e){e||(e=new.target.defaultMessage),super(e)}}Mn(hA,"defaultMessage","Unexpected error occurred");class mu extends hA{}Mn(mu,"defaultMessage","Object loader encountered a runtime problem!");function wN(s){return s!==null&&typeof s=="object"&&"id"in s&&typeof s.id=="string"}function SN(s,e){const t=[];for(let n=0;n<e;n++){const i=s.next();if(i.done)break;t.push(i.value)}return t}var gh,vh,Vs,Ar,hc,yh,Lo,dc,Br,dA,fA,xv,wv;class bN{constructor(e){Lt(this,Br);Lt(this,gh);Lt(this,vh);Lt(this,Vs);Lt(this,Ar);Lt(this,hc);Lt(this,yh);Lt(this,Lo);Lt(this,dc,new TextDecoder);if(Ut(this,Ar,e),Ut(this,hc,e.fetch??((...t)=>globalThis.fetch(...t))),Ut(this,Vs,{}),e.headers)for(const t of e.headers.entries())Ge(this,Vs)[t[0]]=t[1];Ge(this,Vs).Accept="text/plain",Ge(this,Ar).token&&(Ge(this,Vs).Authorization=`Bearer ${Ge(this,Ar).token}`),Ut(this,vh,`${Ge(this,Ar).serverUrl}/api/getobjects/${Ge(this,Ar).streamId}`),Ut(this,gh,`${Ge(this,Ar).serverUrl}/objects/${Ge(this,Ar).streamId}/${Ge(this,Ar).objectId}/single`)}initializePool(e){const{results:t,total:n}=e;Ut(this,yh,t),Ut(this,Lo,new xN({concurrencyAndSizes:ri(this,Br,dA).call(this,n),maxWaitTime:e.maxDownloadBatchWait,processFunction:i=>this.downloadBatch({batch:i,url:Ge(this,vh),headers:Ge(this,Vs)})}))}add(e){ri(this,Br,fA).call(this).add(e)}async disposeAsync(){var e;await((e=Ge(this,Lo))==null?void 0:e.disposeAsync())}async downloadBatch(e){const{batch:t,url:n,headers:i}=e,r=new Set(t),a=await Ge(this,hc).call(this,n,{method:"POST",headers:{...i,"Content-Type":"application/json"},body:JSON.stringify({objects:JSON.stringify(t)})});if(ri(this,Br,wv).call(this,a),!a.body)throw new Error("ReadableStream not supported or response has no body.");const o=a.body.getReader();let l=new Uint8Array(0),c=0;for(;;){const{done:u,value:h}=await o.read();if(u)break;l=await this.processArray(l,h,r,async()=>{c++,c%1e3===0&&await new Promise(d=>setTimeout(d,100))})}if(r.size>0)throw new Error("Items requested were not downloaded: "+SN(r.values(),10).join(","))}async processArray(e,t,n,i){var o;const r=this.concatUint8Arrays(e,t);let a=0;for(let l=0;l<r.length;l++)if(r[l]===10){const c=r.subarray(a,l),u=this.processLine(c);(o=Ge(this,yh))==null||o.add(u),a=l+1,await i(),n.delete(u.baseId)}return r.subarray(a)}processLine(e){for(let t=0;t<e.length;t++)if(e[t]===9){const n=Ge(this,dc).decode(e.subarray(0,t)),i=e.subarray(t+1),r=Ge(this,dc).decode(i),a=ri(this,Br,xv).call(this,n,r);return a.size=i.length,a}throw new mu("Invalid line format: "+Ge(this,dc).decode(e))}concatUint8Arrays(e,t){const n=new Uint8Array(e.length+t.length);return n.set(e,0),n.set(t,e.length),n}async downloadSingle(){const e=await Ge(this,hc).call(this,Ge(this,gh),{headers:Ge(this,Vs)});ri(this,Br,wv).call(this,e);const t=await e.text(),n=ri(this,Br,xv).call(this,Ge(this,Ar).objectId,t);return n.size=0,n}}gh=new WeakMap,vh=new WeakMap,Vs=new WeakMap,Ar=new WeakMap,hc=new WeakMap,yh=new WeakMap,Lo=new WeakMap,dc=new WeakMap,Br=new WeakSet,dA=function(e){return e<=50?[e]:[1e4,3e4,1e4,1e3]},fA=function(){if(Ge(this,Lo))return Ge(this,Lo);throw new Error("Download pool is not initialized")},xv=function(e,t){let n;try{n=JSON.parse(t)}catch(i){throw new Error(`Error parsing object ${e}: ${i.message}`)}if(wN(n))return{baseId:e,base:n};throw new mu(`${e} is not a base`)},wv=function(e){if(!e.ok)throw[401,403].includes(e.status)?new mu("You do not have access!"):new mu(`Failed to fetch objects: ${e.status} ${e.statusText})`)};class Sv{static createFromObjects(e){const t=e[0],n=new Map;return e.forEach(r=>{n.set(r.id,r)}),new Ww({rootId:t.id,database:new oN({items:n}),downloader:new yN(t.id,n)})}static createFromJSON(e){const t=JSON.parse(e);return this.createFromObjects(t)}static createFromUrl(e){return new Ww({rootId:e.objectId,downloader:new bN({serverUrl:e.serverUrl,streamId:e.streamId,objectId:e.objectId,token:e.token,headers:e.headers}),database:new vN({logger:e.logger,indexedDB:e.indexedDB,keyRange:e.keyRange})})}}var xh,Bo,Oo,La,No,fc,zo,pc,Ba;class Ww{constructor(e){Lt(this,xh);Lt(this,Bo);Lt(this,Oo);Lt(this,La);Lt(this,No);Lt(this,fc);Lt(this,zo);Lt(this,pc);Lt(this,Ba);Ut(this,xh,e.rootId),Ut(this,Bo,e.logger||console.log);const t={logger:Ge(this,Bo),maxCacheReadSize:1e4,maxCacheWriteSize:1e4,maxWriteQueueSize:4e4,maxCacheBatchWriteWait:3e3,maxCacheBatchReadWait:3e3};Ut(this,pc,new lN),Ut(this,Oo,e.database),Ut(this,zo,new cN({maxSizeInMb:2e3,ttlms:5e3,logger:Ge(this,Bo)})),Ut(this,fc,new hN(Ge(this,Oo),Ge(this,zo),t)),Ut(this,No,new dN(Ge(this,Oo),Ge(this,pc),Ge(this,zo),t)),Ut(this,La,e.downloader)}async disposeAsync(){await Promise.all([Ge(this,La).disposeAsync(),Ge(this,fc).disposeAsync()]),Ge(this,zo).dispose()}async getRootObject(){return Ge(this,Ba)||(Ut(this,Ba,await Ge(this,Oo).getItem({id:Ge(this,xh)})),Ge(this,Ba)||Ut(this,Ba,await Ge(this,La).downloadSingle())),Ge(this,Ba)}async getObject(e){return await Ge(this,fc).getObject({id:e.id})}async getTotalObjectCount(){const e=await this.getRootObject();return Object.keys((e==null?void 0:e.base.__closure)||{}).length+1}async*getObjectIterator(){const e=await this.getRootObject();if(e===void 0){Ge(this,Bo).call(this,"No root object found!");return}if(Ge(this,No).add(e),yield e.base,!e.base.__closure)return;const t=Object.keys(e.base.__closure),n=t.length;Ge(this,La).initializePool({results:new fN(Ge(this,pc),Ge(this,No)),total:n});for await(const i of Ge(this,No).gather(t,Ge(this,La)))yield i.base}static createFromObjects(e){return Sv.createFromObjects(e)}static createFromJSON(e){return Sv.createFromJSON(e)}}xh=new WeakMap,Bo=new WeakMap,Oo=new WeakMap,La=new WeakMap,No=new WeakMap,fc=new WeakMap,zo=new WeakMap,pc=new WeakMap,Ba=new WeakMap;class Nh{constructor(){this._events={}}on(e,t){this._events[e]||(this._events[e]=[]),this._events[e].push(t)}removeListener(e,t){this._events[e]&&(this._events[e]=this._events[e].filter(n=>n!==t))}emit(e,...t){this._events[e]&&this._events[e].forEach(n=>{n(...t)})}dispose(){this._events=null}}var Na;(function(s){s.TEXTURE_8BPP="png",s.TEXTURE_HDR="hdr",s.TEXTURE_EXR="exr",s.FONT_JSON="font-json"})(Na||(Na={}));const pA={showStats:!1,verbose:!1,environmentSrc:{id:"defaultHDRI",src:"data:image/png;base64,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Q+OARAQ8PARAS8OARAP8OASAQ8OAQAO8P8R8N8O8P/ATgEgEvDwEQEPDgEQEfDgEQEvDgEQD/D/EPDgEgEfDwEQEvDvEvD/EPDvEPDgEgEfDgEQEPDwEgDwEgDvEPEAEgEfDwEgD/DwEAEPDgEgEfDwEfjvEfEvD/DvEfDwEQEvDvEfEAEgEPDQEgD/DwEvjwEQD/DwEQD/DvEPEAEQEfD/D/DwEQEfDvEPEAEQEfDwEQEAEgEfEPDwEgD/EAEgEPD/D/D/wE4BAA8BIBH5IBABEBDxDxLw8BIA/xABIBHw8BIBDw/xDw8BIBHw8BEBHw8BL4/xLw4BIBDw/xHw/xLw4BD47xDw8BIBHw/xLw8BEBDw4BABDw8BIBLw8BEBHxIBH47xHw/xDw4BIBABIBDxDw4BEA/w8BIBDw8BIBHw8BIBIBIA7xDw8BIBHxABIA/w8BEBLw/xHxDxHw8BIBHxIBL4/xHxDxHxABIBHxHxLw4BIBDw8BEBLw/xDw/xHw/xLxABIBLw/xDxEBD5DxD5IBHxIBIBDxEBL48BIBHw/8BQASAR8R8Q8PASAS8Q8Q8Q8R8S8R8PASAQ8QASAS8Q8S/AUPDwEgEPEQEgEvEAEgEPEQEvkPEfDwEgEfEQEgEvEvEvEAEgEPEAEAEQEQEAEgEQEQEAEQEgEgEAEgEAEkjgEAEQEQDwEAEPDwEgDwEkjgDwDwEPEgEQEADwDwEvEPwFABABLxIBEBDxHxLxEBAA8BIBABIBHxABL48BEBIBIBABEBDxEBIBIBEBDxIBFJEA8BDxABABHw8BIBEBEA8BABHw8BAA4BIBEBABLw4BIBABEBABIBIBEA8BIBABIBEBABABIBABEBEBABABIBHxABEBABIBEBLxIA8BEBLxEBEBLxDxHw8BIBHxABL5EBABLxDxEBIBDxEBHxHxEBABLxEBIBEBHxIBDxEBABIBHxEBLxIBEBEBIBLxEBIBIBABIBHxH8BR/A0QEfEvEQEvEQEvEfEPEQEgEAEQEQEgEvEgEfwFIBABIBHxEBH5H5IBHxIBH8HR8RASAR8Q8QAQAS8Q8RASAQARAQASASARARARASARASASAS8S8RASAR8S8S8QASAR8PARAQ8RAS8SAS/AUgEfUkgEgEgEgEgEgEgEgEfEvEgEfEvEvkvEfwFIBD8BSAQAQ+Q/AUgEgEvEkkvkvEvEfEvEPkgEQEgEgEgEPwFIBIBHxEBIBLxIBIBDxEBIBIBLxH8DSAR8S/AUvkfwlIBABIBL5EBL5LxLxDxL8FS/A0gEvwFD5IBIBLxL8DSASAS8RARAS8QARAS+SASAS+SARAS/AUgEgEPEkgEkkkgEkgEfUvEUke0kUkUkku0QEUkvkfUgEQEu0gEkAEkfwBHxEBIBFIBJJIBJJJFIBL1LtIBFJFL1IBEBIBIBHxJFEBFFHxFJLtLtJIBH8BR7SS8SSS7SS7SASAR+SAR7SQSS+R/AEe0Ue0gEvEkfEkUkUkgEgEvEe0Uu0vwBL1JLtLtL8CSS9SS/AEO0kkkgEkkkgEkvUku0vwFLtJLtHtLxJL8DSQASS/A0u0QEku0kvwZL8BS9SAS7RRRSQASASASSSSSARSASASSR7SAQRSS8SARSS/AEfwBJHtJIBJJJJJL1LtJJL1JFIBJL1LtJL1IBJIBIBJJL8AS/AUUu0gEfwFJJIBJL5L5JJLxJEBL1LxHtLxJJL8AS8R8S/AEkke0kfwBJLxL1JJJLxLxLtLtLxL5H8FS/AUkvEvwBHtIBL5LxL8BSASS7SSS9S/BEvwNHxJL1IBL8BRS9SAR+S+S8S/CEgEvEgEvwNJJL1L1L8BS9S/AUvEvwJL8AS7R8RAS7SSR9S/EkvEvkvwBIBIBL8ES7S/AUvUvxRLtLtLxL8DS9SAS8S/A0vUfEkvEvEku0vwBL8AS9S7SASSARS/AEfkku0vwJIBJJL5IBJFL5L8CSSAS/CEvwFJL1JL8ESSSS+S/AEu0u0vwZL8HSASAS/AUu0gEvxFHxL1LtIBL8MS/DEvwZH1L8AS/AEvwBL8AS/CUvwdL8DS9S/AkvyxLtIBABL8JS9R/AEvEQEvkgEu0vkvwBIBH8BS/E0u0ku0gEkgEvEQEfw9JLtL8CSS/DUQEvwhH8JS/EEu0vwFL85S/BEv1JL8ES7S/GUvxJL8fS/DkvxVL8cS8S/AEvwlIBL8HSS/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////9OE////////6h////0N////QT/5J/+R//k3/5F/eSv3kf95P/eRv3kv95I/eTv3kT85L/OSPzk785H/OS/zkn85P/ORvzkz85J/OT/zkj85M/OSvzlD85G/GTPxkn8ZP/GSPxkz8ZK/GUvxkj8ZN/GSvxlH8ZJ/GTfxkv8ZQ/GR/xk38ZK/GUPxkn8ZN/GS/xk/8ZJ/GTfxkv85K/GTvxkv8ZS/GSPwk38JL/CUPwkr8JO/CTPwlH8JJ/CTfwkv8JS/CSvwk78JM/GSPwk38JL/GSvwk78JM/CUvwkr8JO/CS/xkv8JO/CTPwlL8JJ/CTvwkz8JS/CS/wk78JM/GSvwk78JM/GS/wk/8JN/GSvwk/8JM/GS/wk/8JN/CUvwkr8JP/CTPxkz8JQ/CTfxkn8BP/ATPwFL8BL/AT/wE38BS/ASvwE/8BN/CTPwE/8BN/AUvwEr8BO/ATfwkz8BP/ATfwkv8BP/ATPwkz8BP/ATfwkr8BQ/ATfwkz8BO/ATvwFL8BL/AT/wE38JM/AUPwE/8JL/AT/wE38BS/ATPwE/8BO/CS/wFD8BN/CTPwFD8BO/CSvwE/8BN/CTPwE/8BN/AUvwEz8BP/ATfwk38BR/ATvwkv8BQ/ATfwkz8BQ/ATvwkz8BS/ATvwk38BP/ATvwFL8BL/AUfwE78JM/AUfwE/8JM/AUPwE78JN/AUPwE78JL/AUfwE78JN/AUPwE78JM/AUfwE78JN/AUPwE78JM8R8O8S8M8S8Q8S8M8P8O8S8O8S8P/ATPEvDvwE3xDw/8BM8Q8O/ATvEfD/wEvxDw78BN8R8P/ATfD/DvwE3xDxD8BM8R8O/ATfEvDvwE3w/w78BO8P8P/ATPEPDvEvDfEPD/wE38BP8S8O8S8Q/ATPEvDvwE3xDw/8BN8S8P/ATvEvEPwEzxHw78BO8R8Q/ATfEPDvwE78BQ8S8M8S8P/ATvwE/8BN8Q8P/ATvEPEfEvDPEfD/wE78BQ/ATfEvD/EvDvEPEfwEzxLw/8BO8S8Q/ATvEvD/wE7xLxD8BM8S8O/AT/EfEPwE3xLxD8BP/AUfwE7xHxD8BQ8S8P/ATfwE/8BP8S8Q/ATfEvEPwE78BP/ATvwFD8BP/AUfwE3xLw/8BO8R8P/ATvEvD/wE/xHxD8BN8R8P/ATvwFH8BN/AT/EvDvEvEfwE78BQ/ATvEfEPwE78BP/AT/EvEPwE4BAA/w8BEA/w4BABDw8BIBLw0BABHw8BIBLw4BIBDw/xDw4BIBDw8BL44BABHw7w/w4BIBABIA/xDw4BIA/w8BABLw4BIBDw4BIBHw7xDw8BEBLw0BIBHw8BEA/w/xDxD8BOARAQ8PASAQ8P8Q8PARAP8OAS+P8R8PASAP8P8S8OAQAQ8OAS+PASAQ8P/ATgEgEPDvEvDwEQEPEAEQD/D/EPDwEvjgEgEfDwEfjwEgEvEAEgEvEPEvEAEgEvDgEgEfEfEvDgEgEfEfEfD/EvEPEvDwEgEPDwEQEfDvD/D/EvD/EPD/EfDgEQD/DwEgEvDvEvEAEgEvD/wE/xLw8BIA/xABIBLw/w/xDxHw/xL5IBDw4BIBD8BS8PASAQ8R8S8P8Q8QARAQ8QASAS8P8R8OARAS8QASAS8P8S8S8S8PARAQ8P/AUgEgEPEAEQEvD/EfEAEgEfD/EvD/EfDvEvEPEfEPEfwFLw4BEBHxDxLxHxHxDxHw/xLxD8BPASAS8QASAS8P8R8Q8S8P/BUvEQEQEvEfwFHxLxHxLw8BL5EBIBLw/xLxL8BP8Q8QAS+PASAR8R8Q8R8S8RAS+QASAQ8QASAQ8Q/AUfwFLxHxABH4/xHw8BL4/xEBIBDxIBIA/8BPAS+PAQAQ8OASARASAPASAQ8QAQAS8P8R8QARAQ8SAQASASAR+SAQASAQ8RAQAQASAQAQAQ8RARAS8R+SAQARAQASAPAQ8RAPAQAS8PAQASASAQASASASAS+RAQ8SASASASAR8SARASASASASASARAQ8SAQAQ+RAPASAQASAQARAQ8RARAS8QAQ8RAS8R8SAR+RASAS8P8QARASARAQASASASAS8SAR8SARAP8RASASAQ8SAQARASAQAQASARAPARARASAS/AUAEQEfEPEvEQEgEQEgEQEfkfkvEQEfkgEvwFHxEA/xEBABL5L8BR+SASARAR/DT/EvwFLxL8BSASASAQAP/A0QEfEQEgEfEvwFEBEBLxLxLxIBIBLxEBH8BQAR8R8Q/AUfkPkgEgEQEvkvD/EPEAEPEgEgEgEQEvkvwNHxIBHxEBLxIBABIBL5IBL8DSARAS+R8Q+SAS8S/AUvwFD8HSAR/AUvkfEvEfwVIBD8FS8RAS+S8S8S8SAS8SAS/AUgEQEvwNH8DS8S+Q8SASAR+S8SASAR+RAR+SAS8S8R8S8S8S8S/AUvEvEvwNEBIBIBH8BS8R+SAS8S8QS8Q9SAS8SS8Q7S7RS/AEgEvwBIBIBIBIBIBL5JEBHtIBIBJLxIBJLxJJL8ESRR8S/BEgEkfUvEAEu0fwRIBL8AQ+S7R7S7SASASS7SS/AEvkgEgEgEkvUe0u0fkgEUvEvwdIBJIBJJJL8AS9SSAR8S+S8S9SAS9SARS+SASSARS7S9S8S7SASS/AUkfwZLtIBJLxL8AS7S7SS/AkvwpL8CSASAS/AUvEvwVIBLxIBJLxJLxIBH8CS8S8S7S8S9S/AEfwpEBIBJH8GS/AEgEu0kvUvEvUfkvEvEvwRL8DS9S7R/EUvwJL1LtL8BS7S/B0kUUgEkvwJIBFIBLtH8BS8S/AEvwZL8ESASS9S/AkvEUvw1JL8CS/AkvEku0u0vwBEBLtIBL5L8JSAS/BEkUvwJL8BS9S/CUkQEvwJLtIBL8BS+S+S/AUu0kkvUu0kvwNIBIBIBL8AS7S/Dku0vkvEku0vwxLxEBFIBL8AS/AkvEgEvUgEkgEkvEvwNLtL1IBLtL8DS9SSASAS+S/B0u0u0vkvwVL8BSS8S/OEvwZLtL8RR9S/Ikvx1L9AS/WkvwBL8QS/E0u0vzBL1L86S/EUvzZL80S/UUvwhL92S/Gkvw9L9HS/BUvy1L8ES+S/DUvwJLtLxL8KS/TkvwlL8DS/Z0vx5L/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////vBABRhxyCCCCSSSSjTTTjTjjjTjz0UEEkfEvUkg0GEH1NkcDPZS47Fde4mEw+fb0rZ85Lv0T4f7sbMlCU8r5TQVw0rb87n4EzKrm8MjR2HaD5CrwVw093flLnyBxA/nKjImuPH+5NBXuHuZ7kufocQ+IFQLeanr/kmQVpitmfOa79E6LKnRwFvJx6/5TJlcNPcz8S679ASkLGlQlDU9Q/OwVww93Pnd+QOCPSrCQanqL5TQV7p7vylz9DbFeQXRSkho9Re4mQVpvlLn6NZyQW9GZpx4i+SZBWm+UufoLqHqQW0oyk89v5hBWmK2Z8cV5+jSKlA3pHaPneI/lNDFUCtmfOZ+iTHRA3oxE5x4jz53Ve/K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S/AT/wkz8BS/AUPwlD8BQ/AT/wkz8BP/ATvwk38BR/AT/wk38JP/CTvwFL8BO/CTPwlD8JO/CUPwk38BR/AT/wk78BR/AT/wk38JP/CT/wFL8BQ/CTvwFH8BP/CTvwlL8JM/CUPwk/8BR/AUPwk78BS/ATvwk/8BS/AUfwk38BR/AUPwk78BR/AUvwk/8JP/CT/wFL8BS/CTfwk/8JP/AUfwFH8JN/AUfwFD8JQ/CUPwk78BS/AUfwk/8JS/CTvwFL8BQ/CT/wFH8RN/AUPwFL8BS/ATvwFL8BS8S8Q/ATfEvEfwE/8BR/ATvwFL8BQ/AUvwE38BR8S8Q/AUfwE/8BQ/AT/wk7xLxH8BP/AUfwE78BQ/AUPEvwU7xLxD8BR8S8Q/AT/wFH8BR/AUvwE7xLw/8BR/AUvwE/8BR/AT/wFD8BO8S8S/AUfEvEvwE78BQ/AT/EvEPwE78BR/AUfwk/8BS/CUvwE78BS/AUfwFD8BP8S8R/AUvwk78BS/AUPwFL8BP/AUfwFD8BS/ATvwFL8BS/CT/wFL8BS/AUvwE/8BS/AUfEvEfwFDxL8FS/AUvwE/8BS/AUPwk/8BS/AUvwFL8BP/AUvwFH8JP/AUvwFL8JO/CT/EvEvwFL8JR/AUvwFD8JQ/CUPwlL8JO8S8Q/AT/EvEfwE7xLw/xLxHxL8FP/AUPwFDxLxH8BR8R8RAR+Q8S8R/AUAEgEfwVL8BSAS+Q/CUgEvkfEfEPEvEvwFL8BS/AT/EvEPwFLxHxHxLw8BH5L8BS/CT/wNIBL8BS8R/AT/wFH8BS8S/BUPEvwVEBL8HP/AUgEvkvwFLxLxLxL8NSASAR8Q8S/BUvwFL8BQ/AUvwFEBL5L8BQ/CUfwFL8BR8S8R/AUvEvwFL8FS/AUvEvwVD8BS/EUfEvwVD8JS/AUvwVL8FS/AUfwFEBIBLxL8BQ/CUfwlL8JS8S/BUPwFLxL8HS+S/BUvwFLxH8RS8S8S/AUfwlL8RR/AUvEvEfwFL8JQ/AUgEvkvxVLxIBL1L8CS/BUvkgEgEgEvwNL5IBIBH8FSAS+RAS+S/AUvxFEBL5D5LxL5LxH8HS8SAR+S8SAS8R8Q8R/AUQEfwdLxL8FR/CUvw9L5L8HS/A0vwVL8NS/B0vkQEgEvEvEvkgEvEvwFL8BS/AUfwNL8LSAS/D0gEgEfxVLxL8LS/BUvwVL8PS/A0vEvxNLxL8BS/CUvEvytL8XS/DUvwdL5H8HS/A0gEvwNIBL8TS8S8R/K0vxtLxL8TS/AUgEvzlL8FS8S8S8S/BUvwVLxL8HS/H0vwxL8uSASAS8SS/AEvEvEvwFL8lSASASASAR/A0vxZL1L8RS/GEvxBL8PS8S/DUvEvwJIBL8DS9SS/DkvwdIBL5IBL8AS/AkvUkgEvwlL8NS/X0gEvwJL8jS7S8S/AEvxRL8XSS/CkvwBL8ES/CUvwtL8gS/IkvxlL8+S/A0vwJLxJL8DSAS7S7S8S/HUvwRL8VS+S/GUvwRL8KS/B0vylL///GUgEv5lL8IS/TUvyJHxL88S/VEvxxL/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////3kT////////qG////Qz///9A//kj/5G/+TP/kX95J/eRv3k395G/eSv3kj95O/eRfzkr85I/OT/zkf85L/OSfzlD85H/OS/zkn85P/OSPzkz85K/OUPzkj8ZM/GSvzkn8ZM/GSvzkn8ZN/GSvzkr8ZN/GS/zkn8ZN/GS/xlL8ZK/GTfxkz8ZS/GSvxk38ZL/OS/xk78ZM/OSfwk78JM/GS/wk78JM/GSvwk78JM/GS/wk78JM/GSvwk78JM/GTPwk/8JN/GS/wk78JM/GTPwk/8JN/GSvwk/8JN/CUvwkz8JP/CTfxkv8JR/CTfxk38JP/CTfxkv8JQ/CTfxkz8JS/CTvxkz8JR/CTvxk38JQ/CTvxkv8BS/ATvwk38BQ/ATvwkz8BS/ATvwk78BR/ATvwkz8BS/AT/wk78BR/ATvwkz8BR/ATvwk78BS/AUvwkv8BS/AT/wk78BS/AT/wk38BS/AT/wk78BR/AUPwkz8BR/AUPwk78BS/AT/wFL8BN/AUPwE/8JO/AUvwFD8JM/AUvwFH8JO/AUvwE78JO/AUPwE/8JP/CUvwk38JP/CTvwFL8BQ/CTvwFL8BQ/CTvwFL8BP/CTPwFL8BR/CTvwFL8RO/AUvwFD8JQ/GTfwFL8BR/CT/wFH8BQ/CTvwFL8BS/CT/wlD8JN8S8Q/ATvEfEPwE7xLxL8BQ8R8R/ATfEvEfwFDxH8FP8S8S/AT/wFHxLw3xLxH8BP/BUvD/EvEvwFL8BQ/ATvEfEPwE/8JP/AUvwE/8BR/ATvEvEfwE/8BS/AT/EvEvwFDxL8FP/AUvwFD8JP/AUPwFH8JO8S/BUPEvEPwE/8BQ/AT/wFL8BO8R8Q/AT/wFL8BP/AUvwFDxLxL8BO8S/BUPwFL8BO/AUvwFDxL8FP8R/BT/EfEvwFD8JQ/AUvwE78BS/AUfwFL8BO/AUvwFLxL8FP/AUvwFH8BS/AT/wFL8BQ/CTvEvEvwE/xLxL8BO8S8S/CUvwE7xLxD8BQ/CUPwFL8RQ8S8R/AUvwk/8BS/AUPwk7xL8FQ8S/BT/xFL8BO/CUPEvEfEfEPwFLxLxHxLxH8BQ/AUPwFD8BS/AT/wFL8BQ/AUvEvDvwE/8BQ/AUfwFLxHxL8BP8S8S/AUfEfEvwFD8BS/AT/EvEAEvkPwFL8BS8S8Q/AUfwFD8BQ/A0vkvwk/8JS/A0vkfwFL8BS/A0vkfwVLxD8JQ/AUvEvEgEgEvEvwE/xL8FS/CUfwFHxLxDxLxL8BQ8S8QAS+SAS/CUvkfwFD8FS8Q8S8R8S/AUvEvwE/8BR/AT/EvEvEvD/wlHxL8FS8R8Q/CUPwFL8FS8R8S/BUfEvwVH8BR/AUvEfEvwFD8BS/AUvwFHxLxLxL8JS8R8S8Q/CUPwlL8BS/BUvEgEvkPxFL8RQAS/GUgEvEPwFLxH8FS8S8S/AUQEvkvwFLxIBL8LR/AEj/wlIBD8BSAS8Q/FUvwVH8BR8RAS/A0QEvkvwFL8BS/CUgEvkvwtH5IBHxL8HS/C0vwFIBL5HxIBL5L5L8DSASASAS/DUvwtL5L8JS/AUvwNL8jSAS/BUvwtL8JS/CUvEvwdL8BS/B0vwlL5IBH8NS/AUvwVLxL80S/GkgEvEvwVL8DS/EUvEvxFL8ZS/AUvxFL8XSAR/C0vwlIBL8VS/EUvwVL8NS/NkvwNLtIBH8AS/DEkvwxL8AS/G0vw9JIBL5L8FS/FUvEvxVHtL8QS7S/DEvyBL8RSAS/BEvwpL8cSAS/AUgEkvwBJL8ES/IEvwpL8IS/C0vwVL8GS8S/Ekvku0gEvxdL8ES/CEvUkkvwdJIBJL8HS/AUu0vwNL5L8DS9S/AEvwRL8TS/F0vwJIBL8ISS/D0vw1IBL8bS7S/AUkvw9L8ASS/Akfx9L8KS8S9S/AUu0vEvwRL8BS/CEvwlL5L1L8RS/H0v/ZL8cS//////cS/Ikv/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////xEQAUYcccggggkkoow0044000489EBFFDxIBLxLxJJIAF0IuFksDqC0KOQEze2WrYtzSxbNl7swvTJdLGGGZ11ZpuRfVgAsyKlAexGc3MPG0AkBTQg9aEMbmsYyf9JE7dj4Lsm2qzZRVKwbGxhSE703vWJiqB2mX+M4WrZIwi7v/GgCkCRA5Ko0hTEzI0yr4HBy7sJqR0C0X6kkoakHYtedoV7yEvN3bKk0WA3eW+kaCkUl9L0SXIXXdgKbDh8BEAfVjnSxWRWEhNc/Tpavh/LOsiY7Os9VKLKqoewEiYWQIQM0adJ0HskSzHYqvFSxCz/TKsS9jGsI4ZY8XmwWVe28OmohxK4V5xYpJIwSu1XdiYdyRAGGj/RLWSSOEznXdjptYCWbzelOnCWq0ERNl3aNS0NAhG6Ke4GN076lapjq4xm7sF1JzQTspZGDpQxZennPXLdXe0ic+rhU2zVUrycmhGKnIz98TdBFDyEoy7hWLAKTAYvBPAB8gCBEA0dWKiQAicA9IRpTy9VQwXABdgB/C9jCNzgkFrCaqthF3DCWWHcPWTImuGElLAIiBlIQwAFUA1l81KtItCi+Kky51q0rVkVWAdsMnHg3Am1fqyhCXgi9xep9WALyABMAaoDXCmQYThDIEAhSWb8WxP1lH0XXZFFmai6AMGBo6FTxaSExBZdxpL1eABXA0dSqAdEhSRAm31eibwBhANHRqwhFsEZMQWXb5sBzgNYHsAAoPQwEgegtloEa3MhZDif0q8vzEXCtWi+tNgGUQqAS4E5NGHDgxXZsWXiwA4CeFIGuA040lwnBHGDmXdgGmBhUCGAJuADCHUucIygPABIYBGyhDKHyGLEwkgBSgB9CZ7Wl2Ki/MziJ1guU8R8ic4YSyxp9Mkic4YSywAORIF6gAAYfDwYDyJuUCoxY+tNrszNYJ2b5mcq5mhytCAyw1fXmxHoo76DFX8PIA5OUGUj0VhgAzRc7dtSq0t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",type:Na.TEXTURE_EXR}};var gi;(function(s){s.ObjectClicked="object-clicked",s.ObjectDoubleClicked="object-doubleclicked",s.LoadComplete="load-complete",s.UnloadComplete="unload-complete",s.UnloadAllComplete="unload-all-complete",s.Busy="busy",s.FilteringStateSet="filtering-state-set",s.LightConfigUpdated="light-config-updated"})(gi||(gi={}));const AN={enabled:!0,castShadow:!0,intensity:5,color:16777215,elevation:1.33,azimuth:.75,radius:0,indirectLightIntensity:1.2,shadowcatcher:!0};var vt,hr,Eo;(function(s){s[s.STREAM_CONTENT_MESH=10]="STREAM_CONTENT_MESH",s[s.STREAM_CONTENT_LINE=11]="STREAM_CONTENT_LINE",s[s.STREAM_CONTENT_POINT=12]="STREAM_CONTENT_POINT",s[s.STREAM_CONTENT_TEXT=13]="STREAM_CONTENT_TEXT",s[s.STREAM_CONTENT_POINT_CLOUD=14]="STREAM_CONTENT_POINT_CLOUD",s[s.NONE=0]="NONE",s[s.STREAM_CONTENT=1]="STREAM_CONTENT",s[s.PROPS=2]="PROPS",s[s.SHADOWCATCHER=3]="SHADOWCATCHER",s[s.OVERLAY=4]="OVERLAY",s[s.MEASUREMENTS=5]="MEASUREMENTS"})(vt||(vt={})),function(s){s[s.RENDER=1]="RENDER",s[s.SHADOWS=2]="SHADOWS",s[s.CLIPPING_PLANES=4]="CLIPPING_PLANES",s[s.RENDER_RESET=8]="RENDER_RESET"}(hr||(hr={})),function(s){s[s.NONE=0]="NONE",s[s.OVERLAY=1]="OVERLAY",s[s.OUTLINE_ONLY=2]="OUTLINE_ONLY"}(Eo||(Eo={}));class TN extends Hg{constructor(e){super(e)}compileProperEquirectShader(e){this._equirectMaterial=new $n({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null},rotationMatrix:{value:e}},vertexShader:`
          precision mediump float;
          precision mediump int;
          attribute float faceIndex;
          varying vec3 vOutputDirection;
          // RH coordinate system; PMREM face-indexing convention
          vec3 getDirection( vec2 uv, float face ) {
            uv = 2.0 * uv - 1.0;
            vec3 direction = vec3( uv, 1.0 );
            if ( face == 0.0 ) {
              direction = direction.zyx; // ( 1, v, u ) pos x
            } else if ( face == 1.0 ) {
              direction = direction.xzy;
              direction.xz *= -1.0; // ( -u, 1, -v ) pos y
            } else if ( face == 2.0 ) {
              direction.x *= -1.0; // ( -u, v, 1 ) pos z
            } else if ( face == 3.0 ) {
              direction = direction.zyx;
              direction.xz *= -1.0; // ( -1, v, -u ) neg x
            } else if ( face == 4.0 ) {
              direction = direction.xzy;
              direction.xy *= -1.0; // ( -u, -1, v ) neg y
            } else if ( face == 5.0 ) {
              direction.z *= -1.0; // ( u, v, -1 ) neg z
            }
            return direction;
          }
          void main() {
            vOutputDirection = getDirection( uv, faceIndex );
            gl_Position = vec4( position, 1.0 );
          }
        `,fragmentShader:`
          precision mediump float;
          precision mediump int;
          varying vec3 vOutputDirection;
          uniform sampler2D envMap;
          uniform mat4 rotationMatrix;
          #include <common>
          void main() {

            vec3 outputDirection = normalize( vOutputDirection );
            outputDirection = normalize((rotationMatrix * vec4(vOutputDirection, 0.)).xyz);
            vec2 uv = equirectUv( outputDirection );
            gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );
          }
        `,blending:ui,depthTest:!1,depthWrite:!1}),this._compileMaterial(this._equirectMaterial)}}const dt=GL(Wm,"warn")?Wm:L1(Wm,"default");class pr{static getLoader(e,t){if(t===void 0&&(t=e.split(".").pop()),!Object.values(Na).includes(t))return dt.warn(`Asset ${e} could not be loaded. Unknown type`),null;switch(t){case Na.TEXTURE_EXR:return new p2;case Na.TEXTURE_HDR:return new m2;case Na.TEXTURE_8BPP:return new Rb;default:return null}}static hdriToPMREM(e,t){const n=new TN(e),i=new Ne().makeRotationFromEuler(new vr(.5*-Math.PI,0,.5*-Math.PI));n.compileProperEquirectShader(i);const r=n.fromEquirectangular(t);return n.dispose(),r.texture}static getEnvironment(e,t){return this._cache[e.id]?Promise.resolve(pr.hdriToPMREM(t,this._cache[e.id])):new Promise((n,i)=>{const r=pr.getLoader(e.src,e.type);r?r.load(e.src,a=>{this._cache[e.id]=a,n(pr.hdriToPMREM(t,a))},void 0,a=>{i(new Error(`Loading asset ${e.id} failed ${a.message}`))}):i(new Error(`Loading asset ${e.id} failed`))})}static getTexture(e){return this._cache[e.id]?Promise.resolve(this._cache[e.id]):new Promise((t,n)=>{if(e.src.includes("data:image")){const i=new Image;i.src=e.src,i.onload=()=>{const r=new hi(i);r.needsUpdate=!0,this._cache[e.id]=r,t(r)},i.onerror=r=>{n(new Error(`Loading asset ${e.id} failed with ${r.toString()}`))}}else{const i=pr.getLoader(e.src,e.type);i?i.load(e.src,r=>{this._cache[e.id]=r,t(this._cache[e.id])},void 0,r=>{n(new Error(`Loading asset ${e.id} failed ${r.message}`))}):n(new Error(`Loading asset ${e.id} failed`))}})}static getFont(e){let t=null;return t=e.src?e.src:e,this._cache[t]?Promise.resolve(this._cache[t]):new Promise((n,i)=>{new g2().load(t,r=>{n(r)},void 0,r=>{i(new Error(`Loading asset ${t} failed ${r.message}`))})})}static async getTextureData(e){const t=await pr.getTexture(e),n=document.createElement("canvas");n.width=t.image.width,n.height=t.image.height;const i=n.getContext("2d");if(!i)throw new Error("Fatal! 2d context could not be retrieved.");i.drawImage(t.image,0,0);const r=i.getImageData(0,0,n.width,n.height);return Promise.resolve(r)}static generateGradientRampTexture(e,t,n){}static generateDiscreetRampTexture(e){const t=e.length,n=new Uint8Array(4*(1*t));for(let r=0;r<e.length;r++){const a=4*r,o=new ot(e[r]);o.convertSRGBToLinear(),n[a]=Math.floor(255*o.r),n[a+1]=Math.floor(255*o.g),n[a+2]=Math.floor(255*o.b),n[a+3]=255}const i=new Eh(n,t,1);return i.needsUpdate=!0,i}}pr._cache={};class mA{constructor(){this.lastPauseTime=0,this.needsWait=!1}tick(e){performance.now()-this.lastPauseTime>e&&(this.needsWait=!0)}async wait(e){this.lastPauseTime=performance.now(),await new Promise(t=>setTimeout(t,e)),this.needsWait=!1}}const Sr=new Ne,Rs=new Ne,Pl=new Ne;class Ju{constructor(){this.boxes=new Array,this.worldBox=new Tt,this.VecBuff=new T,this.BoxBuff0=new Tt,this.BoxBuff1=new Tt,this._worldOrigin=new T}get worldSize(){this.worldBox.getCenter(this._worldOrigin);const e=new T().subVectors(this.worldBox.max,this.worldBox.min);return{x:e.x,y:e.y,z:e.z}}get worldOrigin(){return this._worldOrigin}expandWorld(e){this.boxes.push(e),this.updateWorld()}reduceWorld(e){this.boxes.splice(this.boxes.indexOf(e),1),this.updateWorld()}updateWorld(){this.worldBox.makeEmpty();for(let e=0;e<this.boxes.length;e++)this.worldBox.union(this.boxes[e])}resetWorld(){this.worldBox.makeEmpty(),this.boxes.length=0}getRelativeOffset(e=.001){if(this.worldBox.isEmpty())return e;Sr.identity(),Sr.makeScale(1+e,1+e,1+e);const t=this.VecBuff.set(.5*this.worldSize.x,.5*this.worldSize.y,.5*this.worldSize.z);this.BoxBuff0.min.set(0,0,0),this.BoxBuff0.max.set(0,0,0),this.BoxBuff1.min.set(0,0,0),this.BoxBuff1.max.set(0,0,0);const n=this.BoxBuff0.expandByVector(t);return this.BoxBuff1.copy(n).applyMatrix4(Sr).max.distanceTo(n.max)}getRelativeOffsetBox(e,t=.001){if(this.worldBox.isEmpty())return e;const n=e.getCenter(new T);Rs.makeTranslation(n.x,n.y,n.z),Pl.copy(Rs).invert(),Sr.identity(),Sr.makeScale(1+t,1+t,1+t);const i=new Tt().copy(e);return i.applyMatrix4(Pl),i.applyMatrix4(Sr),i.applyMatrix4(Rs),i}static expandBoxRelative(e,t=.001){return e.isEmpty()?e:e instanceof Tt?Ju.expandBox3Relative(e,t):Ju.expandOBBRelative(e,t)}static expandBox3Relative(e,t){const n=e.getCenter(new T),i=e.getSize(new T);Rs.makeTranslation(n.x,n.y,n.z),Pl.copy(Rs).invert(),Sr.identity(),Sr.makeScale(1+t,1+t,1+t);const r=new Tt().copy(e);return i.x===0&&(r.min.x+=.5*-t,r.max.x+=.5*t),i.y===0&&(r.min.y+=.5*-t,r.max.y+=.5*t),i.z===0&&(r.min.z+=.5*-t,r.max.z+=.5*t),r.applyMatrix4(Pl),r.applyMatrix4(Sr),r.applyMatrix4(Rs),r}static expandOBBRelative(e,t){const n=e.center,i=e.getSize(new T);Rs.makeTranslation(n.x,n.y,n.z),Pl.copy(Rs).invert(),Sr.identity(),Sr.makeScale(1+t,1+t,1+t);const r=new Ki().copy(e);return i.x===0&&(r.halfSize.x+=.5*t),i.y===0&&(r.halfSize.y+=.5*t),i.z===0&&(r.halfSize.z+=.5*t),r.applyMatrix4(Pl),r.applyMatrix4(Sr),r.applyMatrix4(Rs),r}}var mt;(function(s){s[s.MESH=0]="MESH",s[s.LINE=1]="LINE",s[s.POINT=2]="POINT",s[s.POINT_CLOUD=3]="POINT_CLOUD",s[s.TEXT=4]="TEXT"})(mt||(mt={}));const Li={offset:0,count:0},kn={offset:0,count:1/0};let EN=0;const gA=()=>++EN;class qw{toJSON(){return{}}}class yo{constructor(){this._stencilOutline=Eo.NONE,this.needsCopy=!1}get speckleUserData(){return this.userData}set speckleUserData(e){this.userData=e}get speckleDefines(){return this.defines}set speckleDefines(e){this.defines=e}get vertexProgram(){return""}get fragmentProgram(){return""}get uniformsDef(){return{empty:"empty"}}get baseUniforms(){return{emptyBase:{value:"emptyBase"}}}set stencilOutline(e){this._stencilOutline=e;const t=this;t.stencilWrite=e!==Eo.NONE,t.stencilWrite&&(t.stencilWriteMask=255,t.stencilRef=0,t.stencilFunc=Dv,t.stencilZFail=ec,t.stencilZPass=ec,t.stencilFail=ec,e===Eo.OUTLINE_ONLY&&(t.colorWrite=!1,t.depthWrite=!1,t.stencilWrite=!0))}set pointSize(e){this.size=e}init(e=[]){this.speckleUserData=new qw,this.setUniforms(this.uniformsDef),this.setDefines(e),this.onBeforeCompile=this.onCompile}setUniforms(e){for(const t in e)this.speckleUserData[t]={value:e[t]};this.uniforms=Ga.merge([this.baseUniforms,this.speckleUserData])}setDefines(e=[]){if(e){this.speckleDefines={};for(let t=0;t<e.length;t++)this.speckleDefines[e[t]]=" "}}copyUniforms(e){for(const t in e.userData)this.speckleUserData[t]!==void 0&&(this.speckleUserData[t].value=e.userData[t].value)}bindUniforms(){if(this._internalUniforms)for(const e in this.uniformsDef)this._internalUniforms.uniforms[e]=this.speckleUserData[e]}copyFrom(e){this.speckleUserData=new qw,this.setUniforms(this.uniformsDef),this.copyUniforms(e),this.bindUniforms(),Object.assign(this.speckleDefines,e.defines),e.needsCopy&&(this.needsCopy=e.needsCopy)}onCompile(e){this._internalUniforms=e,this.bindUniforms(),e.vertexShader=this.vertexProgram,e.fragmentShader=this.fragmentProgram}fastCopy(e,t){t.alphaTest=e.alphaTest,t.alphaToCoverage=e.alphaToCoverage,t.blendDst=e.blendDst,t.blendDstAlpha=e.blendDstAlpha,t.blendEquation=e.blendEquation,t.blendEquationAlpha=e.blendEquationAlpha,t.blending=e.blending,t.blendSrc=e.blendSrc,t.blendSrcAlpha=e.blendSrcAlpha,t.clipIntersection=e.clipIntersection,t.clippingPlanes=e.clippingPlanes,t.clipShadows=e.clipShadows,t.colorWrite=e.colorWrite,Object.assign(t.defines,e.defines),t.depthFunc=e.depthFunc,t.depthTest=e.depthTest,t.depthWrite=e.depthWrite,t.stencilWrite=e.stencilWrite,t.stencilFunc=e.stencilFunc,t.stencilRef=e.stencilRef,t.stencilWriteMask=e.stencilWriteMask,t.stencilFuncMask=e.stencilFuncMask,t.stencilFail=e.stencilFail,t.stencilZFail=e.stencilZFail,t.stencilZPass=e.stencilZPass,t.opacity=e.opacity,t.polygonOffset=e.polygonOffset,t.polygonOffsetFactor=e.polygonOffsetFactor,t.polygonOffsetUnits=e.polygonOffsetUnits,t.premultipliedAlpha=e.premultipliedAlpha,t.dithering=e.dithering,t.side=e.side,t.shadowSide=e.shadowSide,t.toneMapped=e.toneMapped,t.transparent=e.transparent,t.vertexColors=e.vertexColors,t.visible=e.visible}setMaterialOptions(e){this.stencilOutline=e.stencilOutlines||Eo.NONE,this.pointSize=e.pointSize||1}}class vA extends kp{}class L0 extends Ja{}class yA extends Ah{}class xA extends Jv{}class wA extends M0{}class SA extends zp{}function xo(s,e){e.forEach(t=>{Object.getOwnPropertyNames(t.prototype).forEach(n=>{Object.defineProperty(s.prototype,n,Object.getOwnPropertyDescriptor(t.prototype,n)||Object.create(null))})})}xo(vA,[yo]),xo(L0,[yo]),xo(yA,[yo]),xo(xA,[yo]),xo(class extends Kv{},[yo]),xo(wA,[yo]),xo(SA,[yo]);class Ca extends wA{get vertexProgram(){return`
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;
		uniform float pixelThreshold;

		varying float vAlpha;

		#define SEARCH_STEPS 10

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec4 instanceColorStart;
		attribute vec4 instanceColorEnd;
		// varying vec3 debugColor;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;
			varying float correctedLineWidth;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

        #ifdef USE_RTE
			attribute vec3 instanceStartLow;
			attribute vec3 instanceEndLow;
            uniform vec3 uViewer_high;
            uniform vec3 uViewer_low;
        #endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		float screenSpaceDistance(vec4 p0, vec4 p1) {
			p0 = projectionMatrix * p0;
			p0 /= p0.w;
			p1 = projectionMatrix * p1;
			p1 /= p1.w;
			return length(p1.xy - p0.xy);
		}

		highp vec4 computeRelativePosition(in highp vec3 position_low, in highp vec3 position_high, in highp vec3 relativeTo_low, in highp vec3 relativeTo_high){
			/* 
			Source https://github.com/virtualglobebook/OpenGlobe/blob/master/Source/Examples/Chapter05/Jitter/GPURelativeToEyeDSFUN90/Shaders/VS.glsl 
			Note here, we're storing the high part of the position encoding inside three's default 'position' attribute buffer so we avoid redundancy 
			*/
			highp vec3 t1 = position_low.xyz - relativeTo_low.xyz;
			highp vec3 e = t1 - position_low.xyz;
			/** This is redunant, but necessary as a workaround for Apple platforms */
			highp float x = position_high.x - relativeTo_high.x;
			highp float y = position_high.y - relativeTo_high.y;
			highp float z = position_high.z - relativeTo_high.z;
			highp vec3 v = vec3(x, y, z);
			/** End of redundant part */
			highp vec3 t2 = ((-relativeTo_low - e) + (position_low.xyz - (t1 - e))) + v;
			highp vec3 highDifference = t1 + t2;
			highp vec3 lowDifference = t2 - (highDifference.xyz - t1.xyz);
			
			highp vec3 position = highDifference.xyz + lowDifference.xyz;
			return vec4(position, 1.);
		}

		void main() {
			if(instanceColorStart.w == 0.) {
				gl_Position = vec4(0.);
				return;
			}
			
			vAlpha = instanceColorStart.w;

            vec3 computedPosition = position;
			#ifdef USE_COLOR

				vColor.xyz = ( computedPosition.y < 0.5 ) ? instanceColorStart.xyz : instanceColorEnd.xyz;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( computedPosition.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
				vUv = uv;

			#endif

			float aspect = resolution.x / resolution.y;

			// camera space
            #ifdef USE_RTE
			/** Source https://github.com/virtualglobebook/OpenGlobe/blob/master/Source/Examples/Chapter05/Jitter/GPURelativeToEyeDSFUN90/Shaders/VS.glsl */
				// vec3 t1 = instanceStartLow.xyz - uViewer_low;
				// vec3 e = t1 - instanceStartLow.xyz;
				// vec3 t2 = ((-uViewer_low - e) + (instanceStartLow.xyz - (t1 - e))) + instanceStart.xyz - uViewer_high;
				// vec3 highDifference = t1 + t2;
				// vec3 lowDifference = t2 - (highDifference - t1);
				// vec4 start = modelViewMatrix * vec4(highDifference.xyz + lowDifference.xyz , 1.);
				vec4 start = modelViewMatrix * computeRelativePosition(instanceStartLow.xyz, instanceStart.xyz, uViewer_low, uViewer_high);
				
				// t1 = instanceEndLow.xyz - uViewer_low;
				// e = t1 - instanceEndLow.xyz;
				// t2 = ((-uViewer_low - e) + (instanceEndLow.xyz - (t1 - e))) + instanceEnd.xyz - uViewer_high;
				// highDifference = t1 + t2;
				// lowDifference = t2 - (highDifference - t1);
				// vec4 end = modelViewMatrix * vec4(highDifference.xyz + lowDifference.xyz , 1.);
				vec4 end = modelViewMatrix * computeRelativePosition(instanceEndLow.xyz, instanceEnd.xyz, uViewer_low, uViewer_high);
            #else
                vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
                vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );
            #endif

			#ifdef WORLD_UNITS

				worldStart = start.xyz;
				worldEnd = end.xyz;

			#else

				vUv = uv;

			#endif

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				// get the offset direction as perpendicular to the view vector
				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 offset;
				if ( computedPosition.y < 0.5 ) {

					offset = normalize( cross( start.xyz, worldDir ) );

				} else {

					offset = normalize( cross( end.xyz, worldDir ) );

				}

				// sign flip
				if ( computedPosition.x < 0.0 ) offset *= - 1.0;

				float forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// extend the line bounds to encompass  endcaps
					start.xyz += - worldDir * linewidth * 0.5;
					end.xyz += worldDir * linewidth * 0.5;

					// shift the position of the quad so it hugs the forward edge of the line
					offset.xy -= dir * forwardOffset;
					offset.z += 0.5;

				#endif

				// endcaps
				if ( computedPosition.y > 1.0 || computedPosition.y < 0.0 ) {

					offset.xy += dir * 2.0 * forwardOffset;

				}

				// debugColor = vec3(0., 0., 1.);
				correctedLineWidth = linewidth;
				vec3 cOffset = offset;
				
				// adjust for linewidth
				offset *= linewidth * 0.5;

				// set the world position
				worldPos = ( computedPosition.y < 0.5 ) ? start : end;

				/*
				Not great, not terrible
				*/
				float pixelSize = length(vec2(pixelThreshold/resolution.x + pixelThreshold/resolution.y));
				float offsetStep = linewidth;
				float d = screenSpaceDistance(worldPos, worldPos + vec4(cOffset * offsetStep, 0.));
				/* We're trying to start off with a step closer to the initial difference between SS distance and the pixel size we want
				*/
				// offsetStep += pixelSize - d;
				vec3 move = offset;
				
				for(int i = 0; i < SEARCH_STEPS; i++){
					move = cOffset * offsetStep;
					d = screenSpaceDistance(worldPos, worldPos + vec4(move, 0.));
					if(d > pixelSize) {
						correctedLineWidth = offsetStep;
						break;
					}
					offsetStep += offsetStep;
				}

				worldPos.xyz += move;

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segments overlap neatly
				vec3 clipPose = ( computedPosition.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( computedPosition.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( computedPosition.y < 0.0 ) {

					offset += - dir;

				} else if ( computedPosition.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( computedPosition.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( computedPosition.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`}get fragmentProgram(){return`
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;
		varying float vAlpha;
		// varying vec3 debugColor;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;
			varying float correctedLineWidth;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha;
			#ifdef UNIFORM_OPACITY
				alpha = opacity;
			#else
				alpha = vAlpha;
			#endif


			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / correctedLineWidth;

				#ifndef USE_DASH

					#ifdef USE_ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef USE_ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			// #include <color_fragment> COMMENTED CHUNK
			#if defined( USE_COLOR_ALPHA )
				diffuseColor *= vColor;
			#elif defined( USE_COLOR )
				diffuseColor.rgb = vColor;
			#endif

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <encodings_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`}get baseUniforms(){return Xn.line.uniforms}get uniformsDef(){return{uViewer_high:new T,uViewer_low:new T,pixelThreshold:0}}set pixelThreshold(e){this.userData.pixelThreshold.value=e,this.needsUpdate=!0}constructor(e,t=[]){super(e),this.init(t)}customProgramCacheKey(){return this.constructor.name}copy(e){return super.copy(e),this.copyFrom(e),this}fastCopy(e,t){super.fastCopy(e,t);const n=e;t.color.copy(n.color),t.userData.pixelThreshold.value=e.userData.pixelThreshold.value}onBeforeRender(e,t,n,i,r){this.defines&&this.defines.USE_RTE&&(r.modelViewMatrix.copy(e.RTEBuffers.rteViewModelMatrix),this.userData.uViewer_low.value.copy(e.RTEBuffers.viewerLow),this.userData.uViewer_high.value.copy(e.RTEBuffers.viewerHigh)),e.getDrawingBufferSize(this.resolution),this.needsUpdate=!0}}class ks extends vA{get vertexProgram(){return`
#define STANDARD
#ifdef USE_RTE
    // The high component is stored as the default 'position' attribute buffer
    attribute vec3 position_low;
    uniform vec3 uViewer_high;
    uniform vec3 uViewer_low;
    uniform mat4 rteShadowMatrix;
    uniform vec3 uShadowViewer_high;
    uniform vec3 uShadowViewer_low;
#endif

#ifdef TRANSFORM_STORAGE
    attribute float objIndex;
    #if TRANSFORM_STORAGE == 0
        #if __VERSION__ == 300
            #define TRANSFORM_STRIDE 4
        #else
            #define TRANSFORM_STRIDE 4.
        #endif
        uniform sampler2D tTransforms;
        uniform float objCount;
    #elif TRANSFORM_STORAGE == 1
        uniform mat4 uTransforms[OBJ_COUNT];
    #endif
#endif

varying vec3 vViewPosition;

#ifdef USE_TRANSMISSION

    varying vec3 vWorldPosition;

#endif

#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

#ifdef TRANSFORM_STORAGE
    void objectTransform(out vec4 quaternion, out vec4 pivotLow, out vec4 pivotHigh, out vec4 translation, out vec4 scale){
        #if TRANSFORM_STORAGE == 0
            #if __VERSION__ == 300
                ivec2 uv = ivec2(int(objIndex) * TRANSFORM_STRIDE, 0); 
                vec4 v0 = texelFetch( tTransforms, uv, 0 );
                vec4 v1 = texelFetch( tTransforms, uv + ivec2(1, 0), 0);
                vec4 v2 = texelFetch( tTransforms, uv + ivec2(2, 0), 0);
                vec4 v3 = texelFetch( tTransforms, uv + ivec2(3, 0), 0);
                quaternion = v0;
                pivotLow = vec4(v1.xyz, 1.);
                pivotHigh = vec4(v2.xyz, 1.);
                translation = vec4(v3.xyz, 1.);
                scale = vec4(v1.w, v2.w, v3.w, 1.);
            #else
                float size = objCount * TRANSFORM_STRIDE;
                vec2 cUv = vec2(0.5/size, 0.5);
                vec2 dUv = vec2(1./size, 0.);
                
                vec2 uv = vec2((objIndex * TRANSFORM_STRIDE)/size + cUv.x, cUv.y);
                vec4 v0 = texture2D( tTransforms, uv);
                vec4 v1 = texture2D( tTransforms, uv + dUv);
                vec4 v2 = texture2D( tTransforms, uv + 2. * dUv);
                vec4 v3 = texture2D( tTransforms, uv + 3. * dUv);
                quaternion = v0;
                pivotLow = vec4(v1.xyz, 1.);
                pivotHigh = vec4(v2.xyz, 1.);
                translation = vec4(v3.xyz, 1.);
                scale = vec4(v1.w, v2.w, v3.w, 1.);
            #endif
        #elif TRANSFORM_STORAGE == 1
            mat4 tMatrix = uTransforms[int(objIndex)];
            quaternion = tMatrix[0];
            pivotLow = vec4(tMatrix[1].xyz, 1.);
            pivotHigh = vec4(tMatrix[2].xyz, 1.);
            translation = vec4(tMatrix[3].xyz, 1.);
            scale = vec4(tMatrix[1][3], tMatrix[2][3], tMatrix[3][3], 1.);
        #endif
    }


    highp vec3 rotate_vertex_position(highp vec3 position, highp vec4 quat)
    {   
        return position + 2.0 * cross(quat.xyz, cross(quat.xyz, position) + quat.w * position);
    }

    /** Another workaround for Apple's stupid compiler */
    vec4 safeMul(vec4 a, vec4 b) {
        // Prevents constant folding and optimization
        return (a + vec4(0.0)) * (b + vec4(1.0)) - a * vec4(1.0);
    }

    highp vec3 rotate_scaled_vertex_position_delta(highp vec4 v0, highp vec4 v1, highp vec4 scale, highp vec4 quat)
    {
        /** !!! WORKAROUND FOR Intel IrisXe CARDS !!! */
        /** The code below will not produce correct results in intel IrisXE integrated GPUs. 
         *  The geometry will turn mangled, albeit stable
         *  I can't know for sure what is going on, but rotating the difference seems to 
         *  force the result into a lower precision?
         */
        // highp vec4 position = v0 - v1;
        // return position.xyz + 2.0 * cross(quat.xyz, cross(quat.xyz, position.xyz) + quat.w * position.xyz);

        /** Subtracting the rotated vectors works. */
        return rotate_vertex_position(safeMul(v0, scale).xyz, quat)  - rotate_vertex_position(safeMul(v1, scale).xyz, quat) ;

        /** An alternate workaround is
         * highp vec3 position = (v0.xyz * (1. + 1e-7)) - (v1.xyz * (1. + 1e-7));
           return position + 2.0 * cross(quat.xyz, cross(quat.xyz, position) + quat.w * position);

           However I'm not such a fan of the (1. + 1e-7) part
         */
    }
#endif

#ifdef USE_RTE
    highp vec4 computeRelativePosition(in highp vec3 position_low, in highp vec3 position_high, in highp vec3 relativeTo_low, in highp vec3 relativeTo_high){
        /* 
        Source https://github.com/virtualglobebook/OpenGlobe/blob/master/Source/Examples/Chapter05/Jitter/GPURelativeToEyeDSFUN90/Shaders/VS.glsl 
        Note here, we're storing the high part of the position encoding inside three's default 'position' attribute buffer so we avoid redundancy 
        */
        highp vec3 t1 = position_low.xyz - relativeTo_low.xyz;
        highp vec3 e = t1 - position_low.xyz;
        /** This is redunant, but necessary as a workaround for Apple platforms */
        highp float x = position_high.x - relativeTo_high.x;
        highp float y = position_high.y - relativeTo_high.y;
        highp float z = position_high.z - relativeTo_high.z;
        highp vec3 v = vec3(x, y, z);
        /** End of redundant part */
        highp vec3 t2 = ((-relativeTo_low - e) + (position_low.xyz - (t1 - e))) + v;
        highp vec3 highDifference = t1 + t2;
        highp vec3 lowDifference = t2 - (highDifference.xyz - t1.xyz);
        
        highp vec3 position = highDifference.xyz + lowDifference.xyz;
        return vec4(position, 1.);
    }
#endif


void main() {

    #include <uv_vertex>
    #include <uv2_vertex>
    #include <color_vertex>
    #include <morphcolor_vertex>
    #include <beginnormal_vertex>
    #include <morphnormal_vertex>
    #include <skinbase_vertex>
    #include <skinnormal_vertex>
    #include <defaultnormal_vertex>
    #include <normal_vertex>

    #include <begin_vertex>
    #include <morphtarget_vertex>
    #include <skinning_vertex>
    #include <displacementmap_vertex>
    //#include <project_vertex> // EDITED CHUNK
    
    #ifdef TRANSFORM_STORAGE
        highp vec4 tQuaternion, tPivotLow, tPivotHigh, tTranslation, tScale;
        objectTransform(tQuaternion, tPivotLow, tPivotHigh, tTranslation, tScale);
    #endif
    #ifdef USE_RTE
        vec4 position_lowT = vec4(position_low, 1.);
        vec4 position_highT = vec4(position, 1.);
        const vec3 ZERO3 = vec3(0., 0., 0.);

        highp vec4 rteLocalPosition = computeRelativePosition(position_lowT.xyz, position_highT.xyz, uViewer_low, uViewer_high);
        #ifdef TRANSFORM_STORAGE
            highp vec4 rtePivot = computeRelativePosition(tPivotLow.xyz, tPivotHigh.xyz, uViewer_low, uViewer_high);
            rteLocalPosition.xyz = rotate_scaled_vertex_position_delta(rteLocalPosition, rtePivot, tScale, tQuaternion) + rtePivot.xyz + tTranslation.xyz;
        #endif
        #ifdef USE_INSTANCING
            vec4 instancePivot = computeRelativePosition(ZERO3, ZERO3, uViewer_low, uViewer_high);
            rteLocalPosition.xyz = (mat3(instanceMatrix) * (rteLocalPosition - instancePivot).xyz) + instancePivot.xyz + instanceMatrix[3].xyz;
        #endif
    #endif

    #ifdef USE_RTE
        vec4 mvPosition = rteLocalPosition;
    #else
        vec4 mvPosition = vec4( transformed, 1.0 );
        #ifdef TRANSFORM_STORAGE
            mvPosition.xyz = rotate_scaled_vertex_position_delta(mvPosition, tPivotHigh, tScale, tQuaternion) + tPivotHigh.xyz + tTranslation.xyz;
        #endif
        #ifdef USE_INSTANCING
            mvPosition = instanceMatrix * mvPosition;
        #endif
    #endif
    
    mvPosition = modelViewMatrix * mvPosition;

    gl_Position = projectionMatrix * mvPosition;


    #include <logdepthbuf_vertex>
    #include <clipping_planes_vertex>

    vViewPosition = - mvPosition.xyz;

    #include <worldpos_vertex>
    // #include <shadowmap_vertex> COMMENTED CHUNK!!!
    #ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		// Offsetting the position used for querying occlusion along the world normal can be used to reduce shadow acne.
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
        highp vec4 shadowPosition = vec4(transformed, 1.0);
        mat4 shadowMatrix = directionalShadowMatrix[ i ];

        #ifdef USE_RTE
            shadowPosition = computeRelativePosition(position_low.xyz, position.xyz, uShadowViewer_low, uShadowViewer_high);
            shadowMatrix = rteShadowMatrix;
            #ifdef TRANSFORM_STORAGE
                highp vec4 rtePivotShadow = computeRelativePosition(tPivotLow.xyz, tPivotHigh.xyz, uShadowViewer_low, uShadowViewer_high);
                shadowPosition.xyz = rotate_scaled_vertex_position_delta(shadowPosition, rtePivotShadow, tScale, tQuaternion) + rtePivotShadow.xyz + tTranslation.xyz;
            #endif
            #ifdef USE_INSTANCING
                vec4 rtePivotShadow = computeRelativePosition(ZERO3, ZERO3, uShadowViewer_low, uShadowViewer_high);
                shadowPosition.xyz = (mat3(instanceMatrix) * (shadowPosition - rtePivotShadow).xyz) + rtePivotShadow.xyz + instanceMatrix[3].xyz;
            #endif
        #else
            #ifdef TRANSFORM_STORAGE
                shadowPosition.xyz = rotate_vertex_position(shadowPosition.xyz * tScale.xyz, tQuaternion) + tTranslation.xyz;
            #endif
            #ifdef USE_INSTANCING
                shadowPosition = instanceMatrix * shadowPosition;
            #endif
        #endif
        shadowWorldPosition = modelMatrix * shadowPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
        vDirectionalShadowCoord[ i ] = shadowMatrix * shadowWorldPosition;
	}
    
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	/*
	#if NUM_RECT_AREA_LIGHTS > 0
		// TODO (abelnation): update vAreaShadowCoord with area light info
	#endif
	*/
    #endif

    #include <fog_vertex>

#ifdef USE_TRANSMISSION

    vWorldPosition = worldPosition.xyz;

#endif
}
`}get fragmentProgram(){return`
#define STANDARD

#ifdef PHYSICAL
    #define IOR
    #define SPECULAR
#endif

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;

#ifdef IOR
    uniform float ior;
#endif

#ifdef SPECULAR
    uniform float specularIntensity;
    uniform vec3 specularColor;

    #ifdef USE_SPECULARINTENSITYMAP
        uniform sampler2D specularIntensityMap;
    #endif

    #ifdef USE_SPECULARCOLORMAP
        uniform sampler2D specularColorMap;
    #endif
#endif

#ifdef USE_CLEARCOAT
    uniform float clearcoat;
    uniform float clearcoatRoughness;
#endif

#ifdef USE_SHEEN
    uniform vec3 sheenColor;
    uniform float sheenRoughness;

    #ifdef USE_SHEENCOLORMAP
        uniform sampler2D sheenColorMap;
    #endif

    #ifdef USE_SHEENROUGHNESSMAP
        uniform sampler2D sheenRoughnessMap;
    #endif
#endif

varying vec3 vViewPosition;
/** We're disabling color grading for now until we want to properly offer it to the users */
//#define CUSTOM_TONEMAPPING 

#ifdef CUSTOM_TONEMAPPING

	uniform float contrast;
	uniform float saturation;
	uniform float whitescale;
	vec3 EvalLogContrastFunc(vec3 col, float eps, float logMidpoint, float contrastFactor)
	{
		vec3 x = max(vec3(0.), col);
		vec3 logX = log2(x+vec3(eps));
		vec3 adjX = vec3(logMidpoint) + (logX - vec3(logMidpoint)) * contrastFactor;
		vec3 ret = max(vec3(0.0), exp2(adjX) - vec3(eps));
		return ret;
	}

	vec3 evalSaturation(vec3 rgbVal, float saturationFactor){
		vec3 lumaWeights = vec3(.25,.50,.25);
		vec3 grey = vec3(dot(lumaWeights,rgbVal));
		return grey + saturationFactor*(rgbVal-grey);
	}

	vec3 evalExposure(vec3 rgbVal, float exposureFactor){
		return rgbVal * exp2(exposureFactor);
	}

	vec3 filmicTonemap(vec3 x) {
		float A = 0.15;
		float B = 0.50;
		float C = 0.10;
		float D = 0.20;
		float E = 0.02;
		float F = 0.30;
		float W = 11.2;
		return ((x*(A*x+C*B)+D*E) / (x*(A*x+B)+D*F))- E / F;
	}


	vec3 applyFilmicToneMap( vec3 color) 
	{
		color = 2.0 * filmicTonemap( color);
		vec3 whiteScale = 1.0 / filmicTonemap(vec3(11.2));
		color *= whiteScale;
		return color;
	}

	vec3 postProcess(in vec3 _color, float exposureFactor, float contrastFactor, float saturationFactor){
		vec3 color = _color;

		// color.rgb *= exposureFactor;
		color.rgb = evalSaturation(color.rgb, saturationFactor);
		color = EvalLogContrastFunc(color, 0.0001, 0.18, contrastFactor);
		color.rgb = ACESFilmicToneMapping( color );//applyFilmicToneMap(color.rgb);
		return color;
	}
#endif

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>


void main() {

    #include <clipping_planes_fragment>

    vec4 diffuseColor = vec4( diffuse, opacity );
    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
    vec3 totalEmissiveRadiance = emissive;

    #include <logdepthbuf_fragment>
    #include <map_fragment>
    #include <color_fragment>
    #include <alphamap_fragment>
    #include <alphatest_fragment>
    #include <roughnessmap_fragment>
    #include <metalnessmap_fragment>
    #include <normal_fragment_begin>
    #include <normal_fragment_maps>
    #include <clearcoat_normal_fragment_begin>
    #include <clearcoat_normal_fragment_maps>
    #include <emissivemap_fragment>

    // accumulation
    #include <lights_physical_fragment>
    #include <lights_fragment_begin>
    #include <lights_fragment_maps>
    #include <lights_fragment_end>

    // modulation
    #include <aomap_fragment>

    vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
    vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;

    #include <transmission_fragment>

    vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;

    #ifdef USE_SHEEN

        // Sheen energy compensation approximation calculation can be found at the end of
        // https://drive.google.com/file/d/1T0D1VSyR4AllqIJTQAraEIzjlb5h4FKH/view?usp=sharing
        float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );

        outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;

    #endif

    #ifdef USE_CLEARCOAT

        float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );

        vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );

        outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;

    #endif

    // #include <output_fragment> COMMENTED CHUNK
    #ifdef OPAQUE
        diffuseColor.a = 1.0;
    #endif

    // https://github.com/mrdoob/three.js/pull/22425
    #ifdef USE_TRANSMISSION
        diffuseColor.a *= transmissionAlpha + 0.1;
    #endif

    gl_FragColor = vec4( outgoingLight, diffuseColor.a );
    // #include <tonemapping_fragment> // COMMENTED OUT
    #ifdef TONE_MAPPING
		#ifdef CUSTOM_TONEMAPPING
			gl_FragColor.rgb = postProcess(gl_FragColor.rgb, toneMappingExposure, contrast, saturation);
		#else
            
			gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
		#endif
	#endif
    #include <encodings_fragment>
    #include <fog_fragment>
    #include <premultiplied_alpha_fragment>
    #include <dithering_fragment>

}
`}get baseUniforms(){return Xn.standard.uniforms}get uniformsDef(){return{uViewer_high:new T,uViewer_low:new T,rteShadowMatrix:new Ne,uShadowViewer_high:new T,uShadowViewer_low:new T,uTransforms:[new Ne],tTransforms:null,objCount:1}}constructor(e,t=[]){super(e),this.init(t)}customProgramCacheKey(){return this.constructor.name}copy(e){return super.copy(e),this.copyFrom(e),e instanceof ks&&(this.originalRoughness=e.originalRoughness,this.artificialRoughness=e.artificialRoughness),this}fastCopy(e,t){super.fastCopy(e,t);const n=t,i=e;n.color.copy(i.color),n.roughness=i.roughness,n.metalness=i.metalness,n.emissive.copy(i.emissive),n.emissiveIntensity=i.emissiveIntensity,n.envMap=i.envMap,n.envMapIntensity=i.envMapIntensity,n.originalRoughness=i.originalRoughness,n.artificialRoughness=i.artificialRoughness}updateArtificialRoughness(e){if(e&&(this.originalRoughness===void 0&&(this.originalRoughness=this.roughness),this.artificialRoughness=e),this.originalRoughness===void 0||this.artificialRoughness===void 0)return;const t=e!==void 0?Math.min(this.originalRoughness,this.artificialRoughness):this.originalRoughness;this.roughness=t,this.needsCopy=!0}onBeforeRender(e,t,n,i,r){this.defines&&this.defines.USE_RTE&&(r.modelViewMatrix.copy(e.RTEBuffers.rteViewModelMatrix),this.userData.uViewer_low.value.copy(e.RTEBuffers.viewerLow),this.userData.uViewer_high.value.copy(e.RTEBuffers.viewerHigh),this.userData.rteShadowMatrix.value.copy(e.RTEBuffers.rteShadowMatrix),this.userData.uShadowViewer_low.value.copy(e.RTEBuffers.shadowViewerLow),this.userData.uShadowViewer_high.value.copy(e.RTEBuffers.shadowViewerHigh),this.needsUpdate=!0)}}const bA=`
uniform float size;
uniform float scale;

#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

#ifdef USE_RTE
    // The high component is stored as the default 'position' attribute buffer
    attribute vec3 position_low;
    uniform vec3 uViewer_high;
    uniform vec3 uViewer_low;
#endif

highp vec4 computeRelativePosition(in highp vec3 position_low, in highp vec3 position_high, in highp vec3 relativeTo_low, in highp vec3 relativeTo_high){
    /* 
    Source https://github.com/virtualglobebook/OpenGlobe/blob/master/Source/Examples/Chapter05/Jitter/GPURelativeToEyeDSFUN90/Shaders/VS.glsl 
    Note here, we're storing the high part of the position encoding inside three's default 'position' attribute buffer so we avoid redundancy 
    */
    highp vec3 t1 = position_low.xyz - relativeTo_low.xyz;
    highp vec3 e = t1 - position_low.xyz;
    /** This is redunant, but necessary as a workaround for Apple platforms */
    highp float x = position_high.x - relativeTo_high.x;
    highp float y = position_high.y - relativeTo_high.y;
    highp float z = position_high.z - relativeTo_high.z;
    highp vec3 v = vec3(x, y, z);
    /** End of redundant part */
    highp vec3 t2 = ((-relativeTo_low - e) + (position_low.xyz - (t1 - e))) + v;
    highp vec3 highDifference = t1 + t2;
    highp vec3 lowDifference = t2 - (highDifference.xyz - t1.xyz);
    
    highp vec3 position = highDifference.xyz + lowDifference.xyz;
    return vec4(position, 1.);
}

#ifdef USE_GRADIENT_RAMP
    attribute float gradientIndex;
    varying float vGradientIndex;
#endif

void main() {

	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	// #include <project_vertex> COMMENTED CHUNK
	#ifdef USE_RTE
        vec4 mvPosition = computeRelativePosition(position_low.xyz, position.xyz, uViewer_low, uViewer_high);
    #else
        vec4 mvPosition = vec4( transformed, 1.0 );
    #endif
    
    #ifdef USE_INSTANCING

        mvPosition = instanceMatrix * mvPosition;

    #endif
    mvPosition = modelViewMatrix * mvPosition;

    #ifdef USE_GRADIENT_RAMP
        vGradientIndex = gradientIndex;
    #endif

    gl_Position = projectionMatrix * mvPosition;

	gl_PointSize = size;

	#ifdef USE_SIZEATTENUATION

		bool isPerspective = isPerspectiveMatrix( projectionMatrix );

		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );

	#endif

	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>

}
`,AA=`
uniform vec3 diffuse;
uniform float opacity;

#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

#ifdef USE_GRADIENT_RAMP
	varying float vGradientIndex;
	uniform sampler2D gradientRamp;
#endif

void main() {

	#include <clipping_planes_fragment>

	vec3 outgoingLight = vec3( 0.0 );

	#ifdef USE_GRADIENT_RAMP
		vec4 diffuseColor = vec4( texture2D(gradientRamp, vec2(vGradientIndex, 0.)).rgb, opacity );
	#else
		vec4 diffuseColor = vec4( diffuse, opacity );
	#endif

	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>

	outgoingLight = diffuseColor.rgb;

	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>

}
`;class kl extends SA{get vertexProgram(){return bA}get fragmentProgram(){return AA}get baseUniforms(){return Xn.points.uniforms}get uniformsDef(){return{uViewer_high:new T,uViewer_low:new T}}constructor(e,t=[]){super(e),this.init(t)}customProgramCacheKey(){return this.constructor.name}copy(e){return super.copy(e),this.copyFrom(e),this}fastCopy(e,t){super.fastCopy(e,t);const n=t,i=e;n.color.copy(i.color),n.size=i.size,n.sizeAttenuation=i.sizeAttenuation}onBeforeRender(e,t,n,i,r){this.defines&&this.defines.USE_RTE&&(r.modelViewMatrix.copy(e.RTEBuffers.rteViewModelMatrix),this.userData.uViewer_low.value.copy(e.RTEBuffers.viewerLow),this.userData.uViewer_high.value.copy(e.RTEBuffers.viewerHigh),this.needsUpdate=!0)}}class Xl extends ks{get vertexProgram(){return`
#define STANDARD
#ifdef USE_RTE
    // The high component is stored as the default 'position' attribute buffer
    attribute vec3 position_low;
    uniform vec3 uViewer_high;
    uniform vec3 uViewer_low;
    uniform mat4 rteShadowMatrix;
    uniform vec3 uShadowViewer_high;
    uniform vec3 uShadowViewer_low;
#endif

#ifdef TRANSFORM_STORAGE
    attribute float objIndex;

    #if TRANSFORM_STORAGE == 0
        #if __VERSION__ == 300
            #define TRANSFORM_STRIDE 4
        #else
            #define TRANSFORM_STRIDE 4.
        #endif
        uniform sampler2D tTransforms;
        uniform float objCount;
    #elif TRANSFORM_STORAGE == 1
        uniform mat4 uTransforms[OBJ_COUNT];
    #endif
#endif

varying vec3 vViewPosition;

#ifdef USE_TRANSMISSION

    varying vec3 vWorldPosition;

#endif

#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

#ifdef TRANSFORM_STORAGE
    void objectTransform(out vec4 quaternion, out vec4 pivotLow, out vec4 pivotHigh, out vec4 translation, out vec4 scale){
        #if TRANSFORM_STORAGE == 0
            #if __VERSION__ == 300
                ivec2 uv = ivec2(int(objIndex) * TRANSFORM_STRIDE, 0); 
                vec4 v0 = texelFetch( tTransforms, uv, 0 );
                vec4 v1 = texelFetch( tTransforms, uv + ivec2(1, 0), 0);
                vec4 v2 = texelFetch( tTransforms, uv + ivec2(2, 0), 0);
                vec4 v3 = texelFetch( tTransforms, uv + ivec2(3, 0), 0);
                quaternion = v0;
                pivotLow = vec4(v1.xyz, 1.);
                pivotHigh = vec4(v2.xyz, 1.);
                translation = vec4(v3.xyz, 1.);
                scale = vec4(v1.w, v2.w, v3.w, 1.);
            #else
                float size = objCount * TRANSFORM_STRIDE;
                vec2 cUv = vec2(0.5/size, 0.5);
                vec2 dUv = vec2(1./size, 0.);
                
                vec2 uv = vec2((objIndex * TRANSFORM_STRIDE)/size + cUv.x, cUv.y);
                vec4 v0 = texture2D( tTransforms, uv);
                vec4 v1 = texture2D( tTransforms, uv + dUv);
                vec4 v2 = texture2D( tTransforms, uv + 2. * dUv);
                vec4 v3 = texture2D( tTransforms, uv + 3. * dUv);
                quaternion = v0;
                pivotLow = vec4(v1.xyz, 1.);
                pivotHigh = vec4(v2.xyz, 1.);
                translation = vec4(v3.xyz, 1.);
                scale = vec4(v1.w, v2.w, v3.w, 1.);
            #endif
        #elif TRANSFORM_STORAGE == 1
            mat4 tMatrix = uTransforms[int(objIndex)];
            quaternion = tMatrix[0];
            pivotLow = vec4(tMatrix[1].xyz, 1.);
            pivotHigh = vec4(tMatrix[2].xyz, 1.);
            translation = vec4(tMatrix[3].xyz, 1.);
            scale = vec4(tMatrix[1][3], tMatrix[2][3], tMatrix[3][3], 1.);
        #endif
    }

    vec3 rotate_vertex_position(vec3 position, vec4 quat)
    { 
        return position + 2.0 * cross(quat.xyz, cross(quat.xyz, position) + quat.w * position);
    }

    /** Another workaround for Apple's stupid compiler */
    vec4 safeMul(vec4 a, vec4 b) {
        // Prevents constant folding and optimization
        return (a + vec4(0.0)) * (b + vec4(1.0)) - a * vec4(1.0);
    }

    highp vec3 rotate_scaled_vertex_position_delta(highp vec4 v0, highp vec4 v1, highp vec4 scale, highp vec4 quat)
    {
        /** !!! WORKAROUND FOR Intel IrisXe CARDS !!! */
        /** The code below will not produce correct results in intel IrisXE integrated GPUs. 
         *  The geometry will turn mangled, albeit stable
         *  I can't know for sure what is going on, but rotating the difference seems to 
         *  force the result into a lower precision?
         */
        // highp vec4 position = v0 - v1;
        // return position.xyz + 2.0 * cross(quat.xyz, cross(quat.xyz, position.xyz) + quat.w * position.xyz);

        /** Subtracting the rotated vectors works. */
        return rotate_vertex_position(safeMul(v0, scale).xyz, quat)  - rotate_vertex_position(safeMul(v1, scale).xyz, quat) ;

        /** An alternate workaround is
         * highp vec3 position = (v0.xyz * (1. + 1e-7)) - (v1.xyz * (1. + 1e-7));
           return position + 2.0 * cross(quat.xyz, cross(quat.xyz, position) + quat.w * position);

           However I'm not such a fan of the (1. + 1e-7) part
         */
    }

#endif

attribute float gradientIndex;
varying float vGradientIndex;

#ifdef USE_RTE
    highp vec4 computeRelativePosition(in highp vec3 position_low, in highp vec3 position_high, in highp vec3 relativeTo_low, in highp vec3 relativeTo_high){
        /* 
        Source https://github.com/virtualglobebook/OpenGlobe/blob/master/Source/Examples/Chapter05/Jitter/GPURelativeToEyeDSFUN90/Shaders/VS.glsl 
        Note here, we're storing the high part of the position encoding inside three's default 'position' attribute buffer so we avoid redundancy 
        */
        highp vec3 t1 = position_low.xyz - relativeTo_low.xyz;
        highp vec3 e = t1 - position_low.xyz;
        /** This is redunant, but necessary as a workaround for Apple platforms */
        highp float x = position_high.x - relativeTo_high.x;
        highp float y = position_high.y - relativeTo_high.y;
        highp float z = position_high.z - relativeTo_high.z;
        highp vec3 v = vec3(x, y, z);
        /** End of redundant part */
        highp vec3 t2 = ((-relativeTo_low - e) + (position_low.xyz - (t1 - e))) + v;
        highp vec3 highDifference = t1 + t2;
        highp vec3 lowDifference = t2 - (highDifference.xyz - t1.xyz);
        
        highp vec3 position = highDifference.xyz + lowDifference.xyz;
        return vec4(position, 1.);
    }
#endif

void main() {

    #include <uv_vertex>
    #include <uv2_vertex>
    #include <color_vertex>
    #include <morphcolor_vertex>
    #include <beginnormal_vertex>
    #include <morphnormal_vertex>
    #include <skinbase_vertex>
    #include <skinnormal_vertex>
    #include <defaultnormal_vertex>
    #include <normal_vertex>

    #include <begin_vertex>
    #include <morphtarget_vertex>
    #include <skinning_vertex>
    #include <displacementmap_vertex>
    //#include <project_vertex> // EDITED CHUNK
    #ifdef TRANSFORM_STORAGE
        vec4 tQuaternion, tPivotLow, tPivotHigh, tTranslation, tScale;
        objectTransform(tQuaternion, tPivotLow, tPivotHigh, tTranslation, tScale);
    #endif
    #ifdef USE_RTE
        vec4 position_lowT = vec4(position_low, 1.);
        vec4 position_highT = vec4(position, 1.);
        const vec3 ZERO3 = vec3(0., 0., 0.);

        highp vec4 rteLocalPosition = computeRelativePosition(position_lowT.xyz, position_highT.xyz, uViewer_low, uViewer_high);
        #ifdef TRANSFORM_STORAGE
            highp vec4 rtePivot = computeRelativePosition(tPivotLow.xyz, tPivotHigh.xyz, uViewer_low, uViewer_high);
            rteLocalPosition.xyz = rotate_scaled_vertex_position_delta(rteLocalPosition, rtePivot, tScale, tQuaternion) + rtePivot.xyz + tTranslation.xyz;
        #endif
        #ifdef USE_INSTANCING
            vec4 instancePivot = computeRelativePosition(ZERO3, ZERO3, uViewer_low, uViewer_high);
            rteLocalPosition.xyz = (mat3(instanceMatrix) * (rteLocalPosition - instancePivot).xyz) + instancePivot.xyz + instanceMatrix[3].xyz;
        #endif
    #endif

    #ifdef USE_RTE
        vec4 mvPosition = rteLocalPosition;
    #else
        vec4 mvPosition = vec4( transformed, 1.0 );
        #ifdef TRANSFORM_STORAGE
            mvPosition.xyz = rotate_scaled_vertex_position_delta(mvPosition, tPivotHigh, tScale, tQuaternion) + tPivotHigh.xyz + tTranslation.xyz;
        #endif
        #ifdef USE_INSTANCING
            mvPosition = instanceMatrix * mvPosition;
        #endif
    #endif


    mvPosition = modelViewMatrix * mvPosition;

    vGradientIndex = gradientIndex;
    gl_Position = projectionMatrix * mvPosition;

    #include <logdepthbuf_vertex>
    #include <clipping_planes_vertex>

    vViewPosition = - mvPosition.xyz;

    #include <worldpos_vertex>
    // #include <shadowmap_vertex>// EDITED CHUNK
    #ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		// Offsetting the position used for querying occlusion along the world normal can be used to reduce shadow acne.
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
        highp vec4 shadowPosition = vec4(transformed, 1.0);
        mat4 shadowMatrix = directionalShadowMatrix[ i ];

        #ifdef USE_RTE
            shadowPosition = computeRelativePosition(position_low.xyz, position.xyz, uShadowViewer_low, uShadowViewer_high);
            shadowMatrix = rteShadowMatrix;
            #ifdef TRANSFORM_STORAGE
                highp vec4 rtePivotShadow = computeRelativePosition(tPivotLow.xyz, tPivotHigh.xyz, uShadowViewer_low, uShadowViewer_high);
                shadowPosition.xyz = rotate_scaled_vertex_position_delta(shadowPosition, rtePivotShadow, tScale, tQuaternion) + rtePivotShadow.xyz + tTranslation.xyz;
            #endif
            #ifdef USE_INSTANCING
                vec4 rtePivotShadow = computeRelativePosition(ZERO3, ZERO3, uShadowViewer_low, uShadowViewer_high);
                shadowPosition.xyz = (mat3(instanceMatrix) * (shadowPosition - rtePivotShadow).xyz) + rtePivotShadow.xyz + instanceMatrix[3].xyz;
            #endif
        #else
            #ifdef TRANSFORM_STORAGE
                shadowPosition.xyz = rotate_vertex_position(shadowPosition.xyz * tScale.xyz, tQuaternion) + tTranslation.xyz;
            #endif
            #ifdef USE_INSTANCING
                shadowPosition = instanceMatrix * shadowPosition;
            #endif
        #endif
        shadowWorldPosition = modelMatrix * shadowPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
        vDirectionalShadowCoord[ i ] = shadowMatrix * shadowWorldPosition;
    
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	/*
	#if NUM_RECT_AREA_LIGHTS > 0
		// TODO (abelnation): update vAreaShadowCoord with area light info
	#endif
	*/
    #endif
    #include <fog_vertex>

#ifdef USE_TRANSMISSION

    vWorldPosition = worldPosition.xyz;

#endif
}
`}get fragmentProgram(){return`
#define STANDARD

#ifdef PHYSICAL
    #define IOR
    #define SPECULAR
#endif

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;

#ifdef IOR
    uniform float ior;
#endif

#ifdef SPECULAR
    uniform float specularIntensity;
    uniform vec3 specularColor;

    #ifdef USE_SPECULARINTENSITYMAP
        uniform sampler2D specularIntensityMap;
    #endif

    #ifdef USE_SPECULARCOLORMAP
        uniform sampler2D specularColorMap;
    #endif
#endif

#ifdef USE_CLEARCOAT
    uniform float clearcoat;
    uniform float clearcoatRoughness;
#endif

#ifdef USE_SHEEN
    uniform vec3 sheenColor;
    uniform float sheenRoughness;

    #ifdef USE_SHEENCOLORMAP
        uniform sampler2D sheenColorMap;
    #endif

    #ifdef USE_SHEENROUGHNESSMAP
        uniform sampler2D sheenRoughnessMap;
    #endif
#endif

varying vec3 vViewPosition;

varying float vGradientIndex;
uniform sampler2D gradientRamp;

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

    #include <clipping_planes_fragment>

    vec4 diffuseColor = vec4( texture2D(gradientRamp, vec2(vGradientIndex, 0.)).rgb, opacity );
    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
    vec3 totalEmissiveRadiance = emissive;

    #include <logdepthbuf_fragment>
    #include <map_fragment>
    #include <color_fragment>
    #include <alphamap_fragment>
    #include <alphatest_fragment>
    #include <roughnessmap_fragment>
    #include <metalnessmap_fragment>
    #include <normal_fragment_begin>
    #include <normal_fragment_maps>
    #include <clearcoat_normal_fragment_begin>
    #include <clearcoat_normal_fragment_maps>
    #include <emissivemap_fragment>

    // accumulation
    #include <lights_physical_fragment>
    #include <lights_fragment_begin>
    #include <lights_fragment_maps>
    #include <lights_fragment_end>

    // modulation
    #include <aomap_fragment>

    vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
    vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;

    #include <transmission_fragment>

    vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;

    #ifdef USE_SHEEN

        // Sheen energy compensation approximation calculation can be found at the end of
        // https://drive.google.com/file/d/1T0D1VSyR4AllqIJTQAraEIzjlb5h4FKH/view?usp=sharing
        float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );

        outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;

    #endif

    #ifdef USE_CLEARCOAT

        float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );

        vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );

        outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;

    #endif

    #include <output_fragment>
    #include <tonemapping_fragment>
    #include <encodings_fragment>
    #include <fog_fragment>
    #include <premultiplied_alpha_fragment>
    #include <dithering_fragment>
}
`}get uniformsDef(){return{...super.uniformsDef,gradientRamp:null}}constructor(e,t=[]){super(e,t)}setGradientTexture(e){this.userData.gradientRamp.value=e,this.userData.gradientRamp.value.generateMipmaps=!1,this.userData.gradientRamp.value.minFilter=wn,this.userData.gradientRamp.value.magFilter=wn,this.needsUpdate=!0}}const It={Millimeters:"mm",Centimeters:"cm",Meters:"m",Kilometers:"km",Inches:"in",Feet:"ft",Yards:"yd",Miles:"mi"};function Qn(s,e=It.Meters){switch(s=jw(s),e=jw(e),s){case It.Millimeters:switch(e){case It.Centimeters:return .1;case It.Meters:return .001;case It.Kilometers:return 1e-6;case It.Inches:return .0393701;case It.Feet:return .00328084;case It.Yards:return .00109361;case It.Miles:return 621371e-12}break;case It.Centimeters:switch(e){case It.Millimeters:return 10;case It.Meters:return .01;case It.Kilometers:return 1e-5;case It.Inches:return .393701;case It.Feet:return .0328084;case It.Yards:return .0109361;case It.Miles:return 621371e-11}break;case It.Meters:switch(e){case It.Millimeters:return 1e3;case It.Centimeters:return 100;case It.Kilometers:return .001;case It.Inches:return 39.3701;case It.Feet:return 3.28084;case It.Yards:return 1.09361;case It.Miles:return 621371e-9}break;case It.Kilometers:switch(e){case It.Millimeters:return 1e6;case It.Centimeters:return 1e5;case It.Meters:return 1e3;case It.Inches:return 39370.1;case It.Feet:return 3280.84;case It.Yards:return 1093.61;case It.Miles:return .621371}break;case It.Inches:switch(e){case It.Millimeters:return 25.4;case It.Centimeters:return 2.54;case It.Meters:return .0254;case It.Kilometers:return 254e-7;case It.Feet:return .0833333;case It.Yards:return .027777694;case It.Miles:return 157828e-10}break;case It.Feet:switch(e){case It.Millimeters:return 304.8;case It.Centimeters:return 30.48;case It.Meters:return .3048;case It.Kilometers:return 3048e-7;case It.Inches:return 12;case It.Yards:return .333332328;case It.Miles:return 189394e-9}break;case It.Miles:switch(e){case It.Millimeters:return 1609e3;case It.Centimeters:return 160934;case It.Meters:return 1609.34;case It.Kilometers:return 1.60934;case It.Inches:return 63360;case It.Feet:return 5280;case It.Yards:return 1759.99469184}}return 1}function jw(s){if(!s)return It.Meters;switch(s.toLowerCase()){case"mm":case"mil":case"millimeters":case"millimetres":return It.Millimeters;case"cm":case"centimetre":case"centimeter":case"centimetres":case"centimeters":return It.Centimeters;case"m":case"meter":case"metre":case"meters":case"metres":default:return It.Meters;case"inches":case"inch":case"in":return It.Inches;case"feet":case"foot":case"ft":return It.Feet;case"yard":case"yards":case"yd":return It.Yards;case"miles":case"mile":case"mi":return It.Miles;case"km":case"kilometers":return It.Kilometers}}class Wi extends L0{get vertexProgram(){return`
#include <common>
#ifdef USE_RTE
    // The high component is stored as the default 'position' attribute buffer
    attribute vec3 position_low;
    uniform vec3 uViewer_high;
    uniform vec3 uViewer_low;
#endif

#ifdef TRANSFORM_STORAGE
    attribute float objIndex;

    #if TRANSFORM_STORAGE == 0
        #if __VERSION__ == 300
            #define TRANSFORM_STRIDE 4
        #else
            #define TRANSFORM_STRIDE 4.
        #endif
        uniform sampler2D tTransforms;
        uniform float objCount;
    #elif TRANSFORM_STORAGE == 1
        uniform mat4 uTransforms[OBJ_COUNT];
    #endif
#endif

#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

#ifdef USE_RTE
    highp vec4 computeRelativePosition(in highp vec3 position_low, in highp vec3 position_high, in highp vec3 relativeTo_low, in highp vec3 relativeTo_high){
        /* 
        Source https://github.com/virtualglobebook/OpenGlobe/blob/master/Source/Examples/Chapter05/Jitter/GPURelativeToEyeDSFUN90/Shaders/VS.glsl 
        Note here, we're storing the high part of the position encoding inside three's default 'position' attribute buffer so we avoid redundancy 
        */
        highp vec3 t1 = position_low.xyz - relativeTo_low.xyz;
        highp vec3 e = t1 - position_low.xyz;
        /** This is redunant, but necessary as a workaround for Apple platforms */
        highp float x = position_high.x - relativeTo_high.x;
        highp float y = position_high.y - relativeTo_high.y;
        highp float z = position_high.z - relativeTo_high.z;
        highp vec3 v = vec3(x, y, z);
        /** End of redundant part */
        highp vec3 t2 = ((-relativeTo_low - e) + (position_low.xyz - (t1 - e))) + v;
        highp vec3 highDifference = t1 + t2;
        highp vec3 lowDifference = t2 - (highDifference.xyz - t1.xyz);
        
        highp vec3 position = highDifference.xyz + lowDifference.xyz;
        return vec4(position, 1.);
    }   
#endif

#ifdef TRANSFORM_STORAGE
    void objectTransform(out vec4 quaternion, out vec4 pivotLow, out vec4 pivotHigh, out vec4 translation, out vec4 scale){
        #if TRANSFORM_STORAGE == 0
            #if __VERSION__ == 300
                ivec2 uv = ivec2(int(objIndex) * TRANSFORM_STRIDE, 0); 
                vec4 v0 = texelFetch( tTransforms, uv, 0 );
                vec4 v1 = texelFetch( tTransforms, uv + ivec2(1, 0), 0);
                vec4 v2 = texelFetch( tTransforms, uv + ivec2(2, 0), 0);
                vec4 v3 = texelFetch( tTransforms, uv + ivec2(3, 0), 0);
                quaternion = v0;
                pivotLow = vec4(v1.xyz, 1.);
                pivotHigh = vec4(v2.xyz, 1.);
                translation = vec4(v3.xyz, 1.);
                scale = vec4(v1.w, v2.w, v3.w, 1.);
            #else
                float size = objCount * TRANSFORM_STRIDE;
                vec2 cUv = vec2(0.5/size, 0.5);
                vec2 dUv = vec2(1./size, 0.);
                
                vec2 uv = vec2((objIndex * TRANSFORM_STRIDE)/size + cUv.x, cUv.y);
                vec4 v0 = texture2D( tTransforms, uv);
                vec4 v1 = texture2D( tTransforms, uv + dUv);
                vec4 v2 = texture2D( tTransforms, uv + 2. * dUv);
                vec4 v3 = texture2D( tTransforms, uv + 3. * dUv);
                quaternion = v0;
                pivotLow = vec4(v1.xyz, 1.);
                pivotHigh = vec4(v2.xyz, 1.);
                translation = vec4(v3.xyz, 1.);
                scale = vec4(v1.w, v2.w, v3.w, 1.);
            #endif
        #elif TRANSFORM_STORAGE == 1
            mat4 tMatrix = uTransforms[int(objIndex)];
            quaternion = tMatrix[0];
            pivotLow = vec4(tMatrix[1].xyz, 1.);
            pivotHigh = vec4(tMatrix[2].xyz, 1.);
            translation = vec4(tMatrix[3].xyz, 1.);
            scale = vec4(tMatrix[1][3], tMatrix[2][3], tMatrix[3][3], 1.);
        #endif
    }

    vec3 rotate_vertex_position(vec3 position, vec4 quat)
    { 
        return position + 2.0 * cross(quat.xyz, cross(quat.xyz, position) + quat.w * position);
    }

    /** Another workaround for Apple's stupid compiler */
    vec4 safeMul(vec4 a, vec4 b) {
        // Prevents constant folding and optimization
        return (a + vec4(0.0)) * (b + vec4(1.0)) - a * vec4(1.0);
    }

    highp vec3 rotate_scaled_vertex_position_delta(highp vec4 v0, highp vec4 v1, highp vec4 scale, highp vec4 quat)
    {
        /** !!! WORKAROUND FOR Intel IrisXe CARDS !!! */
        /** The code below will not produce correct results in intel IrisXE integrated GPUs. 
         *  The geometry will turn mangled, albeit stable
         *  I can't know for sure what is going on, but rotating the difference seems to 
         *  force the result into a lower precision?
         */
        // highp vec4 position = v0 - v1;
        // return position.xyz + 2.0 * cross(quat.xyz, cross(quat.xyz, position.xyz) + quat.w * position.xyz);

        /** Subtracting the rotated vectors works. */
        return rotate_vertex_position(safeMul(v0, scale).xyz, quat)  - rotate_vertex_position(safeMul(v1, scale).xyz, quat) ;

        /** An alternate workaround is
         * highp vec3 position = (v0.xyz * (1. + 1e-7)) - (v1.xyz * (1. + 1e-7));
           return position + 2.0 * cross(quat.xyz, cross(quat.xyz, position) + quat.w * position);

           However I'm not such a fan of the (1. + 1e-7) part
         */
    }

#endif

#if defined(BILLBOARD) || defined(BILLBOARD_FIXED)
    uniform vec3 billboardPos;
    uniform mat4 invProjection;
#endif
#ifdef BILLBOARD_FIXED
    uniform vec2 billboardSize;
    uniform vec2 billboardOffset;
#endif

void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	// #include <project_vertex> COMMENTED CHUNK
    #ifdef TRANSFORM_STORAGE
        vec4 tQuaternion, tPivotLow, tPivotHigh, tTranslation, tScale;
        objectTransform(tQuaternion, tPivotLow, tPivotHigh, tTranslation, tScale);
    #endif
    #ifdef USE_RTE
        vec4 position_lowT = vec4(position_low, 1.);
        vec4 position_highT = vec4(position, 1.);
        const vec3 ZERO3 = vec3(0., 0., 0.);

        highp vec4 rteLocalPosition = computeRelativePosition(position_lowT.xyz, position_highT.xyz, uViewer_low, uViewer_high);
        #ifdef TRANSFORM_STORAGE
            highp vec4 rtePivot = computeRelativePosition(tPivotLow.xyz, tPivotHigh.xyz, uViewer_low, uViewer_high);
            rteLocalPosition.xyz = rotate_scaled_vertex_position_delta(rteLocalPosition, rtePivot, tScale, tQuaternion) + rtePivot.xyz + tTranslation.xyz;
        #endif
        #ifdef USE_INSTANCING
            vec4 instancePivot = computeRelativePosition(ZERO3, ZERO3, uViewer_low, uViewer_high);
            rteLocalPosition.xyz = (mat3(instanceMatrix) * (rteLocalPosition - instancePivot).xyz) + instancePivot.xyz + instanceMatrix[3].xyz;
        #endif
    #endif

    #ifdef USE_RTE
        vec4 mvPosition = rteLocalPosition;
    #else
        vec4 mvPosition = vec4( transformed, 1.0 );
        #ifdef TRANSFORM_STORAGE
            mvPosition.xyz = rotate_scaled_vertex_position_delta(mvPosition, tPivotHigh, tScale, tQuaternion) + tPivotHigh.xyz + tTranslation.xyz;
        #endif
        #ifdef USE_INSTANCING
            mvPosition = instanceMatrix * mvPosition;
        #endif
    #endif
    
    mvPosition = modelViewMatrix * mvPosition;
    
    #if defined(BILLBOARD)
        float div = 1.;
        gl_Position = projectionMatrix * (viewMatrix * vec4(billboardPos, 1.0) + vec4(position.x, position.y, 0., 0.0));
    #elif defined(BILLBOARD_FIXED)
        gl_Position = projectionMatrix * (viewMatrix * vec4(billboardPos, 1.0));
        float div = gl_Position.w;
        gl_Position /= gl_Position.w;
        gl_Position.xy += (position.xy + billboardOffset) * billboardSize;
    #else
        gl_Position = projectionMatrix * mvPosition;
    #endif


	#include <logdepthbuf_vertex>
	// #include <clipping_planes_vertex> COMMENTED CHUNK
    #if NUM_CLIPPING_PLANES > 0
        #if defined(BILLBOARD) || defined(BILLBOARD_FIXED)
            vec4 movelViewProjection = gl_Position * div;
            vClipPosition = - (invProjection * movelViewProjection).xyz;
        #else
	        vClipPosition = - mvPosition.xyz;
        #endif
    #endif
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}
`}get fragmentProgram(){return`
uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	// accumulation (baked indirect lighting only)
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	// modulation
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	// #include <output_fragment> COMMENTED CHUNK
	#ifdef OPAQUE
		diffuseColor.a = 1.0;
	#endif

	// https://github.com/mrdoob/three.js/pull/22425
	#ifdef USE_TRANSMISSION
		diffuseColor.a *= transmissionAlpha + 0.1;
	#endif

	gl_FragColor = vec4( outgoingLight * diffuseColor.a, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}
`}get baseUniforms(){return Xn.basic.uniforms}get uniformsDef(){return{uViewer_high:new T,uViewer_low:new T,uTransforms:[new Ne],tTransforms:null,billboardPos:new T,billboardSize:new Me,billboardOffset:new Me,invProjection:new Ne,objCount:1}}set billboardPixelHeight(e){this._billboardPixelHeight=e}set billboardOffset(e){this._billboardOffset.copy(e)}constructor(e,t=[]){super(e),this._billboardOffset=new Me,this.init(t)}customProgramCacheKey(){return this.constructor.name}copy(e){return super.copy(e),this.copyFrom(e),this}fastCopy(e,t){super.fastCopy(e,t);const n=t,i=e;n.color.copy(i.color),n.refractionRatio=i.refractionRatio,t.userData.billboardPos.value.copy(e.userData.billboardPos.value)}onBeforeRender(e,t,n,i,r){if(this.defines&&this.defines.BILLBOARD_FIXED){const a=e.getDrawingBufferSize(Wi.vecBuff);Wi.vecBuff.set(this._billboardPixelHeight/a.x*2,this._billboardPixelHeight/a.y*2),this.userData.billboardSize.value.copy(Wi.vecBuff),this.userData.billboardOffset.value.copy(this._billboardOffset),Wi.matBuff.copy(n.projectionMatrix).invert(),this.userData.invProjection.value.copy(Wi.matBuff),this.needsUpdate=!0}this.defines&&this.defines.USE_RTE&&(r.modelViewMatrix.copy(e.RTEBuffers.rteViewModelMatrix),this.userData.uViewer_low.value.copy(e.RTEBuffers.viewerLow),this.userData.uViewer_high.value.copy(e.RTEBuffers.viewerHigh),this.needsUpdate=!0)}}Wi.matBuff=new Ne,Wi.vecBuff=new Me;class Cu extends Wi{get vertexProgram(){return`
#include <common>
#ifdef USE_RTE
    // The high component is stored as the default 'position' attribute buffer
    attribute vec3 position_low;
    uniform vec3 uViewer_high;
    uniform vec3 uViewer_low;
#endif

#ifdef TRANSFORM_STORAGE
    attribute float objIndex;

    #if TRANSFORM_STORAGE == 0
        #if __VERSION__ == 300
            #define TRANSFORM_STRIDE 4
        #else
            #define TRANSFORM_STRIDE 4.
        #endif
        uniform sampler2D tTransforms;
        uniform float objCount;
    #elif TRANSFORM_STORAGE == 1
        uniform mat4 uTransforms[OBJ_COUNT];
    #endif
#endif

#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

#ifdef TRANSFORM_STORAGE
    void objectTransform(out vec4 quaternion, out vec4 pivotLow, out vec4 pivotHigh, out vec4 translation, out vec4 scale){
        #if TRANSFORM_STORAGE == 0
            #if __VERSION__ == 300
                ivec2 uv = ivec2(int(objIndex) * TRANSFORM_STRIDE, 0); 
                vec4 v0 = texelFetch( tTransforms, uv, 0 );
                vec4 v1 = texelFetch( tTransforms, uv + ivec2(1, 0), 0);
                vec4 v2 = texelFetch( tTransforms, uv + ivec2(2, 0), 0);
                vec4 v3 = texelFetch( tTransforms, uv + ivec2(3, 0), 0);
                quaternion = v0;
                pivotLow = vec4(v1.xyz, 1.);
                pivotHigh = vec4(v2.xyz, 1.);
                translation = vec4(v3.xyz, 1.);
                scale = vec4(v1.w, v2.w, v3.w, 1.);
            #else
                float size = objCount * TRANSFORM_STRIDE;
                vec2 cUv = vec2(0.5/size, 0.5);
                vec2 dUv = vec2(1./size, 0.);
                
                vec2 uv = vec2((objIndex * TRANSFORM_STRIDE)/size + cUv.x, cUv.y);
                vec4 v0 = texture2D( tTransforms, uv);
                vec4 v1 = texture2D( tTransforms, uv + dUv);
                vec4 v2 = texture2D( tTransforms, uv + 2. * dUv);
                vec4 v3 = texture2D( tTransforms, uv + 3. * dUv);
                quaternion = v0;
                pivotLow = vec4(v1.xyz, 1.);
                pivotHigh = vec4(v2.xyz, 1.);
                translation = vec4(v3.xyz, 1.);
                scale = vec4(v1.w, v2.w, v3.w, 1.);
            #endif
        #elif TRANSFORM_STORAGE == 1
            mat4 tMatrix = uTransforms[int(objIndex)];
            quaternion = tMatrix[0];
            pivotLow = vec4(tMatrix[1].xyz, 1.);
            pivotHigh = vec4(tMatrix[2].xyz, 1.);
            translation = vec4(tMatrix[3].xyz, 1.);
            scale = vec4(tMatrix[1][3], tMatrix[2][3], tMatrix[3][3], 1.);
        #endif
    }

    vec3 rotate_vertex_position(vec3 position, vec4 quat)
    { 
        return position + 2.0 * cross(quat.xyz, cross(quat.xyz, position) + quat.w * position);
    }

   /** Another workaround for Apple's stupid compiler */
    vec4 safeMul(vec4 a, vec4 b) {
        // Prevents constant folding and optimization
        return (a + vec4(0.0)) * (b + vec4(1.0)) - a * vec4(1.0);
    }

    highp vec3 rotate_scaled_vertex_position_delta(highp vec4 v0, highp vec4 v1, highp vec4 scale, highp vec4 quat)
    {
        /** !!! WORKAROUND FOR Intel IrisXe CARDS !!! */
        /** The code below will not produce correct results in intel IrisXE integrated GPUs. 
         *  The geometry will turn mangled, albeit stable
         *  I can't know for sure what is going on, but rotating the difference seems to 
         *  force the result into a lower precision?
         */
        // highp vec4 position = v0 - v1;
        // return position.xyz + 2.0 * cross(quat.xyz, cross(quat.xyz, position.xyz) + quat.w * position.xyz);

        /** Subtracting the rotated vectors works. */
        return rotate_vertex_position(safeMul(v0, scale).xyz, quat)  - rotate_vertex_position(safeMul(v1, scale).xyz, quat) ;

        /** An alternate workaround is
         * highp vec3 position = (v0.xyz * (1. + 1e-7)) - (v1.xyz * (1. + 1e-7));
           return position + 2.0 * cross(quat.xyz, cross(quat.xyz, position) + quat.w * position);

           However I'm not such a fan of the (1. + 1e-7) part
         */
    }
#endif

#ifdef USE_RTE
    highp vec4 computeRelativePosition(in highp vec3 position_low, in highp vec3 position_high, in highp vec3 relativeTo_low, in highp vec3 relativeTo_high){
        /* 
        Source https://github.com/virtualglobebook/OpenGlobe/blob/master/Source/Examples/Chapter05/Jitter/GPURelativeToEyeDSFUN90/Shaders/VS.glsl 
        Note here, we're storing the high part of the position encoding inside three's default 'position' attribute buffer so we avoid redundancy 
        */
        highp vec3 t1 = position_low.xyz - relativeTo_low.xyz;
        highp vec3 e = t1 - position_low.xyz;
        /** This is redunant, but necessary as a workaround for Apple platforms */
        highp float x = position_high.x - relativeTo_high.x;
        highp float y = position_high.y - relativeTo_high.y;
        highp float z = position_high.z - relativeTo_high.z;
        highp vec3 v = vec3(x, y, z);
        /** End of redundant part */
        highp vec3 t2 = ((-relativeTo_low - e) + (position_low.xyz - (t1 - e))) + v;
        highp vec3 highDifference = t1 + t2;
        highp vec3 lowDifference = t2 - (highDifference.xyz - t1.xyz);
        
        highp vec3 position = highDifference.xyz + lowDifference.xyz;
        return vec4(position, 1.);
    }
#endif

void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	// #include <project_vertex> COMMENTED CHUNK
    #ifdef TRANSFORM_STORAGE
        vec4 tQuaternion, tPivotLow, tPivotHigh, tTranslation, tScale;
        objectTransform(tQuaternion, tPivotLow, tPivotHigh, tTranslation, tScale);
    #endif
    #ifdef USE_RTE
        vec4 position_lowT = vec4(position_low, 1.);
        vec4 position_highT = vec4(position, 1.);
        const vec3 ZERO3 = vec3(0., 0., 0.);

        highp vec4 rteLocalPosition = computeRelativePosition(position_lowT.xyz, position_highT.xyz, uViewer_low, uViewer_high);
        #ifdef TRANSFORM_STORAGE
            highp vec4 rtePivot = computeRelativePosition(tPivotLow.xyz, tPivotHigh.xyz, uViewer_low, uViewer_high);
            rteLocalPosition.xyz = rotate_scaled_vertex_position_delta(rteLocalPosition, rtePivot, tScale, tQuaternion) + rtePivot.xyz + tTranslation.xyz;
        #endif
        #ifdef USE_INSTANCING
            vec4 instancePivot = computeRelativePosition(ZERO3, ZERO3, uViewer_low, uViewer_high);
            rteLocalPosition.xyz = (mat3(instanceMatrix) * (rteLocalPosition - instancePivot).xyz) + instancePivot.xyz + instanceMatrix[3].xyz;
        #endif
    #endif

    #ifdef USE_RTE
        vec4 mvPosition = rteLocalPosition;
    #else
        vec4 mvPosition = vec4( transformed, 1.0 );
        #ifdef TRANSFORM_STORAGE
            mvPosition.xyz = rotate_scaled_vertex_position_delta(mvPosition, tPivotHigh, tScale, tQuaternion) + tPivotHigh.xyz + tTranslation.xyz;
        #endif
        #ifdef USE_INSTANCING
            mvPosition = instanceMatrix * mvPosition;
        #endif
    #endif
    
    mvPosition = modelViewMatrix * mvPosition;

    gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}
`}get fragmentProgram(){return`
uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
    // We're disabling alpha testing because we need to use it for shadow rejection. Three.js gave me no choice
	// #include <alphatest_fragment> 
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	// accumulation (baked indirect lighting only)
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	// modulation
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}
`}constructor(e,t=[]){super(e,t)}}class Bi extends L0{get vertexProgram(){return`
#include <common>
#ifdef USE_RTE
    // The high component is stored as the default 'position' attribute buffer
    attribute vec3 position_low;
    uniform vec3 uViewer_high;
    uniform vec3 uViewer_low;
#endif

#ifdef TRANSFORM_STORAGE
    attribute float objIndex;

    #if TRANSFORM_STORAGE == 0
        #if __VERSION__ == 300
            #define TRANSFORM_STRIDE 4
        #else
            #define TRANSFORM_STRIDE 4.
        #endif
        uniform sampler2D tTransforms;
        uniform float objCount;
    #elif TRANSFORM_STORAGE == 1
        uniform mat4 uTransforms[OBJ_COUNT];
    #endif
#endif

#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

#ifdef USE_RTE
    highp vec4 computeRelativePosition(in highp vec3 position_low, in highp vec3 position_high, in highp vec3 relativeTo_low, in highp vec3 relativeTo_high){
        /* 
        Source https://github.com/virtualglobebook/OpenGlobe/blob/master/Source/Examples/Chapter05/Jitter/GPURelativeToEyeDSFUN90/Shaders/VS.glsl 
        Note here, we're storing the high part of the position encoding inside three's default 'position' attribute buffer so we avoid redundancy 
        */
        highp vec3 t1 = position_low.xyz - relativeTo_low.xyz;
        highp vec3 e = t1 - position_low.xyz;
        /** This is redunant, but necessary as a workaround for Apple platforms */
        highp float x = position_high.x - relativeTo_high.x;
        highp float y = position_high.y - relativeTo_high.y;
        highp float z = position_high.z - relativeTo_high.z;
        highp vec3 v = vec3(x, y, z);
        /** End of redundant part */
        highp vec3 t2 = ((-relativeTo_low - e) + (position_low.xyz - (t1 - e))) + v;
        highp vec3 highDifference = t1 + t2;
        highp vec3 lowDifference = t2 - (highDifference.xyz - t1.xyz);
        
        highp vec3 position = highDifference.xyz + lowDifference.xyz;
        return vec4(position, 1.);
    }
#endif

#ifdef TRANSFORM_STORAGE
    void objectTransform(out vec4 quaternion, out vec4 pivotLow, out vec4 pivotHigh, out vec4 translation, out vec4 scale){
        #if TRANSFORM_STORAGE == 0
            #if __VERSION__ == 300
                ivec2 uv = ivec2(int(objIndex) * TRANSFORM_STRIDE, 0); 
                vec4 v0 = texelFetch( tTransforms, uv, 0 );
                vec4 v1 = texelFetch( tTransforms, uv + ivec2(1, 0), 0);
                vec4 v2 = texelFetch( tTransforms, uv + ivec2(2, 0), 0);
                vec4 v3 = texelFetch( tTransforms, uv + ivec2(3, 0), 0);
                quaternion = v0;
                pivotLow = vec4(v1.xyz, 1.);
                pivotHigh = vec4(v2.xyz, 1.);
                translation = vec4(v3.xyz, 1.);
                scale = vec4(v1.w, v2.w, v3.w, 1.);
            #else
                float size = objCount * TRANSFORM_STRIDE;
                vec2 cUv = vec2(0.5/size, 0.5);
                vec2 dUv = vec2(1./size, 0.);
                
                vec2 uv = vec2((objIndex * TRANSFORM_STRIDE)/size + cUv.x, cUv.y);
                vec4 v0 = texture2D( tTransforms, uv);
                vec4 v1 = texture2D( tTransforms, uv + dUv);
                vec4 v2 = texture2D( tTransforms, uv + 2. * dUv);
                vec4 v3 = texture2D( tTransforms, uv + 3. * dUv);
                quaternion = v0;
                pivotLow = vec4(v1.xyz, 1.);
                pivotHigh = vec4(v2.xyz, 1.);
                translation = vec4(v3.xyz, 1.);
                scale = vec4(v1.w, v2.w, v3.w, 1.);
            #endif
        #elif TRANSFORM_STORAGE == 1
            mat4 tMatrix = uTransforms[int(objIndex)];
            quaternion = tMatrix[0];
            pivotLow = vec4(tMatrix[1].xyz, 1.);
            pivotHigh = vec4(tMatrix[2].xyz, 1.);
            translation = vec4(tMatrix[3].xyz, 1.);
            scale = vec4(tMatrix[1][3], tMatrix[2][3], tMatrix[3][3], 1.);
        #endif
    }

    vec3 rotate_vertex_position(vec3 position, vec4 quat)
    { 
        return position + 2.0 * cross(quat.xyz, cross(quat.xyz, position) + quat.w * position);
    }

    /** Another workaround for Apple's stupid compiler */
    vec4 safeMul(vec4 a, vec4 b) {
        // Prevents constant folding and optimization
        return (a + vec4(0.0)) * (b + vec4(1.0)) - a * vec4(1.0);
    }

    highp vec3 rotate_scaled_vertex_position_delta(highp vec4 v0, highp vec4 v1, highp vec4 scale, highp vec4 quat)
    {
        /** !!! WORKAROUND FOR Intel IrisXe CARDS !!! */
        /** The code below will not produce correct results in intel IrisXE integrated GPUs. 
         *  The geometry will turn mangled, albeit stable
         *  I can't know for sure what is going on, but rotating the difference seems to 
         *  force the result into a lower precision?
         */
        // highp vec4 position = v0 - v1;
        // return position.xyz + 2.0 * cross(quat.xyz, cross(quat.xyz, position.xyz) + quat.w * position.xyz);

        /** Subtracting the rotated vectors works. */
        return rotate_vertex_position(safeMul(v0, scale).xyz, quat)  - rotate_vertex_position(safeMul(v1, scale).xyz, quat) ;

        /** An alternate workaround is
         * highp vec3 position = (v0.xyz * (1. + 1e-7)) - (v1.xyz * (1. + 1e-7));
           return position + 2.0 * cross(quat.xyz, cross(quat.xyz, position) + quat.w * position);

           However I'm not such a fan of the (1. + 1e-7) part
         */
    }

#endif

#if defined(BILLBOARD) || defined(BILLBOARD_FIXED)
    uniform vec3 billboardPos;
    uniform mat4 invProjection;
#endif
#ifdef BILLBOARD_FIXED
    uniform vec2 billboardSize;
#endif

void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	// #include <project_vertex> COMMENTED CHUNK
    #ifdef TRANSFORM_STORAGE
        vec4 tQuaternion, tPivotLow, tPivotHigh, tTranslation, tScale;
        objectTransform(tQuaternion, tPivotLow, tPivotHigh, tTranslation, tScale);
    #endif
    #ifdef USE_RTE
        vec4 position_lowT = vec4(position_low, 1.);
        vec4 position_highT = vec4(position, 1.);
        const vec3 ZERO3 = vec3(0., 0., 0.);

        highp vec4 rteLocalPosition = computeRelativePosition(position_lowT.xyz, position_highT.xyz, uViewer_low, uViewer_high);
        #ifdef TRANSFORM_STORAGE
            highp vec4 rtePivot = computeRelativePosition(tPivotLow.xyz, tPivotHigh.xyz, uViewer_low, uViewer_high);
            rteLocalPosition.xyz = rotate_scaled_vertex_position_delta(rteLocalPosition, rtePivot, tScale, tQuaternion) + rtePivot.xyz + tTranslation.xyz;
        #endif
        #ifdef USE_INSTANCING
            vec4 instancePivot = computeRelativePosition(ZERO3, ZERO3, uViewer_low, uViewer_high);
            rteLocalPosition.xyz = (mat3(instanceMatrix) * (rteLocalPosition - instancePivot).xyz) + instancePivot.xyz + instanceMatrix[3].xyz;
        #endif
    #endif

    #ifdef USE_RTE
        vec4 mvPosition = rteLocalPosition;
    #else
        vec4 mvPosition = vec4( transformed, 1.0 );
        #ifdef TRANSFORM_STORAGE
            mvPosition.xyz = rotate_scaled_vertex_position_delta(mvPosition, tPivotHigh, tScale, tQuaternion) + tPivotHigh.xyz + tTranslation.xyz;
        #endif
        #ifdef USE_INSTANCING
            mvPosition = instanceMatrix * mvPosition;
        #endif
    #endif
    
    mvPosition = modelViewMatrix * mvPosition;
    
    #if defined(BILLBOARD)
        float div = 1.;
        gl_Position = projectionMatrix * (viewMatrix * vec4(billboardPos, 1.0) + vec4(position.x, position.y, 0., 0.0));
    #elif defined(BILLBOARD_FIXED)
        gl_Position = projectionMatrix * (viewMatrix * vec4(billboardPos, 1.0));
        float div = gl_Position.w;
        gl_Position /= gl_Position.w;
        gl_Position.xy += position.xy * billboardSize;
    #else
        gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.);
    #endif
	#include <logdepthbuf_vertex>
	// #include <clipping_planes_vertex> COMMENTED CHUNK
    #if NUM_CLIPPING_PLANES > 0
        #if defined(BILLBOARD) || defined(BILLBOARD_FIXED)
            vec4 movelViewProjection = gl_Position * div;
            vClipPosition = - (invProjection * movelViewProjection).xyz;
        #else
	        vClipPosition = - mvPosition.xyz;
        #endif
    #endif
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}
`}get fragmentProgram(){return`
uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	// accumulation (baked indirect lighting only)
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	// modulation
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}
`}get baseUniforms(){return Xn.basic.uniforms}get uniformsDef(){return{uViewer_high:new T,uViewer_low:new T,uTransforms:[new Ne],tTransforms:null,objCount:1,billboardPos:new T,billboardSize:new Me,invProjection:new Ne}}set billboardPixelHeight(e){this._billboardPixelHeight=e}get billboardPixelHeight(){return this._billboardPixelHeight}constructor(e,t=[]){super(e),this.init(t)}customProgramCacheKey(){return this.constructor.name}copy(e){return super.copy(e),this.copyFrom(e),this}getDerivedMaterial(){const e=q1(this);for(const t in this.userData)e.uniforms[t]=this.userData[t];return e}fastCopy(e,t){super.fastCopy(e,t);const n=t,i=e;n.color.copy(i.color),n.refractionRatio=i.refractionRatio,t.userData.billboardPos.value.copy(e.userData.billboardPos.value)}onBeforeRender(e,t,n,i,r){if(this.defines&&this.defines.BILLBOARD_FIXED){const a=e.getDrawingBufferSize(Bi.vecBuff);Bi.vecBuff.set(this._billboardPixelHeight/a.x*2,this._billboardPixelHeight/a.y*2),this.userData.billboardSize.value.copy(Bi.vecBuff),Bi.matBuff.copy(n.projectionMatrix).invert(),this.userData.invProjection.value.copy(Bi.matBuff)}this.needsUpdate=!0}}Bi.matBuff=new Ne,Bi.vecBuff=new Me;class bv extends kl{get vertexProgram(){return bA}get fragmentProgram(){return AA}get uniformsDef(){return{...super.uniformsDef,gradientRamp:null}}constructor(e,t=["USE_GRADIENT_RAMP"]){super(e,t)}setGradientTexture(e){this.userData.gradientRamp.value=e,this.userData.gradientRamp.value.generateMipmaps=!1,this.userData.gradientRamp.value.minFilter=wn,this.userData.gradientRamp.value.magFilter=wn,this.needsUpdate=!0}fastCopy(e,t){super.fastCopy(e,t),t.userData.gradientRamp.value=e.userData.gradientRamp.value}}var Zt;const Jd={id:"defaultGradient",src:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAABCAIAAAAn2YEhAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAHoSURBVDhPTZRRdoMwDAQx9//seaEzI5sXpwFptVqvMOm6/t7retd1Le8XAdF6+SMEYr03l2fF4GJprcfixl4+tyklG6ZvxeAKWGxBQsKDk9FIdD+pDUFiak9IDQEWMAM4dczEZmWSDOXPBuAQ1OCLYI4bc0S0bbnlFOR6Vgo2WwgraIvgbh8L2ZNxRH5T7QWKyKz9E7kNnUE+KTA3Oz6O3YIOkop+4juHoh1H+m3slByVm9vgOCOoXr7HvBJSjLdJRUHuSrbse+jDiZOPPt/jZIv8WPJeW+JVzYj2CIHc9GaEjmc/OhF3C+neQoBgW/KKZx2VuyxFKqDBNwfqA8NXa7p0781GBT6TPkSOozQPMPer4sBqTrvZUZgqSKP5oaCXXirJdZ4jqyRbtyE8amCkLLkzW9qik7Fx9mWE9pHEh9vMHsIawZSPcxut2DcDyjzeKinisypDwQoKnLU5WVLz7pGO/nbrIhC2MMOaGrj8PRLmfKpSJcT4NZn5wFgbKbVlCzia76HbQZMAjP72IyX94v189i7Ewfa2wcdMTfGOqekE2i/O9LZRi/T8qwFuuvknA3kW/YnLTMVO22OwUXg0OZ1IAdeqcEjXffH2jjEqNmSvRZbF43BLuUPsYsk5XPu3NqD3WKzr/QfN+6p+JpC7ZQAAAABJRU5ErkJggg==",type:Na.TEXTURE_8BPP};var _s,Bt;(function(s){s[s.GHOST=0]="GHOST",s[s.GRADIENT=1]="GRADIENT",s[s.COLORED=2]="COLORED",s[s.HIDDEN=3]="HIDDEN"})(_s||(_s={}));class ln{constructor(){this.materialMap={}}static renderMaterialFromNode(e,t){if(!e)return null;let n=null;return e.model.raw.renderMaterial&&(n={id:e.model.raw.renderMaterial.id,color:e.model.raw.renderMaterial.diffuse,emissive:e.model.raw.renderMaterial.emissive,opacity:e.model.raw.renderMaterial.opacity!==void 0?e.model.raw.renderMaterial.opacity:1,roughness:e.model.raw.renderMaterial.roughness,metalness:e.model.raw.renderMaterial.metalness,vertexColors:t&&t.model.raw.colors&&t.model.raw.colors.length>0}),n}static displayStyleFromNode(e){if(!e)return null;let t=null;if(e.model.raw.displayStyle){let n=e.model.raw.displayStyle.lineweight||0;const i=e.model.raw.displayStyle.units;n=i?n*Qn(i):0,n=n<.001?0:n,t={id:e.model.raw.displayStyle.id,color:e.model.raw.displayStyle.diffuse||e.model.raw.displayStyle.color,lineWeight:n}}else e.model.raw.renderMaterial&&(t={id:e.model.raw.renderMaterial.id,color:e.model.raw.renderMaterial.diffuse,lineWeight:0});return t}static colorMaterialFromNode(e){if(!e)return null;let t=null;return e.model.color&&(t={color:e.model.color}),t}static fastCopy(e,t){t.fastCopy(e,t)}static renderMaterialToString(e){return e.color.toString()+"/"+e.opacity.toString()+"/"+e.roughness.toString()+"/"+e.metalness.toString()}static displayStyleToString(e){var t,n,i;return((t=e.color)===null||t===void 0?void 0:t.toString())+"/"+((n=e.lineWeight)===null||n===void 0?void 0:n.toString())+((i=e.opacity)===null||i===void 0?void 0:i.toString())}static minimalMaterialToString(e){return e.color.toString()}static hashCode(e){let t=0;for(let n=0;n<e.length;n++)t=Math.imul(31,t)+e.charCodeAt(n)|0;return t}static isMaterialInstance(e){return e instanceof di}static isFilterMaterial(e){return"filterType"in e}static isRenderMaterial(e){return"color"in e&&"opacity"in e&&"roughness"in e&&"metalness"in e&&"vertexColors"in e}static isDisplayStyle(e){return"color"in e&&"lineWeight"in e}static getMaterialHash(e,t){const n=e.renderData.colorMaterial;let i="";const r=n&&!t&&(e.geometryType===mt.LINE||e.geometryType===mt.POINT),a=e.geometryType===mt.LINE;t||(t=a?e.renderData.displayStyle||e.renderData.renderMaterial:e.renderData.renderMaterial||e.renderData.displayStyle),r?i+=Zt.minimalMaterialToString(n):t&&(i=!Zt.isRenderMaterial(t)||e.geometryType!==mt.MESH&&e.geometryType!==mt.POINT&&e.geometryType!==mt.TEXT?Zt.isDisplayStyle(t)&&e.geometryType!==mt.MESH?Zt.displayStyleToString(t):Zt.isRenderMaterial(t)?Zt.renderMaterialToString(t):"":Zt.renderMaterialToString(t),t.stencilOutlines&&(i+="/"+t.stencilOutlines),t.pointSize&&(i+="/"+t.pointSize));let o="";e.renderData.geometry.attributes&&(o=e.renderData.geometry.attributes.COLOR?"vertexColors":"");const l=e.geometryType.toString()+o+i+(e.geometryType===mt.TEXT?e.renderData.id:"")+(e.renderData.geometry.instanced?"instanced":"");return Zt.hashCode(l)}static isTransparent(e){return e.transparent===!0&&e.opacity<1}static isOpaque(e){return e.transparent===!1||e.transparent===!0&&e.opacity>=1}static isSpeckleMaterial(e){return"speckleUserData"in e}async createDefaultMeshMaterials(){this.meshGhostMaterial=new Cu({color:16777215,side:gr,transparent:!0,opacity:.1}),this.meshGhostMaterial.depthWrite=!1,this.meshGhostMaterial.alphaTest=1,this.meshGradientMaterial=new Xl({side:Qt,transparent:!1,opacity:1}),this.meshGradientMaterial.setGradientTexture(await pr.getTexture(Jd)),this.meshGradientMaterial.clipShadows=!0,this.meshTransparentGradientMaterial=new Xl({side:Qt,transparent:!0,opacity:.5}),this.meshTransparentGradientMaterial.setGradientTexture(await pr.getTexture(Jd)),this.meshTransparentGradientMaterial.clipShadows=!0,this.meshColoredMaterial=new Xl({side:Qt,transparent:!1,wireframe:!1}),this.meshColoredMaterial.clipShadows=!0,this.meshTransparentColoredMaterial=new Xl({side:Qt,transparent:!0,opacity:.5}),this.meshHiddenMaterial=new ks({side:Qt,transparent:!1,opacity:1,wireframe:!1}),this.meshHiddenMaterial.visible=!1}async createLineDefaultMaterials(){this.lineGhostMaterial=new Ca({color:16777215,linewidth:1,worldUnits:!1,vertexColors:!0,alphaToCoverage:!1,resolution:new Me}),this.lineGhostMaterial.color=new ot(16777215),this.lineGhostMaterial.linewidth=1,this.lineGhostMaterial.worldUnits=!0,this.lineGhostMaterial.vertexColors=!0,this.lineGhostMaterial.pixelThreshold=.5,this.lineGhostMaterial.resolution=new Me,this.lineGhostMaterial.toneMapped=!1,this.lineGhostMaterial.opacity=.1,this.lineGhostMaterial.transparent=!0,this.lineColoredMaterial=new Ca({color:16777215,linewidth:1,worldUnits:!1,vertexColors:!0,alphaToCoverage:!1,resolution:new Me}),this.lineColoredMaterial.color=new ot(16777215),this.lineColoredMaterial.linewidth=1,this.lineColoredMaterial.worldUnits=!1,this.lineColoredMaterial.vertexColors=!0,this.lineColoredMaterial.pixelThreshold=.5,this.lineColoredMaterial.resolution=new Me,this.lineColoredMaterial.toneMapped=!1,this.lineHiddenMaterial=new Ca({color:16777215,linewidth:1,worldUnits:!1,vertexColors:!0,alphaToCoverage:!1,resolution:new Me}),this.lineHiddenMaterial.color=new ot(16711680),this.lineHiddenMaterial.linewidth=1,this.lineHiddenMaterial.worldUnits=!1,this.lineHiddenMaterial.vertexColors=!0,this.lineHiddenMaterial.pixelThreshold=.5,this.lineHiddenMaterial.resolution=new Me,this.lineHiddenMaterial.visible=!1}async createDefaultPointMaterials(){this.pointGhostMaterial=new kl({color:16777215,vertexColors:!1,size:2,opacity:.01,sizeAttenuation:!1}),this.pointCloudColouredMaterial=new bv({color:16777215,vertexColors:!1,size:2,sizeAttenuation:!1},["USE_GRADIENT_RAMP"]),this.pointCloudColouredMaterial.toneMapped=!1,this.pointCloudGradientMaterial=new bv({color:16777215,vertexColors:!1,size:2,sizeAttenuation:!1},["USE_GRADIENT_RAMP"]),this.pointCloudGradientMaterial.setGradientTexture(await pr.getTexture(Jd)),this.pointGhostMaterial.toneMapped=!1}async createDefaultTextMaterials(){this.textGhostMaterial=new Bi({color:16777215,opacity:.1,side:Qt}),this.textGhostMaterial.transparent=this.textGhostMaterial.opacity<1,this.textGhostMaterial.depthWrite=!this.textGhostMaterial.transparent,this.textGhostMaterial.toneMapped=!1,this.textGhostMaterial.color.convertSRGBToLinear(),this.textGhostMaterial=this.textGhostMaterial.getDerivedMaterial(),this.textColoredMaterial=new Bi({color:16777215,opacity:1,side:Qt}),this.textColoredMaterial.transparent=this.textColoredMaterial.opacity<1,this.textColoredMaterial.depthWrite=!this.textColoredMaterial.transparent,this.textColoredMaterial.toneMapped=!1,this.textColoredMaterial.color.convertSRGBToLinear(),this.textColoredMaterial=this.textColoredMaterial.getDerivedMaterial(),this.textHiddenMaterial=new Bi({color:16777215,opacity:1,side:Qt}),this.textHiddenMaterial.visible=!1,this.textHiddenMaterial.toneMapped=!1,this.textHiddenMaterial.color.convertSRGBToLinear(),this.textHiddenMaterial=this.textHiddenMaterial.getDerivedMaterial()}async createDefaultNullMaterials(){this.materialMap[Zt.NullRenderMaterialHash]=new ks({color:8355711,emissive:0,roughness:1,metalness:0,side:Qt}),this.materialMap[Zt.NullRenderMaterialHash].color.convertSRGBToLinear(),this.materialMap[Zt.NullRenderMaterialVertexColorsHash]=new ks({color:16777215,emissive:0,roughness:1,metalness:0,side:Qt,vertexColors:!0}),this.materialMap[Zt.NullRenderMaterialVertexColorsHash].color.convertSRGBToLinear();const e=Zt.NullDisplayStyleHash;this.materialMap[e]=new Ca({color:8355711,linewidth:1,worldUnits:!1,vertexColors:!0,alphaToCoverage:!1,resolution:new Me}),this.materialMap[e].color=new ot(8355711),this.materialMap[e].color.convertSRGBToLinear(),this.materialMap[e].linewidth=1,this.materialMap[e].worldUnits=!1,this.materialMap[e].vertexColors=!0,this.materialMap[e].pixelThreshold=.5,this.materialMap[e].resolution=new Me,this.materialMap[Zt.NullTextDisplayStyle]=new Bi({color:8355711,opacity:1,side:Qt}),this.materialMap[Zt.NullTextDisplayStyle].transparent=!1,this.materialMap[Zt.NullTextDisplayStyle].depthWrite=!0,this.materialMap[Zt.NullTextDisplayStyle].toneMapped=!1,this.materialMap[Zt.NullTextDisplayStyle].color.convertSRGBToLinear(),this.materialMap[Zt.NullPointMaterialHash]=new kl({color:8355711,vertexColors:!1,size:2,sizeAttenuation:!1}),this.materialMap[Zt.NullPointMaterialHash].color.convertSRGBToLinear(),this.materialMap[Zt.NullPointCloudVertexColorsMaterialHash]=new kl({color:16777215,vertexColors:!0,size:2,sizeAttenuation:!1}),this.materialMap[Zt.NullPointCloudMaterialHash]=new kl({color:16777215,vertexColors:!1,size:2,sizeAttenuation:!1}),this.materialMap[Zt.NullRenderMaterialInstancedHash]=new ks({color:8355711,emissive:0,roughness:1,metalness:0,side:Qt}),this.materialMap[Zt.NullRenderMaterialInstancedHash].color.convertSRGBToLinear(),this.materialMap[Zt.NullRenderMaterialInstancedVertexColorHash]=new ks({color:16777215,emissive:0,roughness:1,metalness:0,side:Qt,vertexColors:!0}),this.materialMap[Zt.NullRenderMaterialInstancedVertexColorHash].color.convertSRGBToLinear()}async createDefaultMaterials(){await this.createDefaultMeshMaterials(),await this.createLineDefaultMaterials(),await this.createDefaultPointMaterials(),await this.createDefaultTextMaterials(),await this.createDefaultNullMaterials(),this.defaultGradientTextureData=await pr.getTextureData(Jd)}makeMeshMaterial(e){const t=new ks({color:e.color,emissive:0,roughness:e.roughness,metalness:e.metalness,opacity:e.opacity,side:Qt});return t.vertexColors=e.vertexColors,t.transparent=t.opacity<1,t.depthWrite=!t.transparent,t.clipShadows=!0,t.color.convertSRGBToLinear(),t.emissive.convertSRGBToLinear(),t.updateArtificialRoughness(Zt.DEFAULT_ARTIFICIAL_ROUGHNESS),t}makeLineMaterial(e){const t=new Ca({color:e.color,linewidth:e.lineWeight>0?e.lineWeight:1,worldUnits:e.lineWeight>0,vertexColors:!0,alphaToCoverage:!1,resolution:new Me});return t.color=new ot(e.color),t.color.convertSRGBToLinear(),t.opacity=e.opacity!==void 0?e.opacity:1,t.linewidth=e.lineWeight>0?e.lineWeight:1,t.worldUnits=e.lineWeight>0,t.vertexColors=!0,t.pixelThreshold=.5,t.resolution=new Me,t.toneMapped=!1,t}makePointMaterial(e){const t=e.color===-16777216,n=e.vertexColors&&t?16777215:e.color,i=new kl({color:n,...e.opacity!==void 0&&{opacity:e.opacity},...e.vertexColors!==void 0&&{vertexColors:e.vertexColors},size:2,sizeAttenuation:!1});return i.opacity!==void 0&&(i.transparent=i.opacity<1),i.depthWrite=!i.transparent,i.toneMapped=!1,i.color.convertSRGBToLinear(),i}makeTextMaterial(e){if(!e)return this.materialMap[Zt.NullTextDisplayStyle];const t=new Bi({color:e.color,opacity:1,side:Qt});return t.transparent=t.opacity<1,t.depthWrite=!t.transparent,t.toneMapped=!1,t.color.convertSRGBToLinear(),t}getMaterial(e,t,n){let i;switch(n){case mt.MESH:i=this.getMeshMaterial(e,t);break;case mt.LINE:i=this.getLineMaterial(e,t);break;case mt.POINT:i=this.getPointMaterial(e,t);break;case mt.POINT_CLOUD:i=this.getPointCloudMaterial(e,t);break;case mt.TEXT:i=this.getTextMaterial(e,t)}return i.clippingPlanes=[],i}getMeshMaterial(e,t){return this.materialMap[e]||(this.materialMap[e]=this.makeMeshMaterial(t)),this.materialMap[e]}getLineMaterial(e,t){return this.materialMap[e]||(this.materialMap[e]=this.makeLineMaterial(t)),this.materialMap[e]}getPointMaterial(e,t){return this.materialMap[e]||(this.materialMap[e]=this.makePointMaterial(t)),this.materialMap[e]}getPointCloudMaterial(e,t){return this.materialMap[e]||(this.materialMap[e]=this.getPointMaterial(e,t)),this.materialMap[e]}getTextMaterial(e,t){return this.materialMap[e]||(this.materialMap[e]=this.makeTextMaterial(t)),this.materialMap[e].getDerivedMaterial()}getGhostMaterial(e,t){switch(e.geometryType){case mt.MESH:return this.meshGhostMaterial;case mt.LINE:return this.lineGhostMaterial;case mt.POINT:case mt.POINT_CLOUD:return this.pointGhostMaterial;case mt.TEXT:return this.textGhostMaterial}}getGradientMaterial(e,t){switch(e.geometryType){case mt.MESH:{const n=e.transparent?this.meshTransparentGradientMaterial:this.meshGradientMaterial;return t!=null&&t.rampTexture&&n.setGradientTexture(t.rampTexture),n}case mt.LINE:return this.lineColoredMaterial;case mt.POINT:{const n=this.pointCloudGradientMaterial;return t!=null&&t.rampTexture&&n.setGradientTexture(t.rampTexture),n}case mt.POINT_CLOUD:{const n=this.pointCloudGradientMaterial;return t!=null&&t.rampTexture&&n.setGradientTexture(t.rampTexture),n}case mt.TEXT:return this.textColoredMaterial}}getColoredMaterial(e,t){switch(e.geometryType){case mt.MESH:{const n=e.transparent?this.meshTransparentColoredMaterial:this.meshColoredMaterial;return t!=null&&t.rampTexture&&n.setGradientTexture(t.rampTexture),n}case mt.LINE:return this.lineColoredMaterial;case mt.POINT:{const n=this.pointCloudColouredMaterial;return t!=null&&t.rampTexture&&n.setGradientTexture(t.rampTexture),n}case mt.POINT_CLOUD:{const n=this.pointCloudColouredMaterial;return t!=null&&t.rampTexture&&n.setGradientTexture(t.rampTexture),n}case mt.TEXT:return this.textColoredMaterial}}getHiddenMaterial(e,t){switch(e.geometryType){case mt.MESH:return this.meshHiddenMaterial;case mt.LINE:return this.lineHiddenMaterial;case mt.POINT:case mt.POINT_CLOUD:return this.meshHiddenMaterial;case mt.TEXT:return this.textHiddenMaterial}}getFilterMaterial(e,t){let n=null;switch(t.filterType){case _s.GHOST:n=this.getGhostMaterial(e,t);break;case _s.GRADIENT:n=this.getGradientMaterial(e,t);break;case _s.COLORED:n=this.getColoredMaterial(e,t);break;case _s.HIDDEN:n=this.getHiddenMaterial(e,t)}return n&&(n.clippingPlanes=[]),n}getDataMaterial(e,t){const n=Zt.getMaterialHash(e,t);return this.getMaterial(n,t,e.geometryType)}getFilterMaterialOptions(e){switch(e.filterType){case _s.COLORED:return{rampIndex:e.rampIndex!==void 0?e.rampIndex:void 0,rampIndexColor:e.rampIndexColor,rampTexture:e.rampTexture?e.rampTexture:void 0,rampWidth:e.rampTexture?e.rampTexture.image.width:void 0};case _s.GRADIENT:return{rampIndex:e.rampIndex!==void 0?e.rampIndex:void 0,rampIndexColor:e.rampIndexColor!==void 0?e.rampIndexColor:e.rampIndex?new ot().setRGB(this.defaultGradientTextureData.data[4*Math.floor(e.rampIndex*(this.defaultGradientTextureData.width-1))]/255,this.defaultGradientTextureData.data[4*Math.floor(e.rampIndex*(this.defaultGradientTextureData.width-1))+1]/255,this.defaultGradientTextureData.data[4*Math.floor(e.rampIndex*(this.defaultGradientTextureData.width-1))+2]/255).convertSRGBToLinear():void 0,rampTexture:e.rampTexture?e.rampTexture:this.meshGradientMaterial.userData.gradientRamp.value,rampWidth:e.rampTexture?e.rampTexture.image.width:this.meshGradientMaterial.userData.gradientRamp.value.image.width};default:return null}}purge(){}}Zt=ln,ln.UNIFORM_VECTORS_USED=33,ln.DEFAULT_ARTIFICIAL_ROUGHNESS=.6,ln.NullRenderMaterialHash=Zt.hashCode(mt.MESH.toString()),ln.NullRenderMaterialVertexColorsHash=Zt.hashCode(mt.MESH.toString()+"vertexColors"),ln.NullDisplayStyleHash=Zt.hashCode(mt.LINE.toString()),ln.NullTextDisplayStyle=Zt.hashCode(mt.TEXT.toString()),ln.NullPointMaterialHash=Zt.hashCode(mt.POINT.toString()),ln.NullPointCloudMaterialHash=Zt.hashCode(mt.POINT_CLOUD.toString()),ln.NullPointCloudVertexColorsMaterialHash=Zt.hashCode(mt.POINT_CLOUD.toString()+"vertexColors"),ln.NullRenderMaterialInstancedHash=Zt.hashCode(mt.MESH.toString()+"instanced"),ln.NullRenderMaterialInstancedVertexColorHash=Zt.hashCode(mt.MESH.toString()+"vertexColorsinstanced"),function(s){s.View3D="View3D",s.BlockInstance="BlockInstance",s.Pointcloud="Pointcloud",s.Brep="Brep",s.Mesh="Mesh",s.Point="Point",s.Line="Line",s.Polyline="Polyline",s.Box="Box",s.Polycurve="Polycurve",s.Curve="Curve",s.Circle="Circle",s.Arc="Arc",s.Ellipse="Ellipse",s.RevitInstance="RevitInstance",s.Text="Text",s.Transform="Transform",s.InstanceProxy="InstanceProxy",s.RenderMaterialProxy="RenderMaterialProxy",s.ColorProxy="ColorProxy",s.Region="Region",s.Unknown="Unknown"}(Bt||(Bt={}));const MN=[Bt.Pointcloud,Bt.Brep,Bt.Mesh,Bt.Point,Bt.Line,Bt.Polyline,Bt.Box,Bt.Polycurve,Bt.Curve,Bt.Circle,Bt.Arc,Bt.Ellipse,Bt.Text,Bt.Region];class CN{}class RN{get guid(){return this._guid||(this._guid=this._renderData.subtreeId+this._renderData.id),this._guid}get renderData(){return this._renderData}get renderMaterialHash(){return this._materialHash}get hasGeometry(){return this._renderData.geometry&&this._renderData.geometry.attributes}get hasMetadata(){return this._renderData.geometry&&this._renderData.geometry.metaData}get speckleType(){return this._renderData.speckleType}get geometryType(){return this._geometryType}get batchStart(){return this._batchIndexStart}get batchEnd(){return this._batchIndexStart+this._batchIndexCount}get batchCount(){return this._batchIndexCount}get batchId(){return this._batchId}get aabb(){return this._aabb}get transparent(){return this._renderData.renderMaterial&&this._renderData.renderMaterial.opacity<1||!1}get vertStart(){return this._batchVertexStart}get vertEnd(){return this._batchVertexEnd}get needsSegmentConversion(){return this._renderData.speckleType===Bt.Curve||this._renderData.speckleType===Bt.Polyline||this._renderData.speckleType===Bt.Polycurve||this.renderData.speckleType===Bt.Arc||this.renderData.speckleType===Bt.Circle||this.renderData.speckleType===Bt.Ellipse}get validGeometry(){return this._renderData.geometry.attributes&&this._renderData.geometry.attributes.POSITION&&this._renderData.geometry.attributes.POSITION.length>0&&(this._geometryType!==mt.MESH||this._renderData.geometry.attributes.INDEX&&this._renderData.geometry.attributes.INDEX.length>0)||!1}constructor(e){this._guid=null,this._renderData=e,this._geometryType=this.getGeometryType(),this._materialHash=ln.getMaterialHash(this),this._batchId="",this._batchIndexCount=0,this._batchIndexStart=-1,this._batchVertexStart=-1,this._batchVertexEnd=-1}setBatchData(e,t,n,i,r){this._batchId=e,this._batchIndexStart=t,this._batchIndexCount=n,i!==void 0&&(this._batchVertexStart=i),r!==void 0&&(this._batchVertexEnd=r)}computeAABB(){this._aabb||(this._aabb=new Tt),this._renderData.geometry.attributes&&this._renderData.geometry.attributes.POSITION.length&&this._aabb.setFromArray(this._renderData.geometry.attributes.POSITION)}getGeometryType(){switch(this._renderData.speckleType){case Bt.Mesh:case Bt.Brep:return mt.MESH;case Bt.Point:return mt.POINT;case Bt.Pointcloud:return mt.POINT_CLOUD;case Bt.Text:return mt.TEXT;default:return mt.LINE}}disposeGeometry(){for(const e in this._renderData.geometry.attributes)this._renderData.geometry.attributes[e]=[]}}const vg=new Ne,yg=new Tt,xg=new Tt,IN=new T;function Qw(s,e=.001){if(s.isEmpty())return e;vg.identity(),vg.makeScale(1+e,1+e,1+e);const t=s.getSize(IN).multiplyScalar(.5);yg.min.set(0,0,0),yg.max.set(0,0,0),xg.min.set(0,0,0),xg.max.set(0,0,0);const n=yg.expandByVector(t);return xg.copy(n).applyMatrix4(vg).max.distanceTo(n.max)}const PN=new T,Nn=new Float32Array(16);var Ta;(function(s){s.POSITION="POSITION",s.COLOR="COLOR",s.NORMAL="NORMAL",s.UV="UV",s.TANGENT="TANGENT",s.INDEX="INDEX"})(Ta||(Ta={}));class hn{static updateRTEGeometry(e,t){if(e.type==="BufferGeometry"||e.type==="PlaneGeometry"||e.type==="CircleGeometry"){const n=new Float32Array(t.length),i=e.attributes.position.array;hn.DoubleToHighLowBuffer(t,n,i),e.setAttribute("position_low",new Vt(n,3))}else if(e.type==="LineGeometry"||e.type==="LineSegmentsGeometry"){const n=new Float32Array(t.length),i=e.attributes.instanceStart.array;hn.DoubleToHighLowBuffer(t,n,i);const r=new wc(new Float32Array(n),6,1);e.setAttribute("instanceStartLow",new $i(r,3,0)),e.setAttribute("instanceEndLow",new $i(r,3,3))}}static mergeGeometryAttribute(e,t){let n=0;for(let i=0;i<e.length;i++){const r=e[i];if(!r||!t)throw new Error("Cannot merge geometries. Indices or positions are undefined");t.set(r,n),n+=r.length}return t}static mergeIndexAttribute(e,t){let n=0;const i=[];for(let r=0;r<e.length;++r){const a=e[r],o=t[r];if(!a||!o)throw new Error("Cannot merge geometries. Indices or positions are undefined");for(let l=0;l<a.length;++l)i.push(a[l]+n/3);n+=o.length}return i}static mergeGeometryData(e){const t=e[0].attributes,n={attributes:{},bakeTransform:null,transform:null};for(let i=0;i<e.length;i++)e[i].bakeTransform!==null&&hn.transformGeometryData(e[i],e[i].bakeTransform);if(t&&t[Ta.INDEX]){const i=e.map(a=>{if(a.attributes)return a.attributes[Ta.INDEX]}),r=e.map(a=>{if(a.attributes)return a.attributes[Ta.POSITION]});n.attributes&&(n.attributes[Ta.INDEX]=hn.mergeIndexAttribute(i,r))}for(const i in t)if(i!==Ta.INDEX){const r=e.map(a=>{if(a.attributes)return a.attributes[i]});n.attributes&&(n.attributes[i]=hn.mergeGeometryAttribute(r,i===Ta.POSITION?new Float64Array(r.reduce((a,o)=>o?a+o.length:0,0)):new Float32Array(r.reduce((a,o)=>o?a+o.length:0,0))))}return e.forEach(i=>{for(const r in i.attributes)delete i.attributes[r]}),n}static transformGeometryData(e,t){if(!e.attributes||!e.attributes.POSITION||!t)return;const n=t.elements;for(let i=0;i<e.attributes.POSITION.length;i+=3){const r=e.attributes.POSITION[i],a=e.attributes.POSITION[i+1],o=e.attributes.POSITION[i+2],l=1/(n[3]*r+n[7]*a+n[11]*o+n[15]);e.attributes.POSITION[i]=(n[0]*r+n[4]*a+n[8]*o+n[12])*l,e.attributes.POSITION[i+1]=(n[1]*r+n[5]*a+n[9]*o+n[13])*l,e.attributes.POSITION[i+2]=(n[2]*r+n[6]*a+n[10]*o+n[14])*l}}static unpackColors(e){const t=new Array(3*e.length);for(let n=0;n<e.length;n++){const i=e[n],r=i>>16&255,a=i>>8&255,o=255&i;t[3*n]=r/255,t[3*n+1]=a/255,t[3*n+2]=o/255}return t}static DoubleToHighLowVector(e,t,n){let i=e.x;if(i>=0){Nn[0]=i;const r=Nn[0];n.x=r,t.x=i-r}else{Nn[0]=-i;const r=Nn[0];n.x=-r,t.x=i+r}if(i=e.y,i>=0){Nn[0]=i;const r=Nn[0];n.y=r,t.y=i-r}else{Nn[0]=-i;const r=Nn[0];n.y=-r,t.y=i+r}if(i=e.z,i>=0){Nn[0]=i;const r=Nn[0];n.z=r,t.z=i-r}else{Nn[0]=-i;const r=Nn[0];n.z=-r,t.z=i+r}}static DoubleToHighLowBuffer(e,t,n){for(let i=0;i<e.length;i++){const r=e[i];if(r>=0){Nn[0]=r;const a=Nn[0];n[i]=a,t[i]=r-a}else{Nn[0]=-r;const a=Nn[0];n[i]=-a,t[i]=r+a}}}static needsRTE(e){const t=Qw(e,.01),n=Qw(e,.009),i=new Me(1920,1080),r=function(l,c,u,h){const d=l.x/l.y,f=u*Math.tan(.5*jB*c),v=2*f,g=d*v,m=-.5*g;return new Ne().makePerspective(m,m+g,f,f-v,u,h)}(i,50,n,10*n),a=new Me(-1,-1),o=[e.min,e.max,e.getCenter(new T)];for(let l=0;l<o.length;l++){const c=hn.getFP32ProjectionDelta(o[l],r,i,t);a.x=Math.max(a.x,c.x),a.y=Math.max(a.y,c.y)}return a.x>=.5||a.y>=.5}static getFP32ProjectionDelta(e,t,n,i=1){Nn[0]=e.x,Nn[1]=e.y,Nn[2]=e.z;const r=PN.set(Nn[0],Nn[1],Nn[2]),a=new T().copy(e).add(new T(Math.random()*i,Math.random()*i,-i)),o=new Ne().lookAt(a,e,new T(0,1,0));o.setPosition(a),o.invert(),o.premultiply(t);const l=new Ne().copy(o);l.toArray(Nn),l.fromArray(Nn);const c=new Ft(r.x,r.y,r.z,1),u=new Ft(r.x,r.y,r.z,1);return c.applyMatrix4(l),c.multiplyScalar(.5/c.w),c.addScalar(.5),c.multiply(new Ft(n.x,n.y,0,0)),u.applyMatrix4(o),u.multiplyScalar(.5/u.w),u.addScalar(.5),u.multiply(new Ft(n.x,n.y,0,0)),new Me(Math.abs(u.x-c.x),Math.abs(u.y-c.y))}static computeVertexNormalsBuffer(e,t,n){const i=new T,r=new T,a=new T,o=new T,l=new T,c=new T,u=new T,h=new T;for(let d=0,f=n.length;d<f;d+=3){const v=n[d+0],g=n[d+1],m=n[d+2];i.fromArray(t,3*v),r.fromArray(t,3*g),a.fromArray(t,3*m),u.subVectors(a,r),h.subVectors(i,r),u.cross(h),o.fromArray(e,3*v),l.fromArray(e,3*g),c.fromArray(e,3*m),o.add(u),l.add(u),c.add(u),e[3*v]=o.x,e[3*v+1]=o.y,e[3*v+2]=o.z,e[3*g]=l.x,e[3*g+1]=l.y,e[3*g+2]=l.z,e[3*m]=c.x,e[3*m+1]=c.y,e[3*m+2]=c.z}}static computeVertexNormals(e,t){const n=e.index,i=e.getAttribute("position");if(i!==void 0){let r=e.getAttribute("normal");if(r===void 0)r=new Sn(new Float32Array(3*i.count),3),e.setAttribute("normal",r);else for(let v=0,g=r.count;v<g;v++)r.setXYZ(v,0,0,0);const a=new T,o=new T,l=new T,c=new T,u=new T,h=new T,d=new T,f=new T;if(n)for(let v=0,g=n.count;v<g;v+=3){const m=n.getX(v+0),x=n.getX(v+1),w=n.getX(v+2);a.fromArray(t,3*m),o.fromArray(t,3*x),l.fromArray(t,3*w),d.subVectors(l,o),f.subVectors(a,o),d.cross(f),c.fromBufferAttribute(r,m),u.fromBufferAttribute(r,x),h.fromBufferAttribute(r,w),c.add(d),u.add(d),h.add(d),r.setXYZ(m,c.x,c.y,c.z),r.setXYZ(x,u.x,u.y,u.z),r.setXYZ(w,h.x,h.y,h.z)}else for(let v=0,g=i.count;v<g;v+=3)a.fromArray(t,3*v),o.fromArray(t,3*v+1),l.fromArray(t,3*v+2),d.subVectors(l,o),f.subVectors(a,o),d.cross(f),r.setXYZ(v+0,d.x,d.y,d.z),r.setXYZ(v+1,d.x,d.y,d.z),r.setXYZ(v+2,d.x,d.y,d.z);e.normalizeNormals(),r.needsUpdate=!0}}static triangulatePolygon(e){const t=new Array(2*e.length);return e.forEach((n,i)=>n.toArray(t,2*i)),XB(t)}}class DN{get id(){return this.root.model.id}get subtreeId(){return this.root.model.subtreeId}constructor(e,t){this.cancel=!1,this.buildNodeTime=0,this.applyTransformTime=0,this.convertTime=0,this.getNodeTime=0,this.otherTime=0,this.tree=e,this.root=t}buildRenderTree(e){return this.tree.walkAsync(t=>{let n=performance.now();const i=this.buildRenderNode(t,e);return t.model.renderView=i?new RN(i):null,this.buildNodeTime+=performance.now()-n,n=performance.now(),this.applyTransforms(t),this.applyTransformTime+=performance.now()-n,t.model.instanced||e.disposeNodeGeometryData(t.model),!this.cancel},this.root)}applyTransforms(e){if(e.model.renderView){const t=this.computeTransform(e);e.model.renderView.hasGeometry?(e.model.renderView.renderData.geometry.bakeTransform&&t.multiply(e.model.renderView.renderData.geometry.bakeTransform),e.model.instanced&&e.model.renderView.speckleType===Bt.Mesh?e.model.renderView.renderData.geometry.transform=t:hn.transformGeometryData(e.model.renderView.renderData.geometry,t),e.model.renderView.computeAABB()):e.model.renderView.hasMetadata&&e.model.renderView.renderData.geometry.bakeTransform.premultiply(t)}}buildRenderNode(e,t){let n=null,i=performance.now();const r=t.convertNodeToGeometryData(e.model);if(this.convertTime+=performance.now()-i,r){i=performance.now();const a=this.getRenderMaterialNode(e),o=this.getDisplayStyleNode(e),l=this.getColorMaterialNode(e);this.getNodeTime+=performance.now()-i,i=performance.now(),n={id:e.model.id,subtreeId:e.model.subtreeId,speckleType:t.getSpeckleType(e.model),geometry:r,renderMaterial:ln.renderMaterialFromNode(a||o,e),displayStyle:ln.displayStyleFromNode(o||a),colorMaterial:ln.colorMaterialFromNode(l)},this.otherTime+=performance.now()-i}return n}getRenderMaterialNode(e){if(e.model.raw.renderMaterial)return e;const t=this.tree.getAncestors(e);for(let n=0;n<t.length;n++)if(t[n].model.raw.renderMaterial)return t[n];return null}getDisplayStyleNode(e){if(e.model.raw.displayStyle)return e;const t=this.tree.getAncestors(e);for(let n=0;n<t.length;n++)if(t[n].model.raw.displayStyle)return t[n];return null}getColorMaterialNode(e){if(e.model.color)return e;const t=this.tree.getAncestors(e);for(let n=0;n<t.length;n++)if(t[n].model.color)return t[n];return null}computeTransform(e){if(e.model.renderView.speckleType===Bt.Transform)return e.model.renderView.renderData.transform;const t=new Ne,n=this.tree.getAncestors(e);for(let i=0;i<n.length;i++)if(n[i].model.renderView){const r=n[i].model.renderView.renderData;r.speckleType===Bt.Transform&&r.geometry.transform&&t.premultiply(r.geometry.transform)}return t}getInstances(){return this.tree.getInstances(this.root.model.subtreeId)}getRenderableRenderViews(...e){return this.getRenderableNodes(...e).map(t=>t.model.renderView)}getRenderableNodes(...e){return this.root.all(t=>t.model.renderView&&(t.model.renderView.hasGeometry||t.model.renderView.hasMetadata)&&e.includes(t.model.renderView.renderData.speckleType))}getRenderViewsForNode(e){return this.getRenderViewNodesForNode(e).map(t=>t.model.renderView)}getRenderViewNodesForNode(e){return e.model.atomic&&e.model.renderView?[e]:e.all(t=>t.model.renderView&&(t.model.renderView.hasGeometry||t.model.renderView.hasMetadata))}getRenderViewsForNodeId(e,t){const n=this.tree.findId(e,t);if(!n)return dt.warn(`Id ${e} does not exist`),null;const i=[];return n.forEach(r=>{i.push(...this.getRenderViewsForNode(r))}),i}getAtomicParent(e){return e.model.atomic?e:this.tree.getAncestors(e).find(t=>t.model.atomic)}purge(){}cancelBuild(){this.cancel=!0,this.tree.purge(this.id),this.purge()}}class ir{get nodeCount(){return Object.keys(this.all).length}constructor(e){this.all={},this.instances={},this.registerNode(e)}addNode(e){if(e.model.id.includes(ir.COMPOUND_ID_CHAR))this.registerInstance(e);else{if(this.all[e.model.id])return!1;this.registerNode(e)}return!0}removeNode(e){if(e.model.id.includes(ir.COMPOUND_ID_CHAR)){const t=e.model.id.substring(0,e.model.id.indexOf(ir.COMPOUND_ID_CHAR));delete this.instances[t][e.model.id]}else delete this.all[e.model.id];return!0}getNodeById(e){if(e.includes(ir.COMPOUND_ID_CHAR)){const t=e.substring(0,e.indexOf(ir.COMPOUND_ID_CHAR));if(!this.instances[t])return dt.warn("Could not find instance with baseID: ",t),null;if(this.instances[t][e])return[this.instances[t][e]]}return this.all[e]?[this.all[e]]:this.instances[e]?Object.values(this.instances[e]):null}getSubtreeById(e){return this.all[e]}hasId(e){if(e.includes(ir.COMPOUND_ID_CHAR)){const t=e.substring(0,e.indexOf(ir.COMPOUND_ID_CHAR));return!!this.instances[t]}return!!this.all[e]||!!this.instances[e]}registerInstance(e){const t=e.model.id.substring(0,e.model.id.indexOf(ir.COMPOUND_ID_CHAR));this.instances[t]||(this.instances[t]={}),this.instances[t][e.model.id]=e}registerNode(e){this.all[e.model.id]=e}purge(){this.all={},this.instances={}}}ir.COMPOUND_ID_CHAR="~";class Ku{constructor(){this.renderTreeInstances={},this.nodeMaps={},this.supressWarnings=!0,this.subtreeId=0,this.tree=new Yx,this._root=this.parse({id:Ku.ROOT_ID,raw:{},atomic:!0,children:[],renderView:null})}getRenderTree(e){if(!this._root)return console.error("WorldTree not initialised"),null;const t=e?this.findSubtree(e):this.root;if(!t)return null;const n=t.model.id;return this.renderTreeInstances[n]||(this.renderTreeInstances[n]=new DN(this,t)),this.renderTreeInstances[n]}get root(){return this._root}get nextSubtreeId(){return++this.subtreeId}get nodeCount(){let e=0;for(const t in this.nodeMaps)e+=this.nodeMaps[t].nodeCount;return e}isRoot(e){return e===this._root}isSubtreeRoot(e){return e.parent===this._root}parse(e){return this.tree.parse(e)}addSubtree(e){if(this.nodeMaps[e.id])return void dt.error(`Subtree with id ${e.id} already exists!`);const t=this.nextSubtreeId;e.model.subtreeId=t,this.nodeMaps[t]=new ir(e),this._root.addChild(e)}addNode(e,t){var n;t!==null&&t.model.subtreeId!==void 0?(e.model.subtreeId=t.model.subtreeId,!((n=this.nodeMaps[t.model.subtreeId])===null||n===void 0)&&n.addNode(e)&&t.addChild(e)):dt.error("Invalid parent node!")}removeNode(e,t){var n;const i=e.children;if((n=this.nodeMaps[e.model.subtreeId])===null||n===void 0||n.removeNode(e),e.drop(),t&&i)for(let r=0;r<i.length;r++)this.removeNode(i[r],t)}findAll(e,t){return t||this.supressWarnings||dt.warn("Root will be used for searching. You might not want that"),(t||this.root).all(e)}findId(e,t){if(!e)return null;let n=null;if(t)n=this.nodeMaps[t].getNodeById(e);else for(const i in this.nodeMaps){const r=this.nodeMaps[i].getNodeById(e);r&&(n=[...r])}return n}findSubtree(e){let t=null;for(const n in this.nodeMaps)if(t=this.nodeMaps[n].getSubtreeById(e))break;return t}getAncestors(e){return e.getPath().reverse().slice(1)}getInstances(e){return this.nodeMaps[e].instances}walk(e,t){t||this.supressWarnings||dt.warn("Root will be used for searching. You might not want that"),this._root.walk(e,t)}async walkAsync(e,t){t||this.supressWarnings||dt.warn("Root will be used for searching. You might not want that");const n=new mA;let i=!0;return async function r(a,o){let l,c;for(n.tick(100),n.needsWait&&await n.wait(16),i&&(i=a(o)),l=0,c=o.children.length;l<c&&await r(a,o.children[l]);l++);return i}(e,t||this._root)}purge(e){if(e){delete this.renderTreeInstances[e];const t=this.findId(e);t&&(this.nodeMaps[t[0].model.subtreeId].purge(),delete this.nodeMaps[t[0].model.subtreeId],this.removeNode(t[0],!1))}else Object.keys(this.renderTreeInstances).forEach(t=>delete this.renderTreeInstances[t]),Object.keys(this.nodeMaps).forEach(t=>{this.nodeMaps[t].purge,delete this.nodeMaps[t]}),this._root.drop(),this._root.children.length=0,this.tree=new Yx,this._root=this.tree.parse({id:Ku.ROOT_ID,raw:{},atomic:!0,children:[]})}}Ku.ROOT_ID="ROOT";class Ec{get bounds(){return this.geometry.boundingBox||this.geometry.computeBoundingBox(),this.geometry.boundingBox?this.geometry.boundingBox:new Tt}get drawCalls(){return 1}get minDrawCalls(){return 1}get triCount(){return 0}get vertCount(){return this.geometry.attributes.position.count*this.geometry.instanceCount}constructor(e,t,n){this.id=e,this.subtreeId=t,this.renderViews=n}get pointCount(){return 0}get lineCount(){return(this.geometry.index?this.geometry.index.count:0)/3*this.geometry._maxInstanceCount}get renderObject(){return this.mesh}get geometryType(){return mt.LINE}get materials(){return this.mesh.material}get groups(){return[]}getCount(){return this.geometry.attributes.position.array.length/6}setBatchMaterial(e){this.batchMaterial=e,this.batchTransparent=e.transparent,this.batchOpacity=e.opacity}onUpdate(e){}onRender(e){e.getDrawingBufferSize(this.batchMaterial.resolution)}setVisibleRange(e){if(e.length===1&&e[0].offset===Li.offset&&e[0].count===Li.count)return void(this.mesh.visible=!1);if(e.length===1&&e[0].offset===kn.offset&&e[0].count===kn.count)return void(this.mesh.visible=!0);this.mesh.visible=!0;const t=this.colorBuffer.array;for(let n=0;n<t.length;n+=4)t[n+3]=0;for(let n=0;n<e.length;n++){const i=e[n].offset*this.colorBuffer.stride,r=e[n].offset*this.colorBuffer.stride+e[n].count*this.colorBuffer.stride;for(let a=i;a<r;a+=4)t[a+3]=1}this.colorBuffer.updateRange={offset:0,count:t.length},this.colorBuffer.needsUpdate=!0,this.geometry.attributes.instanceColorStart.needsUpdate=!0,this.geometry.attributes.instanceColorEnd.needsUpdate=!0}getVisibleRange(){return kn}getOpaque(){return ln.isOpaque(this.batchMaterial)?kn:Li}getDepth(){return this.getOpaque()}getTransparent(){return ln.isTransparent(this.batchMaterial)?kn:Li}getStencil(){return this.batchMaterial.stencilWrite===!0?kn:Li}setBatchBuffers(e){var t;const n=this.colorBuffer.array;this.batchMaterial.transparent=this.batchTransparent,this.batchMaterial.opacity=this.batchOpacity;for(let i=0;i<e.length;i++){const r=e[i].material,a=e[i].materialOptions,o=a&&a.rampIndexColor?a.rampIndexColor:r.color,l=r.visible?r.opacity:0;(t=this.batchMaterial).transparent||(t.transparent=r.opacity<1),this.batchMaterial.opacity=Math.min(this.batchMaterial.opacity,r.opacity);const c=e[i].offset*this.colorBuffer.stride,u=e[i].offset*this.colorBuffer.stride+e[i].count*this.colorBuffer.stride;Ec.vector4Buffer.set(o.r,o.g,o.b,l),this.updateColorBuffer(c,e[i].count===1/0?this.colorBuffer.array.length:u,Ec.vector4Buffer)}this.colorBuffer.updateRange={offset:0,count:n.length},this.colorBuffer.needsUpdate=!0,this.geometry.attributes.instanceColorStart.needsUpdate=!0,this.geometry.attributes.instanceColorEnd.needsUpdate=!0}setDrawRanges(e){this.setBatchBuffers(e)}resetDrawRanges(){this.setDrawRanges([{offset:0,count:1/0,material:this.batchMaterial}]),this.mesh.material=this.batchMaterial,this.mesh.visible=!0,this.batchMaterial.transparent=this.batchTransparent,this.batchMaterial.opacity=this.batchOpacity}buildBatch(){let e=0;const t=new Tt;this.renderViews.forEach(r=>{if(!r.renderData.geometry.attributes)throw new Error(`Cannot build batch ${this.id}. Invalid geometry`);e+=r.needsSegmentConversion?2*(r.renderData.geometry.attributes.POSITION.length-3):r.renderData.geometry.attributes.POSITION.length,t.union(r.aabb)});const n=new Float64Array(e);let i=0;for(let r=0;r<this.renderViews.length;r++){const a=this.renderViews[r].renderData.geometry;if(!a.attributes)throw new Error(`Cannot build batch ${this.id}. Invalid geometry`);let o;if(this.renderViews[r].needsSegmentConversion){const l=a.attributes.POSITION.length-3;o=new Array(2*l);for(let c=0;c<l;c+=3)o[2*c]=a.attributes.POSITION[c],o[2*c+1]=a.attributes.POSITION[c+1],o[2*c+2]=a.attributes.POSITION[c+2],o[2*c+3]=a.attributes.POSITION[c+3],o[2*c+4]=a.attributes.POSITION[c+4],o[2*c+5]=a.attributes.POSITION[c+5]}else o=a.attributes.POSITION;n.set(o,i),this.renderViews[r].setBatchData(this.id,i/6,o.length/6),i+=o.length}return this.geometry=this.makeLineGeometry(n),hn.needsRTE(t)&&(hn.updateRTEGeometry(this.geometry,n),this.batchMaterial.defines.USE_RTE=" "),this.mesh=new Tc(this.geometry,this.batchMaterial),this.mesh.computeLineDistances(),this.mesh.scale.set(1,1,1),this.mesh.uuid=this.id,this.mesh.layers.set(vt.STREAM_CONTENT_LINE),Promise.resolve()}getRenderView(e){for(let t=0;t<this.renderViews.length;t++)if(e>=this.renderViews[t].batchStart&&e<this.renderViews[t].batchEnd&&this.colorBuffer.array[e*this.colorBuffer.stride+3]!==0)return this.renderViews[t];return null}getMaterialAtIndex(e){return this.batchMaterial}getMaterial(e){const t=e.batchStart*this.colorBuffer.stride,n=this.colorBuffer.array,i=this.batchMaterial.clone();return i.color.setRGB(n[t],n[t+1],n[t+2]),i.opacity=n[t+3],i}makeLineGeometry(e){const t=new Xo;t.setPositions(new Float32Array(e));const n=new Float32Array(e.length+e.length/3);return this.colorBuffer=new wc(n,8,1),this.colorBuffer.setUsage(Pr),this.updateColorBuffer(0,n.length,new Ft(this.batchMaterial.color.r,this.batchMaterial.color.g,this.batchMaterial.color.b,1)),t.setAttribute("instanceColorStart",new $i(this.colorBuffer,4,0)),t.setAttribute("instanceColorEnd",new $i(this.colorBuffer,4,4)),t.computeBoundingBox(),t}updateColorBuffer(e,t,n){const i=this.colorBuffer.array;for(let r=e;r<t;r+=4)i[r]=n.x,i[r+1]=n.y,i[r+2]=n.z,i[r+3]=n.w}purge(){this.renderViews.length=0,this.geometry.dispose(),this.batchMaterial.dispose(),this.colorBuffer.length=0}}Ec.vector4Buffer=new Ft;const Xw={backgroundColor:null,backgroundCornerRadius:1,backgroundPixelHeight:50,textColor:new ot(16777215),billboard:!1};class ic extends gn{static SpeckleTextParamsFromMetadata(e){return{textValue:e.value?e.value:"N/A",height:e.height}}get textMesh(){return this._text}get backgroundMesh(){return this._background}set style(e){Object.assign(this._style,e),this.updateStyle()}constructor(e,t){super(),this._layer=vt.NONE,this._text=null,this._background=null,this._backgroundSize=new T,this._style=Object.assign({},Xw),this._resolution=new Me,this.defaultMaterial=new Ja({color:16777215,side:Qt,transparent:!0}),this.getFlatRaycastMesh=()=>{const n=new gn(new Ks(1,1),this.defaultMaterial);return this.getFlatRaycastMesh=()=>n,n},this.getCurvedRaycastMesh=()=>{const n=new gn(new Ks(1,1,32,1),this.defaultMaterial);return this.getCurvedRaycastMesh=()=>n,n},this.uuid=e,this._layer=t,this._text=new J1,this._text.depthOffset=-.1,this._text.raycast=()=>{},this.layers.set(this._layer),this._text.layers.set(this._layer),this.add(this._text),this.onBeforeRender=n=>{n.getDrawingBufferSize(this._resolution)},this.frustumCulled=!1}async update(e,t){return new Promise(n=>{e.textValue&&(this._text.text=e.textValue),e.richTextValue,e.height&&(this._text.fontSize=e.height),this._text.anchorX=e.anchorX,this._text.anchorY=e.anchorY,this._text._needsSync?this._text.sync(()=>{n(),t&&t()}):(n(),t&&t())})}setTransform(e,t,n){if(e){if(this._style.billboard&&(this.textMesh.material.userData.billboardPos.value.copy(e),this._background)){const i=this.textMesh.geometry.boundingBox.getSize(new T),r=this.textMesh.geometry.boundingBox.getCenter(new T),a=new T().copy(r).multiplyScalar(1.2),o=new T().copy(i).multiplyScalar(1.2).sub(i);a.x+=r.x<0?o.x:r.x>0?-o.x:0,a.y+=r.y<0?o.y:r.y>0?-o.y:0,this._background.material.billboardOffset=new Me(a.x,a.y),this._background.material.userData.billboardPos.value.copy(e)}this.position.copy(e)}t&&this.quaternion.copy(t),n&&this.scale.copy(n)}raycast(e,t){const{textRenderInfo:n,curveRadius:i}=this.textMesh;if(n){const r=n.blockBounds,a=i?this.getCurvedRaycastMesh():this.getFlatRaycastMesh(),o=a.geometry,{position:l,uv:c}=o.attributes;for(let h=0;h<c.count;h++){let d=r[0]+c.getX(h)*(r[2]-r[0]);const f=r[1]+c.getY(h)*(r[3]-r[1]);let v=0;if(i&&(v=i-Math.cos(d/i)*i,d=Math.sin(d/i)*i),this.textMesh.material.defines.BILLBOARD_FIXED){if(this._resolution.length()===0)return;const g=this._background?1.2:1,m=new Me().set(this.textMesh.material.billboardPixelHeight/this._resolution.x*2*g,this.textMesh.material.billboardPixelHeight/this._resolution.y*2*g),x=new Ne().copy(e.camera.projectionMatrix).invert(),w=new Ne().copy(e.camera.matrixWorldInverse).invert(),S=new Ft(this.position.x,this.position.y,this.position.z,1).applyMatrix4(e.camera.matrixWorldInverse).applyMatrix4(e.camera.projectionMatrix),b=S.w;S.multiplyScalar(1/b),S.add(new Ft(d*m.x,f*m.y,0,0)),S.multiplyScalar(b),S.applyMatrix4(x),S.applyMatrix4(w),l.setXYZ(h,S.x,S.y,S.z)}else l.setXYZ(h,d,f,v)}this.textMesh.material.defines.BILLBOARD_FIXED?(o.computeBoundingBox(),o.computeBoundingSphere(),a.matrixWorld.identity()):(o.boundingSphere=this.textMesh.geometry.boundingSphere,o.boundingBox=this.textMesh.geometry.boundingBox,a.matrixWorld=this.textMesh.matrixWorld),a.material.side=this.textMesh.material.side;const u=[];a.raycast(e,u);for(let h=0;h<u.length;h++)u[h].object=this,t.push(u[h])}}updateStyle(){this.updateBackground()}updateBackground(){var e;if(!this._style.backgroundColor)return this._background&&this.remove(this._background),void(this._background=null);this._text.geometry.computeBoundingBox();const t=this._text.geometry.boundingBox.getSize(new T),n=t.distanceTo(this._backgroundSize);let i=(e=this._background)===null||e===void 0?void 0:e.geometry;if(n>.1&&(i=this.RectangleRounded(1.2*t.x,1.2*t.y,.5,5),i.computeBoundingBox(),this._backgroundSize.copy(t),this._background&&(this._background.geometry=i)),this._background===null){const a=new Wi({},["BILLBOARD_FIXED"]);a.toneMapped=!1,a.side=Qt,a.depthTest=!1,this._background=new gn(i,a),this._background.layers.set(this._layer),this._background.frustumCulled=!1,this._background.renderOrder=1,this.add(this._background)}const r=new ot(this._style.backgroundColor).convertSRGBToLinear();this._background.material.color=r,this._background.material.billboardPixelHeight=(this._style.backgroundPixelHeight!==void 0?this._style.backgroundPixelHeight:Xw.backgroundPixelHeight||0)*window.devicePixelRatio}RectangleRounded(e,t,n,i){const r=2*Math.PI,a=4*(i+1),o=[],l=[],c=[];let u,h,d,f,v;for(let x=1;x<a;x++)o.push(0,x,x+1);o.push(0,a,1),l.push(0,0,0),c.push(.5,.5);for(let x=0;x<a;x++)m(x);const g=new Xt;return g.setIndex(new Sn(new Uint32Array(o),1)),g.setAttribute("position",new Sn(new Float32Array(l),3)),g.setAttribute("uv",new Sn(new Float32Array(c),2)),g.computeBoundingBox(),g;function m(x){u=Math.trunc(4*x/a)+1,h=u===1||u===4?1:-1,d=u<3?1:-1,f=h*(e/2-n)+n*Math.cos(r*(x-u+1)/(a-4)),v=d*(t/2-n)+n*Math.sin(r*(x-u+1)/(a-4)),l.push(f,v,0),c.push(.5+f/e,.5+v/t)}}}class Jw{get bounds(){return new Tt().setFromObject(this.mesh)}get drawCalls(){return 1}get minDrawCalls(){return 1}get triCount(){return this.getCount()}get vertCount(){var e;return this.mesh.textMesh.geometry.attributes.position.count+((e=this.mesh.backgroundMesh)===null||e===void 0?void 0:e.geometry.attributes.position.count)}constructor(e,t,n){this.id=e,this.subtreeId=t,this.renderViews=n}get pointCount(){return 0}get lineCount(){return 0}get geometryType(){return mt.TEXT}get renderObject(){return this.mesh}getCount(){var e,t;return this.mesh.textMesh.geometry.index.count+((t=(e=this.mesh.backgroundMesh)===null||e===void 0?void 0:e.geometry.index)===null||t===void 0?void 0:t.count)}get materials(){return this.mesh.material}get groups(){return[]}setBatchMaterial(e){this.batchMaterial=e}onUpdate(e){}onRender(e){}setVisibleRange(e){}getVisibleRange(){return kn}getOpaque(){return ln.isOpaque(this.batchMaterial)?kn:Li}getDepth(){return this.getOpaque()}getTransparent(){return ln.isTransparent(this.batchMaterial)?kn:Li}getStencil(){return this.batchMaterial.stencilWrite===!0?kn:Li}setBatchBuffers(e){throw new Error("Method not implemented.")}setDrawRanges(e){this.mesh.textMesh.material=e[0].material,e[0].materialOptions&&e[0].materialOptions.rampIndexColor&&this.mesh.textMesh.material.color.copy(e[0].materialOptions.rampIndexColor)}resetDrawRanges(){this.mesh.textMesh.material=this.batchMaterial,this.mesh.textMesh.visible=!0}async buildBatch(){if(!this.renderViews[0].renderData.geometry.metaData)throw new Error(`Cannot build batch ${this.id}. Metadata`);this.mesh=new ic(this.id,vt.STREAM_CONTENT_TEXT),this.mesh.matrixAutoUpdate=!1,await this.mesh.update(ic.SpeckleTextParamsFromMetadata(this.renderViews[0].renderData.geometry.metaData)),this.renderViews[0].renderData.geometry.bakeTransform&&this.mesh.matrix.copy(this.renderViews[0].renderData.geometry.bakeTransform),this.renderViews[0].setBatchData(this.id,0,this.mesh.textMesh.geometry.index.count/3),this.mesh.textMesh.material=this.batchMaterial}getRenderView(e){return this.renderViews[0]}getMaterialAtIndex(e){return this.batchMaterial}getMaterial(e){return this.batchMaterial}purge(){this.renderViews.length=0,this.batchMaterial.dispose(),this.mesh.geometry.dispose()}}const B0={strategy:R0,maxDepth:40,maxLeafTris:10,verbose:!0,useSharedArrayBuffer:!1,setBoundingBox:!1,[Symbol("skip tree generation")]:!1};class qr{get geometry(){return this._bvh.geometry}get bvh(){return this._bvh}static buildBVH(e,t,n=B0,i){if(!e||!t)throw new Error("Cannot build BVH with undefined indices or position!");let r=new Float32Array(t);if(i){r=new Float32Array(t.length);const l=new T;for(let c=0;c<t.length;c+=3)l.set(t[c],t[c+1],t[c+2]),l.applyMatrix4(i),r[c]=l.x,r[c+1]=l.y,r[c+2]=l.z}const a=new Xt;let o=null;return t.length>=65535||e.length>=65535?(o=new Uint32Array(e.length),o.set(e,0),a.setIndex(new jo(o,1))):(o=new Uint16Array(e.length),o.set(e,0),a.setIndex(new qo(o,1))),a.setAttribute("position",new Vt(r,3)),a.computeBoundingBox(),new Eu(a,n)}constructor(e){this._bvh=e}raycast(e,t=gr){const n=this._bvh.raycast(this.transformInput(e),t);return n.forEach(i=>{i.point=this.transformOutput(i.point)}),n}raycastFirst(e,t=gr){const n=this._bvh.raycastFirst(this.transformInput(e),t);return n&&(n.point=this.transformOutput(n.point)),n}shapecast(e){const t=new Tt,n=new cs,i=Object.create(null);return e.intersectsBounds&&(i.intersectsBounds=(r,a,o,l,c)=>(t.copy(r),this.transformOutput(t),e.intersectsBounds(t,a,o,l,c))),e.intersectsTriangle&&(i.intersectsTriangle=(r,a,o,l)=>(n.copy(r),this.transformOutput(n.a),this.transformOutput(n.b),this.transformOutput(n.c),e.intersectsTriangle(n,a,o,l))),i.intersectsRange=e.intersectsRange,i.traverseBoundsOrder=e.traverseBoundsOrder,this._bvh.shapecast(i)}transformInput(e){return qr.MatBuff.copy(this.inputOriginTransform).multiply(this.inputTransform),e.applyMatrix4(qr.MatBuff)}transformOutput(e){return qr.MatBuff.copy(this.outputOriginTransfom).premultiply(this.outputTransform),e.applyMatrix4(qr.MatBuff)}getBoundingBox(e){const t=e||new Tt;return this._bvh.getBoundingBox(t),this.transformOutput(t)}getVertexAtIndex(e){const t=this._bvh.geometry.attributes.position.array;return this.transformOutput(new T(t[3*e],t[3*e+1],t[3*e+2]))}}qr.MatBuff=new Ne;class dr{constructor(e){this.debugBVH=!1,this.batchObjects=[],this.bounds=new Tt(new T(0,0,0),new T(0,0,0)),this.batchObjects=e,this.buildBVH(),this.getBoundingBox(this.bounds)}buildBVH(){const e=[],t=new Array(3*dr.CUBE_VERTS*this.batchObjects.length);let n=0;for(let i=0;i<this.batchObjects.length;i++){const r=this.batchObjects[i].accelerationStructure.getBoundingBox(new Tt);this.updateVertArray(r,n,t),e.push(...dr.cubeIndices.map(a=>a+n/3)),this.batchObjects[i].tasVertIndexStart=n/3,this.batchObjects[i].tasVertIndexEnd=n/3+dr.CUBE_VERTS,n+=3*dr.CUBE_VERTS}if(this.accelerationStructure=new qr(qr.buildBVH(e,t)),this.accelerationStructure.inputTransform=new Ne,this.accelerationStructure.outputTransform=new Ne,this.accelerationStructure.inputOriginTransform=new Ne,this.accelerationStructure.outputOriginTransfom=new Ne,this.debugBVH){const i=new gn(this.accelerationStructure.geometry);i.layers.set(vt.OVERLAY),i.geometry.boundsTree=this.accelerationStructure.bvh,this.bvhHelper=new P0(i),this.bvhHelper.layers.set(vt.OVERLAY),this.bvhHelper.children[0].layers.set(vt.OVERLAY),this.bvhHelper.update()}}updateVertArray(e,t,n){n[t]=e.min.x,n[t+1]=e.min.y,n[t+2]=e.max.z,n[t+3]=e.max.x,n[t+4]=e.min.y,n[t+5]=e.max.z,n[t+6]=e.max.x,n[t+7]=e.max.y,n[t+8]=e.max.z,n[t+9]=e.min.x,n[t+10]=e.max.y,n[t+11]=e.max.z,n[t+12]=e.min.x,n[t+13]=e.min.y,n[t+14]=e.min.z,n[t+15]=e.max.x,n[t+16]=e.min.y,n[t+17]=e.min.z,n[t+18]=e.max.x,n[t+19]=e.max.y,n[t+20]=e.min.z,n[t+21]=e.min.x,n[t+22]=e.max.y,n[t+23]=e.min.z}refit(){var e;const t=this.accelerationStructure.geometry.attributes.position.array;for(let n=0;n<this.batchObjects.length;n++){const i=this.batchObjects[n].tasVertIndexStart,r=this.batchObjects[n].aabb;this.updateVertArray(r,3*i,t)}this.accelerationStructure.bvh.refit(),(e=this.bvhHelper)===null||e===void 0||e.update()}raycast(e,t=!1,n=gr){const i=[],r=new Ti;r.copy(e);const a=this.accelerationStructure.raycast(r,n);if(!a.length)return i;const o=this.accelerationStructure.geometry.index;return a.forEach(l=>{const c=o.array[3*l.faceIndex],u=Math.trunc(c/dr.CUBE_VERTS);l.batchObject=this.batchObjects[u],!t&&(r.copy(e),this.batchObjects[u].accelerationStructure.raycast(r,n).forEach(h=>{const d=h;d.batchObject=this.batchObjects[u],i.push(d)}))}),t?a:i}raycastFirst(e,t=!1,n=gr){const i=new Ti;i.copy(e);let r=null,a=null;return a=t?[this.accelerationStructure.raycastFirst(i,n)]:this.accelerationStructure.raycast(i,n),a&&a.length!==0?(a.some(o=>{const l=this.accelerationStructure.geometry.index.array[3*o.faceIndex],c=Math.trunc(l/dr.CUBE_VERTS);return o.batchObject=this.batchObjects[c],!t&&(i.copy(e),r=this.batchObjects[c].accelerationStructure.raycastFirst(i,n),r)?(r.batchObject=this.batchObjects[c],!0):!1}),t?a[0]:r):null}shapecast(e){const t=r=>{const a=Object.create(null);return e.intersectsBounds&&(a.intersectsBounds=e.intersectsBounds),e.intersectsTriangle&&(a.intersectsTriangle=(o,l,c,u)=>e.intersectsTriangle(o,l,c,u,r)),a.intersectsRange=e.intersectsRange,a.traverseBoundsOrder=e.traverseBoundsOrder,a};let n=!1;const i={};return this.accelerationStructure.shapecast({intersectsBounds:(r,a,o,l,c)=>!!e.intersectsTAS&&e.intersectsTAS(r,a,o,l,c),intersectsRange:(r,a)=>{const o=new Set;for(let l=0;l<a;l++){const c=this.accelerationStructure.geometry.index.array[3*r+3*l],u=Math.trunc(c/dr.CUBE_VERTS),h=this.batchObjects[u];if(e.intersectTASRange){if(i[h.renderView.renderData.id]!==void 0)continue;const d=e.intersectTASRange(h);i[h.renderView.renderData.id]=d,d&&o.add(h)}else o.add(h)}if(!o.size)return!1;for(const l of o)n||(n=l.accelerationStructure.shapecast(t(l)));return!1}}),n}closestPointToPoint(e){return this.accelerationStructure.bvh.closestPointToPoint(e)}closestPointToPointHalfplane(e,t,n,i={point:new T,distance:0,faceIndex:0},r=0,a=1/0){const o=new T,l=new T,c=new T,u=r*r,h=a*a;let d=1/0,f=-1;if(this.accelerationStructure.bvh.shapecast({boundsTraverseOrder:g=>(o.copy(e).clamp(g.min,g.max),o.distanceToSquared(e)),intersectsBounds:(g,m,x)=>x<d&&x<h,intersectsRange:g=>{const m=this.accelerationStructure.geometry.index.array[3*g],x=Math.trunc(m/dr.CUBE_VERTS);return this.batchObjects[x].aabb.containsPoint(e)&&n!==void 0&&(d=n*n),!1},intersectsTriangle:(g,m)=>{g.closestPointToPoint(e,o);const x=e.distanceToSquared(o),w=c.subVectors(o,e);return t.dot(w)>=0&&x<d&&(l.copy(o),d=x,f=m),x<u}}),d===1/0)return null;const v=Math.sqrt(d);return i.point?i.point.copy(l):i.point=l.clone(),i.distance=v,i.faceIndex=f,i}getBoundingBox(e){return this.accelerationStructure.getBoundingBox(e),e}}dr.cubeIndices=[0,1,2,2,3,0,1,5,6,6,2,1,7,6,5,5,4,7,4,0,3,3,7,4,4,5,1,1,0,4,3,2,6,6,7,3],dr.CUBE_VERTS=8;const Kw=new Ne,Dl=new Ti,wg=new Zn,Sg=new T,Is=new T,Ps=new T,Ds=new T,bg=new T,Ag=new T,Tg=new T,Kd=new T,Yd=new T,Zd=new T,$d=new Me,ef=new Me,tf=new Me,Eg=new T,nf=new T,Mg=new Ti,Yw=new Ne;var Gs;(function(s){s[s.VERTEX_TEXTURE=0]="VERTEX_TEXTURE",s[s.UNIFORM_ARRAY=1]="UNIFORM_ARRAY"})(Gs||(Gs={}));class qp extends gn{get TAS(){return this.tas}get batchObjects(){return this._batchObjects}get batchIndex(){return this._batchIndex}get needsRTE(){return this._needsRTE}constructor(e,t=!1){super(e),this.materialCache={},this.materialStack=[],this.batchMaterialStack=[],this.materialCacheLUT={},this.transformsBuffer=void 0,this.transformsArrayUniforms=null,this._batchIndex=gA(),this._needsRTE=t}setBatchMaterial(e){this.batchMaterial=this.getCachedMaterial(e),this.material=[this.batchMaterial]}setBatchObjects(e,t){this._batchObjects=e,this.transformStorage=t,this.transformStorage===Gs.VERTEX_TEXTURE?(this.transformsBuffer=new Float32Array(4*this._batchObjects.length*4),this.transformsTextureUniform=new Eh(this.transformsBuffer,this.transformsBuffer.length/4,1,qi,Oi)):this.transformStorage===Gs.UNIFORM_ARRAY&&(this.transformsArrayUniforms=this._batchObjects.map(()=>new Ne)),this.updateTransformsUniform()}setOverrideMaterial(e){this.materialStack.push(this.material),this.material=this.getCachedMaterial(e,!0),this.material.needsUpdate=!0}setOverrideBatchMaterial(e){const t=this.getCachedMaterial(e,!0);this.batchMaterialStack.push(t);const n=this.material;for(let i=0;i<n.length;i++)n[i].uuid===this.batchMaterial.uuid&&(n[i]=t)}restoreBatchMaterial(){const e=this.material,t=this.batchMaterialStack.pop();if(t)for(let n=0;n<e.length;n++)e[n].uuid===t.uuid&&(e[n]=this.batchMaterial)}lookupMaterial(e){return this.materialCache[e.id]||this.materialCache[this.materialCacheLUT[e.id]]}getCachedMaterial(e,t=!1){let n=this.lookupMaterial(e);if(n)(t||e.needsCopy||n.needsCopy)&&ln.fastCopy(e,n);else{const i=e.clone();this._needsRTE&&(i.defines||(i.defines={}),i.defines.USE_RTE=" "),this.materialCache[e.id]=i,this.materialCacheLUT[i.id]=e.id,n=i,this.updateMaterialTransformsUniform(this.materialCache[e.id])}return n}restoreMaterial(){this.materialStack.length>0&&(this.material=this.materialStack.pop())}updateMaterialTransformsUniform(e){ln.isSpeckleMaterial(e)&&(e.defines||(e.defines={}),e.defines.TRANSFORM_STORAGE=this.transformStorage,this.transformStorage===Gs.VERTEX_TEXTURE?(e.userData.tTransforms.value=this.transformsTextureUniform,e.userData.objCount&&(e.userData.objCount.value=this._batchObjects.length)):this.transformStorage===Gs.UNIFORM_ARRAY&&(e.defines.OBJ_COUNT&&e.defines.OBJ_COUNT===this._batchObjects.length||(e.defines.OBJ_COUNT=this._batchObjects.length),e.userData.uTransforms.value=this.transformsArrayUniforms),e.needsUpdate=!0)}updateTransformsUniform(){if(!this.transformsBuffer)return;let e=!1;if(this.transformStorage===Gs.VERTEX_TEXTURE){for(let t=0;t<this._batchObjects.length;t++){const n=this._batchObjects[t];if(!e&&!(e=n.transformDirty))continue;const i=16*n.batchIndex;this.transformsBuffer[i]=n.quaternion.x,this.transformsBuffer[i+1]=n.quaternion.y,this.transformsBuffer[i+2]=n.quaternion.z,this.transformsBuffer[i+3]=n.quaternion.w,this.transformsBuffer[i+4]=n.pivot_Low.x,this.transformsBuffer[i+5]=n.pivot_Low.y,this.transformsBuffer[i+6]=n.pivot_Low.z,this.transformsBuffer[i+7]=n.scaleValue.x,this.transformsBuffer[i+8]=n.pivot_High.x,this.transformsBuffer[i+9]=n.pivot_High.y,this.transformsBuffer[i+10]=n.pivot_High.z,this.transformsBuffer[i+11]=n.scaleValue.y,this.transformsBuffer[i+12]=n.translation.x,this.transformsBuffer[i+13]=n.translation.y,this.transformsBuffer[i+14]=n.translation.z,this.transformsBuffer[i+15]=n.scaleValue.z,n.transformDirty=!1}this.transformsTextureUniform.needsUpdate=e}else{if(!this.transformsArrayUniforms)return;for(let t=0;t<this._batchObjects.length;t++){const n=this._batchObjects[t];(e||(e=n.transformDirty))&&this.transformsArrayUniforms[t].set(n.quaternion.x,n.pivot_Low.x,n.pivot_High.x,n.translation.x,n.quaternion.y,n.pivot_Low.y,n.pivot_High.y,n.translation.y,n.quaternion.z,n.pivot_Low.z,n.pivot_High.z,n.translation.z,n.quaternion.w,n.scaleValue.x,n.scaleValue.y,n.scaleValue.z)}}this.tas&&e&&(this.tas.refit(),this.tas.getBoundingBox(this.tas.bounds),this.geometry.boundingBox||(this.geometry.boundingBox=new Tt),this.geometry.boundingBox.copy(this.tas.bounds),this.geometry.boundingSphere||(this.geometry.boundingSphere=new Zn),this.geometry.boundingBox.getBoundingSphere(this.geometry.boundingSphere))}buildTAS(){this.tas=new dr(this.batchObjects),this.tas.refit()}getBatchObjectMaterial(e){const t=e.renderView,n=this.geometry.groups.find(i=>t.batchStart>=i.start&&t.batchStart+t.batchCount<=i.count+i.start);return Array.isArray(this.material)?n?this.material[n.materialIndex]:(dt.warn(`Could not get material for ${e.renderView.renderData.id}`),null):this.material}convertRaycastIntersect(e,t,n){return e===null?null:(e.point.applyMatrix4(t.matrixWorld),e.distance=e.point.distanceTo(n.ray.origin),e.object=t,e.distance<n.near||e.distance>n.far?null:e)}raycast(e,t){if(this.tas){if(this.batchMaterial===void 0)return;if(Yw.copy(this.matrixWorld).invert(),Mg.copy(e.ray).applyMatrix4(Yw),e.firstHitOnly===!0){const n=this.convertRaycastIntersect(this.tas.raycastFirst(Mg,e.intersectTASOnly,this.batchMaterial),this,e);n&&t.push(n)}else{const n=this.tas.raycast(Mg,e.intersectTASOnly,this.batchMaterial);for(let i=0,r=n.length;i<r;i++){const a=this.convertRaycastIntersect(n[i],this,e);a&&t.push(a)}}}else{const n=this.geometry,i=this.material,r=this.matrixWorld;if(i===void 0||(n.boundingSphere===null&&n.computeBoundingSphere(),wg.copy(n.boundingSphere||new Zn),wg.applyMatrix4(r),e.ray.intersectsSphere(wg)===!1)||(Kw.copy(r).invert(),Dl.copy(e.ray).applyMatrix4(Kw),n.boundingBox!==null&&Dl.intersectsBox(n.boundingBox)===!1))return;let a;const o=n.index,l=n.attributes.position,c=n.attributes.position_low,u=n.morphAttributes.position,h=n.morphTargetsRelative,d=n.attributes.uv,f=n.attributes.uv2,v=n.groups,g=n.drawRange;if(o!==null)if(Array.isArray(i))for(let m=0,x=v.length;m<x;m++){const w=v[m];if(!w.materialIndex){dt.error("Group with no material, skipping!");continue}const S=i[w.materialIndex];for(let b=Math.max(w.start,g.start),E=Math.min(o.count,Math.min(w.start+w.count,g.start+g.count));b<E;b+=3){const C=o.getX(b),P=o.getX(b+1),M=o.getX(b+2);a=rf(this,S,e,Dl,c,l,u,h,d,f,C,P,M),a&&(a.faceIndex=Math.floor(b/3),a.face&&(a.face.materialIndex=w.materialIndex),t.push(a))}}else for(let m=Math.max(0,g.start),x=Math.min(o.count,g.start+g.count);m<x;m+=3){const w=o.getX(m),S=o.getX(m+1),b=o.getX(m+2);a=rf(this,i,e,Dl,c,l,u,h,d,f,w,S,b),a&&(a.faceIndex=Math.floor(m/3),t.push(a))}else if(l!==void 0)if(Array.isArray(i))for(let m=0,x=v.length;m<x;m++){const w=v[m],S=i[w.materialIndex];for(let b=Math.max(w.start,g.start),E=Math.min(l.count,Math.min(w.start+w.count,g.start+g.count));b<E;b+=3)a=rf(this,S,e,Dl,c,l,u,h,d,f,b,b+1,b+2),a&&(a.faceIndex=Math.floor(b/3),a.face&&(a.face.materialIndex=w.materialIndex),t.push(a))}else for(let m=Math.max(0,g.start),x=Math.min(l.count,g.start+g.count);m<x;m+=3)a=rf(this,i,e,Dl,c,l,u,h,d,f,m,m+1,m+2),a&&(a.faceIndex=Math.floor(m/3),t.push(a))}}}function rf(s,e,t,n,i,r,a,o,l,c,u,h,d){Is.fromBufferAttribute(r,u),Ps.fromBufferAttribute(r,h),Ds.fromBufferAttribute(r,d),i&&(Is.add(Sg.fromBufferAttribute(i,u)),Ps.add(Sg.fromBufferAttribute(i,h)),Ds.add(Sg.fromBufferAttribute(i,d)));const f=s.morphTargetInfluences;if(a&&f){Kd.set(0,0,0),Yd.set(0,0,0),Zd.set(0,0,0);for(let g=0,m=a.length;g<m;g++){const x=f[g],w=a[g];x!==0&&(bg.fromBufferAttribute(w,u),Ag.fromBufferAttribute(w,h),Tg.fromBufferAttribute(w,d),o?(Kd.addScaledVector(bg,x),Yd.addScaledVector(Ag,x),Zd.addScaledVector(Tg,x)):(Kd.addScaledVector(bg.sub(Is),x),Yd.addScaledVector(Ag.sub(Ps),x),Zd.addScaledVector(Tg.sub(Ds),x)))}Is.add(Kd),Ps.add(Yd),Ds.add(Zd)}s.isSkinnedMesh&&(s.boneTransform(u,Is),s.boneTransform(h,Ps),s.boneTransform(d,Ds));const v=function(g,m,x,w,S,b,E,C){let P;if(P=m.side===er?w.intersectTriangle(E,b,S,!0,C):w.intersectTriangle(S,b,E,m.side!==Qt,C),P===null)return null;nf.copy(C),nf.applyMatrix4(g.matrixWorld);const M=x.ray.origin.distanceTo(nf);return M<x.near||M>x.far?null:{distance:M,point:nf.clone(),object:g,uv:void 0,uv2:void 0,face:void 0}}(s,e,t,n,Is,Ps,Ds,Eg);if(v){l&&($d.fromBufferAttribute(l,u),ef.fromBufferAttribute(l,h),tf.fromBufferAttribute(l,d),v.uv=Cn.getUV(Eg,Is,Ps,Ds,$d,ef,tf,new Me)),c&&($d.fromBufferAttribute(c,u),ef.fromBufferAttribute(c,h),tf.fromBufferAttribute(c,d),v.uv2=Cn.getUV(Eg,Is,Ps,Ds,$d,ef,tf,new Me));const g={a:u,b:h,c:d,normal:new T,materialIndex:0};Cn.getNormal(Is,Ps,Ds,g.normal),v.face=g}return v}qp.MeshBatchNumber=0;class zh extends yA{get vertexProgram(){return`
#include <common>
#ifdef USE_RTE
    // The high component is stored as the default 'position' attribute buffer
    attribute vec3 position_low;
    uniform vec3 uViewer_high;
    uniform vec3 uViewer_low;
    uniform mat4 rteModelViewMatrix;
#endif

#ifdef TRANSFORM_STORAGE
    attribute float objIndex;

    #if TRANSFORM_STORAGE == 0
        #if __VERSION__ == 300
            #define TRANSFORM_STRIDE 4
        #else
            #define TRANSFORM_STRIDE 4.
        #endif
        uniform sampler2D tTransforms;
        uniform float objCount;
    #elif TRANSFORM_STORAGE == 1
        uniform mat4 uTransforms[OBJ_COUNT];
    #endif
#endif

#ifdef LINEAR_DEPTH
    varying vec4 vViewPosition;
#endif

#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
// This is used for computing an equivalent of gl_FragCoord.z that is as high precision as possible.
// Some platforms compute gl_FragCoord at a lower precision which makes the manually computed value better for
// depth-based postprocessing effects. Reproduced on iPad with A10 processor / iPadOS 13.3.1.
varying vec2 vHighPrecisionZW;

#ifdef TRANSFORM_STORAGE
    void objectTransform(out vec4 quaternion, out vec4 pivotLow, out vec4 pivotHigh, out vec4 translation, out vec4 scale){
        #if TRANSFORM_STORAGE == 0
            #if __VERSION__ == 300
                ivec2 uv = ivec2(int(objIndex) * TRANSFORM_STRIDE, 0); 
                vec4 v0 = texelFetch( tTransforms, uv, 0 );
                vec4 v1 = texelFetch( tTransforms, uv + ivec2(1, 0), 0);
                vec4 v2 = texelFetch( tTransforms, uv + ivec2(2, 0), 0);
                vec4 v3 = texelFetch( tTransforms, uv + ivec2(3, 0), 0);
                quaternion = v0;
                pivotLow = vec4(v1.xyz, 1.);
                pivotHigh = vec4(v2.xyz, 1.);
                translation = vec4(v3.xyz, 1.);
                scale = vec4(v1.w, v2.w, v3.w, 1.);
            #else
                float size = objCount * TRANSFORM_STRIDE;
                vec2 cUv = vec2(0.5/size, 0.5);
                vec2 dUv = vec2(1./size, 0.);
                
                vec2 uv = vec2((objIndex * TRANSFORM_STRIDE)/size + cUv.x, cUv.y);
                vec4 v0 = texture2D( tTransforms, uv);
                vec4 v1 = texture2D( tTransforms, uv + dUv);
                vec4 v2 = texture2D( tTransforms, uv + 2. * dUv);
                vec4 v3 = texture2D( tTransforms, uv + 3. * dUv);
                quaternion = v0;
                pivotLow = vec4(v1.xyz, 1.);
                pivotHigh = vec4(v2.xyz, 1.);
                translation = vec4(v3.xyz, 1.);
                scale = vec4(v1.w, v2.w, v3.w, 1.);
            #endif
        #elif TRANSFORM_STORAGE == 1
            mat4 tMatrix = uTransforms[int(objIndex)];
            quaternion = tMatrix[0];
            pivotLow = vec4(tMatrix[1].xyz, 1.);
            pivotHigh = vec4(tMatrix[2].xyz, 1.);
            translation = vec4(tMatrix[3].xyz, 1.);
            scale = vec4(tMatrix[1][3], tMatrix[2][3], tMatrix[3][3], 1.);
        #endif
    }

    vec3 rotate_vertex_position(vec3 position, vec4 quat)
    { 
        return position + 2.0 * cross(quat.xyz, cross(quat.xyz, position) + quat.w * position);
    }

    /** Another workaround for Apple's stupid compiler */
    vec4 safeMul(vec4 a, vec4 b) {
        // Prevents constant folding and optimization
        return (a + vec4(0.0)) * (b + vec4(1.0)) - a * vec4(1.0);
    }

    highp vec3 rotate_scaled_vertex_position_delta(highp vec4 v0, highp vec4 v1, highp vec4 scale, highp vec4 quat)
    {
        /** !!! WORKAROUND FOR Intel IrisXe CARDS !!! */
        /** The code below will not produce correct results in intel IrisXE integrated GPUs. 
         *  The geometry will turn mangled, albeit stable
         *  I can't know for sure what is going on, but rotating the difference seems to 
         *  force the result into a lower precision?
         */
        // highp vec4 position = v0 - v1;
        // return position.xyz + 2.0 * cross(quat.xyz, cross(quat.xyz, position.xyz) + quat.w * position.xyz);

        /** Subtracting the rotated vectors works. */
        return rotate_vertex_position(safeMul(v0, scale).xyz, quat)  - rotate_vertex_position(safeMul(v1, scale).xyz, quat) ;

        /** An alternate workaround is
         * highp vec3 position = (v0.xyz * (1. + 1e-7)) - (v1.xyz * (1. + 1e-7));
           return position + 2.0 * cross(quat.xyz, cross(quat.xyz, position) + quat.w * position);

           However I'm not such a fan of the (1. + 1e-7) part
         */
    }

    
#endif

#ifdef USE_RTE
    highp vec4 computeRelativePosition(in highp vec3 position_low, in highp vec3 position_high, in highp vec3 relativeTo_low, in highp vec3 relativeTo_high){
        /* 
        Source https://github.com/virtualglobebook/OpenGlobe/blob/master/Source/Examples/Chapter05/Jitter/GPURelativeToEyeDSFUN90/Shaders/VS.glsl 
        Note here, we're storing the high part of the position encoding inside three's default 'position' attribute buffer so we avoid redundancy 
        */
        highp vec3 t1 = position_low.xyz - relativeTo_low.xyz;
        highp vec3 e = t1 - position_low.xyz;
        /** This is redunant, but necessary as a workaround for Apple platforms */
        highp float x = position_high.x - relativeTo_high.x;
        highp float y = position_high.y - relativeTo_high.y;
        highp float z = position_high.z - relativeTo_high.z;
        highp vec3 v = vec3(x, y, z);
        /** End of redundant part */
        highp vec3 t2 = ((-relativeTo_low - e) + (position_low.xyz - (t1 - e))) + v;
        highp vec3 highDifference = t1 + t2;
        highp vec3 lowDifference = t2 - (highDifference.xyz - t1.xyz);
        
        highp vec3 position = highDifference.xyz + lowDifference.xyz;
        return vec4(position, 1.);
    }
#endif


void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	//#include <project_vertex> // EDITED CHUNK
    #ifdef TRANSFORM_STORAGE
        vec4 tQuaternion, tPivotLow, tPivotHigh, tTranslation, tScale;
        objectTransform(tQuaternion, tPivotLow, tPivotHigh, tTranslation, tScale);
    #endif
    #ifdef USE_RTE
        vec4 position_lowT = vec4(position_low, 1.);
        vec4 position_highT = vec4(position, 1.);
        const vec3 ZERO3 = vec3(0., 0., 0.);

        highp vec4 rteLocalPosition = computeRelativePosition(position_lowT.xyz, position_highT.xyz, uViewer_low, uViewer_high);
        #ifdef TRANSFORM_STORAGE
            highp vec4 rtePivot = computeRelativePosition(tPivotLow.xyz, tPivotHigh.xyz, uViewer_low, uViewer_high);
            rteLocalPosition.xyz = rotate_scaled_vertex_position_delta(rteLocalPosition, rtePivot, tScale, tQuaternion) + rtePivot.xyz + tTranslation.xyz;
        #endif
        #ifdef USE_INSTANCING
            vec4 instancePivot = computeRelativePosition(ZERO3, ZERO3, uViewer_low, uViewer_high);
            rteLocalPosition.xyz = (mat3(instanceMatrix) * (rteLocalPosition - instancePivot).xyz) + instancePivot.xyz + instanceMatrix[3].xyz;
        #endif
    #endif

    #ifdef USE_RTE
        vec4 mvPosition = rteLocalPosition;
    #else
        vec4 mvPosition = vec4( transformed, 1.0 );
        #ifdef TRANSFORM_STORAGE
            mvPosition.xyz = rotate_scaled_vertex_position_delta(mvPosition, tPivotHigh, tScale, tQuaternion) + tPivotHigh.xyz + tTranslation.xyz;
        #endif
        #ifdef USE_INSTANCING
            mvPosition = instanceMatrix * mvPosition;
        #endif
    #endif
   
    #ifdef USE_RTE
        mvPosition = rteModelViewMatrix * mvPosition;
    #else
        mvPosition = modelViewMatrix * mvPosition;
    #endif
    
    #ifdef LINEAR_DEPTH
        vViewPosition = mvPosition;
    #endif 
    
    gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	// #include <clipping_planes_vertex>
    #if NUM_CLIPPING_PLANES > 0
	    vClipPosition = - mvPosition.xyz;
    #endif
	vHighPrecisionZW = gl_Position.zw;
}
`}get fragmentProgram(){return`
#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#ifdef LINEAR_DEPTH
    varying vec4 vViewPosition;
	uniform float near;
	uniform float far;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;

void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	// #include <alphatest_fragment>
	#ifdef USE_ALPHATEST
		if ( diffuseColor.a < alphaTest ) discard;
		/** This is a workaround for rejecting shadows for certain materials, since three.js gave me no choice*/
		#ifdef ALPHATEST_REJECTION
			if (alphaTest > 0. ) discard;
		#endif
	#endif
	#include <logdepthbuf_fragment>
	// Higher precision equivalent of gl_FragCoord.z. This assumes depthRange has been left to its default values.
	#ifdef LINEAR_DEPTH
		/** View z is negative moving away from the camera */
		gl_FragColor = packDepthToRGBA((vViewPosition.z + near) / (near - far));
	#else
		float fragCoordZ = (0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5);
		#if DEPTH_PACKING == 3200
			gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
		#elif DEPTH_PACKING == 3201
			gl_FragColor = packDepthToRGBA( fragCoordZ );
		#endif
	#endif
}
`}get baseUniforms(){return Xn.depth.uniforms}get uniformsDef(){return{uViewer_high:new T,uViewer_low:new T,rteModelViewMatrix:new Ne,near:0,far:0,uTransforms:[new Ne],tTransforms:null,objCount:1}}constructor(e,t=[]){super(e),this.init(t)}customProgramCacheKey(){return this.constructor.name}copy(e){return super.copy(e),this.copyFrom(e),this}fastCopy(e,t){super.fastCopy(e,t),t.userData.near.value=e.userData.near.value,t.userData.far.value=e.userData.far.value}onBeforeRender(e,t,n,i,r){this.defines&&this.defines.USE_RTE&&(r.modelViewMatrix.copy(e.RTEBuffers.rteViewModelMatrix),this.userData.uViewer_low.value.copy(e.RTEBuffers.viewerLow),this.userData.uViewer_high.value.copy(e.RTEBuffers.viewerHigh),this.userData.rteModelViewMatrix.value.copy(e.RTEBuffers.rteViewModelMatrix),this.needsUpdate=!0)}}class TA extends ob{constructor(e,t,n,i){super(e,t,n),this._batchIndex=i}get batchIndex(){return this._batchIndex}}const Zw=new Ne,Ll=new Ti,Cg=new Zn,Rg=new T,Ls=new T,Bs=new T,Os=new T,Ig=new T,Pg=new T,Dg=new T,sf=new T,af=new T,of=new T,lf=new Me,cf=new Me,uf=new Me,Lg=new T,hf=new T,Bg=new Ti,$w=new Ne;class O0 extends Er{get TAS(){return this.tas}get batchObjects(){return this._batchObjects}get needsRTE(){return this._needsRTE}constructor(e,t=!1){super(),this.materialCache={},this.materialStack=[],this.batchMaterialStack=[],this.materialCacheLUT={},this.groups=[],this.materials=[],this.instanceGeometry=void 0,this.instances=[],this.instanceGeometry=e,this.userData.raycastChildren=!1,this._needsRTE=t}setBatchMaterial(e){this.batchMaterial=e,this.materialCache[e.id]=e,this.materials.push(this.batchMaterial)}setBatchObjects(e){this._batchObjects=e}setOverrideMaterial(e){const t=[];for(let i=0;i<this.instances.length;i++)t.push(this.instances[i].material);this.materialStack.push(t);const n=this.getCachedMaterial(e,!0);this.instances.forEach(i=>i.material=n)}setOverrideBatchMaterial(e){const t=this.getCachedMaterial(e,!0);this.batchMaterialStack.push(t);const n=this.materials;for(let i=0;i<n.length;i++)n[i].uuid===this.batchMaterial.uuid&&(n[i]=t);this.instances.forEach(i=>{i.material.uuid===this.batchMaterial.uuid&&(i.material=t)})}restoreBatchMaterial(){const e=this.batchMaterialStack.pop();if(e){for(let t=0;t<this.materials.length;t++)this.materials[t].uuid===e.uuid&&(this.materials[t]=this.batchMaterial);this.instances.forEach(t=>{t.material.uuid===e.uuid&&(t.material=this.batchMaterial)})}}lookupMaterial(e){return this.materialCache[e.id]||this.materialCache[this.materialCacheLUT[e.id]]}getCachedMaterial(e,t=!1){let n=this.lookupMaterial(e);if(n)(t||e.needsCopy||n.needsCopy)&&ln.fastCopy(e,n);else{const i=e.clone();this.materialCache[e.id]=i,this.materialCacheLUT[i.id]=e.id,n=i,this.updateMaterialTransformsUniform(this.materialCache[e.id])}return n}restoreMaterial(){if(this.materialStack.length>0){const e=this.materialStack.pop();for(let t=0;t<e.length;t++)this.instances[t].material=e[t]}}buildTAS(){this.tas=new dr(this.batchObjects),this.tas.refit()}updateDrawGroups(e,t,n){this.instances.forEach(i=>{var r;this.remove(i),(r=i.customDepthMaterial)===null||r===void 0||r.dispose(),i.dispose()}),this.instances.length=0;for(let i=0;i<this.groups.length;i++){const r=this.groups[i].materialIndex,a=this.materials[r],o=new TA(this.getInstanceGeometryShallowCopy(),a,0,gA());o.instanceMatrix=new ko(e.subarray(this.groups[i].start,this.groups[i].start+this.groups[i].count),16),o.geometry.setAttribute("gradientIndex",new ko(t.subarray(this.groups[i].start/16,(this.groups[i].start+this.groups[i].count)/16),1)),n&&o.geometry.setAttribute("objIndex",new ko(n.subarray(this.groups[i].start/16,(this.groups[i].start+this.groups[i].count)/16),1)),o.count=this.groups[i].count/16,o.instanceMatrix.needsUpdate=!0,o.layers.set(vt.STREAM_CONTENT_MESH),o.frustumCulled=!1,o.customDepthMaterial=new zh({depthPacking:Ko},["ALPHATEST_REJECTION"]),o.castShadow=!a.transparent,o.receiveShadow=!a.transparent,this.instances.push(o),this.add(o)}this.tas.refit(),this.tas.getBoundingBox(this.tas.bounds)}updateTransformsUniform(){let e=!1;for(let t=0;t<this._batchObjects.length;t++){const n=this._batchObjects[t];if(!e&&!(e=n.transformDirty))continue;const i=n.renderView,r=this.groups.find(a=>i.batchStart>=a.start&&i.batchStart+i.batchCount<=a.count+a.start);if(r){const a=this.instances[this.groups.indexOf(r)];a.setMatrixAt((i.batchStart-r.start)/16,n.transform),a.instanceMatrix.needsUpdate=!0}n.transformDirty=!1}this.tas&&e&&(this.tas.refit(),this.tas.getBoundingBox(this.tas.bounds))}updateMaterialTransformsUniform(e){}getBatchObjectMaterial(e){const t=e.renderView,n=this.groups.find(i=>t.batchStart>=i.start&&t.batchStart+t.batchCount<=i.count+i.start);return n?this.materials[n.materialIndex]:(dt.warn(`Could not get material for ${e.renderView.renderData.id}`),null)}getInstanceGeometryShallowCopy(){var e,t;const n=new Xt;for(const i in(e=this.instanceGeometry)===null||e===void 0?void 0:e.attributes)n.setAttribute(i,this.instanceGeometry.attributes[i]);return n.setIndex((t=this.instanceGeometry)===null||t===void 0?void 0:t.index),n}convertRaycastIntersect(e,t,n){return e===null?null:(e.point.applyMatrix4(t.matrixWorld),e.distance=e.point.distanceTo(n.ray.origin),e.object=t,e.distance<n.near||e.distance>n.far?null:e)}raycast(e,t){if(this.tas){if(!this.batchMaterial)return;if($w.copy(this.matrixWorld).invert(),Bg.copy(e.ray).applyMatrix4($w),e.firstHitOnly===!0){const n=this.convertRaycastIntersect(this.tas.raycastFirst(Bg,e.intersectTASOnly,this.batchMaterial),this,e);n&&t.push(n)}else{const n=this.tas.raycast(Bg,e.intersectTASOnly,this.batchMaterial);for(let i=0,r=n.length;i<r;i++){const a=this.convertRaycastIntersect(n[i],this,e);a&&t.push(a)}}}else{const n=this.instanceGeometry,i=this.materials[0],r=this.matrixWorld;if(i===void 0||n===void 0||(n.boundingSphere===null&&n.computeBoundingSphere(),Cg.copy(n.boundingSphere||new Zn),Cg.applyMatrix4(r),e.ray.intersectsSphere(Cg)===!1)||(Zw.copy(r).invert(),Ll.copy(e.ray).applyMatrix4(Zw),n.boundingBox!==null&&Ll.intersectsBox(n.boundingBox)===!1))return;let a;const o=n.index,l=n.attributes.position,c=n.attributes.position_low,u=n.morphAttributes.position,h=n.morphTargetsRelative,d=n.attributes.uv,f=n.attributes.uv2,v=n.groups,g=n.drawRange;if(o!==null)if(Array.isArray(i))for(let m=0,x=v.length;m<x;m++){const w=v[m];if(!w.materialIndex){dt.error("Group with no material, skipping!");continue}const S=i[w.materialIndex];for(let b=Math.max(w.start,g.start),E=Math.min(o.count,Math.min(w.start+w.count,g.start+g.count));b<E;b+=3){const C=o.getX(b),P=o.getX(b+1),M=o.getX(b+2);a=df(this,S,e,Ll,c,l,u,h,d,f,C,P,M),a&&(a.faceIndex=Math.floor(b/3),a.face&&(a.face.materialIndex=w.materialIndex),t.push(a))}}else for(let m=Math.max(0,g.start),x=Math.min(o.count,g.start+g.count);m<x;m+=3){const w=o.getX(m),S=o.getX(m+1),b=o.getX(m+2);a=df(this,i,e,Ll,c,l,u,h,d,f,w,S,b),a&&(a.faceIndex=Math.floor(m/3),t.push(a))}else if(l!==void 0)if(Array.isArray(i))for(let m=0,x=v.length;m<x;m++){const w=v[m];if(!w.materialIndex){dt.error("Group with no material, skipping!");continue}const S=i[w.materialIndex];for(let b=Math.max(w.start,g.start),E=Math.min(l.count,Math.min(w.start+w.count,g.start+g.count));b<E;b+=3)a=df(this,S,e,Ll,c,l,u,h,d,f,b,b+1,b+2),a&&(a.faceIndex=Math.floor(b/3),a.face&&(a.face.materialIndex=w.materialIndex),t.push(a))}else for(let m=Math.max(0,g.start),x=Math.min(l.count,g.start+g.count);m<x;m+=3)a=df(this,i,e,Ll,c,l,u,h,d,f,m,m+1,m+2),a&&(a.faceIndex=Math.floor(m/3),t.push(a))}}}function df(s,e,t,n,i,r,a,o,l,c,u,h,d){Ls.fromBufferAttribute(r,u),Bs.fromBufferAttribute(r,h),Os.fromBufferAttribute(r,d),i&&(Ls.add(Rg.fromBufferAttribute(i,u)),Bs.add(Rg.fromBufferAttribute(i,h)),Os.add(Rg.fromBufferAttribute(i,d)));const f=s.morphTargetInfluences;if(a&&f){sf.set(0,0,0),af.set(0,0,0),of.set(0,0,0);for(let g=0,m=a.length;g<m;g++){const x=f[g],w=a[g];x!==0&&(Ig.fromBufferAttribute(w,u),Pg.fromBufferAttribute(w,h),Dg.fromBufferAttribute(w,d),o?(sf.addScaledVector(Ig,x),af.addScaledVector(Pg,x),of.addScaledVector(Dg,x)):(sf.addScaledVector(Ig.sub(Ls),x),af.addScaledVector(Pg.sub(Bs),x),of.addScaledVector(Dg.sub(Os),x)))}Ls.add(sf),Bs.add(af),Os.add(of)}s.isSkinnedMesh&&(s.boneTransform(u,Ls),s.boneTransform(h,Bs),s.boneTransform(d,Os));const v=function(g,m,x,w,S,b,E,C){let P;if(P=m.side===er?w.intersectTriangle(E,b,S,!0,C):w.intersectTriangle(S,b,E,m.side!==Qt,C),P===null)return null;hf.copy(C),hf.applyMatrix4(g.matrixWorld);const M=x.ray.origin.distanceTo(hf);return M<x.near||M>x.far?null:{distance:M,point:hf.clone(),object:g,uv:void 0,uv2:void 0,face:void 0,faceIndex:void 0}}(s,e,t,n,Ls,Bs,Os,Lg);if(v){l&&(lf.fromBufferAttribute(l,u),cf.fromBufferAttribute(l,h),uf.fromBufferAttribute(l,d),v.uv=Cn.getUV(Lg,Ls,Bs,Os,lf,cf,uf,new Me)),c&&(lf.fromBufferAttribute(c,u),cf.fromBufferAttribute(c,h),uf.fromBufferAttribute(c,d),v.uv2=Cn.getUV(Lg,Ls,Bs,Os,lf,cf,uf,new Me));const g={a:u,b:h,c:d,normal:new T,materialIndex:0};Cn.getNormal(Ls,Bs,Os,g.normal),v.face=g}return v}O0.MeshBatchNumber=0;class nn{get renderView(){return this._renderView}get accelerationStructure(){return this._accelerationStructure}get batchIndex(){return this._batchIndex}get aabb(){if(this.renderView.aabb){const e=new Tt().copy(this.renderView.aabb);return e.applyMatrix4(this.transform),e}return new Tt}get localOrigin(){return this._localOrigin}set pivot(e){e?this.pivotValue.copy(e):this.pivotValue.copy(this._localOrigin),hn.DoubleToHighLowVector(this.pivotValue,this.pivot_Low,this.pivot_High)}set position(e){this.transformTRS(e,this.eulerValue,this.scaleValue,this.pivotValue)}set euler(e){this.transformTRS(this.translation,e,this.scaleValue,this.pivotValue)}set scale(e){this.transformTRS(this.translation,this.eulerValue,e,this.pivotValue)}constructor(e,t){this.quaternion=new An,this.eulerValue=new vr,this.pivot_High=new T,this.pivot_Low=new T,this.translation=new T,this.scaleValue=new T(1,1,1),this.pivotValue=new T,this.transformDirty=!0,this._renderView=e,this._batchIndex=t,this.transform=new Ne().identity(),this.transformInv=new Ne().identity(),this._localOrigin=this._renderView.aabb.getCenter(new T),this.pivotValue.copy(this._localOrigin),hn.DoubleToHighLowVector(new T(this._localOrigin.x,this._localOrigin.y,this._localOrigin.z),this.pivot_Low,this.pivot_High)}buildAccelerationStructure(e){var t,n;const i=new Ne().makeTranslation(this._localOrigin.x,this._localOrigin.y,this._localOrigin.z);if(i.invert(),!e){const r=(t=this._renderView.renderData.geometry.attributes)===null||t===void 0?void 0:t.INDEX,a=(n=this._renderView.renderData.geometry.attributes)===null||n===void 0?void 0:n.POSITION;e=qr.buildBVH(r,a,B0,i)}this._accelerationStructure=new qr(e),this._accelerationStructure.inputTransform=this.transformInv,this._accelerationStructure.outputTransform=this.transform,this._accelerationStructure.inputOriginTransform=new Ne().copy(i),this._accelerationStructure.outputOriginTransfom=new Ne().copy(i).invert()}transformTRS(e,t,n,i){let r=nn.matBuff0.identity(),a=nn.matBuff1.identity(),o=nn.matBuff2.identity();nn.eulerBuff.set(0,0,0,"XYZ"),nn.translationBuff.set(0,0,0),nn.scaleBuff.set(1,1,1),nn.pivotBuff.copy(this._localOrigin),e&&(r=nn.matBuff0.makeTranslation(e.x,e.y,e.z),nn.translationBuff.set(e.x,e.y,e.z)),t&&(nn.eulerBuff.set(t.x,t.y,t.z,"XYZ"),a=nn.matBuff1.makeRotationFromEuler(nn.eulerBuff),this.quaternion.setFromEuler(nn.eulerBuff),this.eulerValue.copy(nn.eulerBuff)),n&&(o=nn.matBuff2.makeScale(n.x,n.y,n.z),nn.scaleBuff.set(n.x,n.y,n.z)),i&&nn.pivotBuff.set(i.x,i.y,i.z),this.transform.identity(),this.transform.multiply(r),this.transform.multiply(a),this.transform.multiply(o);const l=new Ne().multiplyMatrices(new Ne().makeTranslation(nn.pivotBuff.x,nn.pivotBuff.y,nn.pivotBuff.z),this.transform);l.multiply(new Ne().makeTranslation(-nn.pivotBuff.x,-nn.pivotBuff.y,-nn.pivotBuff.z)),this.transform.copy(l),this.transformInv.copy(this.transform),this.transformInv.invert(),this.translation.copy(nn.translationBuff),this.quaternion.setFromEuler(nn.eulerBuff),this.scaleValue.copy(nn.scaleBuff),this.pivotValue.copy(nn.pivotBuff),hn.DoubleToHighLowVector(nn.pivotBuff,this.pivot_Low,this.pivot_High),this.transformDirty=!0}}nn.matBuff0=new Ne,nn.matBuff1=new Ne,nn.matBuff2=new Ne,nn.eulerBuff=new vr,nn.translationBuff=new T,nn.scaleBuff=new T,nn.pivotBuff=new T;class LN extends nn{constructor(e,t){super(e,t),this.instanceTransform=new Ne,e.renderData.geometry.transform&&this.instanceTransform.copy(e.renderData.geometry.transform),this.transform.copy(this.instanceTransform),this.transformInv.copy(new Ne().copy(this.instanceTransform).invert()),this.transformDirty=!1}transformTRS(e,t,n,i){super.transformTRS(e,t,n,i),this.transform.multiply(this.instanceTransform),this.transformInv.copy(this.transform),this.transformInv.invert()}}class N0{integrateRanges(e,t,n){let i=[];e.sort((u,h)=>u.start-h.start),n.sort((u,h)=>u.offset-h.offset);const r={},a={};for(let u=0,h=e.length-1;u<e.length;u++,h--){const d=e[u],f=e[h];r[d.start]=d.materialIndex,a[f.start+f.count]=f.materialIndex}i=e.map(u=>u.start+u.count),i.unshift(0);for(let u=0;u<n.length;u++){const h=n[u],d=h.offset,f=i.findIndex(w=>w>d),v=i[f];i.splice(f,0,d);const g=h.offset+h.count,m=i.findIndex(w=>w>g);i.splice(m,0,g),i=i.filter(w=>!(w>d&&w<g)),i=[...new Set(i)];const x=t.indexOf(h.material);r[d]=x,r[g]=g>=v?r[v]:a[v]}const o=[];let l=-1,c=0;for(let u=0;u<i.length-1;u++){const h=i[u];c+=i[u+1]-h;const d=r[h],f=u===i.length-2;(r[i[u+1]]!==d&&!f||(l===-1&&(l=h),f))&&(o.push({start:l===-1?h:l,count:c,materialIndex:d}),l=-1,c=0)}return o}}class eS{get bounds(){return this.mesh.TAS.getBoundingBox(new Tt)}get drawCalls(){return this.groups.length}get minDrawCalls(){return[...Array.from(new Set(this.groups.map(e=>e.materialIndex)))].length}get maxDrawCalls(){return 1}get triCount(){return(this.geometry.index?this.geometry.index.count:0)/3*this.renderViews.length}get vertCount(){return this.geometry.attributes.position.count*this.renderViews.length}get pointCount(){return 0}get lineCount(){return 0}get geometryType(){return mt.MESH}get renderObject(){return this.mesh}getCount(){return 16*this.renderViews.length}get materials(){return this.mesh.materials}get groups(){return this.mesh.groups}constructor(e,t,n,i){this.drawRanges=new N0,this.transformBufferIndex=0,this.needsShuffle=!1,this.id=e,this.subtreeId=t,this.renderViews=n,i||(this.instanceObjectIdBuffer=new Float32Array(this.renderViews.length))}setBatchMaterial(e){this.batchMaterial=e}onUpdate(e){this.needsShuffle&&(this.shuffleDrawGroups(),this.needsShuffle=!1)}onRender(e){}setVisibleRange(e){e.length!==1||e[0]!==Li?e.length!==1||e[0]!==kn?(this.mesh.children.forEach(t=>t.visible=!1),e.forEach(t=>{const n=this.groups.find(i=>t.offset===i.start&&t.offset+t.count===i.start+i.count);if(n){const i=this.groups.indexOf(n);i!==-1&&(this.mesh.children[i].visible=!0)}})):this.mesh.children.forEach(t=>t.visible=!0):this.mesh.children.forEach(t=>t.visible=!1)}getVisibleRange(){if(!this.mesh.children[0].visible)return Li;for(let e=0;e<this.mesh.children.length;e++)if(!this.mesh.children[e].visible)return{offset:0,count:16*e};return kn}getOpaque(){const e=this.groups.find(t=>t.materialIndex!==void 0&&(ln.isTransparent(this.materials[t.materialIndex])||this.materials[t.materialIndex].visible===!1));return e?{offset:0,count:e.start}:kn}getDepth(){const e=this.groups.find(t=>t.materialIndex!==void 0&&(ln.isTransparent(this.materials[t.materialIndex])||this.materials[t.materialIndex].visible===!1||this.materials[t.materialIndex].colorWrite===!1));return e?{offset:0,count:e.start}:kn}getTransparent(){const e=this.groups.find(n=>n.materialIndex!==void 0&&ln.isTransparent(this.materials[n.materialIndex])),t=this.groups.find(n=>n.materialIndex!==void 0&&this.materials[n.materialIndex].visible===!1);if(e){const n=e.start,i=t!==void 0?t.start:this.getCount()-e.start;return n===0&&i===this.getCount()?kn:{offset:n,count:i}}return Li}getStencil(){if(this.groups.length===1&&this.materials[0].stencilWrite===!0)return kn;const e=this.groups.find(t=>t.materialIndex!==void 0&&this.materials[t.materialIndex].stencilWrite===!0);return e?{offset:e.start,count:e.count}:Li}setBatchBuffers(e){for(let t=0;t<e.length;t++){const n=e[t];if(n.materialOptions){if(n.materialOptions.rampIndex!==void 0&&n.materialOptions.rampWidth!==void 0){const i=e[t].offset,r=n.materialOptions.rampIndex+.5/n.materialOptions.rampWidth;this.updateGradientIndexBufferData(i/16,r)}n.materialOptions.rampTexture!==void 0&&n.material instanceof Xl&&n.material.setGradientTexture(n.materialOptions.rampTexture)}}}setDrawRanges(e){e.forEach(r=>{r.material&&(r.material=this.mesh.getCachedMaterial(r.material))});const t=e.map(r=>r.material),n=[...Array.from(new Set(t.map(r=>r)))];for(let r=0;r<n.length;r++)this.materials.includes(n[r])||this.materials.push(n[r]);this.mesh.groups=this.drawRanges.integrateRanges(this.groups,this.materials,e);let i=0;this.groups.forEach(r=>i+=r.count),i!==16*this.renderViews.length&&dt.error(`Draw groups invalid on ${this.id}`),this.setBatchBuffers(e),this.cleanMaterials(),this.drawCalls>this.maxDrawCalls?this.needsShuffle=!0:this.mesh.updateDrawGroups(this.getCurrentTransformBuffer(),this.getCurrentGradientBuffer(),this.getCurrentObjectIndexBuffer())}cleanMaterials(){const e=[...Array.from(new Set(this.groups.map(n=>this.materials[n.materialIndex])))];let t=0;for(;this.materials.length>e.length;)e.includes(this.materials[t])?t++:(this.materials.splice(t,1),this.groups.forEach(n=>{n.materialIndex>t&&n.materialIndex--}),t=0)}shuffleDrawGroups(){const e=this.groups.sort((d,f)=>d.start-f.start).slice();this.groups.sort((d,f)=>{const v=this.materials[d.materialIndex],g=this.materials[f.materialIndex],m=+g.visible+ +g.colorWrite-(+v.visible+ +v.colorWrite),x=+v.transparent-+g.transparent;return m!==0?m:x});const t=[];e.reduce((d,f)=>(f.materialIndex!==void 0&&d.indexOf(f.materialIndex)===-1&&d.push(f.materialIndex),d),t);const n=[];for(let d=0;d<t.length;d++)n.push(e.filter(f=>f.materialIndex===t[d]));const i=this.getCurrentTransformBuffer(),r=this.getNextTransformBuffer(),a=this.getCurrentGradientBuffer(),o=new Float32Array(a.length),l=[],c=this.renderViews.slice();c.sort((d,f)=>d.batchStart-f.batchStart);let u=0;for(let d=0;d<n.length;d++){const f=n[d],v=u;let g=0;for(let m=0;m<f.length;m++){const x=f[m].start,w=f[m].count;let S=i.subarray(x,x+w);r.set(S,u),S=a.subarray(x/16,(x+w)/16),o.set(S,u/16);let b=0;for(let E=0;E<c.length;E++)c[E].batchStart>=x&&c[E].batchEnd<=x+w&&(c[E].setBatchData(this.id,u+b,c[E].batchCount),b+=c[E].batchCount,c.splice(E,1),E--);u+=w,g+=w}l.push({offset:v,count:g,materialIndex:f[0].materialIndex})}this.groups.length=0;for(let d=0;d<l.length;d++)this.groups.push({start:l[d].offset,count:l[d].count,materialIndex:l[d].materialIndex});a.set(o,0),this.mesh.updateDrawGroups(r,a,this.getCurrentObjectIndexBuffer());const h=this.groups.find(d=>d.materialIndex!==void 0&&this.materials[d.materialIndex].visible===!1);h&&this.setVisibleRange([{offset:0,count:h.start}])}resetDrawRanges(){this.groups.length=0,this.materials.length=0,this.groups.push({start:0,count:16*this.renderViews.length,materialIndex:0}),this.materials.push(this.batchMaterial),this.setVisibleRange([kn]),this.mesh.updateDrawGroups(this.getCurrentTransformBuffer(),this.getCurrentGradientBuffer(),this.getCurrentObjectIndexBuffer())}getCurrentTransformBuffer(){return this.transformBufferIndex%2==0?this.instanceTransformBuffer0:this.instanceTransformBuffer1}getNextTransformBuffer(){return++this.transformBufferIndex%2==0?this.instanceTransformBuffer0:this.instanceTransformBuffer1}getCurrentGradientBuffer(){return this.instanceGradientBuffer}getCurrentObjectIndexBuffer(){return this.instanceObjectIdBuffer}buildBatch(){var e,t,n,i,r,a;const o=[];let l=null;this.instanceTransformBuffer0=new Float32Array(16*this.renderViews.length),this.instanceTransformBuffer1=new Float32Array(16*this.renderViews.length);const c=this.getCurrentTransformBuffer();for(let v=0;v<this.renderViews.length;v++){const g=this.renderViews[v];if(!g.renderData.geometry.transform)throw new Error(`Instanced Render view with id ${g.renderData.id} has null transform!`);g.renderData.geometry.transform.toArray(c,16*v),this.renderViews[v].setBatchData(this.id,16*v,16),this.instanceObjectIdBuffer&&(this.instanceObjectIdBuffer[v]=v);const m=new LN(this.renderViews[v],v);if(!l){const x=new Ne().makeTranslation(m.localOrigin.x,m.localOrigin.y,m.localOrigin.z);x.invert();const w=(e=this.renderViews[v].renderData.geometry.attributes)===null||e===void 0?void 0:e.INDEX,S=(t=this.renderViews[v].renderData.geometry.attributes)===null||t===void 0?void 0:t.POSITION;l=qr.buildBVH(w,S,B0,x),l.refit()}m.buildAccelerationStructure(l),o.push(m)}const u=(n=this.renderViews[0].renderData.geometry.attributes)===null||n===void 0?void 0:n.INDEX,h=(i=this.renderViews[0].renderData.geometry.attributes)===null||i===void 0?void 0:i.POSITION,d=(r=this.renderViews[0].renderData.geometry.attributes)===null||r===void 0?void 0:r.COLOR,f=(a=this.renderViews[0].renderData.geometry.attributes)===null||a===void 0?void 0:a.NORMAL;if(!u||!h)throw new Error(`Cannot build batch ${this.id}. Undefined indices or positions`);return this.geometry=this.makeInstancedMeshGeometry(h.length>=65535||u.length>=65535?new Uint32Array(u):new Uint16Array(u),new Float64Array(h),f?new Float32Array(f):void 0,d?new Float32Array(d):void 0),this.mesh=new O0(this.geometry),this.mesh.setBatchObjects(o),this.mesh.setBatchMaterial(this.batchMaterial),this.mesh.buildTAS(),this.geometry.boundingBox=this.mesh.TAS.getBoundingBox(new Tt),this.geometry.boundingSphere=this.geometry.boundingBox.getBoundingSphere(new Zn),this.mesh.uuid=this.id,this.mesh.layers.set(vt.STREAM_CONTENT_MESH),this.mesh.frustumCulled=!1,this.groups.push({start:0,count:16*this.renderViews.length,materialIndex:0}),this.mesh.updateDrawGroups(this.getCurrentTransformBuffer(),this.getCurrentGradientBuffer(),this.getCurrentObjectIndexBuffer()),Promise.resolve()}getRenderView(e){return dt.warn("Deprecated! Use InstancedBatchObject"),null}getMaterialAtIndex(e){return dt.warn("Deprecated! Use InstancedBatchObject"),null}getMaterial(e){const t=this.groups.find(n=>e.batchStart>=n.start&&e.batchStart+e.batchCount<=n.count+n.start);return t?this.materials[t.materialIndex]:(dt.warn(`Could not get material for ${e.renderData.id}`),null)}makeInstancedMeshGeometry(e,t,n,i){const r=new Xt;t&&r.setAttribute("position",new Vt(t,3)),i&&r.setAttribute("color",new Vt(i,3));let a=null;return a=t.length>=65535||e.length>=65535?new jo(e,1):new qo(e,1),r.setIndex(a),this.instanceGradientBuffer=new Float32Array(this.renderViews.length),n?r.setAttribute("normal",new Vt(n,3)).normalizeNormals():hn.computeVertexNormals(r,t),r}updateGradientIndexBufferData(e,t){this.getCurrentGradientBuffer()[e]=t}purge(){this.renderViews.length=0,this.geometry.dispose(),this.batchMaterial.dispose()}}class EA{constructor(){this.needsShuffle=!1}get materials(){return this.primitive.material}get groups(){return this.primitive.geometry.groups}set groups(e){this.primitive.geometry.groups=e}get renderObject(){return this.primitive}get drawCalls(){return this.groups.length}get vertCount(){return this.primitive.geometry.attributes.position.count}getCount(){var e;return((e=this.primitive.geometry.index)===null||e===void 0?void 0:e.count)||0}setBatchMaterial(e){this.batchMaterial=e}onUpdate(){this.needsShuffle&&(this.shuffleDrawGroups(),this.needsShuffle=!1)}setVisibleRange(e){if(e.length===1&&e[0]===Li)return this.primitive.geometry.setDrawRange(0,0),void(this.primitive.visible=!1);if(e.length===1&&e[0]===kn)return this.primitive.geometry.setDrawRange(0,this.getCount()),void(this.primitive.visible=!0);let t=1/0,n=0;e.forEach(r=>{t=Math.min(t,r.offset),n=Math.max(n,r.offset)});const i=e.find(r=>r.offset===n);this.primitive.geometry.setDrawRange(t,n-t+(i?i.count:0)),this.primitive.visible=!0}getVisibleRange(){return this.groups.length===1&&this.primitive.visible?kn:this.primitive.visible?{offset:this.primitive.geometry.drawRange.start,count:this.primitive.geometry.drawRange.count}:Li}getOpaque(){const e=this.groups.find(t=>t.materialIndex!==void 0&&(ln.isTransparent(this.materials[t.materialIndex])||this.materials[t.materialIndex].visible===!1));return e?{offset:0,count:e.start}:kn}getDepth(){const e=this.groups.find(t=>t.materialIndex!==void 0&&(ln.isTransparent(this.materials[t.materialIndex])||this.materials[t.materialIndex].visible===!1||this.materials[t.materialIndex].colorWrite===!1));return e?{offset:0,count:e.start}:kn}getTransparent(){const e=this.groups.find(n=>n.materialIndex!==void 0&&ln.isTransparent(this.materials[n.materialIndex])),t=this.groups.find(n=>n.materialIndex!==void 0&&this.materials[n.materialIndex].visible===!1);return e?{offset:e.start,count:t!==void 0?t.start:this.getCount()-e.start}:Li}getStencil(){if(this.groups.length===1&&this.materials[0].stencilWrite===!0)return kn;const e=this.groups.find(t=>t.materialIndex!==void 0&&this.materials[t.materialIndex].stencilWrite===!0);return e?{offset:e.start,count:e.count}:Li}setBatchBuffers(e){let t=1/0,n=0;for(let i=0;i<e.length;i++){const r=e[i];if(r.materialOptions){if(r.materialOptions.rampIndex!==void 0&&r.materialOptions.rampWidth!==void 0){const a=e[i].offset,o=e[i].offset+e[i].count,l=r.materialOptions.rampIndex+.5/r.materialOptions.rampWidth,c=this.updateGradientIndexBufferData(a,r.count===1/0?this.primitive.geometry.attributes.gradientIndex.array.length:o,l);t=Math.min(t,c.minIndex),n=Math.max(n,c.maxIndex)}r.materialOptions.rampTexture!==void 0&&(r.material instanceof Xl||r.material instanceof bv)&&r.material.setGradientTexture(r.materialOptions.rampTexture)}}t<1/0&&n>0&&this.updateGradientIndexBuffer()}cleanMaterials(){const e=[...Array.from(new Set(this.groups.map(n=>{if(n.materialIndex!==void 0)return this.materials[n.materialIndex]})))];let t=0;for(;this.materials.length>e.length;)e.includes(this.materials[t])?t++:(this.materials.splice(t,1),this.groups.forEach(n=>{n.materialIndex!==void 0&&n.materialIndex>t&&n.materialIndex--}),t=0)}shuffleDrawGroups(){const e=this.groups.slice();e.sort(this.shuffleMaterialOrder.bind(this));const t=[];e.reduce((d,f)=>(f.materialIndex!==void 0&&d.indexOf(f.materialIndex)===-1&&d.push(f.materialIndex),d),t);const n=[];for(let d=0;d<t.length;d++)n.push(e.filter(f=>f.materialIndex===t[d]));const i=this.getCurrentIndexBuffer(),r=this.getNextIndexBuffer(),a=i.array,o=r.array,l=[],c=this.renderViews.slice();c.sort((d,f)=>d.batchStart-f.batchStart);let u=0;for(let d=0;d<n.length;d++){const f=n[d],v=u;let g=0;for(let m=0;m<f.length;m++){const x=f[m].start,w=f[m].count,S=a.subarray(x,x+w);o.set(S,u);let b=0;for(let E=0;E<c.length;E++)c[E].batchStart>=x&&c[E].batchEnd<=x+w&&(c[E].setBatchData(this.id,u+b,c[E].batchCount),b+=c[E].batchCount,c.splice(E,1),E--);u+=w,g+=w}l.push({offset:v,count:g,materialIndex:f[0].materialIndex})}this.groups=[];for(let d=0;d<l.length;d++)this.primitive.geometry.addGroup(l[d].offset,l[d].count,l[d].materialIndex);this.primitive.geometry.setIndex(r),this.primitive.geometry.index&&(this.primitive.geometry.index.needsUpdate=!0);const h=this.groups.find(d=>d.materialIndex!==void 0&&this.materials[d.materialIndex].visible===!1);h?this.setVisibleRange([{offset:0,count:h.start}]):this.setVisibleRange([kn])}updateGradientIndexBuffer(e,t){this.gradientIndexBuffer.updateRange={offset:e!==void 0?e:0,count:e!==void 0&&t!==void 0?t-e+1:-1},this.gradientIndexBuffer.needsUpdate=!0,this.primitive.geometry.attributes.gradientIndex.needsUpdate=!0}resetDrawRanges(){this.primitive.visible=!0,this.primitive.geometry.clearGroups(),this.primitive.geometry.addGroup(0,this.getCount(),0),this.primitive.geometry.setDrawRange(0,1/0)}getMaterial(e){for(let t=0;t<this.groups.length;t++){const n=this.groups[t];if(e.batchStart>=n.start&&e.batchEnd<=n.start+n.count)return this.materials[n.materialIndex]}return null}purge(){this.renderViews.length=0,this.primitive.geometry.dispose(),this.batchMaterial.dispose()}}class tS extends EA{get bounds(){return this.primitive.TAS.getBoundingBox(new Tt)}get minDrawCalls(){return[...Array.from(new Set(this.groups.map(e=>e.materialIndex)))].length}get triCount(){return this.getCount()/3}get pointCount(){return 0}get lineCount(){return 0}get geometryType(){return mt.MESH}get mesh(){return this.primitive}constructor(e,t,n,i){super(),this.indexBufferIndex=0,this.drawRanges=new N0,this.id=e,this.subtreeId=t,this.renderViews=n,this.transformStorage=i}getCurrentIndexBuffer(){return this.indexBufferIndex%2==0?this.indexBuffer0:this.indexBuffer1}getNextIndexBuffer(){return++this.indexBufferIndex%2==0?this.indexBuffer0:this.indexBuffer1}shuffleMaterialOrder(e,t){const n=this.materials[e.materialIndex],i=this.materials[t.materialIndex],r=+i.visible-+n.visible,a=+i.colorWrite-+n.colorWrite,o=+n.transparent-+i.transparent;return r!==0?r:a!==0?a:o}updateGradientIndexBufferData(e,t,n){if(!this.primitive.geometry.index)throw new Error(`Invalid geometry on batch ${this.id}`);const i=this.primitive.geometry.index.array,r=this.gradientIndexBuffer.array;let a=1/0,o=0;for(let l=e;l<t;l++){const c=i[l];a=Math.min(a,c),o=Math.max(o,c),r[c]=n}return this.gradientIndexBuffer.updateRange={offset:a,count:o-a+1},this.gradientIndexBuffer.needsUpdate=!0,this.primitive.geometry.attributes.gradientIndex.needsUpdate=!0,{minIndex:a,maxIndex:o}}setDrawRanges(e){e.forEach(r=>{r.material&&(r.material=this.primitive.getCachedMaterial(r.material))});const t=e.map(r=>r.material),n=[...Array.from(new Set(t.map(r=>r)))];for(let r=0;r<n.length;r++)this.materials.includes(n[r])||this.materials.push(n[r]);this.groups=this.drawRanges.integrateRanges(this.groups,this.materials,e);let i=0;if(this.groups.forEach(r=>i+=r.count),i!==this.getCount()&&dt.error(`Draw groups invalid on ${this.id}, ${this.renderViews[0].renderData.id}, ${this.getCount()}, ${this.getCount()-i}`),this.setBatchBuffers(e),this.cleanMaterials(),this.drawCalls>this.minDrawCalls+2)this.needsShuffle=!0;else{const r=this.groups.find(a=>this.materials[a.materialIndex].transparent===!0||this.materials[a.materialIndex].visible===!1||this.materials[a.materialIndex].colorWrite===!1);if(r)for(let a=this.groups.indexOf(r);a<this.groups.length;a++){const o=this.materials[this.groups[a].materialIndex];if(o.visible&&(!o.transparent||o.colorWrite)){this.needsShuffle=!0;break}}}}resetDrawRanges(){super.resetDrawRanges(),this.primitive.setBatchMaterial(this.batchMaterial)}buildBatch(){var e;let t=0,n=0;const i=new Tt;for(let m=0;m<this.renderViews.length;m++){const x=this.renderViews[m];if(!x.renderData.geometry.attributes||!x.renderData.geometry.attributes.INDEX)throw new Error(`Cannot build batch ${this.id}. Invalid geometry, or indices`);t+=x.renderData.geometry.attributes.INDEX.length,n+=x.renderData.geometry.attributes.POSITION.length,i.union(x.aabb)}const r=((e=this.renderViews[0].renderData.geometry.attributes)===null||e===void 0?void 0:e.COLOR)!==void 0,a=new Uint32Array(t),o=new Float64Array(n),l=new Float32Array(r?n:0);l.fill(1);const c=new Float32Array(n/3),u=new Float32Array(n);let h=0,d=0;const f=[];for(let m=0;m<this.renderViews.length;m++){const x=this.renderViews[m].renderData.geometry;if(!x.attributes||!x.attributes.INDEX)throw new Error(`Cannot build batch ${this.id}. Invalid geometry, or indices`);a.set(x.attributes.INDEX.map(S=>S+h/3),d),o.set(x.attributes.POSITION,h),x.attributes.COLOR&&l.set(x.attributes.COLOR,h),x.attributes.NORMAL?u.set(x.attributes.NORMAL,h):hn.computeVertexNormalsBuffer(u.subarray(h,h+x.attributes.POSITION.length),x.attributes.POSITION,x.attributes.INDEX),c.fill(m,h/3,h/3+x.attributes.POSITION.length/3),this.renderViews[m].setBatchData(this.id,d,x.attributes.INDEX.length,h/3,h/3+x.attributes.POSITION.length/3);const w=new nn(this.renderViews[m],m);w.buildAccelerationStructure(),f.push(w),h+=x.attributes.POSITION.length,d+=x.attributes.INDEX.length}const v=this.makeMeshGeometry(a,o,u,c,r?l:void 0),g=hn.needsRTE(i);return g&&hn.updateRTEGeometry(v,o),this.primitive=new qp(v,g),this.primitive.setBatchObjects(f,this.transformStorage),this.primitive.setBatchMaterial(this.batchMaterial),this.primitive.buildTAS(),this.primitive.geometry.boundingBox=this.primitive.TAS.getBoundingBox(new Tt),this.primitive.geometry.boundingSphere=this.primitive.geometry.boundingBox.getBoundingSphere(new Zn),this.primitive.uuid=this.id,this.primitive.layers.set(vt.STREAM_CONTENT_MESH),this.primitive.frustumCulled=!1,this.primitive.geometry.addGroup(0,this.getCount(),0),f.forEach(m=>{m.renderView.disposeGeometry()}),Promise.resolve()}makeMeshGeometry(e,t,n,i,r){const a=new Xt;t.length>=65535||e.length>=65535?(this.indexBuffer0=new jo(e,1),this.indexBuffer1=new jo(new Uint32Array(e.length),1)):(this.indexBuffer0=new qo(e,1),this.indexBuffer1=new qo(new Uint16Array(e.length),1)),a.setIndex(this.indexBuffer0),t&&a.setAttribute("position",new Vt(t,3)),n&&a.setAttribute("normal",new Vt(n,3)).normalizeNormals(),i&&a.setAttribute("objIndex",new Vt(i,1)),r&&a.setAttribute("color",new Vt(r,3));const o=new Float32Array(t.length/3);return this.gradientIndexBuffer=new Vt(o,1),this.gradientIndexBuffer.setUsage(Pr),a.setAttribute("gradientIndex",this.gradientIndexBuffer),a}getRenderView(e){return dt.warn("Deprecated! Use BatchObject"),null}getMaterialAtIndex(e){return dt.warn("Deprecated! Use BatchObject"),null}}class nS extends EA{get geometryType(){return this.renderViews[0].geometryType}get bounds(){return this.primitive.geometry.boundingBox||this.primitive.geometry.computeBoundingBox(),this.primitive.geometry.boundingBox?this.primitive.geometry.boundingBox:new Tt}get minDrawCalls(){return this.materials.length}get triCount(){return 0}get pointCount(){return this.getCount()}get lineCount(){return 0}constructor(e,t,n){super(),this.drawRanges=new N0,this.id=e,this.subtreeId=t,this.renderViews=n}setDrawRanges(e){const t=e.map(r=>r.material),n=[...Array.from(new Set(t.map(r=>r)))];for(let r=0;r<n.length;r++)this.materials.includes(n[r])||this.materials.push(n[r]);this.groups=this.drawRanges.integrateRanges(this.groups,this.materials,e);let i=0;if(this.groups.forEach(r=>i+=r.count),i!==this.getCount()&&dt.error(`Draw groups invalid on ${this.id}`),this.setBatchBuffers(e),this.cleanMaterials(),this.drawCalls>this.minDrawCalls+2)this.needsShuffle=!0;else{const r=this.groups.find(a=>this.materials[a.materialIndex].transparent===!0||this.materials[a.materialIndex].visible===!1);if(r)for(let a=this.groups.indexOf(r);a<this.groups.length;a++){const o=this.materials[this.groups[a].materialIndex];if(o.transparent!==!0&&o.visible!==!1){this.needsShuffle=!0;break}}}}resetDrawRanges(){super.resetDrawRanges(),this.primitive.material=[this.batchMaterial]}getCurrentIndexBuffer(){if(!this.primitive.geometry.index)throw new Error(`Invalid index buffer for batch ${this.id}`);return this.primitive.geometry.index}getNextIndexBuffer(){if(!this.primitive.geometry.index)throw new Error(`Invalid index buffer for batch ${this.id}`);return new Sn(this.primitive.geometry.index.array.slice(),this.primitive.geometry.index.itemSize)}shuffleMaterialOrder(e,t){const n=this.materials[e.materialIndex],i=this.materials[t.materialIndex],r=+i.visible-+n.visible,a=+n.transparent-+i.transparent;return r!==0?r:a}updateGradientIndexBufferData(e,t,n){return this.gradientIndexBuffer.array.fill(n,e,t),this.gradientIndexBuffer.updateRange={offset:e,count:t-e},this.gradientIndexBuffer.needsUpdate=!0,this.primitive.geometry.attributes.gradientIndex.needsUpdate=!0,{minIndex:e,maxIndex:t}}buildBatch(){let e=0;const t=new Tt;for(let c=0;c<this.renderViews.length;c++){const u=this.renderViews[c];if(!u.renderData.geometry.attributes)throw new Error(`Cannot build batch ${this.id}. Invalid geometry, or indices`);e+=u.renderData.geometry.attributes.POSITION.length,t.union(u.aabb)}const n=new Float64Array(e),i=new Float32Array(e).fill(1),r=new Int32Array(e/3);let a=0,o=0;for(let c=0;c<this.renderViews.length;c++){const u=this.renderViews[c].renderData.geometry;if(!u.attributes)throw new Error(`Cannot build batch ${this.id}. Invalid geometry, or indices`);n.set(u.attributes.POSITION,a),u.attributes.COLOR&&i.set(u.attributes.COLOR,a),r.set(new Int32Array(u.attributes.POSITION.length/3).map((h,d)=>d+o),o),this.renderViews[c].setBatchData(this.id,a/3,u.attributes.POSITION.length/3),a+=u.attributes.POSITION.length,o+=u.attributes.POSITION.length/3,this.renderViews[c].disposeGeometry()}const l=this.makePointGeometry(r,n,i);return hn.needsRTE(t)&&(hn.updateRTEGeometry(l,n),this.batchMaterial.defines||(this.batchMaterial.defines={}),this.batchMaterial.defines.USE_RTE=" "),this.primitive=new lb(l,this.batchMaterial),this.primitive.material=[this.batchMaterial],this.primitive.geometry.addGroup(0,this.getCount(),0),this.primitive.uuid=this.id,this.primitive.layers.set(this.renderViews[0].geometryType===mt.POINT?vt.STREAM_CONTENT_POINT:vt.STREAM_CONTENT_POINT_CLOUD),Promise.resolve()}makePointGeometry(e,t,n){const i=new Xt;i.setAttribute("position",new Vt(t,3)),i.setAttribute("color",new Vt(n,3)),t.length>=65535||e.length>=65535?i.setIndex(new jo(e,1)):i.setIndex(new qo(e,1));const r=new Float32Array(t.length/3);return this.gradientIndexBuffer=new Vt(r,1),this.gradientIndexBuffer.setUsage(Pr),i.setAttribute("gradientIndex",this.gradientIndexBuffer),i.computeBoundingSphere(),i.computeBoundingBox(),i}getRenderView(e){for(let t=0;t<this.renderViews.length;t++)if(e>=this.renderViews[t].batchStart&&e<this.renderViews[t].batchEnd)return this.renderViews[t];return null}getMaterialAtIndex(e){for(let t=0;t<this.renderViews.length;t++)if(e>=this.renderViews[t].batchStart&&e<this.renderViews[t].batchEnd){const n=this.renderViews[t],i=this.groups.find(r=>n.batchStart>=r.start&&n.batchStart+n.batchCount<=r.count+r.start);return i?this.materials[i.materialIndex]:(dt.warn("Malformed material index!"),null)}return null}}var Un,ai,Di;(function(s){s.OPAQUE="opaque",s.TRANSPARENT="transparent",s.DEPTH="depth",s.STENCIL="stencil"})(Un||(Un={})),function(s){s[s.COLOR=256]="COLOR",s[s.DEPTH=1024]="DEPTH",s[s.STENCIL=16384]="STENCIL"}(ai||(ai={}));class Hc{constructor(){this._enabled=!0,this.layers=null,this._enabledLayers=[],this._objectVisibility=null,this._jitter=!1,this._options={},this._clearColor=void 0,this._clearAlpha=void 0,this._clearFlags=void 0,this._outputTarget=null,this.onBeforeRender=void 0,this.onAfterRender=void 0}get enabledLayers(){return this._enabledLayers}get displayName(){return"BASE"}get outputTarget(){return this._outputTarget}set outputTarget(e){this._outputTarget=e}get enabled(){return this._enabled}set enabled(e){this._enabled=e}set options(e){Object.assign(this._options,e)}get visibility(){return this._objectVisibility}get overrideMaterial(){return null}get overrideBatchMaterial(){return null}get jitter(){return this._jitter}get clearColor(){return this._clearColor}get clearAlpha(){return this._clearAlpha}get clearFlags(){return this._clearFlags}setClearColor(e,t){this._clearColor=e,this._clearAlpha=t}setClearFlags(e){this._clearFlags=e}setLayers(e){this.layers=e,this._enabledLayers=e.slice()}enableLayer(e,t){this._enabledLayers.includes(e)?t||this._enabledLayers.splice(this._enabledLayers.indexOf(e),1):t&&this._enabledLayers.push(e)}setVisibility(e){this._objectVisibility=e}setJitter(e){this._jitter=e}applyLayers(e){e!==null&&(this.layers!==null?(e.layers.disableAll(),this.layers.forEach(t=>{this._enabledLayers.includes(t)&&e.layers.enable(t)})):e.layers.enableAll())}clear(e){this._clearColor!==void 0&&e.setClearColor(this._clearColor,this._clearAlpha||0),this._clearColor===void 0&&this._clearFlags===void 0||e.clear(this._clearColor!==void 0||this._clearFlags!==void 0&&!!(this._clearFlags&ai.COLOR),this._clearFlags!==void 0&&!!(this._clearFlags&ai.DEPTH),this._clearFlags!==void 0&&!!(this._clearFlags&ai.STENCIL))}setSize(e,t){var n;(n=this._outputTarget)===null||n===void 0||n.setSize(e,t)}}class jp extends Hc{constructor(){super(...arguments),this._frameIndex=0,this._accumulationFrames=0}get frameIndex(){return this._frameIndex}set frameIndex(e){this._frameIndex=e}get accumulationFrames(){return this._accumulationFrames}set accumulationFrames(e){this._accumulationFrames=e}render(e,t,n){return!(this._frameIndex>=this._accumulationFrames-1)}}class BN{constructor(e){this.maxBatchObjects=0,this.maxBatchVertices=5e5,this.minInstancedBatchVertices=1e4,this.batches={},this.caps=e,this.maxBatchObjects=Math.floor((this.caps.maxVertexUniforms-ln.UNIFORM_VECTORS_USED)/4),this.materials=new ln,this.materials.createDefaultMaterials()}async*makeBatches(e,t,n,i){let r=Number.MAX_SAFE_INTEGER,a=-1,o=0,l=0;const c=t.getInstances(),u={},h=new mA;for(const v in c){h.tick(100),h.needsWait&&await h.wait(50);let g=e.findId(v,t.subtreeId);if(!g||(g=g.filter(x=>x.model.renderView&&x.model.renderView.speckleType===Bt.Mesh),!g.length))continue;const m=g[0].model.renderView.renderData.geometry.attributes.POSITION.length/3*g.length;u[m]||(u[m]=[]),u[m].push(v)}for(const v in u)for(let g=0;g<u[v].length;g++){const m=e.findId(u[v][g],t.subtreeId);if(!m)continue;let x=!0;m.every(C=>x&&(x=C.model.instanced));const w=m.map(C=>C.model.renderView).filter(C=>C);let S=hn.needsRTE(w[0].aabb);if(!S){const C=w.map(L=>L.renderData.geometry.transform).filter(L=>L!==null),P=new Tt().copy(w[0].aabb),M=new Tt;for(let L=0;L<C.length&&(M.copy(P),M.applyMatrix4(C[L]),S||(S=hn.needsRTE(M)),!S);L++);}if(Number.parseInt(v)<this.minInstancedBatchVertices||!x||S){w.forEach(C=>{const P=C.renderData.geometry;P.instanced=!1;const M=P.attributes;P.attributes={POSITION:M.POSITION.slice(),INDEX:M.INDEX.slice(),...M.COLOR&&{COLOR:M.COLOR.slice()}},P.transform&&hn.transformGeometryData(P,P.transform),C.computeAABB()});continue}const b=w[0].renderMaterialHash,E=await this.buildInstancedBatch(t,w,b);E&&(this.batches[E.id]=E,r=Math.min(r,E.renderViews.length),a=Math.max(a,E.renderViews.length),l++,yield this.batches[E.id])}const d=t.getRenderableNodes(...n).flatMap(v=>v.model.renderView?v.model.renderView.renderData.geometry.instanced?v.model.renderView.speckleType!==Bt.Mesh?[v.model.renderView]:[]:[v.model.renderView]:[]).sort((v,g)=>v.renderMaterialHash===0?-1:g.renderMaterialHash===0?1:v.renderMaterialHash-g.renderMaterialHash),f=[...Array.from(new Set(d.map(v=>v.renderMaterialHash)))];for(let v=0;v<f.length;v++){let g=d.filter(w=>w.renderMaterialHash===f[v]),m=0;if(g=g.filter(w=>{const S=w.validGeometry;return S&&(m+=w.renderData.geometry.attributes.POSITION.length/3),S||w.hasMetadata}),g.length===0)continue;const x=this.splitBatch(g,m);for(let w=0;w<x.length;w++){h.tick(100),h.needsWait&&await h.wait(50);const S=x[w],b=await this.buildBatch(t,S,f[v],i);b&&(this.batches[b.id]=b,r=Math.min(r,b.renderViews.length),a=Math.max(a,b.renderViews.length),o+=b.renderViews.length,l++,yield this.batches[b.id])}}dt.warn(`Batch total: ${l} min: ${r}, max: ${a}, average: ${o/f.length}`)}splitBatch(e,t){const n=[];if(Math.floor(t/this.maxBatchVertices)>0){let i=0,r=0;n.push([]);for(let a=0;a<e.length;a++){const o=e[a],l=e[a+1];if(!o.renderData.geometry.attributes)throw new Error(`Invalid geometry on render view ${e[a].renderData.id}`);n[r].push(e[a]),i+=o.renderData.geometry.attributes.POSITION.length/3,i+(l&&l.renderData.geometry.attributes?l.renderData.geometry.attributes.POSITION.length/3:0)>=this.maxBatchVertices&&e[a+1]&&(n.push([]),r++,i=0)}}else n.push(e);if(e[0].geometryType===mt.MESH){const i=[];for(let r=0;r<n.length;r++){const a=n[r].length,o=Math.floor(a/this.maxBatchObjects),l=a%this.maxBatchObjects;let c=0;for(let u=0;u<o;u++)i.push(n[r].slice(c,c+this.maxBatchObjects)),c+=this.maxBatchObjects;l>0&&i.push(n[r].slice(c,c+l))}return i}return n}async buildInstancedBatch(e,t,n){if(!t.length)return dt.warn("All renderviews have invalid geometries. Skipping batch!",t),null;const i=t[0].renderData.renderMaterial,r=this.materials.getMaterial(n,i,mt.MESH),a=ci.generateUUID(),o=new eS(a,e.id,t,this.caps.isWebGL2);return o.setBatchMaterial(r),await o.buildBatch(),o}async buildBatch(e,t,n,i){if(!t.length)return dt.warn("All renderviews have invalid geometries. Skipping batch!",t),null;const r=i!==void 0?i:t[0].geometryType;let a=t[0].renderData.renderMaterial;r===mt.MESH?a=t[0].renderData.renderMaterial:r===mt.LINE?a=t[0].renderData.colorMaterial?t[0].renderData.colorMaterial:t[0].renderData.displayStyle:r===mt.POINT?a=t[0].renderData.colorMaterial?t[0].renderData.colorMaterial:t[0].renderData.renderMaterial||t[0].renderData.displayStyle:r===mt.POINT_CLOUD?a=t[0].renderData.renderMaterial:r===mt.TEXT&&(a=t[0].renderData.displayStyle);const o=this.materials.getMaterial(n,a,r),l=ci.generateUUID();let c=null;switch(r){case mt.MESH:c=new tS(l,e.id,t,this.caps.floatVertexTextures?Gs.VERTEX_TEXTURE:Gs.UNIFORM_ARRAY);break;case mt.LINE:c=new Ec(l,e.id,t);break;case mt.POINT:case mt.POINT_CLOUD:c=new nS(l,e.id,t);break;case mt.TEXT:c=new Jw(l,e.id,t)}return c.setBatchMaterial(o),await c.buildBatch(),c}update(e){for(const t in this.batches)this.batches[t].onUpdate(e)}render(e){for(const t in this.batches){const n=this.batches[t];n.onRender&&n.onRender(e)}}saveVisiblity(){const e={};for(const t in this.batches){const n=this.batches[t];e[t]=n.getVisibleRange()}return e}applyVisibility(e){for(const t in this.batches){const n=this.batches[t],i=e[t];i?n.setVisibleRange([i]):n.setVisibleRange([Li])}}getVisibility(e){switch(e){case Un.OPAQUE:return this.getOpaque();case Un.TRANSPARENT:return this.getTransparent();case Un.STENCIL:return this.getStencil();case Un.DEPTH:return this.getDepth()}}getTransparent(){const e={};for(const t in this.batches)e[t]=this.batches[t].getTransparent();return e}getStencil(){const e={};for(const t in this.batches)e[t]=this.batches[t].getStencil();return e}getOpaque(){const e={};for(const t in this.batches)e[t]=this.batches[t].getOpaque();return e}getDepth(){const e={};for(const t in this.batches)e[t]=this.batches[t].getDepth();return e}overrideMaterial(e,t){for(const n in e)this.batches[n].geometryType===mt.MESH&&this.batches[n].renderObject.setOverrideMaterial(t)}overrideBatchMaterial(e,t){for(const n in e)this.batches[n].geometryType===mt.MESH&&this.batches[n].renderObject.setOverrideBatchMaterial(t)}restoreMaterial(e){for(const t in e)this.batches[t].geometryType===mt.MESH&&this.batches[t].renderObject.restoreMaterial()}restoreBatchMaterial(e){for(const t in e)this.batches[t].geometryType===mt.MESH&&this.batches[t].renderObject.restoreBatchMaterial()}purgeBatches(e){for(const t in this.batches)this.batches[t].subtreeId===e&&(this.batches[t].purge(),delete this.batches[t])}getBatches(e,t){return Object.values(this.batches).filter(n=>{const i=e===void 0||n.subtreeId===e,r=t===void 0||this.isBatchType(n,t);return i&&r})}isBatchType(e,t){if(t===void 0)return!0;switch(t){case mt.MESH:return e instanceof tS||e instanceof eS;case mt.LINE:return e instanceof Ec;case mt.POINT:case mt.POINT_CLOUD:return e instanceof nS;case mt.TEXT:return e instanceof Jw;default:return!1}}getBatch(e){return this.batches[e.batchId]}getRenderView(e,t){return this.batches[e]?this.batches[e].getRenderView(t):(dt.error("Invalid batch id!"),null)}getRenderViewMaterial(e,t){return this.batches[e]?this.batches[e].getMaterialAtIndex(t):(dt.error("Invalid batch id!"),null)}resetBatchesDrawRanges(){for(const e in this.batches)this.batches[e].resetDrawRanges()}isolateBatch(e){for(const t in this.batches)t!==e&&this.batches[t].setDrawRanges([{offset:0,count:this.batches[t].getCount(),material:this.materials.getFilterMaterial(this.batches[t].renderViews[0],{filterType:_s.GHOST})}])}}(function(s){s.PointerDown="pointer-down",s.PointerUp="pointer-up",s.PointerMove="pointer-move",s.PointerCancel="pointer-cancel",s.Wheel="wheel",s.Click="click",s.DoubleClick="double-click",s.KeyUp="key-up"})(Di||(Di={}));class Mc extends Nh{constructor(e){let t;super(),this.tapTimeout=0,this.lastTap=0,this.lastClick=0,this.container=e,this.container.addEventListener("pointerdown",n=>{n.preventDefault();const i=this._getNormalisedClickPosition(n);i.event=n,t=new Date().getTime(),this.emit(Di.PointerDown,i)}),this.container.addEventListener("pointerup",n=>{n.preventDefault();const i=this._getNormalisedClickPosition(n);i.event=n,this.emit(Di.PointerUp,i);const r=new Date().getTime(),a=r-t,o=r-this.lastClick;a>Mc.MIN_CLICK_TIMING||o<Mc.MAX_DOUBLE_CLICK_TIMING||(n.shiftKey&&(i.multiSelect=!0),this.emit(Di.Click,i),this.lastClick=new Date().getTime())}),this.container.addEventListener("touchstart",n=>{this.touchLocation=n.targetTouches[0]}),this.container.addEventListener("touchend",n=>{if(n.targetTouches.length>0)return;const i=new Date().getTime(),r=i-this.lastTap;if(clearTimeout(this.tapTimeout),r<500&&r>0){if(this.touchLocation){const a=this._getNormalisedClickPosition(this.touchLocation);this.emit(Di.DoubleClick,a)}}else this.tapTimeout=setTimeout(()=>{clearTimeout(this.tapTimeout)},500);this.lastTap=i}),this.container.addEventListener("dblclick",n=>{const i=this._getNormalisedClickPosition(n);i.event=n,n.shiftKey&&(i.multiSelect=!0),this.emit(Di.DoubleClick,i)}),this.container.addEventListener("pointermove",n=>{const i=this._getNormalisedClickPosition(n);i.event=n,this.emit(Di.PointerMove,i)}),document.addEventListener("keyup",n=>{this.emit(Di.KeyUp,n)}),document.addEventListener("wheel",n=>{this.emit(Di.Wheel,n)}),document.addEventListener("pointercancel",n=>{const i=this._getNormalisedClickPosition(n);i.event=n,this.emit(Di.PointerUp,i),this.emit(Di.PointerCancel,i)})}on(e,t){super.on(e,t)}_getNormalisedClickPosition(e){const t=this.container,n=this.container.getBoundingClientRect(),i=(e.clientX-n.left)*t.width/n.width,r=(e.clientY-n.top)*t.height/n.height;return new Me(i/t.width*2-1,r/t.height*-2+1)}dispose(){super.dispose()}}Mc.MAX_DOUBLE_CLICK_TIMING=500,Mc.MIN_CLICK_TIMING=150;class ON extends Ob{constructor(e,t,n=0,i=1/0){super(e,t,n,i),this.intersectTASOnly=!1,this.onObjectIntersectionTest=null,this.layers.disableAll(),this.layers.enable(vt.STREAM_CONTENT),this.layers.enable(vt.STREAM_CONTENT_MESH),this.layers.enable(vt.STREAM_CONTENT_LINE),this.layers.enable(vt.STREAM_CONTENT_TEXT),this.layers.enable(vt.STREAM_CONTENT_POINT_CLOUD),this.layers.enable(vt.STREAM_CONTENT_POINT),this.params={Line2:{threshold:0}}}intersectObjects(e,t=!0,n=[]){for(let i=0,r=e.length;i<r;i++){const a=MA(e[i],this,n,t);if(this.firstHitOnly===!0&&!a)break}return n.sort(NN),n}}function NN(s,e){return s.distance-e.distance}function MA(s,e,t,n){const i=t.length;if(s.layers.test(e.layers)&&(e.onObjectIntersectionTest&&e.onObjectIntersectionTest(s),s.raycast(e,t)),e.firstHitOnly===!0&&t.length-i>0)return!0;let r=!1;if(n&&(n=s.userData.raycastChildren==null||s.userData.raycastChildren),n===!0){const a=s.children;for(let o=0,l=a.length;o<l&&(r=MA(a[o],e,t,!0),e.firstHitOnly!==!0||!r);o++);}return r}class CA{constructor(){this.boxBuffer=new Tt,this.vec0Buffer=new Ft,this.vec1Buffer=new Ft,this.raycaster=new ON,this.raycaster.params.Line={threshold:.01},this.raycaster.params.Points={threshold:.01},this.raycaster.params.Line2={threshold:1},this.raycaster.onObjectIntersectionTest=this.onObjectIntersection.bind(this)}onObjectIntersection(e){if(e instanceof Tc){const t=this.boxBuffer.setFromObject(e),n=this.vec0Buffer.set(t.min.x,t.min.y,t.min.z,1),i=this.vec1Buffer.set(t.max.y,t.max.y,t.max.z,1);n.applyMatrix4(this.raycaster.camera.matrixWorldInverse).applyMatrix4(this.raycaster.camera.projectionMatrix),i.applyMatrix4(this.raycaster.camera.matrixWorldInverse).applyMatrix4(this.raycaster.camera.projectionMatrix),n.multiplyScalar(.5).multiplyScalar(1/n.w).addScalar(.5),i.multiplyScalar(.5).multiplyScalar(1/i.w).addScalar(.5);const r=new Me().set(n.x,n.y).distanceTo(new Me(i.x,i.y)),a=e.material,o=a.linewidth,l=a.worldUnits;this.raycaster.params.Line2.threshold=l?r<1?2*o:o:r<1?8*o:5*o}}intersect(e,t,n,i,r=!0,a,o=!1,l=!1){this.raycaster.setFromCamera(n,t),this.raycaster.firstHitOnly=o,this.raycaster.intersectTASOnly=l;const c=this.setRaycasterLayers(i);let u;return u=(vt.STREAM_CONTENT_MESH,this.intersectInternal(e,r,a)),this.raycaster.layers.mask=c,u}intersectRay(e,t,n,i,r=!0,a,o=!1,l=!1){this.raycaster.camera=t,this.raycaster.set(n.origin,n.direction),this.raycaster.firstHitOnly=o,this.raycaster.intersectTASOnly=l;const c=this.setRaycasterLayers(i);let u;return u=(vt.STREAM_CONTENT_MESH,this.intersectInternal(e,r,a)),this.raycaster.layers.mask=c,u}setRaycasterLayers(e){const t=this.raycaster.layers.mask;return e!==void 0&&(this.raycaster.layers.disableAll(),Array.isArray(e)?e.forEach(n=>{this.raycaster.layers.enable(n)}):this.raycaster.layers.enable(e)),t}intersectInternal(e,t,n){let i=[];const r=e.getObjectByName("ContentGroup");return r&&(i=this.raycaster.intersectObjects(r.children)),i.length===0?null:(t&&i.sort((a,o)=>a.distance-o.distance),n&&(this.boundsBuffer=Ju.expandBoxRelative(n),i=i.filter(a=>this.boundsBuffer.containsPoint(a.point)||!!a.pointOnLine&&this.boundsBuffer.containsPoint(a.pointOnLine))),i)}}CA.aabbPlanePoints=(s,e)=>{const t=new Ti,n=new Array,i=new T(e.max.x-e.min.x,0,0),r=new T().copy(e.min);t.set(r,i);let a=t.distanceToPlane(s);return a&&n.push(new T().copy(r).addScaledVector(i,a)),r.set(e.min.x,e.max.y,e.min.z),t.set(r,i),a=t.distanceToPlane(s),a&&n.push(new T().copy(r).addScaledVector(i,a)),r.set(e.min.x,e.min.y,e.max.z),t.set(r,i),a=t.distanceToPlane(s),a&&n.push(new T().copy(r).addScaledVector(i,a)),r.set(e.min.x,e.max.y,e.max.z),t.set(r,i),a=t.distanceToPlane(s),a&&n.push(new T().copy(r).addScaledVector(i,a)),i.set(0,e.max.y-e.min.y,0),r.set(e.min.x,e.min.y,e.min.z),t.set(r,i),a=t.distanceToPlane(s),a&&n.push(new T().copy(r).addScaledVector(i,a)),r.set(e.max.x,e.min.y,e.min.z),t.set(r,i),a=t.distanceToPlane(s),a&&n.push(new T().copy(r).addScaledVector(i,a)),r.set(e.min.x,e.min.y,e.max.z),t.set(r,i),a=t.distanceToPlane(s),a&&n.push(new T().copy(r).addScaledVector(i,a)),r.set(e.max.x,e.min.y,e.max.z),t.set(r,i),a=t.distanceToPlane(s),a&&n.push(new T().copy(r).addScaledVector(i,a)),i.set(0,0,e.max.z-e.min.z),r.set(e.min.x,e.min.y,e.min.z),t.set(r,i),a=t.distanceToPlane(s),a&&n.push(new T().copy(r).addScaledVector(i,a)),r.set(e.max.x,e.min.y,e.min.z),t.set(r,i),a=t.distanceToPlane(s),a&&n.push(new T().copy(r).addScaledVector(i,a)),r.set(e.min.x,e.max.y,e.min.z),t.set(r,i),a=t.distanceToPlane(s),a&&n.push(new T().copy(r).addScaledVector(i,a)),r.set(e.max.x,e.max.y,e.min.z),t.set(r,i),a=t.distanceToPlane(s),a&&n.push(new T().copy(r).addScaledVector(i,a)),n};class zN extends Wi{get vertexProgram(){return`
	varying vec2 vUv;
		void main() {
			vUv = vec2(1. - uv.x, uv.y);
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
		}
`}get fragmentProgram(){return`
varying vec2 vUv;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform sampler2D tex3;
uniform vec4 weights;
uniform float sigmoidRange;
uniform float sigmoidStrength;

void main() {
	float color0 = texture2D(tex0, vUv).r * weights.x;
	float color1 = texture2D(tex1, vUv).r * weights.y;
	float color2 = texture2D(tex2, vUv).r * weights.z;
	float color3 = texture2D(tex3, vUv).r * weights.w;

	// float c0 = mix(color0, 0., color1);
	// float c1 = mix(color1, 0., color0);
	// float c2 = mix(color3, 0., color0 * 0.5 + color1 * 0.5);
	// float sum = c0 + c1 + c2;

	float sum = color0 + color1 + color3 + color2;

	float a = sigmoidRange;//2.;
	float b = 0.03;
	float c = sigmoidStrength;//2.43;
	float d = 0.59;
	float e = 0.14;
	sum = clamp((sum*(a*sum+b))/(sum*(c*sum+d)+e), 0., 1.);

	vec2 sUv = vUv * 2. - 1.;
	sum *= 1. - pow(abs(sUv.x), 6.);
	sum *= 1. - pow(abs(sUv.y), 6.);

	gl_FragColor = vec4( vec3(sum), sum );
}
`}get uniformsDef(){return{...super.uniformsDef,tex0:null,tex1:null,tex2:null,tex3:null,weights:new Ft,sigmoidRange:0,sigmoidStrength:0}}constructor(e,t=[]){super(e,t)}}const Av={textureSize:512,weights:{x:1,y:1,z:0,w:1},blurRadius:16,stdDeviation:4,sigmoidRange:1.1,sigmoidStrength:2};class FN extends Hc{get displayName(){return"Shadowcatcher"}get outputTexture(){return this.outputTarget?this.outputTarget.texture:null}set needsUpdate(e){this._needsUpdate=e}get drawDepthMaterial(){return this.depthMaterial}constructor(){super(),this.levels=4,this.debugCamera=!1,this.renderTargets=[],this.tempTargets=[],this._needsUpdate=!1,this.blurStdDev=Av.stdDeviation,this.blurRadius=Av.blurRadius,this.prevBlurStdDev=0,this.prevBlurRadius=0,this.onBeforeRender=void 0,this.onAfterRender=void 0;for(let e=0;e<this.levels;e++){const t=new Yn(256,256,{minFilter:cn,magFilter:cn});this.renderTargets.push(t),this.tempTargets.push(t.clone())}this.outputTarget=new Yn(256,256,{minFilter:cn,magFilter:cn}),this.outputTarget.texture.wrapS=Ho,this.outputTarget.texture.wrapT=Ho,this.camera=new Xr(-128,128,128,-128,0,10),this.vBlurMaterial=new $n({uniforms:Ga.clone(ba.uniforms),defines:Object.assign({},ba.defines),vertexShader:ba.vertexShader,fragmentShader:ba.fragmentShader}),this.vBlurMaterial.defines.DEPTH_PACKING=1,this.vBlurMaterial.blending=ui,this.hBlurMaterial=new $n({uniforms:Ga.clone(ba.uniforms),defines:Object.assign({},ba.defines),vertexShader:ba.vertexShader,fragmentShader:ba.fragmentShader}),this.hBlurMaterial.defines.DEPTH_PACKING=1,this.hBlurMaterial.blending=ui,this.depthMaterial=new zh({depthPacking:jS},["USE_RTE"]),this.depthMaterial.blending=ui,this.depthMaterial.side=Qt,this.blendMaterial=new zN({}),this.fsQuad=new Bh(this.vBlurMaterial)}update(e){if(this.scene=e,this._needsUpdate){!this.cameraHelper&&this.debugCamera&&(this.cameraHelper=new zb(this.camera),this.cameraHelper.layers.set(vt.PROPS),this.scene.add(this.cameraHelper)),this.cameraHelper&&this.cameraHelper.update(),this.vBlurMaterial.defines.PERSPECTIVE_CAMERA=0,this.hBlurMaterial.defines.PERSPECTIVE_CAMERA=0,this.vBlurMaterial.uniforms.cameraNear.value=this.camera.near,this.vBlurMaterial.uniforms.cameraFar.value=this.camera.far,this.hBlurMaterial.uniforms.cameraNear.value=this.camera.near,this.hBlurMaterial.uniforms.cameraFar.value=this.camera.far;const t=0;this.vBlurMaterial.uniforms.depthCutoff.value=t,this.hBlurMaterial.uniforms.depthCutoff.value=t,this.prevBlurStdDev===this.blurStdDev&&this.prevBlurRadius===this.blurRadius||(fp.configure(this.vBlurMaterial,this.blurRadius,this.blurStdDev,new Me(0,1)),fp.configure(this.hBlurMaterial,this.blurRadius,this.blurStdDev,new Me(1,0)),this.prevBlurStdDev=this.blurStdDev,this.prevBlurRadius=this.blurRadius),this.vBlurMaterial.needsUpdate=!0,this.hBlurMaterial.needsUpdate=!0}}render(e){if(this._needsUpdate){const t=e;t.RTEBuffers.push(),t.updateRTEViewModel(this.camera);const n=new ot;t.getClearColor(n);const i=t.getClearAlpha(),r=t.autoClear;this.onBeforeRender&&this.onBeforeRender(),this.applyLayers(this.camera);const a=this.camera.far;for(let o=0;o<this.renderTargets.length;o++)this.camera.far=a,o<2&&(this.camera.far=a/100),o===2&&(this.camera.far=a/4),this.camera.updateProjectionMatrix(),t.setRenderTarget(this.renderTargets[o]),t.setClearColor(0),t.setClearAlpha(1),t.clear(),t.render(this.scene,this.camera),this.scene.overrideMaterial=null,t.setRenderTarget(this.tempTargets[o]),t.setClearColor(16777215),t.setClearAlpha(1),t.clear(),this.vBlurMaterial.uniforms.tDiffuse.value=this.renderTargets[o].texture,this.vBlurMaterial.uniforms.size.value.set(this.renderTargets[o].width,this.renderTargets[o].height),this.vBlurMaterial.needsUpdate=!0,this.fsQuad.material=this.vBlurMaterial,this.fsQuad.render(t),t.setRenderTarget(this.renderTargets[o]),this.hBlurMaterial.uniforms.tDiffuse.value=this.tempTargets[o].texture,this.hBlurMaterial.uniforms.size.value.set(this.tempTargets[o].width,this.tempTargets[o].height),this.hBlurMaterial.needsUpdate,this.fsQuad.material=this.hBlurMaterial,this.fsQuad.render(t);t.setRenderTarget(this.outputTarget),t.setClearColor(0),t.setClearAlpha(1),this.blendMaterial.userData.tex0.value=this.renderTargets[0].texture,this.blendMaterial.userData.tex1.value=this.renderTargets[1].texture,this.blendMaterial.userData.tex2.value=this.renderTargets[2].texture,this.blendMaterial.userData.tex3.value=this.renderTargets[3].texture,this.fsQuad.material=this.blendMaterial,this.fsQuad.render(t),t.setRenderTarget(null),t.autoClear=r,t.setClearColor(n),t.setClearAlpha(i),t.RTEBuffers.pop(),this.onAfterRender&&this.onAfterRender(),this._needsUpdate=!1}return!1}updateClippingPlanes(e){this.depthMaterial.clippingPlanes=e,this.depthMaterial.needsUpdate=!0}setOutputSize(e,t){var n;if(this.renderTargets[0].width!==e||this.renderTargets[0].height!==t){(n=this.outputTarget)===null||n===void 0||n.setSize(e,t),this.blendMaterial.needsUpdate=!0;let i=1;for(let r=0;r<this.renderTargets.length;r++){const a=Math.trunc(e*i),o=Math.trunc(t*i);this.renderTargets[r].setSize(a,o),this.tempTargets[r].setSize(a,o),i*=.5}}}setWeights(e){this.blendMaterial.userData.weights.value=new Ft(e.x,e.y,e.z,e.w),this.blendMaterial.needsUpdate=!0}updateCamera(e,t,n){const i=e.getSize(new T),r=e.getCenter(new T);this.camera.position.copy(new T().copy(r).add(new T(0,0,-.001))),this.camera.lookAt(r),this.camera.left=i.x/-2,this.camera.right=i.x/2,this.camera.top=i.y/2,this.camera.bottom=i.y/-2,this.camera.near=t,this.camera.far=n,this.camera.updateProjectionMatrix(),this.camera.updateMatrixWorld(!0)}updateConfig(e){this.blurRadius=e.blurRadius,this.blurStdDev=e.stdDeviation,this.blendMaterial.userData.sigmoidRange.value=e.sigmoidRange,this.blendMaterial.userData.sigmoidStrength.value=e.sigmoidStrength,this.blendMaterial.needsUpdate=!0}setSize(e,t){}}class as{get shadowcatcherMesh(){return this.planeMesh}set configuration(e){this._config=JSON.parse(JSON.stringify(e))}constructor(e,t){this.planeSize=new Me,this._config=Av,this.shadowcatcherPass=new FN,this.shadowcatcherPass.setLayers(t),this.displayMaterial=new Wi({color:16777215},["USE_RTE"]),this.displayMaterial.toneMapped=!1,this.displayMaterial.map=this.shadowcatcherPass.outputTexture,this.displayMaterial.toneMapped=!1,this.displayMaterial.transparent=!0,this.displayMaterial.blending=Cp,this.displayMaterial.blendEquation=rs,this.displayMaterial.blendEquationAlpha=Fg,this.displayMaterial.blendSrc=Cf,this.displayMaterial.blendSrcAlpha=Ao,this.displayMaterial.blendDst=Rv,this.displayMaterial.blendDstAlpha=Ao,this.displayMaterial.alphaTest=.001,this.planeMesh=new gn,this.planeMesh.material=this.displayMaterial,this.planeMesh.layers.set(e),this.planeMesh.name=as.MESH_NAME,this.planeMesh.frustumCulled=!1}update(e){this.shadowcatcherPass.updateConfig(this._config),this.shadowcatcherPass.update(e)}render(e){this.shadowcatcherPass.render(e)}bake(e,t,n){this.updatePlaneMesh(e,n);const i=this.getTextureSize(t),r=new Tt().setFromObject(this.planeMesh),a=e.getSize(new T).z;this.shadowcatcherPass.updateCamera(r,.001,a),this.shadowcatcherPass.setOutputSize(i.x,i.y),this.shadowcatcherPass.setWeights(this._config.weights),this.shadowcatcherPass.needsUpdate=!0}updateClippingPlanes(e){this.displayMaterial.clippingPlanes=e,this.displayMaterial.needsUpdate=!0,this.shadowcatcherPass.updateClippingPlanes(e)}getTextureSize(e){const t=this.planeSize.x/this.planeSize.y,n=new Me;return n.x=Math.trunc(this._config.textureSize),n.y=Math.trunc(this._config.textureSize/t),n.y>e*as.MAX_TEXTURE_SIZE_SCALE&&(n.y=e*as.MAX_TEXTURE_SIZE_SCALE,n.x=t*n.y),n}updatePlaneMesh(e,t){const n=e.getSize(new T),i=e.getCenter(new T);(new Me(n.x,n.y).distanceTo(this.planeSize)>.001||t)&&this.updatePlaneMeshGeometry(new Me(2*n.x,2*n.y),new T(i.x,i.y,i.z-.5*n.z-.001)),this.planeSize.set(n.x,n.y)}updatePlaneMeshGeometry(e,t){this.planeMesh.geometry&&this.planeMesh.geometry.dispose();const n=new Ks(e.x,e.y,as.PLANE_SUBD,as.PLANE_SUBD),i=new Ne().makeTranslation(t.x,t.y,t.z);n.applyMatrix4(i);const r=new Float64Array(n.attributes.position.array);hn.updateRTEGeometry(n,r),this.planeMesh.geometry=n,this.planeMesh.geometry.computeBoundingBox()}}var Tr,gp;as.MESH_NAME="Shadowcatcher",as.PLANE_SUBD=2,as.MAX_TEXTURE_SIZE_SCALE=.5,function(s){s.Stationary="stationary",s.Dynamic="dynamic",s.FrameUpdate="frame-update",s.LateFrameUpdate="late-frame-update",s.ProjectionChanged="projection-changed",s.InteractionStarted="interaction-started",s.InteractionEnded="interaction-ended"}(Tr||(Tr={})),function(s){s[s.PERSPECTIVE=0]="PERSPECTIVE",s[s.ORTHOGRAPHIC=1]="ORTHOGRAPHIC"}(gp||(gp={}));class vp{constructor(){this.viewer=new T,this.viewerLow=new T,this.viewerHigh=new T,this.rteViewModelMatrix=new Ne,this.shadowViewer=new T,this.shadowViewerLow=new T,this.shadowViewerHigh=new T,this.rteShadowViewModelMatrix=new Ne,this.rteShadowMatrix=new Ne}copy(e,t){t.viewer.copy(e.viewer),t.viewerLow.copy(e.viewerLow),t.viewerHigh.copy(e.viewerHigh),t.rteViewModelMatrix.copy(e.rteViewModelMatrix),t.shadowViewer.copy(e.shadowViewer),t.shadowViewerLow.copy(e.shadowViewerLow),t.shadowViewerHigh.copy(e.shadowViewerHigh),t.rteShadowViewModelMatrix.copy(e.rteShadowViewModelMatrix),t.rteShadowMatrix.copy(e.rteShadowMatrix)}push(){this._cache||(this._cache=new vp),this.copy(this,this._cache)}pop(){this._cache||(this._cache=new vp),this.copy(this._cache,this)}}class UN extends Tn{constructor(){super(...arguments),this.RTEBuffers=new vp,this.readRenderTargetPixels=(e,t,n,i,r,a,o=0)=>{if(!e||!(e instanceof Yn||e instanceof Nv))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let l=this.properties.get(e).__webglFramebuffer;if(e instanceof Uv&&o!==void 0&&(l=l[o]),l){this.state.bindFramebuffer(36160,l);try{const c=Array.isArray(e.texture)?e.texture[0]:e.texture,u=c.format,h=c.type;if(u!==qi&&this.convert(u)!==this.context.getParameter(35739))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");const d=h===Zi&&(this.extensions.has("EXT_color_buffer_half_float")||this.capabilities.isWebGL2&&this.extensions.has("EXT_color_buffer_float"));if(!(h===Js||this.convert(h)===this.context.getParameter(35738)||h===Oi&&(this.capabilities.isWebGL2||this.extensions.has("OES_texture_float")||this.extensions.has("WEBGL_color_buffer_float"))||d))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");t>=0&&t<=e.width-i&&n>=0&&n<=e.height-r&&this.context.readPixels(t,n,i,r,this.convert(u),this.convert(h),a)}finally{const c=this.getRenderTarget()!==null?this.properties.get(this.getRenderTarget()).__webglFramebuffer:null;this.state.bindFramebuffer(36160,c)}}}}updateRTEViewModel(e){this.RTEBuffers.rteViewModelMatrix.copy(e.matrixWorldInverse),this.RTEBuffers.rteViewModelMatrix.elements[12]=0,this.RTEBuffers.rteViewModelMatrix.elements[13]=0,this.RTEBuffers.rteViewModelMatrix.elements[14]=0,this.RTEBuffers.viewer.set(e.matrixWorld.elements[12],e.matrixWorld.elements[13],e.matrixWorld.elements[14]),hn.DoubleToHighLowVector(this.RTEBuffers.viewer,this.RTEBuffers.viewerLow,this.RTEBuffers.viewerHigh)}convert(e,t=null){let n;if(e===Js)return 5121;if(e===OS)return 32819;if(e===NS)return 32820;if(e===DS)return 5120;if(e===LS)return 5122;if(e===vc)return 5123;if(e===BS)return 5124;if(e===gu)return 5125;if(e===Oi)return 5126;if(e===Zi)return this.capabilities.isWebGL2?5131:(n=this.extensions.get("OES_texture_half_float"),n!==null?n.HALF_FLOAT_OES:null);if(e===zS)return 6406;if(e===qi)return 6408;if(e===US)return 6409;if(e===kS)return 6410;if(e===za)return 6402;if(e===Wo)return 34041;if(e===Iv)return 6403;if(e===FS)return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"),6408;if(e===Zf)return n=this.extensions.get("EXT_sRGB"),n!==null?n.SRGB_ALPHA_EXT:null;if(e===_S)return 36244;if(e===VS)return 33319;if(e===GS)return 33320;if(e===HS)return 36249;if(e===Kl||e===Yl||e===Zl||e===$l)if(t===Wt){if(n=this.extensions.get("WEBGL_compressed_texture_s3tc_srgb"),n===null)return null;if(e===Kl)return n.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(e===Yl)return n.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(e===Zl)return n.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(e===$l)return n.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else{if(n=this.extensions.get("WEBGL_compressed_texture_s3tc"),n===null)return null;if(e===Kl)return n.COMPRESSED_RGB_S3TC_DXT1_EXT;if(e===Yl)return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(e===Zl)return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(e===$l)return n.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(e===Rf||e===If||e===Pf||e===Df){if(n=this.extensions.get("WEBGL_compressed_texture_pvrtc"),n===null)return null;if(e===Rf)return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(e===If)return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(e===Pf)return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(e===Df)return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(e===WS)return n=this.extensions.get("WEBGL_compressed_texture_etc1"),n!==null?n.COMPRESSED_RGB_ETC1_WEBGL:null;if(e===Lf||e===Bf){if(n=this.extensions.get("WEBGL_compressed_texture_etc"),n===null)return null;if(e===Lf)return t===Wt?n.COMPRESSED_SRGB8_ETC2:n.COMPRESSED_RGB8_ETC2;if(e===Bf)return t===Wt?n.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:n.COMPRESSED_RGBA8_ETC2_EAC}if(e===Of||e===Nf||e===zf||e===Ff||e===Uf||e===kf||e===_f||e===Vf||e===Gf||e===Hf||e===Wf||e===qf||e===jf||e===Qf){if(n=this.extensions.get("WEBGL_compressed_texture_astc"),n===null)return null;if(e===Of)return t===Wt?n.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:n.COMPRESSED_RGBA_ASTC_4x4_KHR;if(e===Nf)return t===Wt?n.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:n.COMPRESSED_RGBA_ASTC_5x4_KHR;if(e===zf)return t===Wt?n.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:n.COMPRESSED_RGBA_ASTC_5x5_KHR;if(e===Ff)return t===Wt?n.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:n.COMPRESSED_RGBA_ASTC_6x5_KHR;if(e===Uf)return t===Wt?n.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:n.COMPRESSED_RGBA_ASTC_6x6_KHR;if(e===kf)return t===Wt?n.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:n.COMPRESSED_RGBA_ASTC_8x5_KHR;if(e===_f)return t===Wt?n.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:n.COMPRESSED_RGBA_ASTC_8x6_KHR;if(e===Vf)return t===Wt?n.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:n.COMPRESSED_RGBA_ASTC_8x8_KHR;if(e===Gf)return t===Wt?n.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:n.COMPRESSED_RGBA_ASTC_10x5_KHR;if(e===Hf)return t===Wt?n.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:n.COMPRESSED_RGBA_ASTC_10x6_KHR;if(e===Wf)return t===Wt?n.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:n.COMPRESSED_RGBA_ASTC_10x8_KHR;if(e===qf)return t===Wt?n.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:n.COMPRESSED_RGBA_ASTC_10x10_KHR;if(e===jf)return t===Wt?n.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:n.COMPRESSED_RGBA_ASTC_12x10_KHR;if(e===Qf)return t===Wt?n.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:n.COMPRESSED_RGBA_ASTC_12x12_KHR}if(e===Xf){if(n=this.extensions.get("EXT_texture_compression_bptc"),n===null)return null;if(e===Xf)return t===Wt?n.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:n.COMPRESSED_RGBA_BPTC_UNORM_EXT}return e===Fo?this.capabilities.isWebGL2?34042:(n=this.extensions.get("WEBGL_depth_texture"),n!==null?n.UNSIGNED_INT_24_8_WEBGL:null):this.context[e]!==void 0?this.context[e]:null}}class Go extends Hc{get displayName(){return"GEOMETRY"}setClippingPlanes(e){this.overrideMaterial&&(this.overrideMaterial.clippingPlanes=e),this.overrideBatchMaterial&&(this.overrideBatchMaterial.clippingPlanes=e)}render(e,t,n){return!(!t||!n)&&(this.onBeforeRender&&this.onBeforeRender(),this.applyLayers(t),e.setRenderTarget(this.outputTarget),this.clear(e),e.render(n,t),this.onAfterRender&&this.onAfterRender(),!1)}}const RA={edges:!0};class Wc{get options(){return this._options}set options(e){Object.assign(this.options,e)}constructor(e,t={}){this._options=Object.assign({},RA),this.passList=[],this.drawingSize=new Me,this.frameProjection=new Ne,this.jitterIndex=0,this.jitterOffsets=this.generateHaltonJiters(16),this.speckleRenderer=e,this.options=t}get passes(){return this.passList}onBeforePipelineRender(){}onAfterPipelineRender(){}getPass(e){return this.passList.filter(t=>t.displayName===e)}setClippingPlanes(e){this.passList.forEach(t=>{var n;return(n=t.setClippingPlanes)===null||n===void 0?void 0:n.call(t,e)})}update(e){this.passList.forEach(t=>{var n;return t.enabled&&((n=t.update)===null||n===void 0?void 0:n.call(t,e))})}reset(){this.jitterIndex=0}render(){if(this.speckleRenderer.renderer.getDrawingBufferSize(this.drawingSize),this.drawingSize.length()===0)return!1;const e=this.speckleRenderer.renderingCamera,t=this.speckleRenderer.batcher.saveVisiblity(),n={[Un.OPAQUE]:this.speckleRenderer.batcher.getOpaque(),[Un.TRANSPARENT]:this.speckleRenderer.batcher.getTransparent(),[Un.DEPTH]:this.speckleRenderer.batcher.getDepth(),[Un.STENCIL]:this.speckleRenderer.batcher.getStencil()},[i,r]=this.jitterOffsets[this.jitterIndex];this.onBeforePipelineRender(),this.speckleRenderer.renderer.setRenderTarget(null),this.speckleRenderer.renderer.setClearColor(16777215,0),this.speckleRenderer.renderer.clear(!0,!0,!0);let a,o=!1;return this.passList.forEach(l=>{if(!l.enabled||!l.render)return;if(l.visibility?(this.speckleRenderer.batcher.applyVisibility(n[l.visibility]),a=l.visibility):a&&this.speckleRenderer.batcher.applyVisibility(t),l.overrideMaterial&&this.speckleRenderer.batcher.overrideMaterial(l.visibility?n[l.visibility]:t,l.overrideMaterial),l.overrideBatchMaterial&&this.speckleRenderer.batcher.overrideBatchMaterial(l.visibility?n[l.visibility]:t,l.overrideBatchMaterial),l.jitter&&e)if(this.frameProjection.copy(e.projectionMatrix),e instanceof Xr){const u=this.drawingSize.x,h=this.drawingSize.y,d=e.right-e.left,f=e.top-e.bottom,v=u/d,g=h/f;e.setViewOffset(d,f,i/v*.5,r/g*.5,d,f)}else e instanceof li&&(e.projectionMatrix.elements[8]=i/this.drawingSize.x,e.projectionMatrix.elements[9]=r/this.drawingSize.y);const c=l.render(this.speckleRenderer.renderer,this.speckleRenderer.renderingCamera,this.speckleRenderer.scene);o||(o=c),l.visibility&&this.speckleRenderer.batcher.applyVisibility(t),l.overrideMaterial&&this.speckleRenderer.batcher.restoreMaterial(l.visibility?n[l.visibility]:t),l.overrideBatchMaterial&&this.speckleRenderer.batcher.restoreBatchMaterial(l.visibility?n[l.visibility]:t),l.jitter&&e&&e.projectionMatrix.copy(this.frameProjection)}),this.onAfterPipelineRender(),this.jitterIndex=(this.jitterIndex+1)%this.jitterOffsets.length,o}resize(e,t){this.passList.forEach(n=>{var i;return(i=n.setSize)===null||i===void 0?void 0:i.call(n,e,t)})}haltonNumber(e,t){let n=0,i=1;for(;t>0;)i/=e,n+=i*(t%e),t=Math.floor(t/e);return n}generateHaltonJiters(e){const t=[];for(let n=1;n<=e;n++)t.push([2*(this.haltonNumber(2,n)-.5),2*(this.haltonNumber(3,n)-.5)]);return t}static createRenderTarget(e,t,n){const i=new Yn(t||1,n||1,e);return i.depthBuffer=!0,i.stencilBuffer=!0,i}static createMultipleRenderTarget(e,t,n,i){const r=new Nv(n||1,i||1,e,t);return r.depthBuffer=!0,r.stencilBuffer=!0,r}}var Yu;(function(s){s[s.PERSPECTIVE_DEPTH=0]="PERSPECTIVE_DEPTH",s[s.LINEAR_DEPTH=1]="LINEAR_DEPTH"})(Yu||(Yu={}));const IA={depthType:Yu.LINEAR_DEPTH};class Tv extends Go{get displayName(){return"DEPTH"}get depthTexture(){var e;return(e=this._outputTarget)===null||e===void 0?void 0:e.texture}get overrideMaterial(){return this.depthMaterial}set options(e){super.options=e,this.depthType=this._options.depthType}set depthType(e){e===Yu.LINEAR_DEPTH&&(this.depthMaterial.defines?this.depthMaterial.defines.LINEAR_DEPTH=" ":this.depthMaterial.defines&&delete this.depthMaterial.defines.LINEAR_DEPTH),this.depthMaterial.needsUpdate=!0}set depthSide(e){this.depthMaterial.side=e}constructor(){super(),this._options=Object.assign({},IA),this._outputTarget=Wc.createRenderTarget({minFilter:wn,magFilter:wn}),this.depthMaterial=new zh({depthPacking:Ko},["ALPHATEST_REJECTION"]),this.depthMaterial.blending=ui,this.depthMaterial.side=Qt,this.depthType=this._options.depthType}update(e){this.depthMaterial.userData.near.value=e.near,this.depthMaterial.userData.far.value=e.far,this.depthMaterial.needsUpdate=!0}}const kN={intensity:1,kernelRadius:30,bias:.01,kernelSize:16};class _N extends jp{setTexture(e,t){this.generationMaterial.uniforms[e].value=t,this.generationMaterial.needsUpdate=!0}get displayName(){return"PROGRESSIVE-AO"}set options(e){super.options=e,this.kernels=[],this.noiseTextures=[]}constructor(){super(),this._options=Object.assign({},kN),this.kernels=[],this.noiseTextures=[],this._generationBuffer=new Yn(256,256),this._outputTarget=new Yn(256,256),this.generationMaterial=new $n({fragmentShader:`
		#include <common>
		#define AO_ESTIMATOR 1
		#define NORMAL_TEXTURE 0
		#define IMPROVED_NORMAL_RECONSTRUCTION 0
		#define ACCURATE_NORMAL_RECONSTRUCTION 1

		varying vec2 vUv;
		uniform sampler2D tDepth;
		uniform sampler2D tNormal;
        uniform vec2 size;

		uniform float cameraNear;
		uniform float cameraFar;
		uniform mat4 cameraProjectionMatrix;
		uniform mat4 cameraInverseProjectionMatrix;
		
		uniform float intensity;
		uniform float bias;
		uniform float kernelRadius;
		
		
		#if AO_ESTIMATOR == 0
			#define NUM_SAMPLES 16
        	#define SPIRAL_TURNS 2
			#define INV_NUM_SAMPLES 1.0 / float( NUM_SAMPLES )
        	#define offset PI2 / float(NUM_FRAMES)

			uniform float minResolution;
			uniform float frameIndex;
			uniform float scale;
		#endif

		#if AO_ESTIMATOR == 1
			uniform float tanFov;
			uniform sampler2D tNoise;
			uniform vec3 kernel[ KERNEL_SIZE ];
		#endif

		// RGBA depth
		#include <packing>
		vec4 getDefaultColor( const in vec2 screenPosition ) {
			return vec4( 1.0 );
		}


		float getLinearDepth( const in vec2 screenPosition ) {
			return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );
		}

		float getPerspectiveDepth(const in vec2 coords) {
			float linearDepth = unpackRGBAToDepth( texture2D( tDepth, coords ) );
			#if PERSPECTIVE_CAMERA == 1
				float viewZ = orthographicDepthToViewZ(linearDepth, cameraNear, cameraFar);
				float centerDepth = viewZToPerspectiveDepth(viewZ, cameraNear, cameraFar);
				return centerDepth;
			#else
				return linearDepth;
			#endif
		}

		float getViewDepth(const in float linearDepth) {
			return orthographicDepthToViewZ(linearDepth, cameraNear, cameraFar);
		}

		float getViewZ( const in float depth ) {
			#if PERSPECTIVE_CAMERA == 1
			return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );
			#else
			return orthographicDepthToViewZ( depth, cameraNear, cameraFar );
			#endif
		}

		vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {
			float clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];
			vec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );
			clipPosition *= clipW; // unprojection.
			return ( cameraInverseProjectionMatrix * clipPosition ).xyz;
		}

		//https://wickedengine.net/2019/09/22/improved-normal-reconstruction-from-depth/
		vec3 viewNormalImproved(in vec2 uv, in vec3 origin)
		{	
			highp vec2 dd = abs(vec2(1./size.x, 1./size.y));
			highp vec2 ddx = vec2(dd.x, 0.);
			highp vec2 ddy = vec2(0., dd.y);

			float sampleDepth = getPerspectiveDepth( uv - ddy );
			float sampleViewZ = getViewZ( sampleDepth );
			highp vec3 top = getViewPosition( uv - ddy, sampleDepth, sampleViewZ );

			sampleDepth = getPerspectiveDepth( uv + ddy );
			sampleViewZ = getViewZ( sampleDepth );
			highp vec3 bottom = getViewPosition( uv + ddy, sampleDepth, sampleViewZ );

			highp vec3 center = origin;
			
			sampleDepth = getPerspectiveDepth( uv - ddx );
			sampleViewZ = getViewZ( sampleDepth );
			highp vec3 left = getViewPosition( uv - ddx, sampleDepth, sampleViewZ );

			sampleDepth = getPerspectiveDepth( uv + ddx );
			sampleViewZ = getViewZ( sampleDepth );
			highp vec3 right = getViewPosition( uv + ddx, sampleDepth, sampleViewZ );

			 // get the difference between the current and each offset position
			vec3 l = center - left;
			vec3 r = right - center;
			vec3 d = center - top;
			vec3 u = bottom - center;

			// pick horizontal and vertical diff with the smallest z difference
			vec3 hDeriv = abs(l.z) < abs(r.z) ? l : r;
			vec3 vDeriv = abs(d.z) < abs(u.z) ? d : u;

			// get view space normal from the cross product of the two smallest offsets
			vec3 viewNormal = normalize(cross(hDeriv, vDeriv));

			return viewNormal;
		}

		vec3 viewNormalAccurate(in vec2 uv, in vec3 origin, in float centerDepth) {
			highp vec2 dd = abs(vec2(1./size.x, 1./size.y));
			highp vec2 ddx = vec2(dd.x, 0.);
			highp vec2 ddy = vec2(0., dd.y);

			float sampleDepth = getPerspectiveDepth( uv - ddy );
			float sampleViewZ = getViewZ( sampleDepth );
			highp vec3 top = getViewPosition( uv - ddy, sampleDepth, sampleViewZ );

			sampleDepth = getPerspectiveDepth( uv + ddy );
			sampleViewZ = getViewZ( sampleDepth );
			highp vec3 bottom = getViewPosition( uv + ddy, sampleDepth, sampleViewZ );

			highp vec3 center = origin;
			
			sampleDepth = getPerspectiveDepth( uv - ddx );
			sampleViewZ = getViewZ( sampleDepth );
			highp vec3 left = getViewPosition( uv - ddx, sampleDepth, sampleViewZ );

			sampleDepth = getPerspectiveDepth( uv + ddx );
			sampleViewZ = getViewZ( sampleDepth );
			highp vec3 right = getViewPosition( uv + ddx, sampleDepth, sampleViewZ );

			 // get the difference between the current and each offset position
			vec3 l = center - left;
			vec3 r = right - center;
			vec3 d = center - top;
			vec3 u = bottom - center;

			// get depth values at 1 & 2 pixels offsets from current along the horizontal axis
			vec4 H = vec4(
				getLinearDepth(uv - ddx),
				getLinearDepth(uv + ddx),
				getLinearDepth(uv - 2. * ddx),
				getLinearDepth(uv + 2. * ddx)
			);

			// get depth values at 1 & 2 pixels offsets from current along the vertical axis
			vec4 V = vec4(
				getLinearDepth(uv - ddy),
				getLinearDepth(uv + ddy),
				getLinearDepth(uv - 2. * ddy),
				getLinearDepth(uv + 2. * ddy)
			);

			// current pixel's depth difference from slope of offset depth samples
			// differs from original article because we're using non-linear depth values
			// see article's comments
			vec2 he = abs((2. * H.xy - H.zw) - centerDepth);
			vec2 ve = abs((2. * V.xy - V.zw) - centerDepth);

			// pick horizontal and vertical diff with the smallest depth difference from slopes
			vec3 hDeriv = he.x < he.y ? l : r;
			vec3 vDeriv = ve.x < ve.y ? d : u;

			// get view space normal from the cross product of the best derivatives
			vec3 viewNormal = normalize(cross(hDeriv, vDeriv));

			return viewNormal;

		}

		vec3 getViewNormal( const in vec3 viewPosition, const in vec2 screenPosition, in float centerDepth ) {
			#if NORMAL_TEXTURE == 1
				return unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );
			#elif IMPROVED_NORMAL_RECONSTRUCTION == 1
				return viewNormalImproved(screenPosition, viewPosition);
			#elif ACCURATE_NORMAL_RECONSTRUCTION == 1
				return viewNormalAccurate(screenPosition, viewPosition, centerDepth);
			#else
				return normalize( cross( dFdx( viewPosition ), dFdy( viewPosition ) ) );
			#endif
		}


		float scaleDividedByCameraFar;
		float minResolutionMultipliedByCameraFar;
        // moving costly divides into consts
		

		float computeKernelSize(float d, float r) {
			#if PERSPECTIVE_CAMERA == 1
				// Apparently this is wrong
				// return (r * tan(fov) * d) / (size.y * 0.5);
				// And this is correct
				float rp = r / (size.y * 0.5);
				return sqrt((rp*rp*tanFov*tanFov*d*d)/(1. + rp*rp*tanFov*tanFov));
			#else
				float twoOrthoSize = size.y / (2./ cameraProjectionMatrix[1][1]);
				return r / twoOrthoSize;
			#endif
		}

		float getAmbientOcclusion( const in vec3 centerViewPosition, in float centerDepth ) {
            #if AO_ESTIMATOR == 0
                // precompute some variables require in getOcclusion.
                scaleDividedByCameraFar = scale / cameraFar;
                minResolutionMultipliedByCameraFar = minResolution * cameraFar;
                vec3 centerViewNormal = getViewNormal( centerViewPosition, vUv, centerDepth );
                // jsfiddle that shows sample pattern: https://jsfiddle.net/TenHands/jun67k9y/7/
                float occlusionSum = 0.0;
                float weightSum = 0.0;
                for( int i = 0; i < NUM_SAMPLES; i ++ ) {
                    float alpha = ( float(i) + 1. ) / float(NUM_SAMPLES);
                    float angle = float(SPIRAL_TURNS)  * alpha;
                    vec2 radius = (kernelRadius / size) * pow( alpha, 1.1 );
                    vec2 sampleUv = vUv + vec2( cos( angle + frameIndex * offset ), sin( angle + frameIndex * offset ) ) * radius;

                    float sampleDepth = getPerspectiveDepth( sampleUv );
                    if( sampleDepth >= ( 1.0 - EPSILON ) ) {
                        continue;
                    }
                    float sampleViewZ = getViewZ( sampleDepth );
                    vec3 sampleViewPosition = getViewPosition( sampleUv, sampleDepth, sampleViewZ );

					/** McGuire Estimator*/
					vec3 v = sampleViewPosition - centerViewPosition;
					float vv = dot(v, v);
					float vn = dot(v, centerViewNormal) - bias;
					
					// Note large epsilon to avoid overdarkening within cracks
					float radius2 = 2.;//uSampleRadiusWS * uSampleRadiusWS
					float epsilon = 0.01;
					
					float f = max(radius2 - vv, 0.0) / radius2;
					occlusionSum += f * f * f * max(vn / (epsilon + vv), 0.0) / 4.;

					/** Three.js SAO Estimator*/
                    // vec3 viewDelta = sampleViewPosition - centerViewPosition;
                    // float viewDistance = length( viewDelta );
                    // float scaledScreenDistance = scaleDividedByCameraFar * viewDistance;
                    // occlusionSum += max(0.0, (dot(centerViewNormal, viewDelta) - minResolutionMultipliedByCameraFar) / scaledScreenDistance - bias) / (1.0 + pow2( scaledScreenDistance ) );
                    weightSum += 1.0;
                }
                if( weightSum == 0.0 ) discard;
                return occlusionSum * ( intensity / weightSum );
			#elif AO_ESTIMATOR == 1
				vec3 viewPosition = centerViewPosition;
				vec3 viewNormal = getViewNormal( centerViewPosition, vUv, centerDepth );
				vec2 noiseScale = vec2( size.x / 4.0, size.y / 4.0 );
				vec3 random = vec3( texture2D( tNoise, vUv * noiseScale ).r );
				// compute matrix used to reorient a kernel vector
				vec3 tangent = normalize( random - viewNormal * dot( random, viewNormal ) );
				vec3 bitangent = cross( viewNormal, tangent );
				mat3 kernelMatrix = mat3( tangent, bitangent, viewNormal );
				float occlusion = 0.0;
				float kernelSize_ws = computeKernelSize(-viewPosition.z, kernelRadius);
				float div = float( KERNEL_SIZE);
				float maxDist = kernelSize_ws / (cameraFar - cameraNear);
				for ( int i = 0; i < KERNEL_SIZE; i ++ ) {
					vec3 sampleVector = kernelMatrix * kernel[ i ]; // reorient sample vector in view space
					vec3 samplePoint = viewPosition + ( sampleVector * kernelSize_ws ); // calculate sample point
					vec4 samplePointNDC = cameraProjectionMatrix * vec4( samplePoint, 1.0 ); // project point and calculate NDC
					samplePointNDC /= samplePointNDC.w;
					vec2 samplePointUv = samplePointNDC.xy * 0.5 + 0.5; // compute uv coordinates
					float realDepth = getLinearDepth( samplePointUv ); // get linear depth from depth texture
					float sampleDepth = viewZToOrthographicDepth( samplePoint.z + bias, cameraNear, cameraFar ); // compute linear depth of the sample view Z value
					float delta = sampleDepth - realDepth;
					if ( delta > 0. && delta < maxDist ) { // if fragment is before sample point, increase occlusion
						occlusion += 1.0;
					}
				}
				return clamp( occlusion * intensity / div, 0.0, 1.0 );
			#endif
			}
		void main() {
			float linearDepth = unpackRGBAToDepth( texture2D( tDepth, vUv ) );
			float centerDepth = getPerspectiveDepth(vUv);
			if( centerDepth >= ( 1.0 - EPSILON ) ) {
				discard;
			}
			float centerViewZ = getViewDepth(linearDepth);
			vec3 viewPosition = getViewPosition( vUv, centerDepth, centerViewZ );
			vec3 viewNormal = getViewNormal(viewPosition, vUv, linearDepth);
			float ambientOcclusion = getAmbientOcclusion( viewPosition, centerDepth );
			gl_FragColor = getDefaultColor( vUv );
			gl_FragColor.xyz *=  ambientOcclusion;
			gl_FragColor.a = 1.;
		}`,vertexShader:`
		varying vec2 vUv;
		void main() {
			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
		}`,uniforms:{tDepth:{value:null},tNormal:{value:null},size:{value:new Me(512,512)},cameraNear:{value:1},cameraFar:{value:100},cameraProjectionMatrix:{value:new Ne},cameraInverseProjectionMatrix:{value:new Ne},tanFov:{value:0},intensity:{value:this._options.intensity},bias:{value:this._options.bias},kernelRadius:{value:this._options.kernelRadius},tNoise:{value:null},kernel:{value:null}}}),this.generationMaterial.extensions.derivatives=!0,this.generationMaterial.uniforms.size.value.set(256,256),this.generationMaterial.blending=ui,this.generationMaterial.uniformsNeedUpdate=!0,this.accumulateMaterial=new $n({defines:{},fragmentShader:`
    uniform float opacity;
    uniform sampler2D tDiffuse;
    varying vec2 vUv;
    // #define NUM_FRAMES 16

    void main() {
        vec4 frameSample = texture2D( tDiffuse, vUv );
        gl_FragColor.xyz = frameSample.rgb * 1./float(NUM_FRAMES);
        gl_FragColor.a = 1.;//*= opacity;
    }`,vertexShader:`
    varying vec2 vUv;
    void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
    }`,uniforms:{tDiffuse:{value:null},opacity:{value:1}}}),this.accumulateMaterial.uniforms.tDiffuse.value=this._generationBuffer.texture,this.accumulateMaterial.blending=Cp,this.accumulateMaterial.blendSrc=Ao,this.accumulateMaterial.blendDst=Ao,this.accumulateMaterial.blendEquation=ES,this.accumulateMaterial.blendSrcAlpha=Ao,this.accumulateMaterial.blendDstAlpha=Ao,this.accumulateMaterial.blendEquationAlpha=rs,this.fsQuad=new Bh(this.generationMaterial)}update(e){this.generationMaterial.defines.PERSPECTIVE_CAMERA=e.isPerspectiveCamera?1:0,this.generationMaterial.defines.NUM_FRAMES=this.accumulationFrames,this.generationMaterial.defines.KERNEL_SIZE=this._options.kernelSize,this.accumulateMaterial.defines.NUM_FRAMES=this.accumulationFrames,this.generationMaterial.uniforms.cameraNear.value=e.near,this.generationMaterial.uniforms.cameraFar.value=e.far,this.generationMaterial.uniforms.cameraInverseProjectionMatrix.value.copy(e.projectionMatrixInverse),this.generationMaterial.uniforms.cameraProjectionMatrix.value.copy(e.projectionMatrix);const t=e.fov/2*Math.PI/180;this.generationMaterial.uniforms.tanFov.value=Math.tan(t),this.kernels[this.frameIndex]||this.generateSampleKernel(this.frameIndex),this.noiseTextures[this.frameIndex]||this.generateRandomKernelRotations(this.frameIndex),this.generationMaterial.uniforms.kernel.value=this.kernels[this.frameIndex],this.generationMaterial.uniforms.tNoise.value=this.noiseTextures[this.frameIndex],this.generationMaterial.uniforms.intensity.value=this._options.intensity,this.generationMaterial.uniforms.kernelRadius.value=this._options.kernelRadius,this.generationMaterial.uniforms.bias.value=this._options.bias,this.generationMaterial.needsUpdate=!0,this.accumulateMaterial.needsUpdate=!0}render(e){return e.setRenderTarget(this._generationBuffer),e.setClearColor(0),e.setClearAlpha(1),e.clear(!0),this.fsQuad.material=this.generationMaterial,this.fsQuad.render(e),e.setRenderTarget(this._outputTarget),this.frameIndex===0&&this.clear(e),this.fsQuad.material=this.accumulateMaterial,this.fsQuad.render(e),super.render(e)}setSize(e,t){super.setSize(e,t),this._generationBuffer.setSize(e,t),this.generationMaterial.uniforms.size.value.set(e,t),this.generationMaterial.needsUpdate=!0}generateSampleKernel(e){const t=this._options.kernelSize||0;this.kernels[e]=[];for(let n=0;n<t;n++){const i=new T;i.x=2*Math.random()-1,i.y=2*Math.random()-1,i.z=Math.random(),i.normalize();let r=n/t;r=ci.lerp(.1,1,r*r),i.multiplyScalar(r),this.kernels[e].push(i)}}generateRandomKernelRotations(e){Pw===void 0&&console.error("The pass relies on SimplexNoise.");const t=new Pw,n=new Float32Array(64);for(let i=0;i<64;i+=4){const r=2*Math.random()-1,a=2*Math.random()-1,o=0;n[i]=t.noise3d(r,a,o),n[i+1]=0,n[i+2]=0,n[i+3]=0}this.noiseTextures[e]=new Eh(n,4,4,qi,Oi),this.noiseTextures[e].wrapS=Ho,this.noiseTextures[e].wrapT=Ho,this.noiseTextures[e].needsUpdate=!0}}const VN={blendAO:!0,blendEdges:!1};class iS extends jp{set options(e){super.options=e,this.materialCopy.defines.BLEND_AO=+this._options.blendAO,this.materialCopy.defines.BLEND_EDGES=+this._options.blendEdges,this.materialCopy.needsUpdate=!0}constructor(){super(),this._options=Object.assign({},VN),this.materialCopy=new $n({defines:{BLEND_AO:+this._options.blendAO,BLEND_EDGES:+this._options.blendEdges},uniforms:{tAo:{value:null},tEdges:{value:null}},vertexShader:`
		varying vec2 vUv;
		void main() {
			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
		}`,fragmentShader:`

        #if BLEND_AO == 1
		    uniform sampler2D tAo;
        #endif
        #if BLEND_EDGES == 1
            uniform sampler2D tEdges;
        #endif
		varying vec2 vUv;

        #define ONE3 vec3(1.,1.,1.)

		void main() {
            vec3 ao = ONE3;
            vec3 edges = ONE3;
            
            #if BLEND_AO == 1
                ao = texture2D( tAo, vUv ).rgb;
            #endif

            #if BLEND_EDGES == 1
                edges = texture2D (tEdges, vUv).rgb;
            #endif
             
            gl_FragColor.rgb = min(ao, edges);
			gl_FragColor.a = 1.;
		}`,blending:ui}),this.materialCopy.transparent=!0,this.materialCopy.depthTest=!1,this.materialCopy.depthWrite=!1,this.materialCopy.blending=Cp,this.materialCopy.blendSrc=RS,this.materialCopy.blendDst=Cf,this.materialCopy.blendEquation=rs,this.materialCopy.blendSrcAlpha=Rv,this.materialCopy.blendDstAlpha=Cf,this.materialCopy.blendEquationAlpha=rs,this.materialCopy.needsUpdate=!0,this.fsQuad=new Bh(this.materialCopy)}setTexture(e,t){this.materialCopy.uniforms[e].value=t,this.materialCopy.needsUpdate=!0}get displayName(){return"BLEND"}render(e){return e.setRenderTarget(this._outputTarget),this.fsQuad.render(e),super.render(e)}}class yp extends Wc{constructor(){super(...arguments),this.accumulationFrameIndex=0,this.accumulationFrameCount=16,this.dynamicStage=[],this.progressiveStage=[],this.passthroughStage=[],this.accumulating=!1}get passes(){return[...this.dynamicStage,...this.progressiveStage,...this.passthroughStage]}get dynamicPasses(){return[...this.dynamicStage]}get progressivePasses(){return[...this.progressiveStage]}get passthroughPasses(){return[...this.passthroughStage]}getPass(e){return[...this.dynamicStage.filter(t=>t.displayName===e),...this.progressiveStage.filter(t=>t.displayName===e),...this.passthroughStage.filter(t=>t.displayName===e)]}setClippingPlanes(e){this.dynamicStage.forEach(t=>{var n;return(n=t.setClippingPlanes)===null||n===void 0?void 0:n.call(t,e)}),this.progressiveStage.forEach(t=>{var n;return(n=t.setClippingPlanes)===null||n===void 0?void 0:n.call(t,e)}),this.passthroughStage.forEach(t=>{var n;return(n=t.setClippingPlanes)===null||n===void 0?void 0:n.call(t,e)})}update(e){this.passList.forEach(t=>{var n;t.enabled&&((n=t.update)===null||n===void 0||n.call(t,e)),t instanceof jp&&(t.frameIndex=this.accumulationFrameIndex)})}render(){const e=super.render();return this.accumulating&&++this.accumulationFrameIndex===this.accumulationFrameCount&&this.onAccumulationComplete(),e}reset(){super.reset(),this.accumulationFrameIndex=0,this.onStationaryBegin()}resize(e,t){super.resize(e,t),this.dynamicStage.forEach(n=>{var i;return(i=n.setSize)===null||i===void 0?void 0:i.call(n,e,t)}),this.progressiveStage.forEach(n=>{var i;return(i=n.setSize)===null||i===void 0?void 0:i.call(n,e,t)})}onStationaryBegin(){this.accumulationFrameIndex=0,this.accumulating=!0,this.passList=this.progressiveStage}onStationaryEnd(){this.accumulating=!1,this.passList=this.dynamicStage}onAccumulationComplete(){this.accumulating=!1,this.passList=this.passthroughStage}}class PA extends Wi{get vertexProgram(){return`
#include <common>
#ifdef USE_RTE
    // The high component is stored as the default 'position' attribute buffer
    attribute vec3 position_low;
    uniform vec3 uViewer_high;
    uniform vec3 uViewer_low;
#endif
uniform vec2 size;
uniform float displacement;

#ifdef TRANSFORM_STORAGE
    attribute float objIndex;

    #if TRANSFORM_STORAGE == 0
        #if __VERSION__ == 300
            #define TRANSFORM_STRIDE 4
        #else
            #define TRANSFORM_STRIDE 4.
        #endif
        uniform sampler2D tTransforms;
        uniform float objCount;
    #elif TRANSFORM_STORAGE == 1
        uniform mat4 uTransforms[OBJ_COUNT];
    #endif
#endif

#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

#ifdef TRANSFORM_STORAGE
    void objectTransform(out vec4 quaternion, out vec4 pivotLow, out vec4 pivotHigh, out vec4 translation, out vec4 scale){
        #if TRANSFORM_STORAGE == 0
            #if __VERSION__ == 300
                ivec2 uv = ivec2(int(objIndex) * TRANSFORM_STRIDE, 0); 
                vec4 v0 = texelFetch( tTransforms, uv, 0 );
                vec4 v1 = texelFetch( tTransforms, uv + ivec2(1, 0), 0);
                vec4 v2 = texelFetch( tTransforms, uv + ivec2(2, 0), 0);
                vec4 v3 = texelFetch( tTransforms, uv + ivec2(3, 0), 0);
                quaternion = v0;
                pivotLow = vec4(v1.xyz, 1.);
                pivotHigh = vec4(v2.xyz, 1.);
                translation = vec4(v3.xyz, 1.);
                scale = vec4(v1.w, v2.w, v3.w, 1.);
            #else
                float size = objCount * TRANSFORM_STRIDE;
                vec2 cUv = vec2(0.5/size, 0.5);
                vec2 dUv = vec2(1./size, 0.);
                
                vec2 uv = vec2((objIndex * TRANSFORM_STRIDE)/size + cUv.x, cUv.y);
                vec4 v0 = texture2D( tTransforms, uv);
                vec4 v1 = texture2D( tTransforms, uv + dUv);
                vec4 v2 = texture2D( tTransforms, uv + 2. * dUv);
                vec4 v3 = texture2D( tTransforms, uv + 3. * dUv);
                quaternion = v0;
                pivotLow = vec4(v1.xyz, 1.);
                pivotHigh = vec4(v2.xyz, 1.);
                translation = vec4(v3.xyz, 1.);
                scale = vec4(v1.w, v2.w, v3.w, 1.);
            #endif
        #elif TRANSFORM_STORAGE == 1
            mat4 tMatrix = uTransforms[int(objIndex)];
            quaternion = tMatrix[0];
            pivotLow = vec4(tMatrix[1].xyz, 1.);
            pivotHigh = vec4(tMatrix[2].xyz, 1.);
            translation = vec4(tMatrix[3].xyz, 1.);
            scale = vec4(tMatrix[1][3], tMatrix[2][3], tMatrix[3][3], 1.);
        #endif
    }

    vec3 rotate_vertex_position(vec3 position, vec4 quat)
    { 
        return position + 2.0 * cross(quat.xyz, cross(quat.xyz, position) + quat.w * position);
    }

    /** Another workaround for Apple's stupid compiler */
    vec4 safeMul(vec4 a, vec4 b) {
        // Prevents constant folding and optimization
        return (a + vec4(0.0)) * (b + vec4(1.0)) - a * vec4(1.0);
    }

    highp vec3 rotate_scaled_vertex_position_delta(highp vec4 v0, highp vec4 v1, highp vec4 scale, highp vec4 quat)
    {
        /** !!! WORKAROUND FOR Intel IrisXe CARDS !!! */
        /** The code below will not produce correct results in intel IrisXE integrated GPUs. 
         *  The geometry will turn mangled, albeit stable
         *  I can't know for sure what is going on, but rotating the difference seems to 
         *  force the result into a lower precision?
         */
        // highp vec4 position = v0 - v1;
        // return position.xyz + 2.0 * cross(quat.xyz, cross(quat.xyz, position.xyz) + quat.w * position.xyz);

        /** Subtracting the rotated vectors works. */
        return rotate_vertex_position(safeMul(v0, scale).xyz, quat)  - rotate_vertex_position(safeMul(v1, scale).xyz, quat) ;

        /** An alternate workaround is
         * highp vec3 position = (v0.xyz * (1. + 1e-7)) - (v1.xyz * (1. + 1e-7));
           return position + 2.0 * cross(quat.xyz, cross(quat.xyz, position) + quat.w * position);

           However I'm not such a fan of the (1. + 1e-7) part
         */
    }
    
#endif

#ifdef USE_RTE
    highp vec4 computeRelativePosition(in highp vec3 position_low, in highp vec3 position_high, in highp vec3 relativeTo_low, in highp vec3 relativeTo_high){
        /* 
        Source https://github.com/virtualglobebook/OpenGlobe/blob/master/Source/Examples/Chapter05/Jitter/GPURelativeToEyeDSFUN90/Shaders/VS.glsl 
        Note here, we're storing the high part of the position encoding inside three's default 'position' attribute buffer so we avoid redundancy 
        */
        highp vec3 t1 = position_low.xyz - relativeTo_low.xyz;
        highp vec3 e = t1 - position_low.xyz;
        /** This is redunant, but necessary as a workaround for Apple platforms */
        highp float x = position_high.x - relativeTo_high.x;
        highp float y = position_high.y - relativeTo_high.y;
        highp float z = position_high.z - relativeTo_high.z;
        highp vec3 v = vec3(x, y, z);
        /** End of redundant part */
        highp vec3 t2 = ((-relativeTo_low - e) + (position_low.xyz - (t1 - e))) + v;
        highp vec3 highDifference = t1 + t2;
        highp vec3 lowDifference = t2 - (highDifference.xyz - t1.xyz);
        
        highp vec3 position = highDifference.xyz + lowDifference.xyz;
        return vec4(position, 1.);
    }
#endif

void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	// #include <project_vertex> COMMENTED CHUNK
    #ifdef TRANSFORM_STORAGE
        vec4 tQuaternion, tPivotLow, tPivotHigh, tTranslation, tScale;
        objectTransform(tQuaternion, tPivotLow, tPivotHigh, tTranslation, tScale);
    #endif
    #ifdef USE_RTE
        vec4 position_lowT = vec4(position_low, 1.);
        vec4 position_highT = vec4(position, 1.);
        const vec3 ZERO3 = vec3(0., 0., 0.);

        highp vec4 rteLocalPosition = computeRelativePosition(position_lowT.xyz, position_highT.xyz, uViewer_low, uViewer_high);
        #ifdef TRANSFORM_STORAGE
            highp vec4 rtePivot = computeRelativePosition(tPivotLow.xyz, tPivotHigh.xyz, uViewer_low, uViewer_high);
            rteLocalPosition.xyz = rotate_scaled_vertex_position_delta(rteLocalPosition, rtePivot, tScale, tQuaternion) + rtePivot.xyz + tTranslation.xyz;
        #endif
        #ifdef USE_INSTANCING
            vec4 instancePivot = computeRelativePosition(ZERO3, ZERO3, uViewer_low, uViewer_high);
            rteLocalPosition.xyz = (mat3(instanceMatrix) * (rteLocalPosition - instancePivot).xyz) + instancePivot.xyz + instanceMatrix[3].xyz;
        #endif
    #endif

    #ifdef USE_RTE
        vec4 mvPosition = rteLocalPosition;
    #else
        vec4 mvPosition = vec4( transformed, 1.0 );
        #ifdef TRANSFORM_STORAGE
            mvPosition.xyz = rotate_scaled_vertex_position_delta(mvPosition, tPivotHigh, tScale, tQuaternion) + tPivotHigh.xyz + tTranslation.xyz;
        #endif
        #ifdef USE_INSTANCING
            mvPosition = instanceMatrix * mvPosition;
        #endif
    #endif
    
    mvPosition = modelViewMatrix * mvPosition;

    gl_Position = projectionMatrix * mvPosition;
    
    // Transform normal vector from object space to clip space.
    vec3 normalHCS = mat3(projectionMatrix) * normalMatrix * normal;

    // Move vertex along normal vector in clip space.
    gl_Position.xy += normalize(normalHCS.xy) / size * gl_Position.w * displacement * 2.;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}
`}get fragmentProgram(){return`
uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	// accumulation (baked indirect lighting only)
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	// modulation
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}
`}get uniformsDef(){return{...super.uniformsDef,size:new Me,displacement:0}}constructor(e,t=[]){super(e,t)}fastCopy(e,t){super.fastCopy(e,t),t.userData.displacement.value=e.userData.displacement.value}}class GN extends Go{constructor(){super(),this.stencilMaterial=new PA({color:16711680}),this.stencilMaterial.userData.displacement.value=2,this.stencilMaterial.colorWrite=!1,this.stencilMaterial.depthWrite=!1,this.stencilMaterial.stencilWrite=!0,this.stencilMaterial.stencilFunc=Dv,this.stencilMaterial.stencilWriteMask=255,this.stencilMaterial.stencilRef=255,this.stencilMaterial.stencilZFail=ec,this.stencilMaterial.stencilZPass=ec,this.stencilMaterial.stencilFail=ec,this.stencilMaterial.side=Qt}get displayName(){return"STENCIL"}get overrideMaterial(){return this.stencilMaterial}setSize(e,t){super.setSize(e,t),this.stencilMaterial.userData.size.value.copy(new Me(e,t)),this.stencilMaterial.needsUpdate=!0}}class HN extends Go{constructor(){super(),this.stencilMaskMaterial=new PA({color:304635}),this.stencilMaskMaterial.userData.displacement.value=2,this.stencilMaskMaterial.colorWrite=!0,this.stencilMaskMaterial.depthWrite=!1,this.stencilMaskMaterial.stencilWrite=!0,this.stencilMaskMaterial.stencilFunc=TT,this.stencilMaskMaterial.stencilRef=255,this.stencilMaskMaterial.side=Qt}get displayName(){return"STENCIL-MASK"}get overrideMaterial(){return this.stencilMaskMaterial}setSize(e,t){super.setSize(e,t),this.stencilMaskMaterial.userData.size.value.copy(new Me(e,t)),this.stencilMaskMaterial.needsUpdate=!0}}const Ns={depthMultiplier:1,depthBias:.001,normalMultiplier:1,normalBias:15,outlineThickness:1,outlineOpacity:.75,outlineColor:3289650,backgroundColor:268435455};class ff extends Hc{set options(e){var t,n,i,r,a,o,l,c;super.options=e,this.edgesMaterial.uniforms.uDepthMultiplier.value=(t=this._options.depthMultiplier)!==null&&t!==void 0?t:Ns.depthMultiplier,this.edgesMaterial.uniforms.uDepthBias.value=(n=this._options.depthBias)!==null&&n!==void 0?n:Ns.depthBias,this.edgesMaterial.uniforms.uNormalMultiplier.value=(i=this._options.normalMultiplier)!==null&&i!==void 0?i:Ns.normalMultiplier,this.edgesMaterial.uniforms.uNormalBias.value=(r=this._options.normalBias)!==null&&r!==void 0?r:Ns.normalBias,this.edgesMaterial.uniforms.uOutlineThickness.value=(a=this._options.outlineThickness)!==null&&a!==void 0?a:Ns.outlineThickness,this.edgesMaterial.uniforms.uOutlineDensity.value=(o=this._options.outlineOpacity)!==null&&o!==void 0?o:Ns.outlineOpacity,this.edgesMaterial.uniforms.uOutlineColor.value=new ot((l=this._options.outlineColor)!==null&&l!==void 0?l:Ns.outlineColor),this.edgesMaterial.uniforms.uBackgroundColor.value=new ot((c=this._options.backgroundColor)!==null&&c!==void 0?c:Ns.backgroundColor)}constructor(){super(),this._options=Object.assign({},Ns),this._outputTarget=Wc.createRenderTarget({minFilter:cn,magFilter:cn}),this.edgesMaterial=new $n({fragmentShader:`
#include <common>
varying vec2 vUv;
uniform sampler2D tDepth;
uniform sampler2D tNormal;
uniform sampler2D tId;
uniform float uDepthMultiplier;
uniform float uDepthBias;
uniform float uNormalMultiplier;
uniform float uNormalBias;
uniform float uOutlineThickness;
uniform float uOutlineDensity;
uniform vec3 uOutlineColor;
uniform vec3 uBackgroundColor;
uniform vec2 size;

uniform float cameraNear;
uniform float cameraFar;
uniform mat4 cameraProjectionMatrix;
uniform mat4 cameraInverseProjectionMatrix;

#define ID_GRADIENT_THRESHOLD 1e-4
#include <packing>


float getDepth( const in ivec2 screenPosition ) {
  #if __VERSION__ == 300
	  return unpackRGBAToDepth( texelFetch( tDepth, clamp(screenPosition, ivec2(0,0), ivec2(size)), 0 ) );
  #else
    vec2 cUv = vec2(0.5/size.x, 0.5/size.y);
    return unpackRGBAToDepth( texture2D( tDepth, vec2(min(screenPosition, ivec2(size)))/size + cUv ) );
  #endif
}



vec3 SobelSample(sampler2D t, vec2 uv, vec3 offset){
	vec3 pixelCenter = texture2D(t, uv).rgb;
	vec3 pixelLeft   = texture2D(t, uv - offset.xz).rgb;
	vec3 pixelRight  = texture2D(t, uv + offset.xz).rgb;
	vec3 pixelUp     = texture2D(t, uv + offset.zy).rgb;
	vec3 pixelDown   = texture2D(t, uv - offset.zy).rgb;

	return abs(pixelLeft - pixelCenter)  +
			abs(pixelRight - pixelCenter) +
			abs(pixelUp - pixelCenter)    +
			abs(pixelDown - pixelCenter);
}


float GetTolerance(float d, float k)
{
    // -------------------------------------------
    // Find a tolerance for depth that is constant
    // in view space (k in view space).
    //
    // tol = k*ddx(ZtoDepth(z))
    // -------------------------------------------
    
    float A=-   (cameraFar+cameraNear)/(cameraFar - cameraNear);
    float B=-2.0*cameraFar*cameraNear /(cameraFar -cameraNear);
    
    d = d*2.0-1.0;
    
    return -k*(d+A)*(d+A)/B;   
}

float DetectSilho(ivec2 fragCoord, ivec2 dir, float tolerance)
{
    // -------------------------------------------
    //   x0 ___ x1----o 
    //          :    : 
    //       r0 :    : r1
    //          :    : 
    //          o---x2 ___ x3
    //
    // r0 and r1 are the differences between actual
    // and expected (as if x0..3 where on the same
    // plane) depth values.
    // -------------------------------------------
    float x0 = abs(getDepth(fragCoord + dir*-2));
    float x1 = abs(getDepth(fragCoord + dir*-1));
    float x2 = abs(getDepth(fragCoord + dir* 0));
    float x3 = abs(getDepth(fragCoord + dir* 1));
    
    float d0 = (x1-x0);
    float d1 = (x2-x3);
    
    float r0 = x1 + d0 - x2;
    float r1 = x2 + d1 - x1;
    
    float tol = GetTolerance(x2, tolerance);
    
    return smoothstep(0.0, tol*tol, max( - r0*r1, 0.0));

}

// Source: https://www.shadertoy.com/view/DslXz2
float DepthEdge(ivec2 fragCoord, float tolerance)
{
    return max(
        DetectSilho(fragCoord, ivec2(1,0), tolerance), // Horizontal
        DetectSilho(fragCoord, ivec2(0,1), tolerance)  // Vertical
        );
}

float NormalEdge(float scale)
{
	float halfScaleFloor = floor(scale * 0.5);
	float halfScaleCeil = ceil(scale * 0.5);

	vec2 pixelSize = vec2(1.0 / size.x, 1.0 / size.y);

	vec2 bottomLeftUV = vUv - pixelSize * halfScaleFloor;
	vec2 topRightUV = vUv + pixelSize * halfScaleCeil;  
	vec2 bottomRightUV = vUv + vec2(pixelSize.x * halfScaleCeil, -pixelSize.y * halfScaleFloor);
	vec2 topLeftUV = vUv + vec2(-pixelSize.x * halfScaleFloor, pixelSize.y * halfScaleCeil);

	vec3 centerNormal = unpackRGBToNormal(texture2D(tNormal, vUv).rgb);
	vec3 normal0 = unpackRGBToNormal(texture2D(tNormal, bottomLeftUV).rgb);
	vec3 normal1 = unpackRGBToNormal(texture2D(tNormal, topRightUV).rgb);
	vec3 normal2 = unpackRGBToNormal(texture2D(tNormal, bottomRightUV).rgb);
	vec3 normal3 = unpackRGBToNormal(texture2D(tNormal, topLeftUV).rgb);

	vec3 normalFiniteDifference0 = normal1 - normal0;
	vec3 normalFiniteDifference1 = normal3 - normal2;

	return sqrt(dot(normalFiniteDifference0, normalFiniteDifference0) + dot(normalFiniteDifference1, normalFiniteDifference1));
}

/** Alternative to NormalEdge. */
vec3 SobelSampleNormal(vec2 uv){
	float w = 1.0 / size.x;
	float h = 1.0 / size.y;
	vec3 n[9];
	n[0] = unpackRGBToNormal(texture2D(tNormal, uv + vec2( -w, -h)).rgb);
	n[1] = unpackRGBToNormal(texture2D(tNormal, uv + vec2(0.0, -h)).rgb);
	n[2] = unpackRGBToNormal(texture2D(tNormal, uv + vec2(  w, -h)).rgb);
	n[3] = unpackRGBToNormal(texture2D(tNormal, uv + vec2( -w, 0.0)).rgb);
	n[4] = unpackRGBToNormal(texture2D(tNormal, uv).rgb);
	n[5] = unpackRGBToNormal(texture2D(tNormal, uv + vec2(  w, 0.0)).rgb);
	n[6] = unpackRGBToNormal(texture2D(tNormal, uv + vec2( -w, h)).rgb);
	n[7] = unpackRGBToNormal(texture2D(tNormal, uv + vec2(0.0, h)).rgb);
	n[8] = unpackRGBToNormal(texture2D(tNormal, uv + vec2(  w, h)).rgb);

	vec3 sobel_edge_h = n[2] + (2.0*n[5]) + n[8] - (n[0] + (2.0*n[3]) + n[6]);
  	vec3 sobel_edge_v = n[0] + (2.0*n[1]) + n[2] - (n[6] + (2.0*n[7]) + n[8]);
	vec3 sobel = sqrt((sobel_edge_h * sobel_edge_h) + (sobel_edge_v * sobel_edge_v));
	return sobel;
}


void main() {
	// Depth edge
  float depthEdge = DepthEdge(ivec2(gl_FragCoord), uDepthBias) * uDepthMultiplier; 
  // Normal edge
	float normalEdge = pow(NormalEdge(uOutlineThickness) * uNormalMultiplier, uNormalBias);
  // Id edge
	vec3 offset = vec3((1.0 / size.x), (1.0 / size.y), 0.0) * uOutlineThickness;
	vec3 sobelIdVec = abs(SobelSample(tId, vUv, offset));
  // This is the branchless equivalent of sobelIdVec.x + sobelIdVec.y + sobelIdVec.z > ID_GRADIENT_THRESHOLD ? 1. : 0.
	float sobelIdEdge = step(ID_GRADIENT_THRESHOLD, sobelIdVec.x + sobelIdVec.y + sobelIdVec.z);

  // Combine the three edges by taking the minimum
  float maxOutline = saturate(max(sobelIdEdge, max(depthEdge, normalEdge)));
	float sobelOutline = maxOutline * uOutlineDensity;

  
  vec3 color = mix(uBackgroundColor, uOutlineColor, sobelOutline);
  float alpha = mix(0., uOutlineDensity, sobelOutline);
  // vec3 color = vec3(depthEdge, normalEdge, sobelIdEdge); // Debug
	gl_FragColor = vec4(color, alpha);

}`,vertexShader:`
varying vec2 vUv;
void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,uniforms:{tDepth:{value:null},tNormal:{value:null},tId:{value:null},size:{value:new Me(512,512)},uDepthMultiplier:{value:this._options.depthMultiplier},uDepthBias:{value:this._options.depthBias},uNormalMultiplier:{value:this._options.normalMultiplier},uNormalBias:{value:this._options.normalBias},uOutlineThickness:{value:this._options.outlineThickness},uOutlineDensity:{value:this._options.outlineOpacity},uOutlineColor:{value:new ot(this._options.outlineColor)},uBackgroundColor:{value:new ot(this._options.backgroundColor)},cameraNear:{value:1},cameraFar:{value:100},cameraProjectionMatrix:{value:new Ne},cameraInverseProjectionMatrix:{value:new Ne}}}),this.edgesMaterial.depthWrite=!1,this.fsQuad=new Bh(this.edgesMaterial)}setTexture(e,t){this.edgesMaterial.uniforms[e].value=t,this.edgesMaterial.needsUpdate=!0}get displayName(){return"EDGES"}update(e){this.edgesMaterial.defines.PERSPECTIVE_CAMERA=e.isPerspectiveCamera?1:0,this.edgesMaterial.uniforms.cameraNear.value=e.near,this.edgesMaterial.uniforms.cameraFar.value=e.far}render(e){return this.onBeforeRender&&this.onBeforeRender(),e.setRenderTarget(this._outputTarget),this.fsQuad.render(e),this.onAfterRender&&this.onAfterRender(),!1}setSize(e,t){super.setSize(e,t),this.edgesMaterial.uniforms.size.value.set(e,t),this.edgesMaterial.needsUpdate=!0}}class rS extends jp{constructor(){super(),this.outputToScreen=!1,this._outputTarget=new Yn(256,256,{minFilter:cn,magFilter:cn}),this.historyTarget=new Yn(256,256,{minFilter:cn,magFilter:cn}),this.materialCopy=new $n({uniforms:Ga.clone(lg.uniforms),vertexShader:lg.vertexShader,fragmentShader:lg.fragmentShader,blending:ui}),this.materialCopy.needsUpdate=!0,this.reprojectionMaterial=new $n({uniforms:{tDiffuse:{value:null},tLastFrame:{value:null},width:{value:0},height:{value:0}},transparent:!0,blending:ui,depthTest:!1,depthWrite:!1,vertexShader:`
    varying vec2 Uv;
    
    void main() {
        Uv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }`,fragmentShader:`
    uniform float height;
    uniform float width;
    uniform sampler2D tDiffuse;
    uniform sampler2D tLastFrame;
    varying vec2 Uv;

    #define LuminanceEncodeApprox vec3(0.2126, 0.7152, 0.0722)
    float getLuminance(vec3 color) {
        return clamp(dot(color, LuminanceEncodeApprox), 0., 1.);
    }
    
    void main() {
        vec4 texel = texture2D(tDiffuse, Uv);
        vec2 oldPixelUv = Uv;
        vec4 oldTexel = texture2D(tLastFrame, oldPixelUv);

        // Use simple neighbor clamping
        vec4 maxNeighbor = vec4(0.0, 0.0, 0.0, 1.0);
        vec4 minNeighbor = vec4(1.0);
        vec4 average = vec4(0.0);
        for (int x = -1; x <= 1; x++) {
            for (int y = -1; y <= 1; y++) {
                vec2 neighborUv = Uv + vec2(float(x) / width, float(y) / height);
                vec4 neighborTexel = texture2D(tDiffuse, neighborUv);
                maxNeighbor = max(maxNeighbor, neighborTexel);
                minNeighbor = min(minNeighbor, neighborTexel);
                average += neighborTexel / 9.0;
            }
        }
        float lum0 = getLuminance(texel.rgb);
        float lum1 = getLuminance(oldTexel.rgb);

        float unbiased_diff = abs(lum0 - lum1) / max(lum0, max(lum1, 0.2));
        float unbiased_weight = 1.0 - unbiased_diff;
        float unbiased_weight_sqr = unbiased_weight * unbiased_weight;
        float k_feedback = mix(0.8800, 0.9700, unbiased_weight_sqr);
        
        // UE Method to get rid of flickering. Weight frame mixing amount
        // based on local contrast.
        float contrast = distance(average, texel);
        float weight = 0.05 * contrast;

        float blendFactor = mix(1. - weight, k_feedback, 1.);
        vec4 compositeColor = mix(texel, oldTexel, blendFactor);
    
        gl_FragColor = compositeColor;
    }`}),this.reprojectionMaterial.needsUpdate=!0,this.fsQuad=new Bh}get displayName(){return"TAA"}set inputTexture(e){this.inputTex=e}render(e){var t,n;return this.frameIndex===0&&(e.setRenderTarget(this._outputTarget),e.clear(),this.materialCopy.uniforms.tDiffuse.value=this.inputTex,this.materialCopy.needsUpdate=!0,this.fsQuad.material=this.materialCopy,this.fsQuad.render(e)),e.setRenderTarget(this.historyTarget),e.clear(),this.reprojectionMaterial.uniforms.tLastFrame.value=(t=this._outputTarget)===null||t===void 0?void 0:t.texture,this.reprojectionMaterial.uniforms.tDiffuse.value=this.inputTex,this.reprojectionMaterial.needsUpdate=!0,this.fsQuad.material=this.reprojectionMaterial,this.fsQuad.render(e),e.setRenderTarget(this._outputTarget),e.clear(),this.materialCopy.uniforms.tDiffuse.value=this.historyTarget.texture,this.materialCopy.needsUpdate=!0,this.fsQuad.material=this.materialCopy,this.fsQuad.render(e),this.outputToScreen&&(e.setRenderTarget(null),this.materialCopy.uniforms.tDiffuse.value=(n=this._outputTarget)===null||n===void 0?void 0:n.texture,this.materialCopy.needsUpdate=!0,this.fsQuad.material=this.materialCopy,this.fsQuad.render(e)),super.render(e)}setSize(e,t){super.setSize(e,t),this.historyTarget.setSize(e,t),this.reprojectionMaterial.uniforms.width.value=e,this.reprojectionMaterial.uniforms.height.value=t}}class DA extends zh{get vertexProgram(){return`
#include <common>
#ifdef USE_RTE
    // The high component is stored as the default 'position' attribute buffer
    attribute vec3 position_low;
    uniform vec3 uViewer_high;
    uniform vec3 uViewer_low;
    uniform mat4 rteModelViewMatrix;
#endif

#ifdef TRANSFORM_STORAGE
    attribute float objIndex;

    #if TRANSFORM_STORAGE == 0
        #if __VERSION__ == 300
            #define TRANSFORM_STRIDE 4
        #else
            #define TRANSFORM_STRIDE 4.
        #endif
        uniform sampler2D tTransforms;
        uniform float objCount;
    #elif TRANSFORM_STORAGE == 1
        uniform mat4 uTransforms[OBJ_COUNT];
    #endif
#endif

#ifdef LINEAR_DEPTH
    varying vec4 vViewPosition;
#endif
varying vec3 vNormal;

#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
// This is used for computing an equivalent of gl_FragCoord.z that is as high precision as possible.
// Some platforms compute gl_FragCoord at a lower precision which makes the manually computed value better for
// depth-based postprocessing effects. Reproduced on iPad with A10 processor / iPadOS 13.3.1.
varying vec2 vHighPrecisionZW;

#ifdef TRANSFORM_STORAGE
    void objectTransform(out vec4 quaternion, out vec4 pivotLow, out vec4 pivotHigh, out vec4 translation, out vec4 scale){
        #if TRANSFORM_STORAGE == 0
            #if __VERSION__ == 300
                ivec2 uv = ivec2(int(objIndex) * TRANSFORM_STRIDE, 0); 
                vec4 v0 = texelFetch( tTransforms, uv, 0 );
                vec4 v1 = texelFetch( tTransforms, uv + ivec2(1, 0), 0);
                vec4 v2 = texelFetch( tTransforms, uv + ivec2(2, 0), 0);
                vec4 v3 = texelFetch( tTransforms, uv + ivec2(3, 0), 0);
                quaternion = v0;
                pivotLow = vec4(v1.xyz, 1.);
                pivotHigh = vec4(v2.xyz, 1.);
                translation = vec4(v3.xyz, 1.);
                scale = vec4(v1.w, v2.w, v3.w, 1.);
            #else
                float size = objCount * TRANSFORM_STRIDE;
                vec2 cUv = vec2(0.5/size, 0.5);
                vec2 dUv = vec2(1./size, 0.);
                
                vec2 uv = vec2((objIndex * TRANSFORM_STRIDE)/size + cUv.x, cUv.y);
                vec4 v0 = texture2D( tTransforms, uv);
                vec4 v1 = texture2D( tTransforms, uv + dUv);
                vec4 v2 = texture2D( tTransforms, uv + 2. * dUv);
                vec4 v3 = texture2D( tTransforms, uv + 3. * dUv);
                quaternion = v0;
                pivotLow = vec4(v1.xyz, 1.);
                pivotHigh = vec4(v2.xyz, 1.);
                translation = vec4(v3.xyz, 1.);
                scale = vec4(v1.w, v2.w, v3.w, 1.);
            #endif
        #elif TRANSFORM_STORAGE == 1
            mat4 tMatrix = uTransforms[int(objIndex)];
            quaternion = tMatrix[0];
            pivotLow = vec4(tMatrix[1].xyz, 1.);
            pivotHigh = vec4(tMatrix[2].xyz, 1.);
            translation = vec4(tMatrix[3].xyz, 1.);
            scale = vec4(tMatrix[1][3], tMatrix[2][3], tMatrix[3][3], 1.);
        #endif
    }

    vec3 rotate_vertex_position(vec3 position, vec4 quat)
    { 
        return position + 2.0 * cross(quat.xyz, cross(quat.xyz, position) + quat.w * position);
    }

    /** Another workaround for Apple's stupid compiler */
    vec4 safeMul(vec4 a, vec4 b) {
        // Prevents constant folding and optimization
        return (a + vec4(0.0)) * (b + vec4(1.0)) - a * vec4(1.0);
    }

    highp vec3 rotate_scaled_vertex_position_delta(highp vec4 v0, highp vec4 v1, highp vec4 scale, highp vec4 quat)
    {
        /** !!! WORKAROUND FOR Intel IrisXe CARDS !!! */
        /** The code below will not produce correct results in intel IrisXE integrated GPUs. 
         *  The geometry will turn mangled, albeit stable
         *  I can't know for sure what is going on, but rotating the difference seems to 
         *  force the result into a lower precision?
         */
        // highp vec4 position = v0 - v1;
        // return position.xyz + 2.0 * cross(quat.xyz, cross(quat.xyz, position.xyz) + quat.w * position.xyz);

        /** Subtracting the rotated vectors works. */
        return rotate_vertex_position(safeMul(v0, scale).xyz, quat)  - rotate_vertex_position(safeMul(v1, scale).xyz, quat) ;

        /** An alternate workaround is
         * highp vec3 position = (v0.xyz * (1. + 1e-7)) - (v1.xyz * (1. + 1e-7));
           return position + 2.0 * cross(quat.xyz, cross(quat.xyz, position) + quat.w * position);

           However I'm not such a fan of the (1. + 1e-7) part
         */
    }
#endif

#ifdef USE_RTE
    highp vec4 computeRelativePosition(in highp vec3 position_low, in highp vec3 position_high, in highp vec3 relativeTo_low, in highp vec3 relativeTo_high){
        /* 
        Source https://github.com/virtualglobebook/OpenGlobe/blob/master/Source/Examples/Chapter05/Jitter/GPURelativeToEyeDSFUN90/Shaders/VS.glsl 
        Note here, we're storing the high part of the position encoding inside three's default 'position' attribute buffer so we avoid redundancy 
        */
        highp vec3 t1 = position_low.xyz - relativeTo_low.xyz;
        highp vec3 e = t1 - position_low.xyz;
        /** This is redunant, but necessary as a workaround for Apple platforms */
        highp float x = position_high.x - relativeTo_high.x;
        highp float y = position_high.y - relativeTo_high.y;
        highp float z = position_high.z - relativeTo_high.z;
        highp vec3 v = vec3(x, y, z);
        /** End of redundant part */
        highp vec3 t2 = ((-relativeTo_low - e) + (position_low.xyz - (t1 - e))) + v;
        highp vec3 highDifference = t1 + t2;
        highp vec3 lowDifference = t2 - (highDifference.xyz - t1.xyz);
        
        highp vec3 position = highDifference.xyz + lowDifference.xyz;
        return vec4(position, 1.);
    }
#endif


void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
    #include <beginnormal_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
    #include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	//#include <project_vertex> // EDITED CHUNK
    #ifdef TRANSFORM_STORAGE
        vec4 tQuaternion, tPivotLow, tPivotHigh, tTranslation, tScale;
        objectTransform(tQuaternion, tPivotLow, tPivotHigh, tTranslation, tScale);
    #endif
    #ifdef USE_RTE
        vec4 position_lowT = vec4(position_low, 1.);
        vec4 position_highT = vec4(position, 1.);
        const vec3 ZERO3 = vec3(0., 0., 0.);

        highp vec4 rteLocalPosition = computeRelativePosition(position_lowT.xyz, position_highT.xyz, uViewer_low, uViewer_high);
        #ifdef TRANSFORM_STORAGE
            highp vec4 rtePivot = computeRelativePosition(tPivotLow.xyz, tPivotHigh.xyz, uViewer_low, uViewer_high);
            rteLocalPosition.xyz = rotate_scaled_vertex_position_delta(rteLocalPosition, rtePivot, tScale, tQuaternion) + rtePivot.xyz + tTranslation.xyz;
        #endif
        #ifdef USE_INSTANCING
            vec4 instancePivot = computeRelativePosition(ZERO3, ZERO3, uViewer_low, uViewer_high);
            rteLocalPosition.xyz = (mat3(instanceMatrix) * (rteLocalPosition - instancePivot).xyz) + instancePivot.xyz + instanceMatrix[3].xyz;
        #endif
    #endif

    #ifdef USE_RTE
        vec4 mvPosition = rteLocalPosition;
    #else
        vec4 mvPosition = vec4( transformed, 1.0 );
        #ifdef TRANSFORM_STORAGE
            mvPosition.xyz = rotate_scaled_vertex_position_delta(mvPosition, tPivotHigh, tScale, tQuaternion) + tPivotHigh.xyz + tTranslation.xyz;
        #endif
        #ifdef USE_INSTANCING
            mvPosition = instanceMatrix * mvPosition;
        #endif
    #endif
   
    #ifdef USE_RTE
        mvPosition = rteModelViewMatrix * mvPosition;
    #else
        mvPosition = modelViewMatrix * mvPosition;
    #endif
    
    #ifdef LINEAR_DEPTH
        vViewPosition = mvPosition;
    #endif 
    vNormal = normalize( transformedNormal );
    gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	// #include <clipping_planes_vertex>
    #if NUM_CLIPPING_PLANES > 0
	    vClipPosition = - mvPosition.xyz;
    #endif
	vHighPrecisionZW = gl_Position.zw;
}
`}get fragmentProgram(){return`
#if __VERSION__ == 100
    #extension GL_EXT_draw_buffers : require
#endif

#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#ifdef LINEAR_DEPTH
    varying vec4 vViewPosition;
	uniform float near;
	uniform float far;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
varying vec3 vNormal;

#if __VERSION__ == 300
    layout(location = 1) out vec4 gNormal;
#endif

void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	// #include <alphatest_fragment>
	#ifdef USE_ALPHATEST
		if ( diffuseColor.a < alphaTest ) discard;
		/** This is a workaround for rejecting shadows for certain materials, since three.js gave me no choice*/
		#ifdef ALPHATEST_REJECTION
			if (alphaTest > 0. ) discard;
		#endif
	#endif
	#include <logdepthbuf_fragment>
    vec3 normal = normalize( vNormal );

    /** Output view space normals*/
    
    vec4 outNormal = vec4( packNormalToRGB( normal ), 1.0 );
    vec4 outDepth;
	// Higher precision equivalent of gl_FragCoord.z. This assumes depthRange has been left to its default values.
	#ifdef LINEAR_DEPTH
		/** View z is negative moving away from the camera */
		outDepth = packDepthToRGBA((vViewPosition.z + near) / (near - far));
	#else
		float fragCoordZ = (0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5);
		#if DEPTH_PACKING == 3200
			outDepth = vec4( vec3( 1.0 - fragCoordZ ), opacity );
		#elif DEPTH_PACKING == 3201
			outDepth = packDepthToRGBA( fragCoordZ );
		#endif
	#endif
    #if __VERSION__ == 300
        pc_fragColor = outDepth;
        gNormal = outNormal;
    #else
        gl_FragData[0] = outDepth;
        gl_FragData[1] = outNormal;
    #endif
}
`}}const LA={...IA};class WN extends Hc{get displayName(){return"DEPTH-NORMAL"}get overrideMaterial(){return this.mrtMaterial}get depthTexture(){return this.mrt.texture[0]}get normalTexture(){return this.mrt.texture[1]}get outputTarget(){return this.mrt}set outputTarget(e){this.mrt=e}set options(e){super.options=e,this.depthType=this._options.depthType}set depthType(e){e===Yu.LINEAR_DEPTH&&(this.mrtMaterial.defines?this.mrtMaterial.defines.LINEAR_DEPTH=" ":this.mrtMaterial.defines&&delete this.mrtMaterial.defines.LINEAR_DEPTH),this.mrtMaterial.needsUpdate=!0}constructor(){super(),this._options=Object.assign({},LA),this.mrt=Wc.createMultipleRenderTarget(2,{minFilter:wn,magFilter:wn}),this.mrtMaterial=new DA({depthPacking:Ko},["ALPHATEST_REJECTION"]),this.mrtMaterial.blending=ui,this.mrtMaterial.side=Qt,this.depthType=this._options.depthType}setClippingPlanes(e){this.mrtMaterial.clippingPlanes=e}update(e){this.mrtMaterial.userData.near.value=e.near,this.mrtMaterial.userData.far.value=e.far,this.mrtMaterial.needsUpdate=!0}render(e,t,n){return!(!t||!n)&&(this.onBeforeRender&&this.onBeforeRender(),e.setRenderTarget(this.mrt),this.applyLayers(t),this.clear(e),e.render(n,t),this.onAfterRender&&this.onAfterRender(),!1)}setSize(e,t){this.mrt.setSize(e,t)}}class qN extends DA{get vertexProgram(){return`
#include <common>
#ifdef USE_RTE
    // The high component is stored as the default 'position' attribute buffer
    attribute vec3 position_low;
    uniform vec3 uViewer_high;
    uniform vec3 uViewer_low;
    uniform mat4 rteModelViewMatrix;
#endif

#if defined( TRANSFORM_STORAGE ) || ( defined( USE_INSTANCING ) && __VERSION__ == 100)
    attribute float objIndex;
#endif

#ifdef TRANSFORM_STORAGE
    #if TRANSFORM_STORAGE == 0
        #if __VERSION__ == 300
            #define TRANSFORM_STRIDE 4
        #else
            #define TRANSFORM_STRIDE 4.
        #endif
        uniform sampler2D tTransforms;
        uniform float objCount;
    #elif TRANSFORM_STORAGE == 1
        uniform mat4 uTransforms[OBJ_COUNT];
    #endif
#endif

varying vec3 vIdColor;
uniform int batchIndex;

#ifdef LINEAR_DEPTH
    varying vec4 vViewPosition;
#endif
varying vec3 vNormal;

#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
// This is used for computing an equivalent of gl_FragCoord.z that is as high precision as possible.
// Some platforms compute gl_FragCoord at a lower precision which makes the manually computed value better for
// depth-based postprocessing effects. Reproduced on iPad with A10 processor / iPadOS 13.3.1.
varying vec2 vHighPrecisionZW;

#ifdef TRANSFORM_STORAGE
    void objectTransform(out vec4 quaternion, out vec4 pivotLow, out vec4 pivotHigh, out vec4 translation, out vec4 scale){
        #if TRANSFORM_STORAGE == 0
            #if __VERSION__ == 300
                ivec2 uv = ivec2(int(objIndex) * TRANSFORM_STRIDE, 0); 
                vec4 v0 = texelFetch( tTransforms, uv, 0 );
                vec4 v1 = texelFetch( tTransforms, uv + ivec2(1, 0), 0);
                vec4 v2 = texelFetch( tTransforms, uv + ivec2(2, 0), 0);
                vec4 v3 = texelFetch( tTransforms, uv + ivec2(3, 0), 0);
                quaternion = v0;
                pivotLow = vec4(v1.xyz, 1.);
                pivotHigh = vec4(v2.xyz, 1.);
                translation = vec4(v3.xyz, 1.);
                scale = vec4(v1.w, v2.w, v3.w, 1.);
            #else
                float size = objCount * TRANSFORM_STRIDE;
                vec2 cUv = vec2(0.5/size, 0.5);
                vec2 dUv = vec2(1./size, 0.);
                
                vec2 uv = vec2((objIndex * TRANSFORM_STRIDE)/size + cUv.x, cUv.y);
                vec4 v0 = texture2D( tTransforms, uv);
                vec4 v1 = texture2D( tTransforms, uv + dUv);
                vec4 v2 = texture2D( tTransforms, uv + 2. * dUv);
                vec4 v3 = texture2D( tTransforms, uv + 3. * dUv);
                quaternion = v0;
                pivotLow = vec4(v1.xyz, 1.);
                pivotHigh = vec4(v2.xyz, 1.);
                translation = vec4(v3.xyz, 1.);
                scale = vec4(v1.w, v2.w, v3.w, 1.);
            #endif
        #elif TRANSFORM_STORAGE == 1
            mat4 tMatrix = uTransforms[int(objIndex)];
            quaternion = tMatrix[0];
            pivotLow = vec4(tMatrix[1].xyz, 1.);
            pivotHigh = vec4(tMatrix[2].xyz, 1.);
            translation = vec4(tMatrix[3].xyz, 1.);
            scale = vec4(tMatrix[1][3], tMatrix[2][3], tMatrix[3][3], 1.);
        #endif
    }

    vec3 rotate_vertex_position(vec3 position, vec4 quat)
    { 
        return position + 2.0 * cross(quat.xyz, cross(quat.xyz, position) + quat.w * position);
    }

    /** Another workaround for Apple's stupid compiler */
    vec4 safeMul(vec4 a, vec4 b) {
        // Prevents constant folding and optimization
        return (a + vec4(0.0)) * (b + vec4(1.0)) - a * vec4(1.0);
    }

    highp vec3 rotate_scaled_vertex_position_delta(highp vec4 v0, highp vec4 v1, highp vec4 scale, highp vec4 quat)
    {
        /** !!! WORKAROUND FOR Intel IrisXe CARDS !!! */
        /** The code below will not produce correct results in intel IrisXE integrated GPUs. 
         *  The geometry will turn mangled, albeit stable
         *  I can't know for sure what is going on, but rotating the difference seems to 
         *  force the result into a lower precision?
         */
        // highp vec4 position = v0 - v1;
        // return position.xyz + 2.0 * cross(quat.xyz, cross(quat.xyz, position.xyz) + quat.w * position.xyz);

        /** Subtracting the rotated vectors works. */
        return rotate_vertex_position(safeMul(v0, scale).xyz, quat)  - rotate_vertex_position(safeMul(v1, scale).xyz, quat) ;

        /** An alternate workaround is
         * highp vec3 position = (v0.xyz * (1. + 1e-7)) - (v1.xyz * (1. + 1e-7));
           return position + 2.0 * cross(quat.xyz, cross(quat.xyz, position) + quat.w * position);

           However I'm not such a fan of the (1. + 1e-7) part
         */
    }
#endif

#ifdef USE_RTE
    highp vec4 computeRelativePosition(in highp vec3 position_low, in highp vec3 position_high, in highp vec3 relativeTo_low, in highp vec3 relativeTo_high){
        /* 
        Source https://github.com/virtualglobebook/OpenGlobe/blob/master/Source/Examples/Chapter05/Jitter/GPURelativeToEyeDSFUN90/Shaders/VS.glsl 
        Note here, we're storing the high part of the position encoding inside three's default 'position' attribute buffer so we avoid redundancy 
        */
        highp vec3 t1 = position_low.xyz - relativeTo_low.xyz;
        highp vec3 e = t1 - position_low.xyz;
        /** This is redunant, but necessary as a workaround for Apple platforms */
        highp float x = position_high.x - relativeTo_high.x;
        highp float y = position_high.y - relativeTo_high.y;
        highp float z = position_high.z - relativeTo_high.z;
        highp vec3 v = vec3(x, y, z);
        /** End of redundant part */
        highp vec3 t2 = ((-relativeTo_low - e) + (position_low.xyz - (t1 - e))) + v;
        highp vec3 highDifference = t1 + t2;
        highp vec3 lowDifference = t2 - (highDifference.xyz - t1.xyz);
        
        highp vec3 position = highDifference.xyz + lowDifference.xyz;
        return vec4(position, 1.);
    }
#endif


/** Original glsl100 and glsl300 hash functions. Good outputs but maybe a bit slow? */
/*
#if __VERSION__ == 300
    vec3 hashColor(uint id) {
        // A simple integer hash function
        id = (id ^ 61u) ^ (id >> 16u);
        id = id * 9u;
        id = id ^ (id >> 4u);
        id = id * 0x27d4eb2du;
        id = id ^ (id >> 15u);

        return vec3(
            float((id >> 16u) & 0xFFu) / 255.0,
            float((id >> 8u) & 0xFFu) / 255.0,
            float(id & 0xFFu) / 255.0
        );
    }
#elif __VERSION__ == 100
    vec3 hashColor(float id) {
        // Step 1: Simulate XOR by using mod and floating-point arithmetic
        id = mod(id + 61.0, 4294967296.0);
        id = mod(id - floor(id / 65536.0), 4294967296.0); // Approximate id ^ (id >> 16)
        // Step 2: Multiply by 9 (same as original)
        id = mod(id * 9.0, 4294967296.0);
        // Step 3: Simulate XOR with division/mod trick
        id = mod(id - floor(id / 16.0), 4294967296.0); // Approximate id ^ (id >> 4)
        // Step 4: Multiply by large prime
        id = mod(id * 666083407.0, 4294967296.0); // Approximate * 0x27d4eb2dU
        // Step 5: Simulate final XOR
        id = mod(id - floor(id / 32768.0), 4294967296.0); // Approximate id ^ (id >> 15)
        // Convert hash to RGB by extracting "fake" bit shifts
        return vec3(
            mod(floor(id / 65536.0), 256.0) / 255.0, // Simulates (id >> 16) & 0xFF
            mod(floor(id / 256.0), 256.0) / 255.0,   // Simulates (id >> 8) & 0xFF
            mod(id, 256.0) / 255.0                   // Simulates id & 0xFF
        );
    }
#endif
*/

/** Simpler hash function works on both glsl versions */
highp vec3 hashColor(float id) {
    // Large prime multipliers
    highp float r = mod(id * 127.1, 256.0) / 255.0;
    highp float g = mod(id * 987.654, 256.0) / 255.0;
    highp float b = mod(id * 4321.123, 256.0) / 255.0;
    
    return vec3(r, g, b);
}

int szudzikHash(int x, int y) {
    return (x >= y) ? (x * x + x + y) : (y * y + x);
}

void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
    #include <beginnormal_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
    #include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	//#include <project_vertex> // EDITED CHUNK
    #ifdef TRANSFORM_STORAGE
        vec4 tQuaternion, tPivotLow, tPivotHigh, tTranslation, tScale;
        objectTransform(tQuaternion, tPivotLow, tPivotHigh, tTranslation, tScale);
    #endif
    #ifdef USE_RTE
        vec4 position_lowT = vec4(position_low, 1.);
        vec4 position_highT = vec4(position, 1.);
        const vec3 ZERO3 = vec3(0., 0., 0.);

        highp vec4 rteLocalPosition = computeRelativePosition(position_lowT.xyz, position_highT.xyz, uViewer_low, uViewer_high);
        #ifdef TRANSFORM_STORAGE
            highp vec4 rtePivot = computeRelativePosition(tPivotLow.xyz, tPivotHigh.xyz, uViewer_low, uViewer_high);
            rteLocalPosition.xyz = rotate_scaled_vertex_position_delta(rteLocalPosition, rtePivot, tScale, tQuaternion) + rtePivot.xyz + tTranslation.xyz;
        #endif
        #ifdef USE_INSTANCING
            vec4 instancePivot = computeRelativePosition(ZERO3, ZERO3, uViewer_low, uViewer_high);
            rteLocalPosition.xyz = (mat3(instanceMatrix) * (rteLocalPosition - instancePivot).xyz) + instancePivot.xyz + instanceMatrix[3].xyz;
        #endif
    #endif

    #ifdef USE_RTE
        vec4 mvPosition = rteLocalPosition;
    #else
        vec4 mvPosition = vec4( transformed, 1.0 );
        #ifdef TRANSFORM_STORAGE
            mvPosition.xyz = rotate_scaled_vertex_position_delta(mvPosition, tPivotHigh, tScale, tQuaternion) + tPivotHigh.xyz + tTranslation.xyz;
        #endif
        #ifdef USE_INSTANCING
            mvPosition = instanceMatrix * mvPosition;
        #endif
    #endif
   
    #ifdef USE_RTE
        mvPosition = rteModelViewMatrix * mvPosition;
    #else
        mvPosition = modelViewMatrix * mvPosition;
    #endif
    
    #ifdef LINEAR_DEPTH
        vViewPosition = mvPosition;
    #endif 

    vNormal = normalize( transformedNormal );
    
    #ifdef TRANSFORM_STORAGE
        vIdColor = hashColor(float(szudzikHash(int(objIndex), batchIndex)));
    #else
        #if defined( USE_INSTANCING ) 
            #if __VERSION__ == 300
                vIdColor = hashColor(float(szudzikHash(int(gl_InstanceID), batchIndex)));
            #elif __VERSION__ == 100
                vIdColor = hashColor(float(szudzikHash(int(objIndex), batchIndex)));
            #endif
        #else
            vIdColor = vec3(0.);
        #endif
    #endif


    gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	// #include <clipping_planes_vertex>
    #if NUM_CLIPPING_PLANES > 0
	    vClipPosition = - mvPosition.xyz;
    #endif
	vHighPrecisionZW = gl_Position.zw;
}
`}get fragmentProgram(){return`
#if __VERSION__ == 100
    #extension GL_EXT_draw_buffers : require
#endif

#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#ifdef LINEAR_DEPTH
    varying vec4 vViewPosition;
	uniform float near;
	uniform float far;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
varying vec3 vNormal;

varying vec3 vIdColor;

#if __VERSION__ == 300
    layout(location = 1) out vec4 gNormal;
    layout(location = 2) out vec4 gId;
#endif

void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	// #include <alphatest_fragment>
	#ifdef USE_ALPHATEST
		if ( diffuseColor.a < alphaTest ) discard;
		/** This is a workaround for rejecting shadows for certain materials, since three.js gave me no choice*/
		#ifdef ALPHATEST_REJECTION
			if (alphaTest > 0. ) discard;
		#endif
	#endif
	#include <logdepthbuf_fragment>
    vec3 normal = normalize( vNormal );

    /** Output view space normals*/
    
    vec4 outNormal = vec4( packNormalToRGB( normal ), 1.0 );
    vec4 outDepth;
	// Higher precision equivalent of gl_FragCoord.z. This assumes depthRange has been left to its default values.
	#ifdef LINEAR_DEPTH
		/** View z is negative moving away from the camera */
		outDepth = packDepthToRGBA((vViewPosition.z + near) / (near - far));
	#else
		float fragCoordZ = (0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5);
		#if DEPTH_PACKING == 3200
			outDepth = vec4( vec3( 1.0 - fragCoordZ ), opacity );
		#elif DEPTH_PACKING == 3201
			outDepth = packDepthToRGBA( fragCoordZ );
		#endif
	#endif
    #if __VERSION__ == 300
        pc_fragColor = outDepth;
        gNormal = outNormal;
        gId = vec4(vIdColor, 1.0);
    #else
        gl_FragData[0] = outDepth;
        gl_FragData[1] = outNormal;
        gl_FragData[2] = vec4(vIdColor, 1.0);
    #endif
}
`}get uniformsDef(){return{...super.uniformsDef,batchIndex:0}}onBeforeRender(e,t,n,i,r){this.defines&&this.defines.USE_RTE&&(r.modelViewMatrix.copy(e.RTEBuffers.rteViewModelMatrix),this.userData.uViewer_low.value.copy(e.RTEBuffers.viewerLow),this.userData.uViewer_high.value.copy(e.RTEBuffers.viewerHigh),this.userData.rteModelViewMatrix.value.copy(e.RTEBuffers.rteViewModelMatrix),this.needsUpdate=!0),(r instanceof qp||r instanceof TA)&&(this.userData.batchIndex.value=r.batchIndex,this.needsUpdate=!0)}}const jN={...LA};class pf extends WN{get displayName(){return"DEPTH-NORMAL-ID"}get idTexture(){return this.mrt.texture[2]}set options(e){super.options=e}constructor(){super(),this._options=Object.assign({},jN),this.mrt=Wc.createMultipleRenderTarget(3,{minFilter:wn,magFilter:wn}),this.mrtMaterial=new qN({depthPacking:Ko},["ALPHATEST_REJECTION"]),this.mrtMaterial.blending=ui,this.mrtMaterial.side=Qt,this.depthType=this._options.depthType}}class QN extends xA{get vertexProgram(){return`
#define NORMAL
#ifdef USE_RTE
    // The high component is stored as the default 'position' attribute buffer
    attribute vec3 position_low;
    uniform vec3 uViewer_high;
    uniform vec3 uViewer_low;
#endif

#ifdef TRANSFORM_STORAGE
    attribute float objIndex;

    #if TRANSFORM_STORAGE == 0
        #if __VERSION__ == 300
            #define TRANSFORM_STRIDE 4
        #else
            #define TRANSFORM_STRIDE 4.
        #endif
        uniform sampler2D tTransforms;
        uniform float objCount;
    #elif TRANSFORM_STORAGE == 1
        uniform mat4 uTransforms[OBJ_COUNT];
    #endif
#endif

#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

#ifdef USE_RTE
    highp vec4 computeRelativePosition(in highp vec3 position_low, in highp vec3 position_high, in highp vec3 relativeTo_low, in highp vec3 relativeTo_high){
        /* 
        Source https://github.com/virtualglobebook/OpenGlobe/blob/master/Source/Examples/Chapter05/Jitter/GPURelativeToEyeDSFUN90/Shaders/VS.glsl 
        Note here, we're storing the high part of the position encoding inside three's default 'position' attribute buffer so we avoid redundancy 
        */
        highp vec3 t1 = position_low.xyz - relativeTo_low.xyz;
        highp vec3 e = t1 - position_low.xyz;
        /** This is redunant, but necessary as a workaround for Apple platforms */
        highp float x = position_high.x - relativeTo_high.x;
        highp float y = position_high.y - relativeTo_high.y;
        highp float z = position_high.z - relativeTo_high.z;
        highp vec3 v = vec3(x, y, z);
        /** End of redundant part */
        highp vec3 t2 = ((-relativeTo_low - e) + (position_low.xyz - (t1 - e))) + v;
        highp vec3 highDifference = t1 + t2;
        highp vec3 lowDifference = t2 - (highDifference.xyz - t1.xyz);
        
        highp vec3 position = highDifference.xyz + lowDifference.xyz;
        return vec4(position, 1.);
    }
#endif

#ifdef TRANSFORM_STORAGE
    void objectTransform(out vec4 quaternion, out vec4 pivotLow, out vec4 pivotHigh, out vec4 translation, out vec4 scale){
        #if TRANSFORM_STORAGE == 0
            #if __VERSION__ == 300
                ivec2 uv = ivec2(int(objIndex) * TRANSFORM_STRIDE, 0); 
                vec4 v0 = texelFetch( tTransforms, uv, 0 );
                vec4 v1 = texelFetch( tTransforms, uv + ivec2(1, 0), 0);
                vec4 v2 = texelFetch( tTransforms, uv + ivec2(2, 0), 0);
                vec4 v3 = texelFetch( tTransforms, uv + ivec2(3, 0), 0);
                quaternion = v0;
                pivotLow = vec4(v1.xyz, 1.);
                pivotHigh = vec4(v2.xyz, 1.);
                translation = vec4(v3.xyz, 1.);
                scale = vec4(v1.w, v2.w, v3.w, 1.);
            #else
                float size = objCount * TRANSFORM_STRIDE;
                vec2 cUv = vec2(0.5/size, 0.5);
                vec2 dUv = vec2(1./size, 0.);
                
                vec2 uv = vec2((objIndex * TRANSFORM_STRIDE)/size + cUv.x, cUv.y);
                vec4 v0 = texture2D( tTransforms, uv);
                vec4 v1 = texture2D( tTransforms, uv + dUv);
                vec4 v2 = texture2D( tTransforms, uv + 2. * dUv);
                vec4 v3 = texture2D( tTransforms, uv + 3. * dUv);
                quaternion = v0;
                pivotLow = vec4(v1.xyz, 1.);
                pivotHigh = vec4(v2.xyz, 1.);
                translation = vec4(v3.xyz, 1.);
                scale = vec4(v1.w, v2.w, v3.w, 1.);
            #endif
        #elif TRANSFORM_STORAGE == 1
            mat4 tMatrix = uTransforms[int(objIndex)];
            quaternion = tMatrix[0];
            pivotLow = vec4(tMatrix[1].xyz, 1.);
            pivotHigh = vec4(tMatrix[2].xyz, 1.);
            translation = vec4(tMatrix[3].xyz, 1.);
            scale = vec4(tMatrix[1][3], tMatrix[2][3], tMatrix[3][3], 1.);
        #endif
    }

    vec3 rotate_vertex_position(vec3 position, vec4 quat)
    { 
        return position + 2.0 * cross(quat.xyz, cross(quat.xyz, position) + quat.w * position);
    }

    /** Another workaround for Apple's stupid compiler */
    vec4 safeMul(vec4 a, vec4 b) {
        // Prevents constant folding and optimization
        return (a + vec4(0.0)) * (b + vec4(1.0)) - a * vec4(1.0);
    }

    highp vec3 rotate_scaled_vertex_position_delta(highp vec4 v0, highp vec4 v1, highp vec4 scale, highp vec4 quat)
    {
        /** !!! WORKAROUND FOR Intel IrisXe CARDS !!! */
        /** The code below will not produce correct results in intel IrisXE integrated GPUs. 
         *  The geometry will turn mangled, albeit stable
         *  I can't know for sure what is going on, but rotating the difference seems to 
         *  force the result into a lower precision?
         */
        // highp vec4 position = v0 - v1;
        // return position.xyz + 2.0 * cross(quat.xyz, cross(quat.xyz, position.xyz) + quat.w * position.xyz);

        /** Subtracting the rotated vectors works. */
        return rotate_vertex_position(safeMul(v0, scale).xyz, quat)  - rotate_vertex_position(safeMul(v1, scale).xyz, quat) ;

        /** An alternate workaround is
         * highp vec3 position = (v0.xyz * (1. + 1e-7)) - (v1.xyz * (1. + 1e-7));
           return position + 2.0 * cross(quat.xyz, cross(quat.xyz, position) + quat.w * position);

           However I'm not such a fan of the (1. + 1e-7) part
         */
    }

#endif

void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
    //#include <project_vertex> // EDITED CHUNK
   #ifdef TRANSFORM_STORAGE
        vec4 tQuaternion, tPivotLow, tPivotHigh, tTranslation, tScale;
        objectTransform(tQuaternion, tPivotLow, tPivotHigh, tTranslation, tScale);
    #endif
    #ifdef USE_RTE
        vec4 position_lowT = vec4(position_low, 1.);
        vec4 position_highT = vec4(position, 1.);
        const vec3 ZERO3 = vec3(0., 0., 0.);

        highp vec4 rteLocalPosition = computeRelativePosition(position_lowT.xyz, position_highT.xyz, uViewer_low, uViewer_high);
        #ifdef TRANSFORM_STORAGE
            highp vec4 rtePivot = computeRelativePosition(tPivotLow.xyz, tPivotHigh.xyz, uViewer_low, uViewer_high);
            rteLocalPosition.xyz = rotate_scaled_vertex_position_delta(rteLocalPosition, rtePivot, tScale, tQuaternion) + rtePivot.xyz + tTranslation.xyz;
        #endif
        #ifdef USE_INSTANCING
            vec4 instancePivot = computeRelativePosition(ZERO3, ZERO3, uViewer_low, uViewer_high);
            rteLocalPosition.xyz = (mat3(instanceMatrix) * (rteLocalPosition - instancePivot).xyz) + instancePivot.xyz + instanceMatrix[3].xyz;
        #endif
    #endif

    #ifdef USE_RTE
        vec4 mvPosition = rteLocalPosition;
    #else
        vec4 mvPosition = vec4( transformed, 1.0 );
        #ifdef TRANSFORM_STORAGE
            mvPosition.xyz = rotate_scaled_vertex_position_delta(mvPosition, tPivotHigh, tScale, tQuaternion) + tPivotHigh.xyz + tTranslation.xyz;
        #endif
        #ifdef USE_INSTANCING
            mvPosition = instanceMatrix * mvPosition;
        #endif
    #endif

    mvPosition = modelViewMatrix * mvPosition;

    gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
    #if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	    vViewPosition = - mvPosition.xyz;
    #endif
}
`}get fragmentProgram(){return`
#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}
`}get baseUniforms(){return Xn.normal.uniforms}get uniformsDef(){return{uViewer_high:new T,uViewer_low:new T,uTransforms:[new Ne],tTransforms:null}}constructor(e,t=[]){super(e),this.init(t)}customProgramCacheKey(){return this.constructor.name}copy(e){return super.copy(e),this.copyFrom(e),this}onBeforeRender(e,t,n,i,r){this.defines&&this.defines.USE_RTE&&(r.modelViewMatrix.copy(e.RTEBuffers.rteViewModelMatrix),this.userData.uViewer_low.value.copy(e.RTEBuffers.viewerLow),this.userData.uViewer_high.value.copy(e.RTEBuffers.viewerHigh),this.needsUpdate=!0)}}class sS extends Go{get displayName(){return"GEOMETRY-NORMALS"}get overrideMaterial(){return this.normalsMaterial}constructor(){super(),this._outputTarget=Wc.createRenderTarget({minFilter:wn,magFilter:wn}),this.normalsMaterial=new QN({}),this.normalsMaterial.blending=ui,this.normalsMaterial.side=Qt}}const XN={outlineThickness:1,outlineOpacity:.75,outlineColor:3289650};class JN extends yp{constructor(e,t=XN){super(e,t),e.renderer.capabilities.isWebGL2||e.renderer.context.getExtension("WEBGL_draw_buffers")!==null?this.MRTPipeline(t):this.SRTPipeline(t)}MRTPipeline(e){var t,n,i;const r=new pf;r.setLayers([vt.STREAM_CONTENT_MESH]),r.setJitter(!0),r.setClearColor(0,1),r.setClearFlags(ai.COLOR|ai.DEPTH),r.setVisibility(Un.DEPTH);const a=new pf;a.setLayers([vt.STREAM_CONTENT_MESH]),a.setJitter(!0),a.setVisibility(Un.TRANSPARENT),a.outputTarget=r.outputTarget;const o=new pf;o.setLayers([vt.STREAM_CONTENT_MESH]),o.setClearColor(0,1),o.setClearFlags(ai.COLOR|ai.DEPTH),o.setVisibility(Un.DEPTH);const l=new pf;l.setLayers([vt.STREAM_CONTENT_MESH]),l.setVisibility(Un.TRANSPARENT),l.outputTarget=o.outputTarget;const c=new ff;c.setTexture("tDepth",r.depthTexture),c.setTexture("tNormal",r.normalTexture),c.setTexture("tId",r.idTexture),c.options=e;const u=new ff;u.setTexture("tDepth",o.depthTexture),u.setTexture("tNormal",o.normalTexture),u.setTexture("tId",o.idTexture),u.options=e;const h=new rS;h.inputTexture=(t=c.outputTarget)===null||t===void 0?void 0:t.texture,h.accumulationFrames=this.accumulationFrameCount,this.dynamicStage.push(o,l,u),this.progressiveStage.push(r,a,c,h),this.passList=this.dynamicStage,this.depthPass=r,this.depthPassDynamic=o,this.edgePass=c,this.edgePassDynamic=u,this.outputTexture=(n=h.outputTarget)===null||n===void 0?void 0:n.texture,this.outputTextureDynamic=(i=u.outputTarget)===null||i===void 0?void 0:i.texture}SRTPipeline(e){var t,n,i,r,a,o,l;const c=new Tv;c.setLayers([vt.STREAM_CONTENT_MESH]),c.setVisibility(Un.DEPTH),c.setJitter(!0),c.setClearColor(0,1),c.setClearFlags(ai.COLOR|ai.DEPTH);const u=new sS;u.setLayers([vt.STREAM_CONTENT_MESH]),u.setVisibility(Un.OPAQUE),u.setJitter(!0),u.setClearColor(0,1),u.setClearFlags(ai.COLOR|ai.DEPTH);const h=new Tv;h.setLayers([vt.STREAM_CONTENT_MESH]),h.setVisibility(Un.DEPTH),h.setClearColor(0,1),h.setClearFlags(ai.COLOR|ai.DEPTH);const d=new sS;d.setLayers([vt.STREAM_CONTENT_MESH]),d.setVisibility(Un.OPAQUE),d.setClearColor(0,1),d.setClearFlags(ai.COLOR|ai.DEPTH);const f=new ff;f.setTexture("tDepth",(t=c.outputTarget)===null||t===void 0?void 0:t.texture),f.setTexture("tNormal",(n=u.outputTarget)===null||n===void 0?void 0:n.texture),f.options=e;const v=new ff;v.setTexture("tDepth",(i=h.outputTarget)===null||i===void 0?void 0:i.texture),v.setTexture("tNormal",(r=d.outputTarget)===null||r===void 0?void 0:r.texture),v.options=e;const g=new rS;g.inputTexture=(a=f.outputTarget)===null||a===void 0?void 0:a.texture,g.accumulationFrames=this.accumulationFrameCount,this.dynamicStage.push(h,d,v),this.progressiveStage.push(c,u,f,g),this.passList=this.dynamicStage,this.depthPass=c,this.depthPassDynamic=h,this.edgePass=f,this.edgePassDynamic=v,this.outputTexture=(o=g.outputTarget)===null||o===void 0?void 0:o.texture,this.outputTextureDynamic=(l=v.outputTarget)===null||l===void 0?void 0:l.texture}}class KN extends yp{constructor(e,t=RA){var n,i;super(e);const r=t.edges?new JN(e):null,a=t.edges?null:new Tv;a&&(a.setLayers([vt.STREAM_CONTENT_MESH]),a.setVisibility(Un.DEPTH),a.setJitter(!0),a.setClearColor(0,1),a.setClearFlags(ai.COLOR|ai.DEPTH));const o=t.edges?r==null?void 0:r.depthPass.depthTexture:(n=a==null?void 0:a.outputTarget)===null||n===void 0?void 0:n.texture,l=(t.edges?r==null?void 0:r.dynamicPasses:[])||[],c=(t.edges?r==null?void 0:r.progressivePasses:a?[a]:[])||[],u=new Go;u.setLayers([vt.STREAM_CONTENT,vt.STREAM_CONTENT_MESH,vt.STREAM_CONTENT_LINE,vt.STREAM_CONTENT_POINT,vt.STREAM_CONTENT_POINT_CLOUD,vt.STREAM_CONTENT_TEXT,vt.PROPS]),u.setVisibility(Un.OPAQUE);const h=new Go;h.setLayers([vt.STREAM_CONTENT,vt.STREAM_CONTENT_MESH,vt.STREAM_CONTENT_LINE,vt.STREAM_CONTENT_POINT,vt.STREAM_CONTENT_POINT_CLOUD,vt.STREAM_CONTENT_TEXT,vt.SHADOWCATCHER]),h.setVisibility(Un.TRANSPARENT);const d=new _N;d.setTexture("tDepth",o),d.accumulationFrames=this.accumulationFrameCount,d.setClearColor(16777215,1);const f=new iS;f.options={blendAO:!0,blendEdges:t.edges},f.setTexture("tAo",(i=d.outputTarget)===null||i===void 0?void 0:i.texture),f.setTexture("tEdges",t.edges?r==null?void 0:r.outputTexture:void 0),f.accumulationFrames=this.accumulationFrameCount;const v=new iS;v.options={blendAO:!1,blendEdges:t.edges},v.setTexture("tEdges",t.edges?r==null?void 0:r.outputTextureDynamic:void 0),v.accumulationFrames=this.accumulationFrameCount;const g=new GN;g.setVisibility(Un.STENCIL),g.setLayers([vt.STREAM_CONTENT_MESH]);const m=new HN;m.setVisibility(Un.STENCIL),m.setLayers([vt.STREAM_CONTENT_MESH]),m.setClearFlags(ai.DEPTH);const x=new Go;x.setLayers([vt.OVERLAY,vt.MEASUREMENTS]),this.dynamicStage.push(...l,g,u,h,...t.edges?[v]:[],m,x),this.progressiveStage.push(...c,g,u,h,m,d,f,x),this.passthroughStage.push(g,u,h,m,f,x),this.passList=this.dynamicStage}}const Bl=new T,Ol=new Tt;Ki.prototype.isEmpty=function(){return this.halfSize.length()===0},Ki.prototype.equals=function(s,e=1e-6){if(Bl.copy(this.center),Bl.sub(s.center),Bl.length()>e||(Bl.copy(this.halfSize),Bl.sub(s.halfSize),Bl.length()>e))return!1;for(let t=0;t<9;t++)if(Math.abs(this.rotation.elements[t]-s.rotation.elements[t])>e)return!1;return!0},Ki.prototype._min=new T,Ki.prototype._max=new T,Object.defineProperty(Ki.prototype,"min",{get(){return new T().copy(this.center).sub(this.halfSize)},set(s){this._min.copy(s),Ol.set(s,this._max),Ol.getCenter(this.center),Ol.getSize(this.halfSize),this.halfSize.multiplyScalar(.5)},enumerable:!0,configurable:!0}),Object.defineProperty(Ki.prototype,"max",{get(){return new T().copy(this.center).add(this.halfSize)},set(s){this._max.copy(s),Ol.set(this._min,s),Ol.getCenter(this.center),Ol.getSize(this.halfSize),this.halfSize.multiplyScalar(.5)},enumerable:!0,configurable:!0}),Tt.prototype.fromOBB=function(s){const{center:e,halfSize:t,rotation:n}=s,i=[new T(-t.x,-t.y,-t.z),new T(-t.x,-t.y,t.z),new T(-t.x,t.y,-t.z),new T(-t.x,t.y,t.z),new T(t.x,-t.y,-t.z),new T(t.x,-t.y,t.z),new T(t.x,t.y,-t.z),new T(t.x,t.y,t.z)].map(r=>r.applyMatrix3(n).add(e));return new Tt().setFromPoints(i)},Tt.prototype.intersectOBB=function(s){const e=[new T(this.min.x,this.min.y,this.min.z),new T(this.min.x,this.min.y,this.max.z),new T(this.min.x,this.max.y,this.min.z),new T(this.min.x,this.max.y,this.max.z),new T(this.max.x,this.min.y,this.min.z),new T(this.max.x,this.min.y,this.max.z),new T(this.max.x,this.max.y,this.min.z),new T(this.max.x,this.max.y,this.max.z)],t=new Hn().copy(s.rotation).invert(),n=e.map(c=>c.clone().sub(s.center).applyMatrix3(t)),i=[];for(const c of n)Math.abs(c.x)<=s.halfSize.x&&Math.abs(c.y)<=s.halfSize.y&&Math.abs(c.z)<=s.halfSize.z&&i.push(c);if(i.length===0)return null;const r=new T;i.forEach(c=>r.add(c)),r.divideScalar(i.length);const a=[new T,new T,new T];s.rotation.extractBasis(a[0],a[1],a[2]);const o=new T;for(const c of i)for(let u=0;u<3;u++){const h=c.clone().sub(r).dot(a[u]);o.setComponent(u,Math.max(o.getComponent(u),Math.abs(h)))}const l=r.applyMatrix3(s.rotation).add(s.center);return new Ki(l,o,s.rotation.clone())};class YN{constructor(){this.renderTimeAcc=0,this.renderTimeSamples=0,this.renderTimeMaxSamples=500,this.renderTimeStart=0,this.renderTime=0,this.objects=0,this.batchCount=0,this.drawCalls=0,this.trisCount=0,this.vertCount=0}frameStart(){this.renderTimeStart=performance.now()}frameEnd(){this.renderTimeAcc+=performance.now()-this.renderTimeStart,this.renderTimeSamples++,this.renderTimeSamples%this.renderTimeMaxSamples==0&&(this.renderTime=this.renderTimeAcc/this.renderTimeSamples,this.renderTimeSamples=0,this.renderTimeAcc=0)}}class ZN{get renderer(){return this._renderer}set needsRender(e){this._needsRender||(this._needsRender=e)}set shadowMapNeedsUpdate(e){this._renderer.shadowMap.needsUpdate=e}get sceneBox(){const e=new Tt,t=this.batcher.getBatches();for(let n=0;n<t.length;n++)e.union(t[n].bounds);return e}get sceneSphere(){return this.sceneBox.getBoundingSphere(new Zn)}get sceneCenter(){return this.sceneBox.getCenter(new T)}get clippingVolume(){return!this._clippingVolume.isEmpty()&&this._renderer.localClippingEnabled?this._clippingVolume:new Ki().fromBox3(this.sceneBox)}set clippingVolume(e){this.sceneBox&&(e instanceof Tt?this._clippingVolume=new Ki().fromBox3(this.sceneBox.intersect(e)):e instanceof Ki?this._clippingVolume=new Ki().copy(e):dt.error(`Incorrect clipping volume set: ${e}. Required Box3 or OBB`))}get clippingPlanes(){return this._clippingPlanes}set clippingPlanes(e){this._clippingPlanes=e.map(t=>new vi().copy(t)),this.updateClippingPlanes(),this.renderer.shadowMap.needsUpdate=!0,this.needsRender=!0,this.resetPipeline()}get allObjects(){return this._scene.getObjectByName("ContentGroup")}get scene(){return this._scene}get sunLight(){return this.sun}set indirectIBL(e){this._scene.environment=e}set indirectIBLIntensity(e){const t=this.batcher.getBatches(void 0,mt.MESH);for(let n=0;n<t.length;n++){const i=t[n].materials;for(let r=0;r<i.length;r++)i[r].envMapIntensity=e}}get speckleCamera(){return this._speckleCamera}set speckleCamera(e){this._speckleCamera=e,this._speckleCamera.on(Tr.Dynamic,()=>{this._needsRender=!0,this._pipeline instanceof yp&&this._pipeline.onStationaryEnd()}),this._speckleCamera.on(Tr.Stationary,()=>{this._needsRender=!0,this._pipeline instanceof yp&&this._pipeline.onStationaryBegin()}),this._speckleCamera.on(Tr.FrameUpdate,t=>{this.needsRender=t})}get renderingCamera(){return this._speckleCamera?this._speckleCamera.renderingCamera:null}set pipeline(e){this._pipeline=e,this._pipeline.setClippingPlanes(this._clippingPlanes),this._pipeline.reset(),this.resize()}get pipeline(){return this._pipeline}get shadowcatcher(){return this._shadowcatcher}get intersections(){return this._intersections}get renderingStats(){const e=Object.values(this.batcher.batches);return this._renderinStats.objects=e.reduce((t,n)=>t+n.renderViews.length,0),this._renderinStats.batchCount=e.length,this._renderinStats.drawCalls=e.reduce((t,n)=>t+n.drawCalls,0),this._renderinStats.trisCount=e.reduce((t,n)=>t+n.triCount,0),this._renderinStats.vertCount=e.reduce((t,n)=>t+n.vertCount,0),this._renderinStats.batchDetails=e.map(t=>({type:t.constructor.name,objCount:t.renderViews.length,drawCalls:t.drawCalls,minDrawCalls:t.minDrawCalls,tris:t.triCount,verts:t.vertCount})),this._renderinStats}constructor(e,t){this.SHOW_HELPERS=!1,this.IGNORE_ZERO_OPACITY_OBJECTS=!0,this.SHOW_BVH=!1,this._speckleCamera=null,this.sunConfiguration=AN,this.cancel={},this._clippingPlanes=[],this._clippingVolume=new Ki,this._renderOverride=null,this.tree=e,this._renderinStats=new YN,this._scene=new _v,this.rootGroup=new Er,this.rootGroup.name="ContentGroup",this.rootGroup.layers.set(vt.STREAM_CONTENT),this._scene.add(this.rootGroup),this._intersections=new CA,this.viewer=t}create(e){if(this._renderer=new UN({antialias:!0,alpha:!0,preserveDrawingBuffer:!0,stencil:!0}),this._renderer.setClearColor(16777215,0),this._renderer.setPixelRatio(window.devicePixelRatio),this._renderer.outputEncoding=Wt,this._renderer.toneMapping=IS,this._renderer.toneMappingExposure=.5,this._renderer.shadowMap.enabled=!0,this._renderer.shadowMap.type=_l,this._renderer.shadowMap.autoUpdate=!1,this._renderer.shadowMap.needsUpdate=!0,this._renderer.physicallyCorrectLights=!0,this._renderer.autoClear=!1,this._renderer.autoClearColor=!1,this._renderer.autoClearDepth=!1,this._renderer.autoClearStencil=!1,this.container=e,this._renderer.setSize(e.offsetWidth,e.offsetHeight),e.appendChild(this._renderer.domElement),this.batcher=new BN(this.renderer.capabilities),this._pipeline=new KN(this),this.input=new Mc(this._renderer.domElement),this.input.on(Di.Click,this.onClick.bind(this)),this.input.on(Di.DoubleClick,this.onDoubleClick.bind(this)),this.addDirectLights(),this.SHOW_HELPERS){const i=new Er;i.name="Helpers",this._scene.add(i);const r=new QI(this.sun,50,16711680);r.name="DirLightHelper",r.layers.set(vt.PROPS),i.add(r);const a=new zb(this.sun.shadow.camera);a.name="CamHelper",a.layers.set(vt.PROPS),i.add(a)}let t,n;this._shadowcatcher=new as(vt.SHADOWCATCHER,[vt.STREAM_CONTENT_MESH]),this._shadowcatcher.shadowcatcherPass.onBeforeRender=()=>{t=this.batcher.saveVisiblity(),n=this.batcher.getOpaque(),this.batcher.applyVisibility(n),this.batcher.overrideMaterial(n,this._shadowcatcher.shadowcatcherPass.drawDepthMaterial)},this._shadowcatcher.shadowcatcherPass.onAfterRender=()=>{this.batcher.applyVisibility(t),this.batcher.restoreMaterial(n)},this._scene.add(this._shadowcatcher.shadowcatcherMesh)}update(e){this.renderingCamera&&(this.batcher.update(e),this.renderingCamera.updateMatrixWorld(!0),this._renderer.updateRTEViewModel(this.renderingCamera),this.updateRTEShadows(),this.updateTransforms(),this._pipeline.update(this.renderingCamera),this.sunConfiguration.shadowcatcher&&this._shadowcatcher&&this._shadowcatcher.update(this._scene))}updateRTEShadowBuffers(){return!!this._renderer.shadowMap.needsUpdate&&(this._renderer.RTEBuffers.shadowViewer.set(this.sun.shadow.camera.matrixWorld.elements[12],this.sun.shadow.camera.matrixWorld.elements[13],this.sun.shadow.camera.matrixWorld.elements[14]),hn.DoubleToHighLowVector(this._renderer.RTEBuffers.shadowViewer,this._renderer.RTEBuffers.shadowViewerLow,this._renderer.RTEBuffers.shadowViewerHigh),this._renderer.RTEBuffers.rteShadowViewModelMatrix.copy(this.sun.shadow.camera.matrixWorldInverse),this._renderer.RTEBuffers.rteShadowViewModelMatrix.elements[12]=0,this._renderer.RTEBuffers.rteShadowViewModelMatrix.elements[13]=0,this._renderer.RTEBuffers.rteShadowViewModelMatrix.elements[14]=0,this._renderer.RTEBuffers.rteShadowMatrix.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),this._renderer.RTEBuffers.rteShadowMatrix.multiply(this.sun.shadow.camera.projectionMatrix),this._renderer.RTEBuffers.rteShadowMatrix.multiply(this._renderer.RTEBuffers.rteShadowViewModelMatrix),!0)}updateRTEShadows(){if(!this.updateRTEShadowBuffers())return;const e=this.batcher.getBatches(void 0,mt.MESH);for(let t=0;t<e.length;t++)e[t].mesh.traverse(n=>{const i=n.customDepthMaterial;i&&(i.userData.uViewer_low.value.copy(this._renderer.RTEBuffers.shadowViewerLow),i.userData.uViewer_high.value.copy(this._renderer.RTEBuffers.shadowViewerHigh),i.userData.rteModelViewMatrix.value.copy(this._renderer.RTEBuffers.rteShadowViewModelMatrix),i.needsUpdate=!0)})}updateTransforms(){const e=this.batcher.getBatches(void 0,mt.MESH);for(let t=0;t<e.length;t++){const n=e[t].mesh;n.updateTransformsUniform(),n.traverse(i=>{const r=i.customDepthMaterial;r&&n.updateMaterialTransformsUniform(r)})}}resetPipeline(){this._needsRender=!0,this._pipeline.reset()}render(){this._renderOverride?this._renderOverride():this._speckleCamera&&this._needsRender&&(this._renderinStats.frameStart(),this.batcher.render(this.renderer),this._needsRender=this._pipeline.render(),this._renderinStats.frameEnd(),this.sunConfiguration.shadowcatcher&&this._shadowcatcher&&this._shadowcatcher.render(this._renderer))}resize(e,t){if(!e||!t){const i=this._renderer.getSize(new Me);e=i.x,t=i.y}e=Math.floor(e),t=Math.floor(t),this.renderer.setSize(e,t);const n=this._renderer.getPixelRatio();this._pipeline.resize(e*n,t*n),this._pipeline.reset(),this._needsRender=!0}async*addRenderTree(e){this.cancel[e.id]=!1;const t=new Er;t.name=e.id,t.layers.set(vt.STREAM_CONTENT),this.rootGroup.add(t);const n=this.batcher.makeBatches(this.tree,e,MN);let i=0,r=-1;this._renderOverride=()=>{i>r&&(this._pipeline.render(),r=i)};for await(const a of n)if(a){if(this.addBatch(a,t),a.geometryType===mt.MESH&&this.updateDirectLights(),this.cancel[e.id]){n.return(),this.removeRenderTree(e.id),delete this.cancel[e.id];break}i++,yield}this._renderOverride=null,this.updateHelpers(),this.updateShadowCatcher(!0),this.updateClippingPlanes(),this._speckleCamera&&this._speckleCamera.updateCameraPlanes(this.sceneBox),delete this.cancel[e.id]}addBatch(e,t){const n=e.renderObject;t.add(n);let i=!1;(n instanceof qp||n instanceof O0)&&(n.TAS.bvhHelper&&t.add(n.TAS.bvhHelper),i=n.needsRTE),e.geometryType===mt.MESH&&n.traverse(r=>{if(r instanceof gn){const a=Array.isArray(r.material)?r.material[0]:r.material;r.castShadow=!a.transparent,r.receiveShadow=!a.transparent,r.customDepthMaterial=new zh({depthPacking:Ko},i?["USE_RTE","ALPHATEST_REJECTION"]:["ALPHATEST_REJECTION"])}}),this.viewer.World.expandWorld(e.bounds)}removeRenderTree(e){this.rootGroup.remove(this.rootGroup.getObjectByName(e)),this.batcher.getBatches(e).forEach(t=>{this.viewer.World.reduceWorld(t.bounds)}),this.batcher.purgeBatches(e),this.updateDirectLights(),this.updateHelpers(),this.updateShadowCatcher(!0)}cancelRenderTree(e){this.cancel[e]!==void 0&&(this.cancel[e]=!0)}setMaterial(e,t){if(!t)return;const n={};for(let i=0;i<e.length;i++)e[i].batchId&&(n[e[i].batchId]||(n[e[i].batchId]=[]),n[e[i].batchId].includes(e[i])||n[e[i].batchId].push(e[i]));ln.isMaterialInstance(t)?this.setMaterialInstance(n,t):ln.isFilterMaterial(t)?this.setFilterMaterial(n,t):(ln.isRenderMaterial(t)||ln.isDisplayStyle(t))&&this.setDataMaterial(n,t)}setMaterialInstance(e,t){for(const n in e){const i=e[n].map(r=>({offset:r.batchStart,count:r.batchCount,material:t}));this.batcher.batches[n]&&this.batcher.batches[n].setDrawRanges(this.flattenDrawRanges(i))}}setFilterMaterial(e,t){for(const n in e){const i=e[n].map(r=>({offset:r.batchStart,count:r.batchCount,material:this.batcher.materials.getFilterMaterial(r,t),materialOptions:this.batcher.materials.getFilterMaterialOptions(t)}));this.batcher.batches[n]&&this.batcher.batches[n].setDrawRanges(this.flattenDrawRanges(i))}}setDataMaterial(e,t){for(const n in e){const i=e[n].map(r=>{const a=this.batcher.materials.getDataMaterial(r,t);return a.setMaterialOptions(t),{offset:r.batchStart,count:r.batchCount,material:a}});this.batcher.batches[n]&&this.batcher.batches[n].setDrawRanges(this.flattenDrawRanges(i))}}flattenDrawRanges(e){if(e.length<3)return e;const t=[];let n=(e=e.sort((r,a)=>r.offset-a.offset))[0].offset,i=0;for(let r=0;r<e.length-1;r++)i+=e[r].count,n+i!==e[r+1].offset?(t.push({offset:n,count:i,material:e[r].material,...e[r].materialOptions&&{materialOptions:e[r].materialOptions}}),n=e[r+1].offset,i=0,r===e.length-2&&t.push({offset:e[r+1].offset,count:e[r+1].count,material:e[r+1].material,...e[r].materialOptions&&{materialOptions:e[r].materialOptions}})):r===e.length-2&&t.push({offset:n,count:i+e[r+1].count,material:e[r].material,...e[r].materialOptions&&{materialOptions:e[r].materialOptions}});return t}getMaterial(e){var t,n;return e&&e.batchId&&(n=(t=this.batcher.getBatch(e))===null||t===void 0?void 0:t.getMaterial(e))!==null&&n!==void 0?n:null}getBatchMaterial(e){var t,n;return e&&e.batchId&&(n=(t=this.batcher.getBatch(e))===null||t===void 0?void 0:t.batchMaterial)!==null&&n!==void 0?n:null}resetMaterials(){this.batcher.resetBatchesDrawRanges()}getBatch(e){return this.batcher.batches[e]}updateClippingPlanes(){var e;if(!this.allObjects)return;const t=this._clippingPlanes;this.allObjects.traverse(n=>{const i=n.material;if(i)if(Array.isArray(i))for(let r=0;r<i.length;r++)i[r].clippingPlanes=t;else i.clippingPlanes=t}),this._pipeline.setClippingPlanes(t),(e=this._shadowcatcher)===null||e===void 0||e.updateClippingPlanes(t)}updateShadowCatcher(e=!1){this.sunConfiguration.shadowcatcher!==void 0&&(this._shadowcatcher.shadowcatcherMesh.visible=this.sunConfiguration.shadowcatcher),this.sunConfiguration.shadowcatcher&&(this._shadowcatcher.bake(new Tt().fromOBB(this.clippingVolume),this._renderer.capabilities.maxTextureSize,e),this.needsRender=!0)}addDirectLights(){this.sun=new Lb(16777215,5),this.sun.name="sun",this.sun.layers.set(vt.STREAM_CONTENT),this._scene.add(this.sun),this.sun.castShadow=!0,this.sun.shadow.mapSize.width=2048,this.sun.shadow.mapSize.height=2048,this.sun.shadow.camera.left=-50,this.sun.shadow.camera.right=50,this.sun.shadow.camera.top=50,this.sun.shadow.camera.bottom=-50,this.sun.shadow.camera.near=5,this.sun.shadow.camera.far=350,this.sun.shadow.bias=-.001,this.sun.shadow.radius=2,this.sunTarget=new fn,this._scene.add(this.sunTarget),this.sunTarget.position.copy(this.sceneCenter),this.sun.target=this.sunTarget}updateDirectLights(){const e=this.sunConfiguration.elevation,t=this.sunConfiguration.azimuth,n=this.sunConfiguration.radius||0;this.sunConfiguration.castShadow!==void 0&&(this.sun.castShadow=this.sunConfiguration.castShadow),this.sunConfiguration.intensity!==void 0&&(this.sun.intensity=this.sunConfiguration.intensity),this.sun.color=new ot(this.sunConfiguration.color),this.sunConfiguration.enabled!==void 0&&(this.sun.visible=this.sunConfiguration.enabled),this.sunTarget.position.copy(this.sceneCenter);const i=new vf(this.sceneSphere.radius+n,e,t);this.sun.position.setFromSpherical(i),this.sun.position.add(this.sunTarget.position),this.sun.updateWorldMatrix(!0,!0),this.sunTarget.updateMatrixWorld(),this.sun.shadow.updateMatrices(this.sun);const r=this.sceneBox,a=r.min,o=r.max,l=new T(a.x,a.y,a.z),c=new T(o.x,a.y,a.z),u=new T(a.x,o.y,a.z),h=new T(a.x,a.y,o.z),d=new T(o.x,o.y,a.z),f=new T(o.x,a.y,o.z),v=new T(a.x,o.y,o.z),g=new T(o.x,o.y,o.z);l.applyMatrix4(this.sun.shadow.camera.matrixWorldInverse),c.applyMatrix4(this.sun.shadow.camera.matrixWorldInverse),u.applyMatrix4(this.sun.shadow.camera.matrixWorldInverse),h.applyMatrix4(this.sun.shadow.camera.matrixWorldInverse),d.applyMatrix4(this.sun.shadow.camera.matrixWorldInverse),f.applyMatrix4(this.sun.shadow.camera.matrixWorldInverse),v.applyMatrix4(this.sun.shadow.camera.matrixWorldInverse),g.applyMatrix4(this.sun.shadow.camera.matrixWorldInverse);const m=new Tt().setFromPoints([l,c,u,h,d,f,v,g]);this.sun.shadow.camera.left=m.min.x,this.sun.shadow.camera.right=m.max.x,this.sun.shadow.camera.top=m.min.y,this.sun.shadow.camera.bottom=m.max.y,this.sun.shadow.camera.near=Math.abs(m.max.z),this.sun.shadow.camera.far=Math.abs(m.min.z),this.sun.shadow.camera.updateProjectionMatrix(),this.renderer.shadowMap.needsUpdate=!0,this.updateHelpers()}setSunLightConfiguration(e){Object.assign(this.sunConfiguration,e),e.indirectLightIntensity!==void 0&&(this.indirectIBLIntensity=e.indirectLightIntensity),this.updateDirectLights(),this.updateShadowCatcher(),this.viewer.emit(gi.LightConfigUpdated,{...e})}updateHelpers(){this.SHOW_HELPERS&&(this._scene.getObjectByName("CamHelper").update(),this._scene.getObjectByName("DirLightHelper").update())}queryHits(e){const t=[],n=[];for(let r=0;r<e.length;r++){const a=this.renderViewFromIntersection(e[r]);a&&(t.push(a),n.push(e[r].point))}if(t.length===0)return null;const i=[];for(let r=0;r<t.length;r++){const a=t[r].renderData.id,o=t[r].renderData.subtreeId,l=this.tree.findId(a,o);if(!l)continue;let c=l[0];for(;!c.model.atomic&&c.parent;)c=c.parent;i.push({node:c,point:n[r]})}return i}queryHitIds(e){var t;const n=[];for(let i=0;i<e.length;i++){let r=(t=e[i].batchObject)===null||t===void 0?void 0:t.renderView;if(!r){const a=e[i].faceIndex!==void 0?e[i].faceIndex:e[i].index;a&&(r=this.batcher.getRenderView(e[i].object.uuid,a))}r&&n.push({nodeId:r.renderData.id,point:e[i].point})}return n.length===0?null:n}renderViewFromIntersection(e){let t=null;if(e.batchObject){t=e.batchObject.renderView;const n=e.object.getBatchObjectMaterial(e.batchObject);if(n&&n.opacity===0&&this.IGNORE_ZERO_OPACITY_OBJECTS)return null}else{const n=e.faceIndex!==void 0&&e.faceIndex!==null?e.faceIndex:e.index!==void 0&&e.index!==null?e.index:void 0;if(n!==void 0&&(t=this.batcher.getRenderView(e.object.uuid,n),t)){const i=this.batcher.getRenderViewMaterial(e.object.uuid,n);if(i&&i.opacity===0&&this.IGNORE_ZERO_OPACITY_OBJECTS)return null}}return t}onClick(e){if(!this.renderingCamera)return;const t=this._intersections.intersect(this._scene,this.renderingCamera,e,void 0,!0,this.clippingVolume);if(!t)return void this.viewer.emit(gi.ObjectClicked,null);let n=!1;e.multiSelect&&(n=!0);const i=this.queryHits(t);if(!i)return void this.viewer.emit(gi.ObjectClicked,n?{multiple:!0,event:e.event}:null);const r={multiple:n,event:e.event,hits:i.map(a=>({node:a.node,point:a.point}))};this.viewer.emit(gi.ObjectClicked,r)}onDoubleClick(e){if(!this.renderingCamera)return;const t=this._intersections.intersect(this._scene,this.renderingCamera,e,void 0,!0,this.clippingVolume);if(!t)return void this.viewer.emit(gi.ObjectDoubleClicked,null);let n=!1;e.multiSelect&&(n=!0);const i=this.queryHits(t);if(!i)return void this.viewer.emit(gi.ObjectDoubleClicked,null);const r={multiple:n,hits:i.map(a=>({node:a.node,point:a.point}))};this.viewer.emit(gi.ObjectDoubleClicked,r)}boxFromObjects(e){let t=new Tt;const n=[];if(e.length>0)for(let i=0;i<e.length;i++){const r=this.tree.findId(e[i]);r&&r.forEach(a=>{n.push(...this.tree.getRenderTree().getRenderViewsForNode(a))})}else t=this.sceneBox;for(let i=0;i<n.length;i++){const r=this.getObject(n[i]),a=r?r.aabb:n[i].aabb;a&&t.union(a)}return t.getSize(new T).length()===0&&console.error("object selection resulted in empty box"),t}screenToNDC(e,t,n,i){const r=this._renderer.domElement,a=this.container.getBoundingClientRect(),o=n===void 0?(e-a.left)*r.width/a.width:e,l=i===void 0?(t-a.top)*r.height/a.height:t;return{x:o/(n===void 0?r.width:n)*2-1,y:l/(i===void 0?r.height:i)*-2+1}}NDCToScreen(e,t,n,i){const r=this._renderer.domElement;return{x:(.5*e+.5)*(n=n!==void 0?n:r.width),y:(-.5*t+.5)*(i=i!==void 0?i:r.height)}}debugShowBatches(){for(const e in this.batcher.batches){const t={id:"string",color:Math.floor(16777215*Math.random()),opacity:1,roughness:1,metalness:0,vertexColors:!1,lineWeight:1};this.setMaterial(this.batcher.batches[e].renderViews,t)}}getBatchIds(){const e=Object.values(this.batcher.batches);e.sort((n,i)=>n.renderViews.length-i.renderViews.length);const t=[];for(let n=0;n<e.length;n++)t.push(e[n].id);return t.reverse()}getBatchSize(e){return this.batcher.batches[e].renderViews.length}isolateBatch(e){this.batcher.resetBatchesDrawRanges(),this.batcher.isolateBatch(e)}getObjects(){return this.batcher.getBatches(void 0,mt.MESH).map(e=>e.mesh).flatMap(e=>e.batchObjects)}getObject(e){const t=this.batcher.getBatch(e);return t&&t.geometryType===mt.MESH?t.mesh.batchObjects.find(n=>n.renderView.guid===e.guid):null}enableLayers(e,t){this._pipeline.passes.forEach(n=>{n instanceof Hc&&e.forEach(i=>{n.enableLayer(i,t)})})}}const BA=function(s){const e={};for(const t in s){if(t==="id"||t==="__closure"||t==="__parents"||t==="bbox"||t==="totalChildrenCount")continue;const n=s[t];if(n==null||Array.isArray(n))continue;if(n.constructor===Object){const r=BA(n);for(const a in r)e[t+"."+a]=r[a];continue}const i=typeof n;i!=="string"&&i!=="number"&&i!=="boolean"||(e[t]=n)}return s.id&&(e.id=s.id),e};class $N{constructor(){this.propCache={}}async getProperties(e,t=null,n=!1){let i=e.root;if(!n&&this.propCache[t||i.model.id])return this.propCache[t||i.model.id];if(t){const o=i.children.find(l=>l.model.id===t);if(!o)throw new Error(`Could not find root node for ${t} - is it loaded?`);i=o}const r={};await e.walkAsync(o=>{if(!o.model.atomic)return!0;const l=BA(o.model.raw);for(const c in l)Array.isArray(l[c])||(r[c]||(r[c]=[]),r[c].push({value:l[c],id:l.id}));return!0},i);const a=[];for(const o in r){const l=r[o],c={};if(c.key=o,c.type=typeof l[0].value=="string"?"string":"number",c.objectCount=l.length,c.type==="string"){const u=c,h={};for(const{value:d,id:f}of l)h[d]||(h[d]=[]),h[d].push(f);u.valueGroups=[];for(const d in h)u.valueGroups.push({value:d,ids:h[d]});u.valueGroups=u.valueGroups.sort((d,f)=>d.value.localeCompare(f.value))}if(c.type==="number"){const u=c;u.min=Number.MAX_VALUE,u.max=Number.MIN_VALUE;for(const{value:h}of l)h<u.min&&(u.min=h),h>u.max&&(u.max=h);u.valueGroups=l.sort((h,d)=>h.value-d.value)}a.push(c)}return this.propCache[i.model.id]=a,a}}const aS=new bh,Nl=new T;class Ea{static isPointQuery(e){return e.operation==="Project"||e.operation==="Unproject"}static isIntersectionQuery(e){return e.operation==="Occlusion"||e.operation==="Pick"}}Ea.DefaultPointQuerySolver=new class{setContext(s){this.renderer=s}solve(s){switch(s.operation){case"Project":return this.solveProjection(s);case"Unproject":return this.solveUnprojection(s);default:return dt.error("Malformed query"),null}}solveProjection(s){const e=new T(s.point.x,s.point.y,s.point.z);let t=!1;return this.renderer.renderingCamera?(Nl.copy(e),Nl.applyMatrix4(this.renderer.renderingCamera.matrixWorldInverse),t=aS.setFromProjectionMatrix(this.renderer.renderingCamera.projectionMatrix).containsPoint(Nl),e.project(this.renderer.renderingCamera)):dt.error("Could not run query. Camera is null"),{x:e.x,y:e.y,z:e.z,inFrustum:t}}solveUnprojection(s){let e=!1;const t=new T(s.point.x,s.point.y,s.point.z);return this.renderer.renderingCamera?(t.unproject(this.renderer.renderingCamera),Nl.copy(t),Nl.applyMatrix4(this.renderer.renderingCamera.matrixWorldInverse),e=aS.setFromProjectionMatrix(this.renderer.renderingCamera.projectionMatrix).containsPoint(Nl)):dt.error("Could not run query. Camera is null"),{x:t.x,y:t.y,z:t.z,inFrustum:e}}},Ea.DefaultIntersectionQuerySolver=new class{constructor(){this.vecBuff0=new T,this.vecBuff1=new T}setContext(s){this.renderer=s}solve(s){switch(s.operation){case"Occlusion":return this.solveOcclusion(s);case"Pick":return this.solvePick(s);default:return dt.error("Malformed query"),null}}solveOcclusion(s){if(!this.renderer.renderingCamera)return{objects:null};const e=this.vecBuff0.set(s.point.x,s.point.y,s.point.z||0),t=this.vecBuff1.copy(e).sub(this.renderer.renderingCamera.position);t.normalize();const n=new Ti(this.renderer.renderingCamera.position,t),i=this.renderer.intersections.intersectRay(this.renderer.scene,this.renderer.renderingCamera,n,vt.STREAM_CONTENT_MESH,!0,this.renderer.clippingVolume);if(!i||i.length===0)return{objects:null};const r=this.renderer.queryHitIds(i);if(!r)return{objects:null};let a=this.renderer.renderingCamera.position.distanceTo(e);return a-=s.tolerance!==void 0?s.tolerance:0,a<i[0].distance?{objects:null}:{objects:[{guid:r[0].nodeId,point:r[0].point}]}}solvePick(s){if(!this.renderer.renderingCamera)return null;const e=this.renderer.intersections.intersect(this.renderer.scene,this.renderer.renderingCamera,new Me(s.point.x,s.point.y),void 0,!0,this.renderer.clippingVolume);if(!e)return null;const t=this.renderer.queryHits(e);return t?{objects:t.map(n=>({guid:n.node.model.id,object:n.node.model.raw,point:n.point}))}:null}};class Qp extends Nh{get inject(){return[]}get enabled(){return this._enabled}set enabled(e){this._enabled=e}constructor(e,...t){super(),this._enabled=!1,this.viewer=e}onEarlyUpdate(e){}onLateUpdate(e){}onRender(){}onResize(){}}/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const OA=10*Oh.second;class ts{constructor(e=50){this.velocity=0,this.naturalFrequency=0,this.setDecayTime(e)}setDecayTime(e){this.naturalFrequency=1/Math.max(.001,e)}update(e,t,n,i){const r=2e-4*this.naturalFrequency;if(e===null||i===0||e===t&&this.velocity===0)return t;if(n<0)return e;const a=e-t,o=this.velocity+this.naturalFrequency*a,l=a+n*o,c=Math.exp(-this.naturalFrequency*n),u=(o-this.naturalFrequency*l)*c,h=-this.naturalFrequency*(u+o*c);return Math.abs(u)<r*Math.abs(i)&&h*a>=0?(this.velocity=0,t):(this.velocity=u,t+l*c)}}class NA extends Nh{constructor(){super(...arguments),this._up=new T(0,1,0),this._minDist=0}get up(){return this._up}set up(e){this._up.copy(e)}get minDist(){return this._minDist}set minDist(e){this._minDist=e}}/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */Oh.second;class Og{constructor(e=50){this.velocity=0,this.naturalFrequency=0,this.setDecayTime(e)}setDecayTime(e){this.naturalFrequency=1/Math.max(.001,e)}wrapAngle(e){const t=2*Math.PI;return((e+Math.PI)%t+t)%t-Math.PI}update(e,t,n,i){const r=2e-4*this.naturalFrequency;if(e===null||i===0||e===t&&this.velocity===0)return t;if(n<0)return e;const a=this.wrapAngle(e-t),o=this.velocity+this.naturalFrequency*a,l=a+n*o,c=Math.exp(-this.naturalFrequency*n),u=(o-this.naturalFrequency*l)*c,h=-this.naturalFrequency*(u+o*c);return Math.abs(u)<r*Math.abs(i)&&h*a>=0?(this.velocity=0,t):(this.velocity=u,t+l*c)}}const wo=new T,ez={type:"change"},oS=Math.PI/2;class lS extends NA{get enabled(){return this._enabled}set enabled(e){this._enabled=e}get options(){return this._options}set options(e){Object.assign(this._options,e),e.moveSpeed&&console.warn("Fly speed modifier: ",this._options.moveSpeed),this.setDamperDecayTime(this._options.damperDecay)}set targetCamera(e){this._targetCamera=e,this.rotate(this.euler),this._targetCamera.position.copy(this.position)}get up(){return this._up}set up(e){this._up.copy(e),this._basisTransform.makeRotationFromQuaternion(new An().setFromUnitVectors(new T(0,1,0),this._up)),this._basisTransformInv.copy(this._basisTransform),this._basisTransformInv.invert()}set minDist(e){this._minDist=e}constructor(e,t,n,i){super(),this.velocity=new T,this.euler=new vr(0,0,0,"YXZ"),this.position=new T,this.goalEuler=new vr(0,0,0,"YXZ"),this.goalPosition=new T,this.keyMap={forward:!1,back:!1,left:!1,right:!1,up:!1,down:!1},this.contextMenuTriggered=!1,this.eulerXDamper=new Og,this.eulerYDamper=new Og,this.eulerZDamper=new Og,this.positionXDamper=new ts,this.positionYDamper=new ts,this.positionZDamper=new ts,this._lastTick=0,this._enabled=!1,this._basisTransform=new Ne,this._basisTransformInv=new Ne,this.onMouseMove=r=>{if(r.buttons!==1||!this._enabled)return;const a=r.movementX||0,o=r.movementY||0,l=new Me;l.y=.005*a*this._options.lookSpeed,l.x=.005*o*this._options.lookSpeed,this.rotateBy(l),this.emit(ez)},this.onKeyDown=r=>{switch(r.code){case"ArrowUp":case"KeyW":this.keyMap.forward=!0;break;case"ArrowLeft":case"KeyA":this.keyMap.left=!0;break;case"ArrowDown":case"KeyS":this.keyMap.back=!0;break;case"ArrowRight":case"KeyD":this.keyMap.right=!0;break;case"PageUp":case"KeyE":this.keyMap.up=!0;break;case"PageDown":case"KeyQ":this.keyMap.down=!0}},this.onKeyUp=r=>{switch(r.code){case"ArrowUp":case"KeyW":this.keyMap.forward=!1;break;case"ArrowLeft":case"KeyA":this.keyMap.left=!1;break;case"ArrowDown":case"KeyS":this.keyMap.back=!1;break;case"ArrowRight":case"KeyD":this.keyMap.right=!1;break;case"PageUp":case"KeyE":this.keyMap.up=!1;break;case"PageDown":case"KeyQ":this.keyMap.down=!1}},this.onContextMenu=()=>{this.contextMenuTriggered=!0},this._targetCamera=e,this.container=t,this.world=n,this._options=Object.assign({},i),this.connect()}isStationary(){return this.goalEuler.equals(this.euler)&&this.goalPosition.equals(this.position)&&this.velocity.length()===0}update(e){this.contextMenuTriggered&&(this.cancelMove(),this.contextMenuTriggered=!1);const t=performance.now();if(e=e!==void 0?e:t-this._lastTick,this._lastTick=t,!this._enabled)return!1;let n=this.world.getRelativeOffset(.2);this._minDist&&this._minDist<.5*n&&(n=this.world.getRelativeOffset(.03));const i=e/Oh.second,r=1.42*n;return this.keyMap.forward&&(this.velocity.z=-r*this._options.moveSpeed*i),this.keyMap.back&&(this.velocity.z=r*this._options.moveSpeed*i),this.keyMap.forward||this.keyMap.back||(this.velocity.z=0),this.keyMap.left&&(this.velocity.x=-r*this._options.moveSpeed*i),this.keyMap.right&&(this.velocity.x=r*this._options.moveSpeed*i),this.keyMap.left||this.keyMap.right||(this.velocity.x=0),this.keyMap.up&&(this.velocity.y=r*this._options.moveSpeed*i),this.keyMap.down&&(this.velocity.y=-r*this._options.moveSpeed*i),this.keyMap.down||this.keyMap.up||(this.velocity.y=0),!this.isStationary()&&(this.moveBy(this.velocity),this.updatePositionRotation(e),!0)}updatePositionRotation(e){const t=this.world.worldBox.min.distanceTo(this.world.worldBox.max),n=t<1?this.world.getRelativeOffset(t):1;this.position.x=this.positionXDamper.update(this.position.x,this.goalPosition.x,e,n),this.position.y=this.positionYDamper.update(this.position.y,this.goalPosition.y,e,n),this.position.z=this.positionZDamper.update(this.position.z,this.goalPosition.z,e,n),this.euler.x=this.eulerXDamper.update(this.euler.x,this.goalEuler.x,e,1),this.euler.y=this.eulerYDamper.update(this.euler.y,this.goalEuler.y,e,1),this.euler.z=this.eulerZDamper.update(this.euler.z,this.goalEuler.z,e,1),this.rotate(this.euler),this._targetCamera.position.copy(this.position)}jumpToGoal(){this.updatePositionRotation(OA)}fitToSphere(e){const t=this._targetCamera.getWorldDirection(new T);t.negate();const n=new T().copy(e.center).addScaledVector(t,e.radius);this.goalPosition.copy(n)}fromPositionAndTarget(e,t){const n=this.getPosition(),i=this.getTarget();if(n.equals(e)&&i.equals(t))return;const r=new T().copy(e),a=new T().copy(t),o=new Ne().lookAt(r,a,this._up).premultiply(this._basisTransformInv),l=new An().setFromRotationMatrix(o);this.goalEuler.setFromQuaternion(l),this.goalPosition.copy(r)}getTarget(){const e=new T().copy(this.goalPosition),t=new Ne().makeRotationFromEuler(this.goalEuler),n=new T().setFromMatrixColumn(t,2).applyMatrix4(this._basisTransform).normalize();return e.addScaledVector(n,-this.world.getRelativeOffset(.01)),e}getPosition(){return new T().copy(this.goalPosition)}getCurrentPosition(){return this.position}getCurrentTarget(){const e=new T().copy(this.position),t=new Ne().makeRotationFromEuler(this.euler),n=new T().setFromMatrixColumn(t,2).applyMatrix4(this._basisTransform).normalize();return e.addScaledVector(n,-this.world.getRelativeOffset(.01)),e}setDamperDecayTime(e){this.eulerXDamper.setDecayTime(e),this.eulerYDamper.setDecayTime(e),this.eulerZDamper.setDecayTime(e),this.positionXDamper.setDecayTime(e),this.positionYDamper.setDecayTime(e),this.positionZDamper.setDecayTime(e)}moveBy(e){const t=this._targetCamera;wo.setFromMatrixColumn(t.matrix,2),this.goalPosition.addScaledVector(wo,e.z),this._options.relativeUpDown?wo.setFromMatrixColumn(t.matrix,1):wo.copy(this.up),this.goalPosition.addScaledVector(wo,e.y),wo.setFromMatrixColumn(t.matrix,0),this.goalPosition.addScaledVector(wo,e.x)}rotateBy(e){this.goalEuler.y-=e.y,this.goalEuler.x-=e.x;const t=Math.PI;this.goalEuler.x=Math.max(oS-t,Math.min(oS-0,this.goalEuler.x))}connect(){this._enabled||(this.container.addEventListener("pointermove",this.onMouseMove),document.addEventListener("keydown",this.onKeyDown),document.addEventListener("keyup",this.onKeyUp),document.addEventListener("contextmenu",this.onContextMenu))}disconnect(){if(this._enabled){this.container.removeEventListener("pointermove",this.onMouseMove),document.removeEventListener("keydown",this.onKeyDown),document.removeEventListener("keyup",this.onKeyUp),document.removeEventListener("contextmenu",this.onContextMenu);for(const e in this.keyMap)this.keyMap[e]=!1}}dispose(){this.disconnect()}rotate(e){if(!this._options.enableLook)return;const t=new An,n=new An().setFromRotationMatrix(this._basisTransform);t.setFromEuler(e).premultiply(n),this._targetCamera.quaternion.slerp(t,.999)}cancelMove(){this.keyMap.forward=!1,this.keyMap.left=!1,this.keyMap.back=!1,this.keyMap.right=!1,this.keyMap.up=!1,this.keyMap.down=!1}}/* @license
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const zs=(s,e,t)=>Math.max(e,Math.min(t,s)),Ng=new T;var xp;(function(s){s.PointerChangeStart="pointer-change-start",s.PointerChangeEnd="pointer-change-end"})(xp||(xp={}));class zg extends NA{get enabled(){return this._enabled}set enabled(e){e?this.enableInteraction():(this.disableInteraction(),this.orbitSphere.visible=!1),this._enabled=e}get up(){return this._up}set up(e){this._up.copy(e),this._basisTransform.makeRotationFromQuaternion(new An().setFromUnitVectors(new T(0,1,0),this._up)),this._basisTransformInv.copy(this._basisTransform),this._basisTransformInv.invert()}constructor(e,t,n,i,r){super(),this._enabled=!1,this.isUserPointing=!1,this.enablePan=!0,this.enableTap=!0,this.panProjection=new Hn,this.panPerPixel=0,this.spherical=new vf,this.goalSpherical=new vf,this.origin=new T,this.pivotalOrigin=new T,this.goalOrigin=new T,this.targetDamperX=new ts,this.targetDamperY=new ts,this.targetDamperZ=new ts,this.thetaDamper=new ts,this.phiDamper=new ts,this.radiusDamper=new ts,this.logFov=Math.log(55),this.goalLogFov=this.logFov,this.fovDamper=new ts,this.touchMode=null,this.pointers=[],this.startPointerPosition={clientX:0,clientY:0},this.lastSeparation=0,this.touchDecided=!1,this.zoomControlCoord=new Me,this._lastTick=0,this._basisTransform=new Ne,this._basisTransformInv=new Ne,this._radiusDelta=0,this.pivotPoint=new T,this.lastPivotPoint=new T,this.usePivotal=!1,this.touchModeZoom=(o,l)=>{const c=this.twoTouchDistance(this.pointers[0],this.pointers[1]),u=.08*this._options.zoomSensitivity*+this._options.enableZoom*(this.lastSeparation-c)*50/this._container.offsetHeight;this.lastSeparation=c,this.userAdjustOrbit(0,0,u),this.panPerPixel>0&&this.movePan(o,l)},this.disableScroll=o=>{o.preventDefault()},this.touchModeRotate=(o,l)=>{const{touchAction:c}=this._options;if(!this.touchDecided&&c!=="none"){this.touchDecided=!0;const u=Math.abs(o),h=Math.abs(l);if(c==="pan-y"&&h>u||c==="pan-x"&&u>h)return void(this.touchMode=null);this._container.addEventListener("touchmove",this.disableScroll,{passive:!1})}this.handleSinglePointerMove(o,l)},this.onPointerDown=o=>{var l;if(this._options.orbitAroundCursor){const c=this._container.getBoundingClientRect(),u=(o.clientX-c.left)/c.width*2-1,h=(o.clientY-c.top)/c.height*-2+1;let d=this.renderer.intersections.intersect(this.renderer.scene,this._targetCamera,new Me(u,h),vt.STREAM_CONTENT_MESH,!0,this.renderer.clippingVolume);d=(l=d==null?void 0:d.filter(this.filterOrbitToCursorHits.bind(this)))!==null&&l!==void 0?l:[],d.length?(this.pivotPoint.copy(d[0].point),this.usePivotal=!0,this.orbitSphere.visible=this._options.showOrbitPoint):(this.usePivotal=!1,this.orbitSphere.visible=!1)}this.pointers.length>2||(this.pointers.length===0&&(this._container.addEventListener("pointermove",this.onPointerMove),this._container.addEventListener("pointerup",this.onPointerUp),this.touchMode=null,this.touchDecided=!1,this.startPointerPosition.clientX=o.clientX,this.startPointerPosition.clientY=o.clientY),this.pointers.push({clientX:o.clientX,clientY:o.clientY,id:o.pointerId}),this.isUserPointing=!1,o.pointerType==="touch"?this.onTouchChange(o):this.onMouseDown(o))},this.onPointerMove=o=>{const l=this.pointers.find(d=>d.id===o.pointerId);if(!l)return;if(o.pointerType==="mouse"&&o.buttons===0)return void this.onPointerUp(o);const c=this.pointers.length,u=(o.clientX-l.clientX)/c,h=(o.clientY-l.clientY)/c;u===0&&h===0||(l.clientX=o.clientX,l.clientY=o.clientY,o.pointerType==="touch"?this.touchMode!==null&&this.touchMode(u,h):this.panPerPixel>0?this.movePan(u,h):this.handleSinglePointerMove(u,h))},this.onPointerUp=o=>{const l=this.pointers.findIndex(c=>c.id===o.pointerId);l!==-1&&this.pointers.splice(l,1),this.pointers.length===0?(this._container.removeEventListener("pointermove",this.onPointerMove),this._container.removeEventListener("pointerup",this.onPointerUp),this._container.removeEventListener("touchmove",this.disableScroll)):this.touchMode!==null&&this.onTouchChange(o),this.panPerPixel=0,this.isUserPointing&&this.emit(xp.PointerChangeEnd),this.orbitSphere.visible=!1},this.onWheel=o=>{const l=this._container.getBoundingClientRect(),c=(o.clientX-l.left)/l.width*2-1,u=(o.clientY-l.top)/l.height*-2+1;this.zoomControlCoord.set(c,u);const h=o.deltaY*(o.deltaMode===1?18:1)*.08*this._options.zoomSensitivity*+this._options.enableZoom/60;this.userAdjustOrbit(0,0,h),o.preventDefault(),this.usePivotal=!1,this.orbitSphere.visible=!1},this.onContext=o=>{if(this.enablePan)o.preventDefault();else for(const l of this.pointers)this.onPointerUp(new PointerEvent("pointercancel",{...this.startPointerPosition,pointerId:l.id}))},this._targetCamera=e,this._container=t,this.world=n,this.renderer=i,this._options=Object.assign({},r),this.setDamperDecayTime(this._options.damperDecay);const a=new Wi({color:294651},["BILLBOARD_FIXED"]);a.opacity=.75,a.transparent=!0,a.color.convertSRGBToLinear(),a.toneMapped=!1,a.depthTest=!1,a.billboardPixelHeight=15*window.devicePixelRatio,this.orbitSphere=new gn(new Xv(.5,32,16),a),this.orbitSphere.layers.set(vt.OVERLAY),this.orbitSphere.visible=!1,this.orbitSphere.frustumCulled=!1,this.renderer.scene.add(this.orbitSphere)}get options(){return this._options}set options(e){this.applyOptions(e)}set targetCamera(e){if(e instanceof Xr&&this.goalSpherical.radius<this._minDist){let t=this.options.minimumRadius+.5*(this._options.maximumRadius-this.options.minimumRadius);const n=new Ti(this._targetCamera.position,this._targetCamera.getWorldDirection(new T)),i=this.renderer.intersections.intersectRay(this.renderer.scene,this._targetCamera,n,vt.STREAM_CONTENT_MESH,!1,this.renderer.clippingVolume,!1,!1);i&&i.length&&(t=i[0].distance),this.spherical.radius=t,this.goalSpherical.radius=t}this._targetCamera=e,this.usePivotal=this._options.orbitAroundCursor,this.lastPivotPoint.set(this.world.worldOrigin.x+this.world.worldSize.x,this.world.worldOrigin.y+this.world.worldSize.y,this.world.worldOrigin.z+this.world.worldSize.z),this.moveCamera()}set minDist(e){this._minDist=e}fromPositionAndTarget(e,t){const n=this.getPosition(),i=this.getTarget(),r=Ng.subVectors(t,i).length();if(Ng.subVectors(e,n).length()<1e-7||r<1e-7)return;const a=new T().copy(e),o=new T().copy(t);a.sub(o).applyMatrix4(this._basisTransformInv);const l=new vf;l.setFromCartesianCoords(a.x,a.y,a.z),this.setOrbit(l.theta,l.phi,l.radius),o.applyMatrix4(this._basisTransformInv),this.setTarget(o.x,o.y,o.z),this.usePivotal=!1}jumpToGoal(){this.update(OA)}fitToSphere(e){const t=new T().copy(e.center).applyMatrix4(this._basisTransformInv);this.setTarget(t.x,t.y,t.z),this.setRadius(e.radius),this.usePivotal=!1}getPosition(){return this.positionFromSpherical(this.goalSpherical,this.goalOrigin).applyMatrix4(this._basisTransform)}getTarget(){return this.goalOrigin.clone().applyMatrix4(this._basisTransform)}getCurrentPosition(){return this.positionFromSpherical(this.spherical,this.origin).applyMatrix4(this._basisTransform)}getCurrentTarget(){return this.origin.clone().applyMatrix4(this._basisTransform)}isStationary(){return this.goalSpherical.theta===this.spherical.theta&&this.goalSpherical.phi===this.spherical.phi&&this.goalSpherical.radius===this.spherical.radius&&this.goalLogFov===this.logFov&&this.goalOrigin.equals(this.origin)&&this.pivotPoint.equals(this.lastPivotPoint)}applyOptions(e){Object.assign(this._options,e),this.setDamperDecayTime(this._options.damperDecay),this.setOrbit(),this.setFieldOfView(Math.exp(this.goalLogFov))}computeMinMaxRadius(){if(this.world){const e=this.world.getRelativeOffset(10),t=this.world.getRelativeOffset(.01);isNaN(e)||isNaN(t)||Object.assign(this._options,{maximumRadius:e,minimumRadius:t})}}setOrbit(e=this.goalSpherical.theta,t=this.goalSpherical.phi,n=this.goalSpherical.radius){this.computeMinMaxRadius();const{minimumAzimuthalAngle:i,maximumAzimuthalAngle:r,minimumPolarAngle:a,maximumPolarAngle:o,minimumRadius:l,maximumRadius:c}=this._options,{theta:u,phi:h,radius:d}=this.goalSpherical,f=zs(e,i,r);isFinite(i)||isFinite(r)||(this.spherical.theta=this.wrapAngle(this.spherical.theta-f)+f);const v=zs(t,a,o),g=zs(n,l,c);return(f!==u||v!==h||g!==d)&&!!(isFinite(f)&&isFinite(v)&&isFinite(g))&&(this.goalSpherical.theta=f,this.goalSpherical.phi=v,this.goalSpherical.radius=g,this.goalSpherical.makeSafe(),!0)}setRadius(e){this.goalSpherical.radius=e,this.setOrbit()}setFieldOfView(e){const{minimumFieldOfView:t,maximumFieldOfView:n}=this._options;e=zs(e,t,n),this.goalLogFov=Math.log(e)}setDamperDecayTime(e){this.thetaDamper.setDecayTime(e),this.phiDamper.setDecayTime(e),this.radiusDamper.setDecayTime(e),this.fovDamper.setDecayTime(e),this.targetDamperX.setDecayTime(e),this.targetDamperY.setDecayTime(e),this.targetDamperZ.setDecayTime(e)}setTarget(e,t,n){this.goalOrigin.set(e,t,n)}adjustOrbit(e,t,n){this._radiusDelta;const{theta:i,phi:r,radius:a}=this.goalSpherical,o=this.spherical.theta-i,l=Math.PI-.001,c=i-zs(e,-l-o,l-o),u=r-t;if(this.setOrbit(c,u),n===0)return;const h=this.spherical.radius/this.world.worldBox.getSize(new T).length();let d=QB(this.world.getRelativeOffset(.16)*Math.abs(n),this.world.getRelativeOffset(.64)*Math.abs(n),h>=.5?Math.exp(h):h);d=zs(d,this.world.getRelativeOffset(.01),this.world.getRelativeOffset(.2));const f=d*Math.sign(n),v=a+f;if(this.setOrbit(c,u,v),this._radiusDelta=a-this.goalSpherical.radius,this._options.zoomToCursor){const g=new T;if(v<this._options.minimumRadius&&this._options.infiniteZoom&&this._targetCamera instanceof li){const L=new T().setFromSpherical(this.spherical).normalize();g.copy(L).multiplyScalar(f),this._radiusDelta=-f}const m=new T().setFromSpherical(this.spherical).normalize().negate(),x=new T().copy(m).cross(new T(0,1,0)).normalize();x.lengthSq()===0&&(x.x=1);const w=new T().crossVectors(x,m),S={x:this._container.offsetWidth,y:this._container.offsetHeight},b=S.x/S.y,E=zs(this.goalSpherical.radius,Math.abs(f),Number.MAX_VALUE)*Math.tan(Math.exp(this.logFov)*ci.DEG2RAD*.5),C=new T().copy(this.goalOrigin).add(x.multiplyScalar(this.zoomControlCoord.x*E*b*1)).add(w.multiplyScalar(this.zoomControlCoord.y*E*1)).add(g),P=zs(this._radiusDelta/this.goalSpherical.radius,-1,1),M=new T().copy(this.goalOrigin).lerp(C,P);this.setTarget(M.x,M.y,M.z)}}update(e){const t=performance.now();if(e=e!==void 0?e:t-this._lastTick,this._lastTick=t,this.isStationary())return!1;this.computeMinMaxRadius();const{maximumPolarAngle:n}=this._options,i=this.spherical.theta-this.goalSpherical.theta;Math.abs(i)>Math.PI&&!isFinite(this._options.minimumAzimuthalAngle)&&!isFinite(this._options.maximumAzimuthalAngle)&&(this.spherical.theta-=2*Math.sign(i)*Math.PI),this.spherical.theta=this.thetaDamper.update(this.spherical.theta,this.goalSpherical.theta,e,Math.PI),this.spherical.phi=this.phiDamper.update(this.spherical.phi,this.goalSpherical.phi,e,n);const r=this._options.maximumRadius-this._options.minimumRadius,a=r<1?r:1;this.spherical.radius=this.radiusDamper.update(this.spherical.radius,this.goalSpherical.radius,e,a),this.logFov=this.goalLogFov;let o=1;this.world&&(o=this.world.worldBox.getBoundingSphere(new Zn).radius/10);const l=this.targetDamperX.update(this.origin.x,this.goalOrigin.x,e,o),c=this.targetDamperY.update(this.origin.y,this.goalOrigin.y,e,o),u=this.targetDamperZ.update(this.origin.z,this.goalOrigin.z,e,o);return this.origin.set(l,c,u),this.moveCamera()}polarFromPivotal(e){const t=this.quaternionFromSpherical(this.spherical),n=new T().setFromMatrixColumn(new Ne().makeRotationFromQuaternion(t),2),i=new T().copy(e),r=new T().copy(this.pivotPoint).applyMatrix4(this._basisTransformInv),a=i.distanceTo(r),o=new T().copy(i).sub(r);o.normalize();const l=Math.min(Math.max(n.dot(o),-1),1),c=Math.acos(l),u=a*Math.cos(c),h=i.sub(new T().copy(n).multiplyScalar(u));this.goalOrigin.copy(h),this.origin.copy(h),this._targetCamera instanceof li&&(this.goalSpherical.radius=u,this.spherical.radius=u)}positionFromPivotal(e,t){const n=new T().copy(this.pivotPoint).applyMatrix4(this._basisTransformInv),i=new T;return i.copy(e),i.sub(n),i.applyQuaternion(t),i.add(n),i}getPivotalOrigin(e,t,n){const i=new T().copy(t);return i.sub(e),i.applyQuaternion(new An().copy(n).invert()),i.add(e),i}moveCamera(){const e=new T().copy(this._targetCamera.position),t=new An().copy(this._targetCamera.quaternion);this.spherical.makeSafe();const n=this.quaternionFromSpherical(this.spherical);let i=this.positionFromSpherical(this.spherical,this.origin);if(this.usePivotal){const o=new T().copy(this.pivotPoint).applyMatrix4(this._basisTransformInv);new T().copy(this.lastPivotPoint).applyMatrix4(this._basisTransformInv).sub(o).length()>0&&this.pivotalOrigin.copy(this.getPivotalOrigin(o,i,n)),i=this.positionFromPivotal(this.pivotalOrigin,n),this.polarFromPivotal(i),this.lastPivotPoint.copy(this.pivotPoint)}if(i.applyQuaternion(new An().setFromRotationMatrix(this._basisTransform)),n.premultiply(new An().setFromRotationMatrix(this._basisTransform)),this._targetCamera instanceof Xr){const o=new T().setFromSpherical(this.spherical).applyQuaternion(new An().setFromRotationMatrix(this._basisTransform)).normalize();i.add(o.multiplyScalar(this._options.maximumRadius-this.options.minimumRadius-this.spherical.radius))}if(this._targetCamera.position.copy(i),this._targetCamera.quaternion.copy(n),this._targetCamera.updateMatrixWorld(!0),this._targetCamera instanceof li&&this._targetCamera.fov!==Math.exp(this.logFov)&&(this._targetCamera.fov=Math.exp(this.logFov),this._targetCamera.updateProjectionMatrix()),this._targetCamera instanceof Xr){const o=zA(this.spherical.radius,Math.exp(this.logFov),this._container.offsetWidth/this._container.offsetHeight);this._targetCamera.zoom=1,this._targetCamera.left=o.x/-2,this._targetCamera.right=o.x/2,this._targetCamera.top=o.y/2,this._targetCamera.bottom=o.y/-2,this._targetCamera.updateProjectionMatrix()}const r=this._options.orbitAroundCursor&&this.usePivotal?this.pivotPoint:new T().copy(this.origin).applyMatrix4(this._basisTransform);this.orbitSphere.material.userData.billboardPos.value.copy(r);const a=Math.min(1e-5,this.world.getRelativeOffset(1e-5));return e.sub(this._targetCamera.position).length()>a||t.angleTo(this._targetCamera.quaternion)>a}positionFromSpherical(e,t){const n=new T;return n.setFromSpherical(e),t&&n.add(t),n}quaternionFromSpherical(e){const t=new An;return t.setFromEuler(new vr(e.phi-Math.PI/2,e.theta,0,"YXZ")),t}userAdjustOrbit(e,t,n){this.adjustOrbit(e*this._options.orbitSensitivity*+this._options.enableOrbit*this._options.inputSensitivity,t*this._options.orbitSensitivity*+this._options.enableOrbit*this._options.inputSensitivity,n*this._options.zoomSensitivity*+this._options.enableZoom*this._options.inputSensitivity)}enableInteraction(){this._enabled||(this._container.addEventListener("pointerdown",this.onPointerDown),this._container.addEventListener("pointercancel",this.onPointerUp),this._container.addEventListener("wheel",this.onWheel),this._container.addEventListener("touchmove",()=>{},{passive:!1}),this._container.addEventListener("contextmenu",this.onContext))}disableInteraction(){this._enabled&&(this._container.removeEventListener("pointerdown",this.onPointerDown),this._container.removeEventListener("pointermove",this.onPointerMove),this._container.removeEventListener("pointerup",this.onPointerUp),this._container.removeEventListener("pointercancel",this.onPointerUp),this._container.removeEventListener("wheel",this.onWheel),this._container.removeEventListener("contextmenu",this.onContext),this.touchMode=null,this.pointers.length=0)}wrapAngle(e){const t=(e+Math.PI)/(2*Math.PI);return 2*(t-Math.floor(t))*Math.PI-Math.PI}pixelLengthToSphericalAngle(e){return 2*Math.PI*e/this._container.offsetHeight}twoTouchDistance(e,t){const{clientX:n,clientY:i}=e,{clientX:r,clientY:a}=t,o=r-n,l=a-i;return Math.sqrt(o*o+l*l)}handleSinglePointerMove(e,t){const n=this.pixelLengthToSphericalAngle(e),i=this.pixelLengthToSphericalAngle(t);this.isUserPointing===!1&&(this.isUserPointing=!0,this.emit(xp.PointerChangeStart)),this.userAdjustOrbit(n,i,0)}initializePan(){const{theta:e,phi:t}=this.spherical,n=e;this.panPerPixel=.018*this._options.panSensitivity*+this._options.enablePan/this._container.offsetHeight,this.panProjection.set(-Math.cos(n),-Math.cos(t)*Math.sin(n),0,0,Math.sin(t),0,Math.sin(n),-Math.cos(t)*Math.cos(n),0)}movePan(e,t){const n=Ng.set(e,t,0).multiplyScalar(this._options.inputSensitivity);let i=this.world.getRelativeOffset(.4);this._minDist&&this._minDist<.5*i&&(i=this.world.getRelativeOffset(.06));const r=zs(this.spherical.radius,this.world.getRelativeOffset(.025),Number.MAX_VALUE),a=Math.max(i,r)*Math.exp(this.logFov)*this.panPerPixel;n.multiplyScalar(a);const o=this.getTarget().applyMatrix4(this._basisTransformInv);o.add(n.applyMatrix3(this.panProjection)),this.setTarget(o.x,o.y,o.z),this.usePivotal=!1,this.orbitSphere.visible=!1}filterOrbitToCursorHits(e){var t;const n=this.renderer.getMaterial(e.batchObject.renderView);return(t=n==null?void 0:n.visible)!==null&&t!==void 0&&t}onTouchChange(e){if(this.pointers.length===1)this.touchMode=this.touchModeRotate;else{if(!this._options.enableZoom)return this.touchMode=null,void this._container.removeEventListener("touchmove",this.disableScroll);this.touchMode=this.touchDecided&&this.touchMode===null?null:this.touchModeZoom,this.touchDecided=!0,this._container.addEventListener("touchmove",this.disableScroll,{passive:!1}),this.lastSeparation=this.twoTouchDistance(this.pointers[0],this.pointers[1]),this.enablePan&&this.touchMode!==null&&(this.initializePan(),e.altKey)}}onMouseDown(e){this.panPerPixel=0,this.enablePan&&(e.button===2||e.ctrlKey||e.metaKey||e.shiftKey)&&(this.initializePan(),this.orbitSphere.visible=!1)}dispose(){throw new Error("Method not implemented.")}}var wp;function zA(s,e,t){const n=2*Math.tan(ci.DEG2RAD*(e/2))*s;return new Me(n*t,n)}(function(s){s[s.EMPIRIC=0]="EMPIRIC",s[s.ACCURATE=1]="ACCURATE"})(wp||(wp={}));const tz={enableOrbit:!0,enableZoom:!0,enablePan:!0,orbitSensitivity:1,zoomSensitivity:1,panSensitivity:1,inputSensitivity:1,minimumRadius:0,maximumRadius:1/0,minimumPolarAngle:0,maximumPolarAngle:Math.PI,minimumAzimuthalAngle:-1/0,maximumAzimuthalAngle:1/0,minimumFieldOfView:40,maximumFieldOfView:60,touchAction:"none",infiniteZoom:!0,zoomToCursor:!0,orbitAroundCursor:!0,showOrbitPoint:!0,lookSpeed:1,moveSpeed:1,damperDecay:30,enableLook:!0,relativeUpDown:!1,nearPlaneCalculation:wp.ACCURATE};class Zu extends Qp{get renderingCamera(){return this._renderingCamera}set renderingCamera(e){this._renderingCamera=e}get enabled(){return this._activeControls.enabled}set enabled(e){this.controls.enabled=e}get fieldOfView(){return this.perspectiveCamera.fov}set fieldOfView(e){this.perspectiveCamera.fov=e,this.perspectiveCamera.updateProjectionMatrix()}get aspect(){return this.perspectiveCamera.aspect}get controls(){return this._activeControls}get options(){return this._options}set options(e){Object.assign(this._options,e),this._orbitControls.options=e,this._flyControls.options=e}constructor(e){super(e),this._lastCameraChanged=!1,this._options=tz,this.perspectiveCamera=new li(55,window.innerWidth/window.innerHeight);const t=this.viewer.getContainer().offsetWidth/this.viewer.getContainer().offsetHeight;this.orthographicCamera=new Xr(-50*t/2,50*t/2,25,-25,.001,1e4),this.renderingCamera=this.perspectiveCamera,this._flyControls=new lS(this._renderingCamera,this.viewer.getContainer(),this.viewer.World,this._options),this._flyControls.enabled=!1,this._flyControls.setDamperDecayTime(30),this._flyControls.up=new T(0,0,1),this._orbitControls=new zg(this.perspectiveCamera,this.viewer.getContainer(),this.viewer.World,this.viewer.getRenderer(),this._options),this._orbitControls.enabled=!0,this.viewer.getRenderer().speckleCamera=this,this._activeControls=this._orbitControls,this.default()}default(){this._activeControls instanceof zg&&(this._activeControls.up=new T(0,0,1),this._activeControls.setOrbit(2.356,.955),this._activeControls.jumpToGoal())}on(e,t){super.on(e,t)}getTarget(){return this._activeControls.getTarget()}getPosition(){return this._activeControls.getPosition()}toggleControls(){const e=this._activeControls;let t;if(this._activeControls instanceof zg?t=this._flyControls:this._activeControls instanceof lS&&(t=this._orbitControls),!t)throw new Error("Not controls found!");e.enabled=!1,t.enabled=!0,t.fromPositionAndTarget(e.getCurrentPosition(),e.getCurrentTarget()),t.jumpToGoal(),this._activeControls=t,this.viewer.requestRender()}setCameraView(e,t=!0,n=1.2){e?Array.isArray(e)?this.zoom(e,n,t):this.isBox3(e)?this.zoomToBox(e,n,t):this.setView(e,t):this.zoomExtents(n,t),this.emit(Tr.Dynamic)}onEarlyUpdate(e){const t=this._activeControls.update(e);t!==this._lastCameraChanged&&this.emit(t?Tr.Dynamic:Tr.Stationary),this.emit(Tr.FrameUpdate,t),this._lastCameraChanged=t,t&&this.updateCameraPlanes()}onLateUpdate(){this.emit(Tr.LateFrameUpdate,this._lastCameraChanged)}onResize(){const e=this.viewer.getContainer().offsetWidth/this.viewer.getContainer().offsetHeight;this.perspectiveCamera.aspect=e,this.perspectiveCamera.updateProjectionMatrix();const t=zA(this._activeControls.getPosition().distanceTo(this._activeControls.getTarget()),this.perspectiveCamera.fov,e);this.orthographicCamera.zoom=1,this.orthographicCamera.left=t.x/-2,this.orthographicCamera.right=t.x/2,this.orthographicCamera.top=t.y/2,this.orthographicCamera.bottom=t.y/-2,this.orthographicCamera.updateProjectionMatrix()}setPerspectiveCameraOn(){this._renderingCamera!==this.perspectiveCamera&&(this.renderingCamera=this.perspectiveCamera,this.setupPerspectiveCamera(),this.viewer.requestRender(hr.RENDER_RESET))}setOrthoCameraOn(){this._renderingCamera!==this.orthographicCamera&&(this.renderingCamera=this.orthographicCamera,this.setupOrthoCamera(),this.viewer.requestRender(hr.RENDER_RESET))}toggleCameras(){this._renderingCamera===this.perspectiveCamera?this.setOrthoCameraOn():this.setPerspectiveCameraOn()}setupOrthoCamera(){this.controls.targetCamera=this.orthographicCamera,this.enableRotations(),this.updateCameraPlanes(this.viewer.getRenderer().sceneBox),this.emit(Tr.ProjectionChanged,gp.ORTHOGRAPHIC)}setupPerspectiveCamera(){this.controls.targetCamera=this.perspectiveCamera,this.enableRotations(),this.updateCameraPlanes(this.viewer.getRenderer().sceneBox),this.emit(Tr.ProjectionChanged,gp.PERSPECTIVE)}disableRotations(){this.options={enableOrbit:!1,enableLook:!1}}enableRotations(){this.options={enableOrbit:!0,enableLook:!0}}updateCameraPlanes(e,t=1){const n=this.viewer.getRenderer();if(!n.renderingCamera)return;e||(e=this.viewer.getRenderer().sceneBox);let i=this.computeNearCameraPlaneEmpiric(e,t);this._options.nearPlaneCalculation===wp.ACCURATE&&(i=this.computeNearCameraPlaneAccurate(e,t,i)),i&&(n.renderingCamera.near=i,n.renderingCamera.updateProjectionMatrix()),this.updateFarCameraPlane()}computeNearCameraPlaneEmpiric(e,t=1){if(!e)return;if(e.isEmpty())return void dt.warn("Cannot set camera planes for empty volume");const n=e.getSize(new T),i=Math.max(n.x,n.y,n.z),r=this._renderingCamera===this.perspectiveCamera?this.fieldOfView:55,a=this._renderingCamera===this.perspectiveCamera?this.aspect:1.2,o=i/(2*Math.atan(Math.PI*r/360)),l=o/a,c=t*Math.max(o,l);return this.perspectiveCamera?c/100:.001}computeNearCameraPlaneAccurate(e,t=1,n){const i=this.getClosestGeometryDistance(n);if(this._flyControls.minDist=i,this._orbitControls.minDist=i,i===Number.POSITIVE_INFINITY)return this.computeNearCameraPlaneEmpiric(e,t);const r=this._renderingCamera===this.perspectiveCamera?this.fieldOfView:55,a=this._renderingCamera===this.perspectiveCamera?this.aspect:1.2;return Math.max(i,0)/Math.sqrt(1+Math.pow(Math.tan(r/180*Math.PI/2),2)*(Math.pow(a,2)+1))}updateFarCameraPlane(){const e=this.viewer.getRenderer();if(!e.renderingCamera)return;const t=new T,n=e.sceneBox,i=new T().copy(e.renderingCamera.position);let r=0;t.set(n.min.x,n.min.y,n.min.z),r=Math.max(i.distanceTo(t),r),t.set(n.min.x,n.min.y,n.max.z),r=Math.max(i.distanceTo(t),r),t.set(n.min.x,n.max.y,n.min.z),r=Math.max(i.distanceTo(t),r),t.set(n.min.x,n.max.y,n.max.z),r=Math.max(i.distanceTo(t),r),t.set(n.max.x,n.min.y,n.min.z),r=Math.max(i.distanceTo(t),r),t.set(n.max.x,n.min.y,n.max.z),r=Math.max(i.distanceTo(t),r),t.set(n.max.x,n.max.y,n.min.z),r=Math.max(i.distanceTo(t),r),t.set(n.max.x,n.max.y,n.max.z),r=Math.max(i.distanceTo(t),r),e.renderingCamera.far=2*r,e.renderingCamera.updateProjectionMatrix()}getClosestGeometryDistance(e){const t=this._activeControls.getCurrentPosition(),n=this._activeControls.getCurrentTarget(),i=new T().subVectors(n,t).normalize(),r=this.viewer.getRenderer().batcher.getBatches(void 0,mt.MESH);let a=Number.POSITIVE_INFINITY;for(let o=0;o<r.length;o++){const l=r[o].mesh.TAS.closestPointToPointHalfplane(t,i,e);l&&(a=Math.min(a,l.distance))}return a}zoom(e,t,n){e?this.zoomToBox(this.viewer.getRenderer().boxFromObjects(e),t,n):this.zoomExtents(t,n)}zoomExtents(e=1.2,t=!0){if(this.viewer.getRenderer().clippingVolume.isEmpty()){const i=new Tt(new T(-1,-1,-1),new T(1,1,1));return void this.zoomToBox(i,e,t)}const n=new Tt().fromOBB(this.viewer.getRenderer().clippingVolume);n.min.equals(n.max)&&n.expandByVector(new T(1,1,1)),this.zoomToBox(n,e,t)}zoomToBox(e,t=1.2,n=!0){e.max.x!==1/0&&e.max.x!==-1/0||(e=new Tt(new T(-1,-1,-1),new T(1,1,1)));const i=new Zn;e.getBoundingSphere(i),i.radius=this.fitToRadius(i.radius)*t,this._activeControls.fitToSphere(i),this.updateCameraPlanes(e,t),n||this._activeControls.jumpToGoal()}fitToRadius(e){const t=this.perspectiveCamera.getEffectiveFOV()*ci.DEG2RAD,n=2*Math.atan(Math.tan(.5*t)*this.perspectiveCamera.aspect),i=1<this.perspectiveCamera.aspect?t:n;return e/Math.sin(.5*i)}isSpeckleView(e){return e.name!==void 0}isCanonicalView(e){return typeof e=="string"}isInlineView(e){return e.position!==void 0&&e.target!==void 0}isPolarView(e){return e.azimuth!==void 0&&e.polar!==void 0}isBox3(e){return e instanceof Tt}setView(e,t=!0){this.isSpeckleView(e)&&this.setViewSpeckle(e,t),this.isCanonicalView(e)&&this.setViewCanonical(e,t),this.isInlineView(e)&&this.setViewInline(e,t),this.isPolarView(e)&&this.setViewPolar(e,t)}setViewSpeckle(e,t=!0){this._activeControls.fromPositionAndTarget(new T(e.origin.x,e.origin.y,e.origin.z),new T(e.target.x,e.target.y,e.target.z)),t||this._activeControls.jumpToGoal(),this.enableRotations()}setViewCanonical(e,t=!0){const n=new Zn;this.viewer.World.worldBox.getBoundingSphere(n);const i=this.fitToRadius(n.radius),r=new T().copy(this.viewer.World.worldBox.getCenter(new T)),a=new T().copy(r),o=new An().setFromUnitVectors(new T(0,1,0),this._activeControls.up);switch(e){case"front":this._activeControls.fromPositionAndTarget(r.add(new T(0,0,1).applyQuaternion(o).multiplyScalar(i)),a),this._renderingCamera===this.orthographicCamera&&this.disableRotations();break;case"back":this._activeControls.fromPositionAndTarget(r.add(new T(0,0,-1).applyQuaternion(o).multiplyScalar(i)),a),this._renderingCamera===this.orthographicCamera&&this.disableRotations();break;case"up":case"top":this._activeControls.fromPositionAndTarget(r.add(new T(0,1,0).applyQuaternion(o).multiplyScalar(i)),a),this._renderingCamera===this.orthographicCamera&&this.disableRotations();break;case"down":case"bottom":this._activeControls.fromPositionAndTarget(r.add(new T(0,-1,0).applyQuaternion(o).multiplyScalar(i)),a),this._renderingCamera===this.orthographicCamera&&this.disableRotations();break;case"right":this._activeControls.fromPositionAndTarget(r.add(new T(1,0,0).applyQuaternion(o).multiplyScalar(i)),a),this._renderingCamera===this.orthographicCamera&&this.disableRotations();break;case"left":this._activeControls.fromPositionAndTarget(r.add(new T(-1,0,0).applyQuaternion(o).multiplyScalar(i)),a),this._renderingCamera===this.orthographicCamera&&this.disableRotations();break;case"3d":this._activeControls.fromPositionAndTarget(new T().copy(this.viewer.World.worldBox.max),a),this.zoomExtents();break;default:this.enableRotations()}t||this._activeControls.jumpToGoal()}setViewInline(e,t=!0){this._activeControls.fromPositionAndTarget(e.position,e.target),t||this._activeControls.jumpToGoal(),this.enableRotations()}setViewPolar(e,t=!0){this._activeControls.adjustOrbit(e.azimuth,e.polar,e.radius?e.radius:0),t||this._activeControls.jumpToGoal(),this.enableRotations()}}const nz=Mu;class FA extends Nh{get World(){return this.world}get Utils(){return this.utils||(this.utils={screenToNDC:this.speckleRenderer.screenToNDC.bind(this.speckleRenderer),NDCToScreen:this.speckleRenderer.NDCToScreen.bind(this.speckleRenderer)}),this.utils}get input(){return this.speckleRenderer.input}getConstructorChain(e){const t=[];let n=e;do(n=Object.getPrototypeOf(n))&&t.push(n.constructor.name||null);while(n!==null);return t}createExtension(e){const t=e.prototype.inject,n=[];t.forEach(r=>{if(this.extensions[r.name])n.push(this.extensions[r.name]);else for(const a in this.extensions)this.getConstructorChain(this.extensions[a]).includes(r.name)&&n.push(this.extensions[a])});const i=new e(this,...n);return this.extensions[e.name]=i,i}getExtension(e){let t;if((t=this.getExtensionInternal(e))!==null)return t;throw new Error(`Could not get Extension of type ${e.name}. Is it created?`)}hasExtension(e){return!!this.getExtensionInternal(e)}getExtensionInternal(e){if(this.extensions[e.name])return this.extensions[e.name];for(const t in this.extensions)if(this.getConstructorChain(this.extensions[t]).includes(e.name))return this.extensions[t];return null}constructor(e,t=pA){super(),this.tree=new Ku,this.world=new Ju,this.loaders={},this.extensions={},dt.useDefaults(),dt.setLevel(t.verbose?dt.TRACE:dt.ERROR),this.container=e||document.getElementById("renderer"),t.showStats&&(this.stats=nz(),this.container.prepend(this.stats.dom),this.stats.dom.style.position="relative"),this.loaders={},this.startupParams=t,this.clock=new DI,this.inProgressOperations=0,this.speckleRenderer=new ZN(this.tree,this),this.speckleRenderer.create(this.container),window.addEventListener("resize",this.resize.bind(this),!1),this.propertyManager=new $N,this.frame(),this.resize()}getContainer(){return this.container}getRenderer(){return this.speckleRenderer}resize(){const e=this.container.offsetWidth,t=this.container.offsetHeight;this.speckleRenderer.resize(e,t),Object.values(this.extensions).forEach(n=>{n.onResize()})}requestRender(e=hr.RENDER){e&hr.RENDER&&(this.speckleRenderer.needsRender=!0),e&hr.SHADOWS&&(this.speckleRenderer.shadowMapNeedsUpdate=!0),e&hr.CLIPPING_PLANES&&this.speckleRenderer.updateClippingPlanes(),e&hr.RENDER_RESET&&(this.speckleRenderer.needsRender=!0,this.speckleRenderer.resetPipeline())}frame(){this.update(),this.render()}update(){var e;const t=this.clock.getDelta()*Oh.second,n=Object.values(this.extensions);n.forEach(i=>{i.onEarlyUpdate(t)}),this.speckleRenderer.update(t),n.forEach(i=>{i.onLateUpdate(t)}),(e=this.stats)===null||e===void 0||e.update(),requestAnimationFrame(this.frame.bind(this))}render(){this.speckleRenderer.render(),Object.values(this.extensions).forEach(e=>{e.onRender()})}async init(){this.startupParams.environmentSrc&&pr.getEnvironment(this.startupParams.environmentSrc,this.speckleRenderer.renderer).then(e=>{this.speckleRenderer.indirectIBL=e}).catch(e=>{dt.error(e),dt.error("Environment failed to load!")})}on(e,t){super.on(e,t)}getObjectProperties(e=null,t=!0){return this.propertyManager.getProperties(this.tree,e,t)}getDataTree(){dt.error("DataTree has been deprecated! Please use WorldTree")}getWorldTree(){return this.tree}query(e){return Ea.isPointQuery(e)?(Ea.DefaultPointQuerySolver.setContext(this.speckleRenderer),Ea.DefaultPointQuerySolver.solve(e)):Ea.isIntersectionQuery(e)?(Ea.DefaultIntersectionQuerySolver.setContext(this.speckleRenderer),Ea.DefaultIntersectionQuerySolver.solve(e)):null}setLightConfiguration(e){this.speckleRenderer.setSunLightConfiguration(e)}getViews(){return this.tree.findAll(e=>{var t;return((t=e.model.renderView)===null||t===void 0?void 0:t.speckleType)===Bt.View3D}).map(e=>e.model.raw)}screenshot(){return new Promise(e=>{e(this.speckleRenderer.renderer.domElement.toDataURL("image/png"))})}async loadObject(e,t=!0){var n;if(t&&((n=this.getExtension(Zu))===null||n===void 0||n.default()),++this.inProgressOperations==1&&this.emit(gi.Busy,!0),this.loaders[e.resource]=e,await e.load()){const i=this.tree.getRenderTree(e.resource);if(!i)throw new Error(`Could not get render tree ${e.resource}`);const r=performance.now();for await(const a of this.speckleRenderer.addRenderTree(i))if(t){const o=this.getExtension(Zu);o&&(o.setCameraView([],!1),this.speckleRenderer.pipeline.render())}dt.log(this.getRenderer().renderingStats),dt.log("ASYNC batch build time -> ",performance.now()-r),this.requestRender(hr.RENDER_RESET|hr.SHADOWS),this.emit(gi.LoadComplete,e.resource)}this.loaders[e.resource]&&this.loaders[e.resource].dispose(),delete this.loaders[e.resource],--this.inProgressOperations==0&&this.emit(gi.Busy,!1)}async cancelLoad(e,t=!1){var n;this.loaders[e].cancel(),(n=this.tree.getRenderTree(e))===null||n===void 0||n.cancelBuild(),this.speckleRenderer.cancelRenderTree(e),t?await this.unloadObject(e):--this.inProgressOperations==0&&this.emit(gi.Busy,!1)}async unloadObject(e){var t;try{if(++this.inProgressOperations==1&&this.emit(gi.Busy,!0),this.tree.findSubtree(e)){if(this.loaders[e])return void await this.cancelLoad(e,!0);delete this.loaders[e],this.speckleRenderer.removeRenderTree(e),(t=this.tree.getRenderTree(e))===null||t===void 0||t.purge(),this.tree.purge(e),this.requestRender(hr.RENDER_RESET|hr.SHADOWS)}}finally{--this.inProgressOperations==0&&(this.emit(gi.Busy,!1),dt.warn(`Removed subtree ${e}`),this.emit(gi.UnloadComplete,e))}}async unloadAll(){try{++this.inProgressOperations==1&&this.emit(gi.Busy,!0);for(const e of Object.keys(this.loaders))this.loaders[e]&&await this.cancelLoad(e,!1),delete this.loaders[e];this.tree.root.children.forEach(e=>{var t;this.speckleRenderer.removeRenderTree(e.model.id),(t=this.tree.getRenderTree())===null||t===void 0||t.purge()}),this.tree.purge()}finally{--this.inProgressOperations==0&&(this.emit(gi.Busy,!1),dt.warn("Removed all subtrees"),this.emit(gi.UnloadAllComplete))}}dispose(){}}var pn;FA.theAssets=new pr,function(s){s[s.HIDDEN=0]="HIDDEN",s[s.DANGLING_START=1]="DANGLING_START",s[s.DANGLING_END=2]="DANGLING_END",s[s.COMPLETE=3]="COMPLETE"}(pn||(pn={}));class Xp extends fn{constructor(){super(...arguments),this.startPoint=new T,this.endPoint=new T,this.startNormal=new T,this.endNormal=new T,this.value=0,this.units="m",this.precision=2,this._state=pn.HIDDEN,this.renderingSize=new Me}set state(e){this._state=e}get state(){return this._state}get bounds(){return new Tt().expandByPoint(this.startPoint).expandByPoint(this.endPoint)}frameUpdate(e,t,n){this.renderingCamera=e,this.renderingSize.copy(t)}}const Vi=new T,$r={dashedLine:!1,normalIndicatorPixelSize:40,normalIndicatorColor:294651,normalIndicatorOpacity:1,lineColor:294651,lineOpacity:1,pointColor:294651,pointOpacity:1,textColor:16777215,textOpacity:1,textPixelHeight:17,pointPixelHeight:5};class Jo extends Er{set style(e){Object.assign(this._style,e),this.updateStyle()}set highlight(e){e?(this.normalIndicator.material.color=new ot(16711680),this.line.material.color=new ot(16711680),this.point.material.color=new ot(16711680),this.text.textMesh.material.color.copy(new ot(16711680))):this.updateStyle()}getNormalIndicatorMaterial(){const e=new Ca({color:294651,linewidth:1,worldUnits:!1,vertexColors:!1,alphaToCoverage:!1,resolution:new Me(1,1)},["USE_RTE"]);return e.color=new ot(this._style.normalIndicatorColor),e.color.convertSRGBToLinear(),e.toneMapped=!1,e.linewidth=2,e.worldUnits=!1,e.resolution=new Me(256,256),e.opacity=this._style.normalIndicatorOpacity!==void 0?this._style.normalIndicatorOpacity:$r.normalIndicatorOpacity,e.transparent=e.opacity<1,e.depthTest=!1,e}getLineMaterial(){const e=new Ca({color:294651,linewidth:1,worldUnits:!1,vertexColors:!1,alphaToCoverage:!1,resolution:new Me(1,1)},["USE_RTE","UNIFORM_OPACITY"].concat(this._style.dashedLine?["USE_DASH"]:[]));return e.color=new ot(this._style.lineColor),e.color.convertSRGBToLinear(),e.toneMapped=!1,this._style.dashedLine&&(e.dashSize=1,e.gapSize=1,e.dashScale=10),e.linewidth=2,e.worldUnits=!1,e.resolution=new Me(256,256),e.opacity=this._style.lineOpacity!==void 0?this._style.lineOpacity:$r.lineOpacity,e.transparent=e.opacity<1,e.depthTest=!1,e}getPointMaterial(e){const t=new Wi({color:e||this._style.pointColor},["BILLBOARD_FIXED"]);return t.opacity=this._style.pointOpacity!==void 0?this._style.pointOpacity:$r.pointOpacity,t.transparent=t.opacity<1,t.color.convertSRGBToLinear(),t.toneMapped=!1,t.depthTest=!1,t.billboardPixelHeight=(this._style.pointPixelHeight!==void 0?this._style.pointPixelHeight:$r.pointPixelHeight)*window.devicePixelRatio,t.userData.billboardPos.value.copy(this.point.position),t}getTextMaterial(){const e=new Bi({color:this._style.textColor,opacity:1,side:Qt},["BILLBOARD_FIXED"]);return e.toneMapped=!1,e.color.convertSRGBToLinear(),e.opacity=this._style.textOpacity!==void 0?this._style.textOpacity:$r.textOpacity,e.transparent=e.opacity<1,e.depthTest=!1,e.billboardPixelHeight=(this._style.textPixelHeight!==void 0?this._style.textPixelHeight:$r.textPixelHeight)*window.devicePixelRatio,e.userData.billboardPos.value.copy(this.text.position),e.getDerivedMaterial()}constructor(e){super(),this.normalIndicatorBuffer=new Float64Array(24),this.normalIndicatorNormal=new T,this.normalIndicatorTangent=new T,this.normalIndicatorBitangent=new T,this._style=Object.assign({},$r),this.layers.set(vt.MEASUREMENTS);const t=new Xo;t.setPositions(new Float32Array(this.normalIndicatorBuffer.length)),t.attributes.instanceStart.data.setUsage(Pr),hn.updateRTEGeometry(t,this.normalIndicatorBuffer),this.normalIndicator=new Tc(t,void 0),this.normalIndicator.computeLineDistances(),this.normalIndicator.name="test-mesurements-normal-indicator",this.normalIndicator.frustumCulled=!1,this.normalIndicator.layers.set(vt.MEASUREMENTS);const n=new Float64Array(18),i=new Xo;i.setPositions(new Float32Array(n)),i.attributes.instanceStart.data.setUsage(Pr),hn.updateRTEGeometry(i,n),this.line=new Tc(i,void 0),this.line.computeLineDistances(),this.line.name="test-mesurements-line",this.line.frustumCulled=!1,this.line.renderOrder=0,this.line.layers.set(vt.MEASUREMENTS);const r=new jv(1,16);this.point=new gn(r,void 0),this.point.layers.set(vt.MEASUREMENTS),this.point.visible=!1,this.point.renderOrder=1;const a=new gn(r,this.getPointMaterial(16777215));a.renderOrder=2,a.material.billboardPixelHeight=(this._style.pointPixelHeight!==void 0?this._style.pointPixelHeight:$r.pointPixelHeight)*window.devicePixelRatio-2*window.devicePixelRatio,a.layers.set(vt.MEASUREMENTS),this.point.add(a),this.text=new ic(ci.generateUUID(),vt.MEASUREMENTS),this.text.textMesh.material=null,this.add(this.point),this.add(this.normalIndicator),this.add(this.line),this.add(this.text),this.style=e||$r}enable(e,t,n,i){this.normalIndicator.visible=e,this.line.visible=t,this.point.visible=n,this.text.visible=i,this.text.textMesh.visible=i,this.line.material.visible=t}frameUpdate(e,t){let n=0;const i=this._style.normalIndicatorPixelSize!==void 0?this._style.normalIndicatorPixelSize:$r.normalIndicatorPixelSize;if(e instanceof li){const o=e.position.distanceTo(this.normalIndicator.position),l=ci.degToRad(e.fov);n=i*(2*o*Math.tan(l/2)/t.y)/2}else e instanceof Xr&&(n=i*((e.top-e.bottom)/t.y)/2);Vi.copy(this.normalIndicator.position).addScaledVector(this.normalIndicatorTangent,n).addScaledVector(this.normalIndicatorBitangent,-n),Vi.toArray(this.normalIndicatorBuffer,0),Vi.copy(this.normalIndicator.position).addScaledVector(this.normalIndicatorTangent,-n).addScaledVector(this.normalIndicatorBitangent,-n),Vi.toArray(this.normalIndicatorBuffer,3),Vi.copy(this.normalIndicator.position).addScaledVector(this.normalIndicatorTangent,-n).addScaledVector(this.normalIndicatorBitangent,-n),Vi.toArray(this.normalIndicatorBuffer,6),Vi.copy(this.normalIndicator.position).addScaledVector(this.normalIndicatorTangent,-n).addScaledVector(this.normalIndicatorBitangent,n),Vi.toArray(this.normalIndicatorBuffer,9),Vi.copy(this.normalIndicator.position).addScaledVector(this.normalIndicatorTangent,-n).addScaledVector(this.normalIndicatorBitangent,n),Vi.toArray(this.normalIndicatorBuffer,12),Vi.copy(this.normalIndicator.position).addScaledVector(this.normalIndicatorTangent,n).addScaledVector(this.normalIndicatorBitangent,n),Vi.toArray(this.normalIndicatorBuffer,15),Vi.copy(this.normalIndicator.position).addScaledVector(this.normalIndicatorTangent,n).addScaledVector(this.normalIndicatorBitangent,n),Vi.toArray(this.normalIndicatorBuffer,18),Vi.copy(this.normalIndicator.position).addScaledVector(this.normalIndicatorTangent,n).addScaledVector(this.normalIndicatorBitangent,-n),Vi.toArray(this.normalIndicatorBuffer,21);const r=this.normalIndicator.geometry.attributes.instanceStart.data,a=this.normalIndicator.geometry.attributes.instanceStartLow.data;hn.DoubleToHighLowBuffer(this.normalIndicatorBuffer,a.array,r.array),r.needsUpdate=!0,a.needsUpdate=!0,this.normalIndicator.geometry.computeBoundingBox(),this.normalIndicator.geometry.computeBoundingSphere(),this.normalIndicator.computeLineDistances()}updateNormalIndicator(e,t){this.normalIndicator.position.copy(e),this.normalIndicatorNormal.copy(t),Math.abs(t.x)>Math.abs(t.z)?this.normalIndicatorTangent.set(-t.y,t.x,0):this.normalIndicatorTangent.set(0,-t.z,t.y),this.normalIndicatorTangent.normalize(),this.normalIndicatorBitangent.crossVectors(this.normalIndicatorNormal,this.normalIndicatorTangent).normalize()}updatePoint(e){this.point.position.copy(e),this.point.material.userData.billboardPos.value.copy(this.point.position),this.point.children[0].material.userData.billboardPos.value.copy(this.point.position)}updateLine(e){const t=new Float64Array(3*e.length);e.forEach((r,a)=>{r.toArray(t,3*a)});const n=this.line.geometry.attributes.instanceStart.data,i=this.line.geometry.attributes.instanceStartLow.data;hn.DoubleToHighLowBuffer(t,i.array,n.array),n.needsUpdate=!0,n.updateRange={offset:0,count:3*e.length},i.needsUpdate=!0,i.updateRange={offset:0,count:3*e.length},this.line.visible=!0,this.line.geometry.instanceCount=e.length/2,this.line.geometry.attributes.instanceStart.needsUpdate=!0,this.line.geometry.attributes.instanceEnd.needsUpdate=!0,this.line.geometry.attributes.instanceStartLow.needsUpdate=!0,this.line.geometry.attributes.instanceEndLow.needsUpdate=!0,this.line.geometry.computeBoundingBox(),this.line.geometry.computeBoundingSphere(),this.line.computeLineDistances()}updateText(e,t,n,i){return this.text.update({textValue:e,height:1,anchorX:"50%",anchorY:"50%"}).then(()=>{this.text.style={backgroundColor:new ot(294651),billboard:!0,backgroundPixelHeight:20},this.text.setTransform(t,n,i),this.text.backgroundMesh&&(this.text.backgroundMesh.renderOrder=3),this.text.textMesh.renderOrder=4}).catch(r=>{dt.log(`Could not update text: ${r}`)})}updateStyle(){this.normalIndicator.material=this.getNormalIndicatorMaterial(),this.line.material=this.getLineMaterial(),this.point.material=this.getPointMaterial(),this.text.textMesh.material=this.getTextMaterial()}raycast(e,t){this.text.raycast(e,t)}updateClippingPlanes(e){var t;this.normalIndicator.material.clippingPlanes=e,this.point.material.clippingPlanes=e,this.point.children[0].material.clippingPlanes=e,this.line.material.clippingPlanes=e,this.text.backgroundMesh&&(this.text.backgroundMesh.material.clippingPlanes=e),this.text.textMesh&&(((t=this.text.textMesh)===null||t===void 0?void 0:t.material).clippingPlanes=e)}}const mf=new T,cu=new T,cS=new T,uS=new T,iz=new T,zl=new T,rz=new Ft,hS=new Ft,sz=new Ft,az=new Me;class oz extends Xp{set isVisible(e){var t,n;(t=this.startGizmo)===null||t===void 0||t.enable(e,e,e,e),(n=this.endGizmo)===null||n===void 0||n.enable(e,e,e,e)}get bounds(){return new Tt().expandByPoint(this.startPoint).expandByPoint(this.midPoint)}constructor(){super(),this.startGizmo=null,this.endGizmo=null,this.normalIndicatorPixelSize=15*window.devicePixelRatio,this.flipStartNormal=!1,this.midPoint=new T,this.type="PerpendicularMeasurement",this.startPoint.set(NaN,NaN,NaN),this.startGizmo=new Jo,this.endGizmo=new Jo({dashedLine:!0,lineOpacity:.25}),this.startLineLength=.25,this.add(this.startGizmo),this.add(this.endGizmo),this.layers.set(vt.MEASUREMENTS)}frameUpdate(e,t,n){var i,r;super.frameUpdate(e,t,n),(i=this.startGizmo)===null||i===void 0||i.frameUpdate(e,t),(r=this.endGizmo)===null||r===void 0||r.frameUpdate(e,t),this._state===pn.DANGLING_START&&this.update()}locationUpdated(e,t){if(this.state===pn.DANGLING_START)this.startPoint.copy(e),this.startNormal.copy(t);else if(this.state===pn.DANGLING_END){const n=new T().subVectors(e,this.startPoint).normalize().dot(this.startNormal);this.flipStartNormal=n<0,this.endPoint.copy(e),this.endNormal.copy(t)}}locationSelected(){this.state===pn.DANGLING_START?this.state=pn.DANGLING_END:this.state===pn.DANGLING_END&&(this.state=pn.COMPLETE)}update(){var e,t,n,i,r,a,o,l,c,u,h;let d=Promise.resolve();if(isNaN(this.startPoint.length())||!this.renderingCamera)return d;if((e=this.startGizmo)===null||e===void 0||e.updateNormalIndicator(this.startPoint,this.startNormal),(t=this.startGizmo)===null||t===void 0||t.updatePoint(this.startPoint),(n=this.endGizmo)===null||n===void 0||n.updateNormalIndicator(this.endPoint,this.endNormal),this._state===pn.DANGLING_START){const f=mf.copy(this.startPoint),v=rz.set(this.startPoint.x,this.startPoint.y,this.startPoint.z,1).applyMatrix4(this.renderingCamera.matrixWorldInverse).applyMatrix4(this.renderingCamera.projectionMatrix),g=v.w;v.multiplyScalar(1/g);const m=hS.set(this.startNormal.x,this.startNormal.y,this.startNormal.z,0).applyMatrix4(this.renderingCamera.matrixWorldInverse).applyMatrix4(this.renderingCamera.projectionMatrix).normalize(),x=az.set(this.normalIndicatorPixelSize/this.renderingSize.x*2,this.normalIndicatorPixelSize/this.renderingSize.y*2),w=sz.set(v.x,v.y,v.z,1).add(hS.set(m.x*x.x,m.y*x.y,0,0));w.multiplyScalar(g),w.applyMatrix4(this.renderingCamera.projectionMatrixInverse).applyMatrix4(this.renderingCamera.matrixWorld),(i=this.startGizmo)===null||i===void 0||i.updateLine([f,cu.set(w.x,w.y,w.z)]),(r=this.endGizmo)===null||r===void 0||r.enable(!1,!1,!1,!1)}if(this._state===pn.DANGLING_END){zl.copy(this.startNormal),this.flipStartNormal&&zl.negate();const f=this.startPoint.distanceTo(this.endPoint),v=mf.copy(this.startPoint).sub(this.endPoint).normalize();let g=zl.dot(v);const m=Math.acos(Math.min(Math.max(g,-1),1));this.startLineLength=Math.abs(f*Math.cos(m)),this.midPoint.copy(mf.copy(this.startPoint).add(cu.copy(zl).multiplyScalar(this.startLineLength)));const x=cu.copy(this.midPoint).sub(this.endPoint).normalize();this.endLineLength=this.midPoint.distanceTo(this.endPoint),g=this.endNormal.dot(x);const w=Math.acos(Math.min(Math.max(g,-1),1)),S=this.endLineLength*Math.cos(w),b=cu.copy(this.endPoint).add(cS.copy(this.endNormal).multiplyScalar(S)),E=cS.copy(this.startPoint),C=uS.copy(this.startPoint).add(iz.copy(zl).multiplyScalar(this.startLineLength));(a=this.startGizmo)===null||a===void 0||a.updateLine([E,C]);const P=uS.copy(this.endPoint);(o=this.endGizmo)===null||o===void 0||o.updateLine([P,b,b,this.midPoint,this.midPoint,P]),(l=this.endGizmo)===null||l===void 0||l.updatePoint(this.midPoint);const M=mf.copy(this.startPoint).add(cu.copy(zl).multiplyScalar(.5*this.startLineLength));this.value=this.midPoint.distanceTo(this.startPoint),this.startGizmo&&(d=this.startGizmo.updateText(`${(this.value*Qn("m",this.units)).toFixed(this.precision)} ${this.units}`,M)),(c=this.endGizmo)===null||c===void 0||c.enable(!0,!0,!0,!0)}return this._state===pn.COMPLETE&&(this.startGizmo&&(d=this.startGizmo.updateText(`${(this.value*Qn("m",this.units)).toFixed(this.precision)} ${this.units}`)),(u=this.startGizmo)===null||u===void 0||u.enable(!1,!0,!0,!0),(h=this.endGizmo)===null||h===void 0||h.enable(!1,!1,!0,!1)),d}raycast(e,t){var n,i;const r=[];(n=this.startGizmo)===null||n===void 0||n.raycast(e,r),(i=this.endGizmo)===null||i===void 0||i.raycast(e,r),r.length&&t.push({distance:r[0].distance,face:r[0].face,faceIndex:r[0].faceIndex,object:this,point:r[0].point,uv:r[0].uv})}highlight(e){this.startGizmo&&(this.startGizmo.highlight=e),this.endGizmo&&(this.endGizmo.highlight=e)}updateClippingPlanes(e){this.startGizmo&&this.startGizmo.updateClippingPlanes(e),this.endGizmo&&this.endGizmo.updateClippingPlanes(e)}}const dS=new T,fS=new T,pS=new T,lz=new T,cz=new T;class uz extends Xp{set isVisible(e){var t,n;(t=this.startGizmo)===null||t===void 0||t.enable(e,e,e,e),(n=this.endGizmo)===null||n===void 0||n.enable(e,e,e,e)}constructor(){super(),this.startGizmo=null,this.endGizmo=null,this.type="PointToPointMeasurement",this.startGizmo=new Jo,this.endGizmo=new Jo({dashedLine:!0,lineOpacity:.25}),this.startLineLength=0,this.add(this.startGizmo),this.add(this.endGizmo),this.layers.set(vt.MEASUREMENTS)}frameUpdate(e,t,n){var i,r;super.frameUpdate(e,t,n),(i=this.startGizmo)===null||i===void 0||i.frameUpdate(e,t),(r=this.endGizmo)===null||r===void 0||r.frameUpdate(e,t)}locationUpdated(e,t){this.state===pn.DANGLING_START?(this.startPoint.copy(e),this.startNormal.copy(t)):this.state===pn.DANGLING_END&&(this.endPoint.copy(e),this.endNormal.copy(t))}locationSelected(){this.state===pn.DANGLING_START?this.state=pn.DANGLING_END:this.state===pn.DANGLING_END&&(this.state=pn.COMPLETE)}update(){var e,t,n,i,r,a,o,l,c,u;let h=Promise.resolve();if((e=this.startGizmo)===null||e===void 0||e.updateNormalIndicator(this.startPoint,this.startNormal),(t=this.startGizmo)===null||t===void 0||t.updatePoint(this.startPoint),(n=this.endGizmo)===null||n===void 0||n.updateNormalIndicator(this.endPoint,this.endNormal),this._state===pn.DANGLING_START){const d=dS.copy(this.startPoint),f=fS.copy(this.startPoint).add(pS.copy(this.startNormal).multiplyScalar(this.startLineLength));(i=this.startGizmo)===null||i===void 0||i.updateLine([d,f]),(r=this.endGizmo)===null||r===void 0||r.enable(!1,!1,!1,!1)}if(this._state===pn.DANGLING_END){this.startLineLength=this.startPoint.distanceTo(this.endPoint),this.value=this.startLineLength;const d=dS.copy(this.endPoint).sub(this.startPoint).normalize(),f=fS.copy(this.startPoint).add(pS.copy(d).multiplyScalar(this.startLineLength)),v=lz.copy(this.startPoint).add(cz.copy(d).multiplyScalar(.5*this.startLineLength));(a=this.startGizmo)===null||a===void 0||a.updateLine([this.startPoint,f]),(o=this.endGizmo)===null||o===void 0||o.updatePoint(f),this.startGizmo&&(h=this.startGizmo.updateText(`${(this.value*Qn("m",this.units)).toFixed(this.precision)} ${this.units}`,v)),(l=this.endGizmo)===null||l===void 0||l.enable(!0,!0,!0,!0)}return this._state===pn.COMPLETE&&((c=this.startGizmo)===null||c===void 0||c.enable(!1,!0,!0,!0),(u=this.endGizmo)===null||u===void 0||u.enable(!1,!1,!0,!1),this.startGizmo&&(h=this.startGizmo.updateText(`${(this.value*Qn("m",this.units)).toFixed(this.precision)} ${this.units}`))),h}raycast(e,t){var n,i;const r=[];(n=this.startGizmo)===null||n===void 0||n.raycast(e,r),(i=this.endGizmo)===null||i===void 0||i.raycast(e,r),r.length&&t.push({distance:r[0].distance,face:r[0].face,faceIndex:r[0].faceIndex,object:this,point:r[0].point,uv:r[0].uv})}highlight(e){this.startGizmo&&(this.startGizmo.highlight=e),this.endGizmo&&(this.endGizmo.highlight=e)}updateClippingPlanes(e){this.startGizmo&&this.startGizmo.updateClippingPlanes(e),this.endGizmo&&this.endGizmo.updateClippingPlanes(e)}}const hz=new T,dz=new T,fz=new T;class mS extends Xp{set isVisible(e){this.pointGizmos.forEach(t=>{t.enable(e,e,e,e)})}get bounds(){const e=new Tt;return this.polygonPoints.forEach(t=>e.expandByPoint(t)),e}constructor(){super(),this.pointGizmos=[],this.surfacePoint=new T,this.surfaceNormal=new T,this.planeOrigin=new T,this.planeNormal=new T,this.labelPoint=new T,this.pointIndex=0,this.points=[],this.measuredPoints=[],this.polygonPoints=[],this.snapDistance=10,this.type="AreaMeasurement";const e=new Jo;e.enable(!1,!0,!0,!1),this.pointGizmos.push(e),this.add(this.pointGizmos[0]),this.layers.set(vt.MEASUREMENTS),this.polygonPoints.push(new T)}frameUpdate(e,t,n){super.frameUpdate(e,t,n),this.pointGizmos.forEach(i=>{i.frameUpdate(e,t)})}locationUpdated(e,t){this.surfacePoint.copy(e),this.surfaceNormal.copy(t),this.projectOnPlane(this.surfacePoint,this.planeOrigin,this.planeNormal,this.polygonPoints[0]),this.updateFillPolygon(this.polygonPoints)}locationSelected(){this.pointIndex===0&&(this.planeOrigin.copy(this.surfacePoint),this.planeNormal.copy(this.surfaceNormal)),this.addPoint()}addPoint(){const e=new T().copy(this.surfacePoint);this.pointIndex>0&&(e.copy(this.projectOnPlane(this.surfacePoint,this.planeOrigin,this.planeNormal)),this.surfacePoint.distanceTo(this.points[0])<1e-10&&(this._state=pn.COMPLETE,e.copy(this.measuredPoints[0]),this.surfacePoint.copy(this.points[0])));const t=new Jo;return t.enable(!1,!0,!0,!1),this.pointGizmos.push(t),this.add(t),this.points.push(this.surfacePoint.clone()),this.measuredPoints.push(e),this.polygonPoints.push(e),this.pointIndex++,this.update(),this.points.length>=2&&(this.projectOnPlane(this.surfacePoint,this.planeOrigin,this.planeNormal,this.polygonPoints[0]),this.updateFillPolygon(this.polygonPoints),this.updateLabelLocation(this.measuredPoints)),this.points.length}removePoint(){return this.pointIndex<1?0:(this.remove(this.pointGizmos.pop()),this.points.pop(),this.measuredPoints.pop(),this.polygonPoints.pop(),this.pointIndex--,this.update(),this.updateFillPolygon(this.polygonPoints),this.updateLabelLocation(this.measuredPoints),this.points.length)}autoFinish(){this.surfacePoint.copy(this.planeOrigin),this.surfaceNormal.copy(this.planeNormal),this.locationSelected()}snap(e,t,n,i){if(this.pointIndex<2)return!1;const r=new T().copy(this.points[0]).project(this.renderingCamera);r.set((.5*r.x+.5)*this.renderingSize.x,(-.5*r.y+.5)*this.renderingSize.y,0);const a=new T((.5*e.x+.5)*this.renderingSize.x,(-.5*e.y+.5)*this.renderingSize.y,0);return r.distanceTo(a)<this.snapDistance*window.devicePixelRatio&&(n.copy(this.points[0]),i.copy(this.planeNormal),!0)}update(){let e=Promise.resolve();if(this.pointGizmos[this.pointIndex].updateNormalIndicator(this.surfacePoint,this.surfaceNormal),this.pointGizmos[this.pointIndex].updatePoint(this.surfacePoint),this.pointIndex===0)return this.pointGizmos[this.pointIndex].enable(!0,!0,!0,!1),e;const t=this.surfacePoint,n=this.points[this.pointIndex-1];return this.pointGizmos[this.pointIndex].updateLine([n,t]),this.pointGizmos[this.pointIndex].enable(!0,!0,!0,!1),this.pointGizmos[this.pointIndex-1].enable(!1,!0,!0,!1),this.measuredPoints.length>1&&(this.value=this.shoelaceArea3D(this.polygonPoints,this.planeNormal),e=this.pointGizmos[0].updateText(`${(this.value*Qn("m",this.units)).toFixed(this.precision)} ${this.units}²`,this.labelPoint),this.pointGizmos[0].enable(!1,!0,!0,!0)),this._state===pn.COMPLETE&&(this.pointGizmos[this.pointIndex-1].updateLine([this.points[this.pointIndex-2],this.points[0]]),this.pointGizmos[this.pointIndex-1].enable(!1,!0,!1,!1),this.pointGizmos[this.pointIndex].enable(!1,!1,!1,!1)),e}updateLabelLocation(e){const t=new An().setFromUnitVectors(this.planeNormal,new T(0,0,1)),n=new An().copy(t).invert(),i=new T,r=e.map(o=>(i.copy(o),i.applyQuaternion(t),[i.x,i.y])),a=JO([r],.1);this.labelPoint.set(a[0],a[1],this.planeOrigin.z),this.labelPoint.applyQuaternion(n),this.projectOnPlane(this.labelPoint,this.planeOrigin,this.planeNormal,this.labelPoint)}updateFillPolygon(e){if(!this.fillPolygon){const c=new Wi({color:294651,side:Qt,opacity:.5,transparent:!0,toneMapped:!1});c.color.convertSRGBToLinear(),this.fillPolygon=new gn(new Xt,c),this.fillPolygon.frustumCulled=!1,this.fillPolygon.layers.set(vt.MEASUREMENTS),this.add(this.fillPolygon)}const t=this.fillPolygon.geometry,n=t.getAttribute("position"),i=t.getIndex();if(e.length<3)return void(this.fillPolygon.visible=!1);this.fillPolygon.visible=!0;const[r,a]=this.chooseProjectionAxes(this.planeNormal),o=e.map(c=>new Me(c[r],c[a])),l=hn.triangulatePolygon(o);if(n&&n.count===e.length)e.forEach((c,u)=>c.toArray(n.array,3*u)),n.needsUpdate=!0;else{const c=new Float32Array(3*e.length);e.forEach((h,d)=>h.toArray(c,3*d));const u=new Sn(c,3);u.setUsage(Pr),t.setAttribute("position",u)}i&&i.count===l.length?(i.array.set(l,0),i.needsUpdate=!0):t.setIndex(new Sn(new Uint16Array(l),1)),t.computeBoundingBox()}raycast(e,t){const n=[];this.pointGizmos.forEach(i=>{i.raycast(e,n)}),n.length&&t.push({distance:n[0].distance,face:n[0].face,faceIndex:n[0].faceIndex,object:this,point:n[0].point,uv:n[0].uv})}highlight(e){this.pointGizmos.forEach(t=>{t.highlight=e})}updateClippingPlanes(e){this.pointGizmos.forEach(t=>{t.updateClippingPlanes(e)}),this.fillPolygon.material.clippingPlanes=e}projectOnPlane(e,t,n,i){const r=hz.copy(e),a=dz.copy(t),o=fz.copy(n).normalize(),l=r.sub(a).dot(o);return(i||new T).copy(e).sub(o.multiplyScalar(l))}chooseProjectionAxes(e){const t=e.clone().set(Math.abs(e.x),Math.abs(e.y),Math.abs(e.z));return t.z>=t.x&&t.z>=t.y?["x","y","z"]:t.y>=t.x&&t.y>=t.z?["x","z","y"]:["y","z","x"]}shoelaceArea(e){const t=e.length;if(t<3)return 0;let n=0;for(let i=0;i<t;i++){const r=(i+1)%t;n+=e[i].x*e[r].y-e[r].x*e[i].y}return Math.abs(n)/2}shoelaceArea3D(e,t){const[n,i]=this.chooseProjectionAxes(t),r=e.map(a=>new Me(a[n],a[i]));return this.shoelaceArea(r)}}const pz=new Ft,mz=new Ft,gz=new Ft,vz=new Ft,yz=new Ne,xz=new Ne;class gS extends Xp{set isVisible(e){this.gizmo.visible=e,this.xLabel.visible=e,this.yLabel.visible=e,this.zLabel.visible=e}constructor(){super(),this.xLabelPosition=new T,this.yLabelPosition=new T,this.zLabelPosition=new T,this.pixelsOffX=50*window.devicePixelRatio,this.pixelsOffY=27*window.devicePixelRatio,this.type="PointMeasurement",this.gizmo=new Jo,this.add(this.gizmo),this.xLabel=new ic(ci.generateUUID(),vt.MEASUREMENTS);const e=new Bi({color:16777215,opacity:1,side:Qt},["USE_RTE","BILLBOARD_FIXED"]);e.toneMapped=!1,e.color.convertSRGBToLinear(),e.opacity=1,e.transparent=!1,e.depthTest=!1,e.billboardPixelHeight=17*window.devicePixelRatio,e.userData.billboardPos.value.copy(this.position),this.xLabel.textMesh.material=e.getDerivedMaterial(),this.add(this.xLabel),this.yLabel=new ic(ci.generateUUID(),vt.MEASUREMENTS);const t=new Bi({color:16777215,opacity:1,side:Qt},["USE_RTE","BILLBOARD_FIXED"]);t.toneMapped=!1,t.color.convertSRGBToLinear(),t.opacity=1,t.transparent=!1,t.depthTest=!1,t.billboardPixelHeight=17*window.devicePixelRatio,t.userData.billboardPos.value.copy(this.position),this.yLabel.textMesh.material=t.getDerivedMaterial(),this.add(this.yLabel),this.zLabel=new ic(ci.generateUUID(),vt.MEASUREMENTS);const n=new Bi({color:16777215,opacity:1,side:Qt},["USE_RTE","BILLBOARD_FIXED"]);n.toneMapped=!1,n.color.convertSRGBToLinear(),n.opacity=1,n.transparent=!1,n.depthTest=!1,n.billboardPixelHeight=17*window.devicePixelRatio,n.userData.billboardPos.value.copy(this.position),this.zLabel.textMesh.material=n.getDerivedMaterial(),this.add(this.zLabel),this.layers.set(vt.MEASUREMENTS)}frameUpdate(e,t,n){super.frameUpdate(e,t,n),this.updateLabelPositions(),this.xLabel.setTransform(this.xLabelPosition),this.yLabel.setTransform(this.yLabelPosition),this.zLabel.setTransform(this.zLabelPosition),this.gizmo.frameUpdate(e,t)}locationUpdated(e,t){this.startPoint.copy(e),this.startNormal.copy(t)}locationSelected(){this.state===pn.DANGLING_START&&(this.state=pn.COMPLETE)}updateLabelPositions(){const e=this.renderingCamera;if(!e)return;const t=pz.set(this.startPoint.x,this.startPoint.y,this.startPoint.z,1);t.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);const n=t.w;t.multiplyScalar(1/n);const i=this.pixelsOffX/this.renderingSize.x*2,r=this.pixelsOffY/this.renderingSize.y*2,a=mz.set(t.x+i,t.y+r,t.z,1),o=gz.set(t.x+i,t.y,t.z,1),l=vz.set(t.x+i,t.y-r,t.z,1),c=yz.copy(e.projectionMatrix).invert(),u=xz.copy(e.matrixWorldInverse).invert();a.multiplyScalar(n),a.applyMatrix4(c),a.applyMatrix4(u),o.multiplyScalar(n),o.applyMatrix4(c),o.applyMatrix4(u),l.multiplyScalar(n),l.applyMatrix4(c),l.applyMatrix4(u),this.xLabelPosition.set(a.x,a.y,a.z),this.yLabelPosition.set(o.x,o.y,o.z),this.zLabelPosition.set(l.x,l.y,l.z)}async update(){const e=this.xLabel.update({textValue:`x : ${(this.startPoint.x*Qn("m",this.units)).toFixed(this.precision)} ${this.units}`,height:1,anchorX:"0%",anchorY:"50%"}).then(()=>{this.xLabel.style={backgroundColor:new ot(16450564),billboard:!0,backgroundPixelHeight:20},this.xLabel.setTransform(this.xLabelPosition),this.xLabel.backgroundMesh&&(this.xLabel.backgroundMesh.renderOrder=3),this.xLabel.textMesh.renderOrder=4}),t=this.yLabel.update({textValue:`y : ${(this.startPoint.y*Qn("m",this.units)).toFixed(this.precision)} ${this.units}`,height:1,anchorX:"0%",anchorY:"50%"}).then(()=>{this.yLabel.style={backgroundColor:new ot(248067),billboard:!0,backgroundPixelHeight:20},this.yLabel.setTransform(this.yLabelPosition),this.yLabel.backgroundMesh&&(this.yLabel.backgroundMesh.renderOrder=3),this.yLabel.textMesh.renderOrder=4}),n=this.zLabel.update({textValue:`z : ${(this.startPoint.z*Qn("m",this.units)).toFixed(this.precision)} ${this.units}`,height:1,anchorX:"0%",anchorY:"50%"}).then(()=>{this.zLabel.style={backgroundColor:new ot(294651),billboard:!0,backgroundPixelHeight:20},this.zLabel.setTransform(this.zLabelPosition),this.zLabel.backgroundMesh&&(this.zLabel.backgroundMesh.renderOrder=3),this.zLabel.textMesh.renderOrder=4});this.gizmo.updateNormalIndicator(this.startPoint,this.startNormal),this.gizmo.updatePoint(this.startPoint),this.gizmo.enable(!0,!1,!0,!1),this.value=this.startPoint.length(),await Promise.all([e,t,n])}raycast(e,t){const n=[];this.gizmo.raycast(e,n),this.xLabel.raycast(e,n),this.yLabel.raycast(e,n),this.zLabel.raycast(e,n),n.length&&t.push({distance:n[0].distance,face:n[0].face,faceIndex:n[0].faceIndex,object:this,point:n[0].point,uv:n[0].uv})}highlight(e){this.gizmo&&(this.gizmo.highlight=e),e?(this.xLabel.textMesh.material.color.copy(new ot(16711680)),this.yLabel.textMesh.material.color.copy(new ot(16711680)),this.zLabel.textMesh.material.color.copy(new ot(16711680))):(this.xLabel.textMesh.material.color.copy(new ot(16777215)),this.yLabel.textMesh.material.color.copy(new ot(16777215)),this.zLabel.textMesh.material.color.copy(new ot(16777215)))}updateClippingPlanes(e){var t,n,i;this.gizmo.updateClippingPlanes(e),this.xLabel.backgroundMesh&&(this.xLabel.backgroundMesh.material.clippingPlanes=e),this.xLabel.textMesh&&(((t=this.xLabel.textMesh)===null||t===void 0?void 0:t.material).clippingPlanes=e),this.yLabel.backgroundMesh&&(this.yLabel.backgroundMesh.material.clippingPlanes=e),this.yLabel.textMesh&&(((n=this.yLabel.textMesh)===null||n===void 0?void 0:n.material).clippingPlanes=e),this.zLabel.backgroundMesh&&(this.zLabel.backgroundMesh.material.clippingPlanes=e),this.zLabel.textMesh&&(((i=this.zLabel.textMesh)===null||i===void 0?void 0:i.material).clippingPlanes=e)}}var Gr;(function(s){s[s.PERPENDICULAR=0]="PERPENDICULAR",s[s.POINTTOPOINT=1]="POINTTOPOINT",s[s.AREA=2]="AREA",s[s.POINT=3]="POINT"})(Gr||(Gr={}));const uu={visible:!0,type:Gr.POINT,vertexSnap:!0,units:"m",precision:2,chain:!1};class wz extends Qp{get inject(){return[Zu]}get enabled(){return this._enabled}set enabled(e){this._enabled=e,this._activeMeasurement&&(this._activeMeasurement.isVisible=e,this._activeMeasurement.update(),e||this.cancelMeasurement()),this.viewer.requestRender()}get options(){return this._options}set options(e){const t=this._options.type!==e.type&&this._activeMeasurement&&this._activeMeasurement.state===pn.DANGLING_START;Object.assign(this._options,e),t&&this.cancelMeasurement(),this.applyOptions()}get selectedMeasurement(){return this._selectedMeasurement}get activeMeasurement(){return this._activeMeasurement}constructor(e,t){super(e),this.cameraProvider=t,this.measurements=[],this._activeMeasurement=null,this._selectedMeasurement=null,this._options=Object.assign({},uu),this._frameLock=!1,this._paused=!1,this._sceneHit=!1,this.pointBuff=new T,this.normalBuff=new T,this.screenBuff0=new Me,this.screenBuff1=new Me,this.renderer=e.getRenderer(),this.raycaster=new Ob,this.raycaster.layers.enable(vt.MEASUREMENTS),this.renderer.input.on(Di.PointerMove,this.onPointerMove.bind(this)),this.renderer.input.on(Di.Click,this.onPointerClick.bind(this)),this.renderer.input.on(Di.DoubleClick,this.onPointerDoubleClick.bind(this))}onLateUpdate(){const e=this.renderer.renderingCamera;e&&(this._frameLock=!1,this.renderer.renderer.getDrawingBufferSize(this.screenBuff0),this._activeMeasurement&&this._enabled&&this._activeMeasurement.frameUpdate(e,this.screenBuff0,this.renderer.sceneBox),this.measurements.forEach(t=>{(this._enabled||t instanceof gS)&&t.frameUpdate(e,this.screenBuff0,this.renderer.sceneBox)}),this._enabled&&this.updateClippingPlanes(this.renderer.clippingPlanes))}onResize(){this.renderer.renderer.getDrawingBufferSize(this.screenBuff0)}onPointerMove(e){var t;if(!this._enabled||this._paused)return;const n=this.renderer.renderingCamera;if(!n||this._frameLock)return;let i=this.renderer.intersections.intersect(this.renderer.scene,n,e,vt.STREAM_CONTENT_MESH,!0,this.renderer.clippingVolume)||[];if(i=i.filter(a=>{const o=a.object.getBatchObjectMaterial(a.batchObject);return o&&!(o instanceof Cu)&&o.visible}),!i.length)return void(this._sceneHit=!1);this.pointBuff.copy(i[0].point),this.normalBuff.copy(i[0].face.normal);let r=this._options.vertexSnap;this._activeMeasurement&&this._activeMeasurement.snap&&(r=!this._activeMeasurement.snap(e,i[0],this.pointBuff,this.normalBuff)),r&&this.snap(i[0],this.pointBuff,this.normalBuff),this._activeMeasurement||(this._activeMeasurement=this.startMeasurement(),this._activeMeasurement.isVisible=!0),(t=this.activeMeasurement)===null||t===void 0||t.locationUpdated(this.pointBuff,this.normalBuff),this._activeMeasurement.update().then(()=>{this.viewer.requestRender()}),this._frameLock=!0,this._sceneHit=!0}onPointerClick(e){if(!this._enabled)return;const t=this.pickMeasurement(e);t?this.selectMeasurement(t,!0):e.event.button!==2?this._activeMeasurement&&this._sceneHit&&(this._activeMeasurement.locationSelected(),this._activeMeasurement.state===pn.COMPLETE&&this.finishMeasurement()):this._activeMeasurement&&this._activeMeasurement instanceof mS?this._activeMeasurement.removePoint()===0&&this.cancelMeasurement():this.cancelMeasurement()}onPointerDoubleClick(e){const t=this.pickMeasurement(e);t?this.cameraProvider.setCameraView(t.bounds,!0):this._options.type!==Gr.PERPENDICULAR?this._options.type===Gr.AREA&&(this._activeMeasurement.autoFinish(),this.finishMeasurement()):this.autoLazerMeasure(e)}autoLazerMeasure(e){if(!this._activeMeasurement||!this.renderer.renderingCamera)return;this._activeMeasurement.state=pn.DANGLING_START;let t=this.renderer.intersections.intersect(this.renderer.scene,this.renderer.renderingCamera,e,vt.STREAM_CONTENT_MESH,!0,this.renderer.clippingVolume)||[];if(t=t.filter(o=>{const l=o.object.getBatchObjectMaterial(o.batchObject);return l&&!(l instanceof Cu)&&l.visible}),!t.length)return;const n=new T().copy(t[0].point),i=new T().copy(t[0].face.normal),r=new T().copy(n).add(new T().copy(i).multiplyScalar(1e-6));let a=this.renderer.intersections.intersectRay(this.renderer.scene,this.renderer.renderingCamera,new Ti(r,i),vt.STREAM_CONTENT_MESH,!0,this.renderer.clippingVolume)||[];a=a.filter(o=>{const l=o.object.getBatchObjectMaterial(o.batchObject);return l&&!(l instanceof Cu)&&l.visible}),a.length?(this._activeMeasurement.startPoint.copy(n),this._activeMeasurement.startNormal.copy(i),this._activeMeasurement.endPoint.copy(a[0].point),this._activeMeasurement.endNormal.copy(a[0].face.normal),this._activeMeasurement.state=pn.DANGLING_END,this._activeMeasurement.update().then(()=>{this.finishMeasurement()})):this.flashMeasurement()}startMeasurement(){let e;if(this._options.type===Gr.PERPENDICULAR)e=new oz;else if(this._options.type===Gr.POINTTOPOINT)e=new uz;else if(this._options.type===Gr.AREA)e=new mS;else{if(this._options.type!==Gr.POINT)throw new Error("Unsupported measurement type!");e=new gS}return e.state=pn.DANGLING_START,e.units=this._options.units!==void 0?this._options.units:uu.units,e.precision=this._options.precision!==void 0?this._options.precision:uu.precision,e.frameUpdate(this.renderer.renderingCamera,this.screenBuff0,this.renderer.sceneBox),this.renderer.scene.add(e),e}cancelMeasurement(){this._activeMeasurement&&this.renderer.scene.remove(this._activeMeasurement),this._activeMeasurement=null,this.viewer.requestRender()}finishMeasurement(){if(this._activeMeasurement){if(this._activeMeasurement.update(),this._activeMeasurement.value>0?this.measurements.push(this._activeMeasurement):(this.renderer.scene.remove(this._activeMeasurement),dt.error("Ignoring zero value measurement!")),this._options.chain){const e=new T,t=new T;let n;this._options.type===Gr.PERPENDICULAR?(n=this._activeMeasurement,e.copy(n.midPoint),t.copy(n.startNormal)):(n=this._activeMeasurement,e.copy(this.pointBuff),t.copy(this.normalBuff)),this._activeMeasurement=this.startMeasurement(),this._activeMeasurement.locationUpdated(e,t),this._activeMeasurement.locationSelected()}else this._activeMeasurement=null;this.viewer.requestRender()}}removeMeasurement(){this._selectedMeasurement?(this.measurements.splice(this.measurements.indexOf(this._selectedMeasurement),1),this.renderer.scene.remove(this._selectedMeasurement),this._selectedMeasurement=null,this.viewer.requestRender()):this.cancelMeasurement()}clearMeasurements(){this.removeMeasurement(),this.measurements.forEach(e=>{this.renderer.scene.remove(e)}),this.measurements=[],this.viewer.requestRender()}flashMeasurement(){let e=0;const t=setInterval(()=>{this._activeMeasurement&&(this._activeMeasurement.highlight(!!(e++%2)),e>=5&&clearInterval(t),this.viewer.requestRender())},100)}pickMeasurement(e){var t;return this.renderer.renderingCamera?(this.measurements.forEach(n=>{n.highlight(!1)}),this.raycaster.setFromCamera(e,this.renderer.renderingCamera),(t=this.raycaster.intersectObjects(this.measurements,!1)[0])===null||t===void 0?void 0:t.object):null}selectMeasurement(e,t){this.cancelMeasurement(),e.highlight(t),this._selectedMeasurement=e}snap(e,t,n){if(!this.renderer.renderingCamera)return;const i=e.batchObject.accelerationStructure.getVertexAtIndex(e.face.a).project(this.renderer.renderingCamera),r=e.batchObject.accelerationStructure.getVertexAtIndex(e.face.b).project(this.renderer.renderingCamera),a=e.batchObject.accelerationStructure.getVertexAtIndex(e.face.c).project(this.renderer.renderingCamera),o=e.point.project(this.renderer.renderingCamera),l=[i,r,a];l.sort((d,f)=>o.distanceTo(d)-o.distanceTo(f));const c=this.renderer.NDCToScreen(l[0].x,l[0].y),u=this.renderer.NDCToScreen(o.x,o.y);this.screenBuff0.set(c.x,c.y),this.screenBuff1.set(u.x,u.y);const h=l[0].unproject(this.renderer.renderingCamera);this.screenBuff0.distanceTo(this.screenBuff1)<10*window.devicePixelRatio&&(t.copy(h),n.copy(e.face.normal))}updateClippingPlanes(e){this.measurements.forEach(t=>{t.updateClippingPlanes(e)})}applyOptions(){const e=[this._activeMeasurement,...this.measurements],t=[];e.forEach(n=>{n&&(n.units=this._options.units!==void 0?this._options.units:uu.units,n.precision=this._options.precision!==void 0?this._options.precision:uu.precision,t.push(n.update()))}),this.viewer.getRenderer().enableLayers([vt.MEASUREMENTS],this._options.visible),this._options.visible?this.raycaster.layers.enable(vt.MEASUREMENTS):this.raycaster.layers.disable(vt.MEASUREMENTS),Promise.all(t).then(()=>{this.viewer.requestRender()})}async fromMeasurementData(e,t){const n=this._options.type;this._options.type=Gr.POINTTOPOINT,this._activeMeasurement=this.startMeasurement(),this._activeMeasurement.isVisible=!0,this._activeMeasurement.startPoint.copy(e),this._activeMeasurement.startNormal.copy(new T(0,0,1)),await this._activeMeasurement.update(),this._activeMeasurement.state=pn.DANGLING_END,this._activeMeasurement.endPoint.copy(t),this._activeMeasurement.endNormal.copy(new T(0,0,1)),await this._activeMeasurement.update(),this._options.type=n}}ci.generateUUID(),Eo.OVERLAY;var Ru,In,vS,yS,Iu,xS;(function(s){s.DragStart="section-box-drag-start",s.DragEnd="section-box-drag-end",s.Updated="section-box-changed"})(Ru||(Ru={}));class Sz extends Qp{get inject(){return[Zu]}constructor(e,t){super(e),this.cameraProvider=t}get visible(){return!1}set visible(e){}getBox(){return new Tt}setBox(e,t){}toggle(){this.enabled=!this._enabled}}(function(s){s.POSITIVE_X="POSITIVE_X",s.POSITIVE_Y="POSITIVE_Y",s.POSITIVE_Z="POSITIVE_Z",s.NEGATIVE_X="NEGATIVE_X",s.NEGATIVE_Y="NEGATIVE_Y",s.NEGATIVE_Z="NEGATIVE_Z"})(In||(In={}));class $u extends Qp{get inject(){return[Sz]}constructor(e,t){super(e),this.sectionProvider=t,this.tmpVec=new T,this.up=new T(0,1,0),this.down=new T(0,-1,0),this.left=new T(-1,0,0),this.right=new T(1,0,0),this.forward=new T(0,0,1),this.back=new T(0,0,-1),this.planeOutlines={},this.lastSectionPlanes=[],this.sectionPlanesChanged=[],this.planeOutlines[In.POSITIVE_X]=this.createPlaneOutline(In.POSITIVE_X),this.planeOutlines[In.NEGATIVE_X]=this.createPlaneOutline(In.NEGATIVE_X),this.planeOutlines[In.POSITIVE_Y]=this.createPlaneOutline(In.POSITIVE_Y),this.planeOutlines[In.NEGATIVE_Y]=this.createPlaneOutline(In.NEGATIVE_Y),this.planeOutlines[In.NEGATIVE_Z]=this.createPlaneOutline(In.NEGATIVE_Z),this.planeOutlines[In.POSITIVE_Z]=this.createPlaneOutline(In.POSITIVE_Z);const n=new Er;n.name="SectionBoxOutlines",this.viewer.getRenderer().scene.add(n),n.add(this.getPlaneOutline(In.NEGATIVE_Z).renderable),n.add(this.getPlaneOutline(In.POSITIVE_Z).renderable),n.add(this.getPlaneOutline(In.POSITIVE_X).renderable),n.add(this.getPlaneOutline(In.NEGATIVE_X).renderable),n.add(this.getPlaneOutline(In.POSITIVE_Y).renderable),n.add(this.getPlaneOutline(In.NEGATIVE_Y).renderable),this.lastSectionPlanes.push(new vi,new vi,new vi,new vi,new vi,new vi),this.sectionProvider.on(Ru.DragStart,this.onSectionBoxDragStart.bind(this)),this.sectionProvider.on(Ru.DragEnd,this.onSectionBoxDragEnd.bind(this)),this.sectionProvider.on(Ru.Updated,this.sectionUpdated.bind(this))}getPlaneOutline(e){return this.planeOutlines[e]}get enabled(){return this._enabled}set enabled(e){this._enabled=e;for(const t in this.planeOutlines)this.planeOutlines[t].renderable.visible=e}sectionUpdated(e){this.sectionProvider.enabled||(this.enabled=!1);for(const t in this.planeOutlines){const n=e.filter(i=>this.getPlaneId(i)!==t);this.planeOutlines[t].renderable.material.clippingPlanes=n}}requestUpdate(e=!1){this.setSectionPlaneChanged(this.viewer.getRenderer().clippingPlanes),this.updateOutlines(e?this.viewer.getRenderer().clippingPlanes:this.sectionPlanesChanged)}updatePlaneOutline(e,t,n){const i=new T,r=new T,a=new T,o=new T,l=new T,c=new Mr,u=this.getPlaneId(t);if(!u)return void dt.error("Invalid plane! Aborting section outline update",t.normal);const h=this.planeOutlines[u].renderable;let d=0,f=h.geometry.attributes.instanceStart.data;const v=new Array;for(let m=0;m<e.length;m++){const x=new vi().copy(t);e[m].mesh.TAS.shapecast({intersectsTAS:w=>x.intersectsBox(w),intersectsBounds:w=>x.intersectsBox(w),intersectsTriangle(w,S,b,E,C){if(!C)throw new Error("Null batch object in AS intersection!");const P=e[m].mesh.getBatchObjectMaterial(C);if(P instanceof Cu||P.visible===!1||P===null)return;const M=x;let L=0;c.start.copy(w.a),c.end.copy(w.b),M.intersectLine(c,i)&&(i.add(l.copy(x.normal).multiplyScalar(-n)),v[3*d]=i.x,v[3*d+1]=i.y,v[3*d+2]=i.z,d++,L++),c.start.copy(w.b),c.end.copy(w.c),M.intersectLine(c,i)&&(i.add(l.copy(x.normal).multiplyScalar(-n)),v[3*d]=i.x,v[3*d+1]=i.y,v[3*d+2]=i.z,L++,d++),c.start.copy(w.c),c.end.copy(w.a),M.intersectLine(c,i)&&(i.add(l.copy(x.normal).multiplyScalar(-n)),v[3*d]=i.x,v[3*d+1]=i.y,v[3*d+2]=i.z,L++,d++),L===3&&(r.set(v[3*(d-3)],v[3*(d-3)+1],v[3*(d-3)+2]),a.set(v[3*(d-2)],v[3*(d-2)+1],v[3*(d-2)+2]),o.set(v[3*(d-1)],v[3*(d-1)+1],v[3*(d-1)+2]),o.equals(r)||o.equals(a)?(L--,d--):r.equals(a)&&(o.set(i.x,i.y,i.z),o.add(l.copy(x.normal).multiplyScalar(-n)),v[3*(d-2)]=o.x,v[3*(d-2)+1]=o.y,v[3*(d-2)+2]=o.z,L--,d--)),L!==2&&(d-=L)}})}v.length>f.array.length&&(this.resizeGeometryBuffer(this.planeOutlines[u],v.length),console.warn(`Resized outline buffer from ${f.array.length} to ${v.length}. ${v.length/6} instance count`)),f=h.geometry.attributes.instanceStart.data;const g=h.geometry.attributes.instanceStartLow.data;hn.DoubleToHighLowBuffer(v,g.array,f.array),f.needsUpdate=!0,f.updateRange={offset:0,count:3*d},g.needsUpdate=!0,g.updateRange={offset:0,count:3*d},h.visible=!0,h.geometry.instanceCount=d/2,h.geometry.attributes.instanceStart.needsUpdate=!0,h.geometry.attributes.instanceEnd.needsUpdate=!0,h.geometry.attributes.instanceStartLow.needsUpdate=!0,h.geometry.attributes.instanceEndLow.needsUpdate=!0,h.geometry.computeBoundingBox(),h.geometry.computeBoundingSphere()}createPlaneOutline(e){const t=new Float64Array($u.INITIAL_BUFFER_SIZE),n=new Xo;n.setPositions(new Float32Array(t)),n.attributes.instanceStart.data.setUsage(Pr),hn.updateRTEGeometry(n,t);const i=new Ca({color:294651,linewidth:2,worldUnits:!1,vertexColors:!1,alphaToCoverage:!1,resolution:new Me(919,848)},["USE_RTE"]);i.color=new ot(294651),i.color.convertSRGBToLinear(),i.linewidth=2,i.worldUnits=!1,i.resolution=new Me(1513,1306);const r=new Tc(n,i);return r.name=`${e}-outline`,r.frustumCulled=!1,r.renderOrder=1,r.layers.set(vt.PROPS),r.visible=!1,{renderable:r}}onSectionBoxDragStart(){this.enabled=!1}onSectionBoxDragEnd(){this.setSectionPlaneChanged(this.viewer.getRenderer().clippingPlanes),this.updateOutlines(this.sectionPlanesChanged)}setSectionPlaneChanged(e){this.sectionPlanesChanged.length=0;const t=this.viewer.World.getRelativeOffset(1e-4);for(let n=0;n<e.length;n++)(Math.abs(this.lastSectionPlanes[n].constant-e[n].constant)>t||Math.abs(this.lastSectionPlanes[n].normal.length()-e[n].normal.length())>t)&&this.sectionPlanesChanged.push(e[n]),this.lastSectionPlanes[n].copy(e[n])}updateOutlines(e){const t=performance.now(),n=this.viewer.World.getRelativeOffset($u.OUTLINE_Z_OFFSET);for(let i=0;i<e.length;i++)this.updatePlaneOutline(this.viewer.getRenderer().batcher.getBatches(void 0,mt.MESH),e[i],n);this.enabled=this.sectionProvider.enabled,dt.warn("Outline time: ",performance.now()-t)}resizeGeometryBuffer(e,t){e.renderable.geometry.dispose();const n=new Float32Array(t);e.renderable.geometry=new Xo,e.renderable.geometry.setPositions(new Float32Array(n)),e.renderable.geometry.attributes.instanceStart.data.setUsage(Pr),hn.updateRTEGeometry(e.renderable.geometry,n)}getPlaneId(e){this.tmpVec.set(e.normal.x,e.normal.y,e.normal.z);let t=this.sectionProvider.getBox();t instanceof Tt&&(t=new Ki().fromBox3(t));const n=new Ne().setFromMatrix3(t.rotation).invert();return this.tmpVec.applyMatrix4(n).normalize(),this.tmpVec.set(Math.round(this.tmpVec.x),Math.round(this.tmpVec.y),Math.round(this.tmpVec.z)),this.tmpVec.equals(this.right)?In.POSITIVE_X:this.tmpVec.equals(this.left)?In.NEGATIVE_X:this.tmpVec.equals(this.up)?In.POSITIVE_Y:this.tmpVec.equals(this.down)?In.NEGATIVE_Y:this.tmpVec.equals(this.back)?In.NEGATIVE_Z:this.tmpVec.equals(this.forward)?In.POSITIVE_Z:void 0}}$u.OUTLINE_Z_OFFSET=1e-4,$u.INITIAL_BUFFER_SIZE=6e4;(function(s){s[s.HIDE=10]="HIDE",s[s.SHOW=11]="SHOW",s[s.ISOLATE=20]="ISOLATE",s[s.UNISOLATE=21]="UNISOLATE",s[s.NONE=30]="NONE"})(vS||(vS={}));(function(s){s.Finshed="explode-finished"})(yS||(yS={}));class bz{constructor(e,t){this.spoofIDs=!1,this.typeLookupTable={},this.instanceDefinitionLookupTable={},this.instancedObjectsLookupTable={},this.instanceProxies={},this.renderMaterialMap={},this.colorMap={},this.instanceCounter=0,this.NodeConverterMapping={View3D:this.View3DToNode.bind(this),BlockInstance:this.BlockInstanceToNode.bind(this),Pointcloud:this.PointcloudToNode.bind(this),Brep:this.BrepToNode.bind(this),BrepX:this.BrepToNode.bind(this),ExtrusionX:this.BrepToNode.bind(this),SubDX:this.BrepToNode.bind(this),Mesh:this.MeshToNode.bind(this),Point:this.PointToNode.bind(this),Line:this.LineToNode.bind(this),Polyline:this.PolylineToNode.bind(this),Box:this.BoxToNode.bind(this),Polycurve:this.PolycurveToNode.bind(this),Curve:this.CurveToNode.bind(this),Circle:this.CircleToNode.bind(this),Arc:this.ArcToNode.bind(this),Ellipse:this.EllipseToNode.bind(this),RevitInstance:this.RevitInstanceToNode.bind(this),Text:this.TextToNode.bind(this),Dimension:this.DimensionToNode.bind(this),InstanceDefinitionProxy:this.InstanceDefinitionProxyToNode.bind(this),InstanceProxy:this.InstanceProxyToNode.bind(this),RenderMaterialProxy:this.RenderMaterialProxyToNode.bind(this),ColorProxy:this.ColorProxyToNode.bind(this),Region:this.RegionToNode.bind(this),Parameter:null},this.IgnoreNodes=["Parameter"],e||dt.warn("Converter initialized without a corresponding object loader. Any objects that include references will throw errors."),this.objectLoader=e,this.activePromises=0,this.maxChildrenPromises=200,this.tree=t}async traverse(e,t,n,i=null){if(t===null||typeof t!="object")return;t.referencedId&&(t=await this.resolveReference(t));const r=[];if(Array.isArray(t)){for(const c of t){if(typeof c!="object")break;if(this.activePromises>=this.maxChildrenPromises)await this.traverse(e,c,n,i);else{const u=this.traverse(e,c,n,i);r.push(u)}}return this.activePromises+=r.length,await Promise.all(r),void(this.activePromises-=r.length)}if(this.IgnoreNodes.includes(this.getSpeckleType(t))||!t.id)return;const a=this.tree.parse({id:this.getNodeId(t),raw:t,atomic:!0,children:[]});if(i===null?(this.subtree=this.tree.parse({id:e,raw:{id:e,children:[t]},atomic:!0,children:[]}),this.tree.addSubtree(this.subtree),this.tree.addNode(a,this.subtree)):this.tree.addNode(a,i),this.directNodeConverterExists(t))try{return await this.convertToNode(t,a),void await n()}catch(c){dt.warn(`(Traversing - direct) Failed to convert ${this.getSpeckleType(t)} with id: ${t.id}`,c)}const o=t;let l=this.getDisplayValue(o);if(a.model.atomic=!!l,l){if(Array.isArray(l))for(const c of l){const u=await this.resolveReference(c);u.units||(u.units=t.units);const h=this.tree.parse({id:this.getNodeId(u),raw:u,atomic:!1,children:[]});this.tree.addNode(h,a),await this.convertToNode(u,h),await n()}else{l=await this.resolveReference(l),l.units||(l.units=t.units);try{const c=this.tree.parse({id:this.getNodeId(l),raw:l,atomic:!1,children:[]});this.tree.addNode(c,a),await this.convertToNode(l,c),await n()}catch(c){dt.warn(`(Traversing) Failed to convert obj with id: ${t.id} — ${c.message}`)}}if(t.speckle_type.toLowerCase().includes("builtelements")||t.speckle_type.toLowerCase().includes("objects.data")){const c=this.getElementsValue(t);return void(c&&(r.push(this.traverse(e,c,n,a)),this.activePromises+=r.length,await Promise.all(r),this.activePromises-=r.length))}}for(const c in o)if(c!=="__parents"&&c!=="bbox"&&c!=="__closure"&&!["displayMesh","@displayMesh","displayValue","@displayValue"].includes(c)&&typeof o[c]=="object"&&o[c]!==null)if(this.activePromises>=this.maxChildrenPromises)await this.traverse(e,o[c],n,a);else{const u=this.traverse(e,o[c],n,a);r.push(u)}this.activePromises+=r.length,await Promise.all(r),this.activePromises-=r.length}getNodeId(e){return this.spoofIDs?ci.generateUUID():e.id}async dechunk(e){if(!e||e.length===0||!e[0].referencedId)return e;const t=[];for(const n of e){const i=await this.objectLoader.getObject({id:n.referencedId});t.push(i.data)}return[].concat(...t)}async resolveReference(e){return e.referencedId?await this.objectLoader.getObject({id:e.referencedId}):e}getSpeckleType(e){const t=e.speckle_type?e.speckle_type:"Base",n=this.typeLookupTable[t];if(n)return n;let i="Base";const r=this.getSpeckleTypeChain(e);for(const a of r)if(a in this.NodeConverterMapping){i=a;break}return this.typeLookupTable[t]=i,i}getSpeckleTypeChain(e){let t=["Base"];return t=e.speckle_type?e.speckle_type.split(":").reverse():t,t=t.map(n=>n.split(".").reverse()[0]),t}directNodeConverterExists(e){return this.getSpeckleType(e)in this.NodeConverterMapping}async convertToNode(e,t){e.referencedId&&(e=await this.resolveReference(e));try{if(this.directNodeConverterExists(e)){const n=this.NodeConverterMapping[this.getSpeckleType(e)];if(n)return await n(e,t)}return null}catch(n){throw dt.warn(`(Direct convert) Failed to convert object with id: ${e.id}`),n}}getDisplayValue(e){const t=e.displayValue||e["@displayValue"]||e.displayMesh||e["@displayMesh"];if(t){if(Array.isArray(t)){const n=t.filter(i=>i);return t.length!==n.length&&dt.warn(`Object ${e.id} has null display values which will be ignored`),n}return t}return null}getElementsValue(e){return e.elements||e["@elements"]}getBlockDefinition(e){return e["@blockDefinition"]||e.blockDefinition||e.definition||e["@definition"]}getBlockDefinitionGeometry(e){return e["@geometry"]||e.geometry}getCompoundId(e,t){const n=e.indexOf(ir.COMPOUND_ID_CHAR);return n===-1?e+ir.COMPOUND_ID_CHAR+t:e.substring(0,n)+ir.COMPOUND_ID_CHAR+t}getEmptyTransformData(e){return{id:e,speckle_type:"Transform",units:"m",matrix:new Array(16)}}async View3DToNode(e,t){e.origin.units=e.units,e.target.units=e.units}async displayableLookup(e,t,n){if(this.directNodeConverterExists(e))await this.convertToNode(e,t);else{const i=this.getDisplayValue(e),r=this.getElementsValue(e),a=[...i||[],...r||[]];for(const o of a){const l=await this.resolveReference(o),c=this.tree.parse({id:this.getCompoundId(l.id,this.instanceCounter++),raw:l,atomic:!1,children:[],instanced:n});this.tree.addNode(c,t),await this.displayableLookup(l,c,n)}}}async parseInstanceDefinitionGeometry(e,t,n){const i=ci.generateUUID();let r=null;Array.isArray(e.transform)?(r=this.getEmptyTransformData(i),r.units=e.units,r.matrix=e.transform):r=e.transform?e.transform:this.getEmptyTransformData(i);const a=this.tree.parse({id:i,raw:r,atomic:!1,children:[]});this.tree.addNode(a,n);const o=this.tree.parse({id:this.getCompoundId(t.id,this.instanceCounter++),raw:t,atomic:!1,children:[],instanced:!0});this.tree.addNode(o,a),await this.displayableLookup(t,o,!0)}async parseInstanceElement(e,t,n){const i=this.tree.parse({id:this.getNodeId(t),raw:t,atomic:!1,children:[]});this.tree.addNode(i,n),await this.displayableLookup(t,i,!1)}async BlockInstanceToNode(e,t){const n=await this.resolveReference(this.getBlockDefinition(e));t.model.raw.definition=n;for(const r of this.getBlockDefinitionGeometry(n)){const a=await this.resolveReference(r);await this.parseInstanceDefinitionGeometry(e,a,t)}const i=this.getElementsValue(e);if(i)for(const r of i){const a=await this.resolveReference(r);this.parseInstanceElement(e,a,t)}}async RevitInstanceToNode(e,t){const n=await this.resolveReference(e.definition);t.model.raw.definition=n,await this.parseInstanceDefinitionGeometry(e,n,t);const i=this.getElementsValue(e);if(i)for(const r of i){const a=await this.resolveReference(r);this.parseInstanceElement(e,a,t)}}async InstanceDefinitionProxyToNode(e,t){e.applicationId?this.instanceDefinitionLookupTable[e.applicationId]=t:dt.warn(`Instance Definition Proxy ${e.id} has no applicationId`)}async InstanceProxyToNode(e,t){e.applicationId?this.instanceProxies[e.applicationId]=t:dt.warn(`Instance proxy ${e.id} has no application id`)}async RenderMaterialProxyToNode(e,t){if(!e.value)return void dt.error(`Render Material Proxy ${e.id} has no render material value!`);e.objects&&Array.isArray(e.objects)&&e.objects.length!==0||dt.warn(`Render Material Proxy ${e.id} has no target objects!`);const n=e.value,i=e.objects;for(let r=0;r<i.length;r++)this.renderMaterialMap[i[r]]&&dt.error(`Overwritting renderMaterial ${i[r]}`),this.renderMaterialMap[i[r]]=n}async ColorProxyToNode(e,t){if(!e.value||typeof e.value!="number")return void dt.error(`Color ${e.id} has no value, or value is not a number!`);if(!e.objects||!Array.isArray(e.objects)||e.objects.length===0)return void dt.warn(`Color Proxy ${e.id} has no target objects!`);const n=e.objects;for(let i=0;i<n.length;i++)this.colorMap[n[i]]&&dt.error(`Overwritting color ${n[i]}`),this.colorMap[n[i]]=e}getInstanceProxyDefinitionId(e){return e.DefinitionId||e.definitionId}getInstanceProxyTransform(e){return e.transform||e.Transform?e.transform||e.Transform:new Ne().toArray()}getInstanceProxyDefinitionObjects(e){return e.Objects||e.objects}createTransformNode(e){const t=ci.generateUUID(),n=this.getEmptyTransformData(t);return n.units=e.units,n.matrix=this.getInstanceProxyTransform(e),this.tree.parse({id:t,raw:n,atomic:!1,children:[]})}async ConvertInstanceProxyToNode(e,t){const n=this.getInstanceProxyDefinitionId(e);if(!n)return void dt.warn(`Instance Proxy ${e.id} has no definitionId`);const i=this.instanceDefinitionLookupTable[n],r=this.createTransformNode(e);this.tree.addNode(r,t);const a=this.getInstanceProxyDefinitionObjects(i.model.raw);for(const o of a){const l=this.instancedObjectsLookupTable[o];if(!l){dt.warn(`Object ${o} is is missing from definition ${n}. Someone probably sent an instance containing unsopprted elements - this is ok, do not panic.`);continue}const c=this.tree.parse({id:this.getCompoundId(l.id,this.instanceCounter++),raw:l,atomic:!1,children:[],instanced:!0});this.tree.addNode(c,r),await this.convertToNode(l,c)}}async convertInstances(){this.NodeConverterMapping.InstanceProxy=this.ConvertInstanceProxyToNode.bind(this);const e={};let t=0;for(const n in this.instanceDefinitionLookupTable){const i=this.instanceDefinitionLookupTable[n],r=this.getInstanceProxyDefinitionObjects(i.model.raw);for(let a=0;a<r.length;a++)e[r[a].toString()]=null,t++}await this.tree.walkAsync(n=>{if(!n.model.raw.applicationId)return!0;const i=n.model.raw.applicationId.toString();return e[i]!==void 0&&(e[i]=n,t--),t!==0},this.subtree);for(const n in e){const i=e[n];if(i){if(this.instancedObjectsLookupTable[n]=i.model.raw,this.instanceProxies[n]){const r=this.instanceProxies[n].model.raw.definitionId;Object.values(this.instanceProxies).forEach(a=>{a.model.raw.definitionId===r&&(a.model.raw.parentLayerApplicationId=a.parent.model.raw.applicationId)})}else this.instancedObjectsLookupTable[n].parentLayerApplicationId=i.parent.model.raw.applicationId;delete this.instanceProxies[n],this.tree.removeNode(i,!0)}else dt.error(`Consumable applicationId ${n} could not be found`)}for(const n in this.instanceProxies){const i=this.instanceProxies[n];await this.convertToNode(i.model.raw,i)}}async applyMaterials(){const e=Object.keys(this.renderMaterialMap).length,t=Object.keys(this.colorMap).length;if(e!==0||t!==0){await this.tree.walkAsync(n=>{if(!n.model.raw.applicationId)return!0;const i=n.model.raw.applicationId.toString(),r=n.model.raw.parentLayerApplicationId;return this.renderMaterialMap[i]?n.model.raw.renderMaterial=this.renderMaterialMap[i]:this.renderMaterialMap[r]&&(n.model.raw.renderMaterial=this.renderMaterialMap[r]),this.colorMap[i]===void 0||n.model.instanced||(n.model.color=this.colorMap[i].value),!0},this.subtree);for(const n in this.instanceProxies){const i=this.tree.findAll(a=>this.getSpeckleType(a.model.raw)===Bt.InstanceProxy,this.instanceProxies[n]).reduce((a,o)=>a&&a.model.raw.maxDepth>o.model.raw.maxDepth?a:o).model.raw.maxDepth,r=this.tree.findAll(a=>a.model.raw.maxDepth===i,this.instanceProxies[n]);for(let a=0;a<r.length;a++){const o=this.colorMap[r[a].model.raw.applicationId]||this.colorMap[r[a].model.raw.parentLayerApplicationId],l=r[a].children[0].children;for(let c=0;c<l.length;c++){const u=this.colorMap[l[c].model.raw.applicationId],h=this.colorMap[l[c].model.raw.parentLayerApplicationId];if(u){if(u.source==="object"||u.source==="layer")l[c].model.color=u.value;else if(u.source==="block"&&o){if(o.source==="object")l[c].model.color=o.value;else if(o.source==="block"){const d=this.tree.getAncestors(r[a]).find(v=>this.getSpeckleType(v.model.raw)===Bt.InstanceProxy)||r[a],f=this.colorMap[d.model.raw.applicationId];l[c].model.color=f==null?void 0:f.value}}}else l[c].model.color=h==null?void 0:h.value}}}}}async PointcloudToNode(e,t){t.model.raw.points=await this.dechunk(e.points),t.model.raw.colors=await this.dechunk(e.colors)}async BrepToNode(e,t){try{if(!e)return;let n=this.getDisplayValue(e);if(Array.isArray(n)&&(n=n[0]),!n)return;const i=await this.resolveReference(n),r=this.tree.parse({id:t.model.instanced?this.getCompoundId(i.id,this.instanceCounter++):this.getNodeId(i),raw:i,atomic:!1,children:[],...t.model.instanced&&{instanced:t.model.instanced}});await this.convertToNode(i,r),this.tree.addNode(r,t),delete e.Edges,delete e.Faces,delete e.Loops,delete e.Trims,delete e.Curve2D,delete e.Curve3D,delete e.Surfaces,delete e.Vertices}catch(n){throw dt.warn(`Failed to convert brep id: ${e.id}`),n}}async MeshToNode(e,t){e&&(e.vertices&&e.vertices.length!==0?e.faces&&e.faces.length!==0?(t.model.raw.vertices=await this.dechunk(e.vertices),t.model.raw.faces=await this.dechunk(e.faces),t.model.raw.colors=await this.dechunk(e.colors),t.model.raw.vertexNormals=await this.dechunk(e.vertexNormals)):dt.warn(`Object id ${e.id} of type ${e.speckle_type} has no face data and will be ignored`):dt.warn(`Object id ${e.id} of type ${e.speckle_type} has no vertex position data and will be ignored`))}async RegionToNode(e,t){try{if(!e)return;let n=this.getDisplayValue(e);if(Array.isArray(n)&&(n=n[0]),!n)return;const i=await this.resolveReference(n),r=this.tree.parse({id:t.model.instanced?this.getCompoundId(i.id,this.instanceCounter++):this.getNodeId(i),raw:i,atomic:!1,children:[],...t.model.instanced&&{instanced:t.model.instanced}});await this.convertToNode(i,r),this.tree.addNode(r,t)}catch(n){throw dt.warn(`Failed to convert Region id: ${e.id}`),n}}async TextToNode(e,t){}async DimensionToNode(e,t){const n=[...this.getDisplayValue(e)];for(const a of n){const o=this.tree.parse({id:this.getNodeId(a),raw:a,atomic:!1,children:[]});this.tree.addNode(o,t),await this.convertToNode(a,o)}const i=JSON.parse(JSON.stringify(e));switch(i.plane=i.RhinoProps.plane,this.getSpeckleTypeChain(i)[0]){case"LengthDimension":i.plane.origin=i.position;break;case"DistanceDimension":case"AngleDimension":i.plane.origin=i.textPosition}i.speckle_type="Objects.Other.Text";const r=this.tree.parse({id:ci.generateUUID(),raw:i,atomic:!1,children:[]});this.tree.addNode(r,t),await this.convertToNode(i,r)}async PointToNode(e,t){}async LineToNode(e,t){}async PolylineToNode(e,t){t.model.raw.value=await this.dechunk(e.value)}async BoxToNode(e,t){}async PolycurveToNode(e,t){t.model.nestedNodes=[];for(let n=0;n<e.segments.length;n++){let i=e.segments[n];this.directNodeConverterExists(i)||(i=this.getDisplayValue(i),i.referencedId&&(i=await this.resolveReference(i)));const r=this.tree.parse({id:this.getNodeId(i),raw:i,atomic:!1,children:[]});await this.convertToNode(i,r),t.model.nestedNodes.push(r)}}async CurveToNode(e,t){let n=this.getDisplayValue(e);if(!n)return void dt.warn(`Object ${e.id} of type ${e.speckle_type} has no display value and will be ignored`);t.model.nestedNodes=[],n=await this.resolveReference(e.displayValue),n.units=n.units||e.units;const i=this.tree.parse({id:this.getNodeId(n),raw:n,atomic:!1,children:[]});await this.convertToNode(n,i),t.model.nestedNodes.push(i)}async CircleToNode(e,t){}async ArcToNode(e,t){}async EllipseToNode(e,t){}}(function(s){s.LoadProgress="load-progress",s.LoadCancelled="load-cancelled",s.LoadWarning="load-warning"})(Iu||(Iu={}));class Az extends Nh{constructor(e,t){super(),this._resource=e,this._resourceData=t}on(e,t){super.on(e,t)}dispose(){super.dispose()}}class Tz{static triangulateFace(e,t,n){let i=t[e];function r(f){return e+f+1}function a(f){const v=3*t[r(f)];return new Mo(n[v],n[v+1],n[v+2])}i<3&&(i+=3);const o=Array(3*(i-2)),l=new Mo(0,0,0);for(let f=i-1,v=0;v<i;f=v,v++){const g=a(f),m=a(v);l.x+=(m.y-g.y)*(g.z+m.z),l.y+=(m.z-g.z)*(g.x+m.x),l.z+=(m.x-g.x)*(g.y+m.y)}l.normalize();const c=Array(i),u=Array(i);for(let f=0;f<i;f++)c[f]=f-1,u[f]=f+1;c[0]=i-1,u[i-1]=0;let h=0,d=0;for(;i>=3;){let f=!0;if(i>3&&d<i){const v=a(c[h]),g=a(h),m=a(u[h]);if(this.triangleIsCCW(l,v,g,m)){let x=u[u[h]];do{if(this.testPointTriangle(a(x),v,g,m)){f=!1;break}x=u[x]}while(x!==c[h])}else f=!1}if(f){const v=t[r(h)],g=t[r(u[h])],m=t[r(c[h])];o.push(v,g,m),u[c[h]]=u[h],c[u[h]]=c[h],i--,h=c[h],d=0}else h=u[h],d++}return o}static testPointTriangle(e,t,n,i){function r(a,o,l){const c=a.cross(o),u=a.cross(l),h=Number.EPSILON+c.dot(u);return Math.sign(h)!==-1}return r(n.sub(t),e.sub(t),i.sub(t))&&r(i.sub(n),e.sub(n),t.sub(n))&&r(t.sub(i),e.sub(i),n.sub(i))}static triangleIsCCW(e,t,n,i){const r=i.sub(t).cross(n.sub(t));return r.normalize(),e.dot(r)>0}}class Mo{constructor(e,t,n){this.x=e,this.y=t,this.z=n}add(e){return new Mo(this.x+e.x,this.y+e.y,this.z+e.z)}sub(e){return new Mo(this.x-e.x,this.y-e.y,this.z-e.z)}mul(e){return new Mo(this.x-e,this.y-e,this.z-e)}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}cross(e){const t=this.y*e.z-this.z*e.y,n=this.z*e.x-this.x*e.z,i=this.x*e.y-this.y*e.x;return new Mo(t,n,i)}squareSum(){return this.x*this.x+this.y*this.y+this.z*this.z}normalize(){const e=1/Math.sqrt(this.squareSum());this.x*=e,this.y*=e,this.z*=e}}class Ez extends CN{constructor(){super(...arguments),this.typeLookupTable={},this.meshTriangulationTime=0,this.actualTriangulateTime=0,this.pushTime=0}getSpeckleType(e){const t=e.raw.speckle_type?e.raw.speckle_type:"Base",n=this.typeLookupTable[t];if(n)return n;let i=Bt.Unknown,r=[];r=t.split(":").reverse(),r=r.map(a=>a.split(".").reverse()[0]);for(const a of r)if(a in Bt){i=a;break}return this.typeLookupTable[t]=i,i}convertNodeToGeometryData(e){switch(this.getSpeckleType(e)){case Bt.BlockInstance:return this.BlockInstanceToGeometryData(e);case Bt.Pointcloud:return this.PointcloudToGeometryData(e);case Bt.Brep:return this.BrepToGeometryData(e);case Bt.Mesh:return this.MeshToGeometryData(e);case Bt.Point:return this.PointToGeometryData(e);case Bt.Line:return this.LineToGeometryData(e);case Bt.Polyline:return this.PolylineToGeometryData(e);case Bt.Box:return this.BoxToGeometryData(e);case Bt.Polycurve:return this.PolycurveToGeometryData(e);case Bt.Curve:return this.CurveToGeometryData(e);case Bt.Circle:return this.CircleToGeometryData(e);case Bt.Arc:return this.ArcToGeometryData(e);case Bt.Ellipse:return this.EllipseToGeometryData(e);case Bt.View3D:return this.View3DToGeometryData(e);case Bt.RevitInstance:return this.RevitInstanceToGeometryData(e);case Bt.Text:return this.TextToGeometryData(e);case Bt.Transform:return this.TransformToGeometryData(e);case Bt.InstanceProxy:return this.InstanceProxyToGeometyData(e);case Bt.Region:return this.RegionGeometyData(e);case Bt.Unknown:default:return null}}disposeNodeGeometryData(e){switch(this.getSpeckleType(e)){case Bt.Pointcloud:e.raw.vertices=[],e.raw.colors=[];break;case Bt.Mesh:e.raw.vertices=[],e.raw.faces=[],e.raw.colors=[];break;case Bt.Point:e.raw.value?e.raw.value=[]:(delete e.raw.x,delete e.raw.y,delete e.raw.z);break;case Bt.Line:e.raw.start.value?e.raw.start.value=[]:(delete e.raw.start.x,delete e.raw.start.y,delete e.raw.start.z),e.raw.end.value?e.raw.end.value=[]:(delete e.raw.end.x,delete e.raw.end.y,delete e.raw.end.z);break;case Bt.Polyline:e.raw.value=[]}}View3DToGeometryData(e){const t=this.PointToVector3(e.raw.origin),n=this.PointToVector3(e.raw.target);return e.raw.origin=t,e.raw.target=n,{attributes:null,bakeTransform:null,transform:null}}TransformToGeometryData(e){const t=Qn(e.raw.units),n=e.raw.value?e.raw.value:e.raw.matrix,i=new Ne().fromArray(n).transpose();return{attributes:null,bakeTransform:null,transform:new Ne().makeScale(t,t,t).multiply(i).multiply(new Ne().makeScale(1/t,1/t,1/t))}}BlockInstanceToGeometryData(e){return null}RevitInstanceToGeometryData(e){return null}InstanceProxyToGeometyData(e){return null}PointcloudToGeometryData(e){const t=Qn(e.raw.units),n=e.instanced?e.raw.points.slice():e.raw.points,i=e.raw.colors;let r=null;return i&&i.length!==0&&(i.length!==n.length/3&&dt.warn(`Mesh (id ${e.raw.id}) colours are mismatched with vertice counts. The number of colours must equal the number of vertices.`),r=this.unpackColors(i,!0)),{attributes:{POSITION:n,COLOR:r},bakeTransform:new Ne().makeScale(t,t,t),transform:null}}BrepToGeometryData(e){return null}RegionGeometyData(e){return null}MeshToGeometryData(e){if(!e.raw)return null;const t=Qn(e.raw.units),n=[];if(!e.raw.vertices||!e.raw.faces)return null;const i=performance.now(),r=e.raw.vertices,a=e.raw.faces,o=e.raw.colors;let l,c=e.raw.vertexNormals,u=0;for(;u<a.length;){let h=a[u];if(h<3&&(h+=3),h===3){const d=performance.now();n.push(a[u+1],a[u+2],a[u+3]),this.pushTime+=performance.now()-d}else{const d=performance.now(),f=Tz.triangulateFace(u,a,r);this.actualTriangulateTime+=performance.now()-d,n.push(...f.filter(v=>v!==void 0))}u+=h+1}return this.meshTriangulationTime+=performance.now()-i,o&&o.length!==0&&(o.length!==r.length/3?dt.warn(`Mesh (id ${e.raw.id}) colours are mismatched with vertice counts. The number of colours must equal the number of vertices.`):l=this.unpackColors(o,!0)),c&&c.length!==0?c.length!==r.length&&(dt.warn(`Mesh (id ${e.raw.id}) normals are mismatched with vertice counts. The number of normals must equal the number of vertices.`),c=void 0):c=void 0,{attributes:{POSITION:r,INDEX:n,...l&&{COLOR:l},...c&&{NORMAL:c}},bakeTransform:new Ne().makeScale(t,t,t),transform:null,...e.instanced&&{instanced:!0}}}TextToGeometryData(e){const t=Qn(e.raw.units),n=e.raw.plane||{origin:e.raw.origin,xdir:new T(1,0,0),ydir:new T(0,1,0),normal:new T(0,0,1)},i=new T(n.origin.x,n.origin.y,n.origin.z),r=new Ne().makeScale(t,t,t),a=new Ne().makeBasis(n.xdir,n.ydir,n.normal);return a.setPosition(i),a.premultiply(r),{attributes:null,bakeTransform:a,transform:null,metaData:e.raw}}PointToGeometryData(e){const t=Qn(e.raw.units);return{attributes:{POSITION:this.PointToFloatArray(e.raw)},bakeTransform:new Ne().makeScale(t,t,t),transform:null}}LineToGeometryData(e){const t=Qn(e.raw.units);return{attributes:{POSITION:this.PointToFloatArray(e.raw.start).concat(this.PointToFloatArray(e.raw.end))},bakeTransform:new Ne().makeScale(t,t,t),transform:null}}PolylineToGeometryData(e){const t=Qn(e.raw.units);return e.raw.closed&&e.raw.value.push(e.raw.value[0],e.raw.value[1],e.raw.value[2]),{attributes:{POSITION:e.raw.value.slice(0)},bakeTransform:new Ne().makeScale(t,t,t),transform:null}}BoxToGeometryData(e){const t=Qn(e.raw.units),n=new Ne,i=new Ne;if(e.raw.basePlane){n.setPosition(this.PointToVector3(e.raw.basePlane.origin));const c=1e-7,u=new T().copy(e.raw.basePlane.xdir),h=new T().copy(e.raw.basePlane.ydir),d=new T().copy(e.raw.basePlane.normal);Math.abs(u.dot(h))<c&&Math.abs(u.dot(d))<c&&Math.abs(h.dot(d))<c?i.makeBasis(e.raw.basePlane.xdir,e.raw.basePlane.ydir,e.raw.basePlane.normal):dt.warn(`Box ${e.raw.id} does not have orthogonal base plane vectors`)}else dt.warn(`Box ${e.raw.id} is missing it's base plane`);const r=(e.raw.xSize.end-e.raw.xSize.start)*t,a=(e.raw.ySize.end-e.raw.ySize.start)*t,o=(e.raw.zSize.end-e.raw.zSize.start)*t,l=new Tt(new T(.5*-r,.5*-a,.5*-o),new T(.5*r,.5*a,.5*o));return{attributes:{POSITION:[l.min.x,l.min.y,l.min.z,l.min.x,l.max.y,l.min.z,l.min.x,l.min.y,l.max.z,l.min.x,l.max.y,l.max.z,l.min.x,l.min.y,l.min.z,l.min.x,l.min.y,l.max.z,l.min.x,l.max.y,l.min.z,l.min.x,l.max.y,l.max.z,l.max.x,l.min.y,l.min.z,l.max.x,l.max.y,l.min.z,l.max.x,l.min.y,l.max.z,l.max.x,l.max.y,l.max.z,l.max.x,l.min.y,l.min.z,l.max.x,l.min.y,l.max.z,l.max.x,l.max.y,l.min.z,l.max.x,l.max.y,l.max.z,l.max.x,l.min.y,l.max.z,l.min.x,l.min.y,l.max.z,l.max.x,l.min.y,l.min.z,l.min.x,l.min.y,l.min.z,l.max.x,l.max.y,l.max.z,l.min.x,l.max.y,l.max.z,l.max.x,l.max.y,l.min.z,l.min.x,l.max.y,l.min.z]},bakeTransform:new Ne().copy(n).multiply(i),transform:null}}PolycurveToGeometryData(e){if(!e.nestedNodes||e.nestedNodes.length===0)return null;const t=[];for(let n=0;n<e.nestedNodes.length;n++){const i=e.nestedNodes[n].model,r=this.convertNodeToGeometryData(i);t.push(r)}return hn.mergeGeometryData(t)}CurveToGeometryData(e){if(!e.nestedNodes||e.nestedNodes.length===0)return null;const t=this.PolylineToGeometryData(e.nestedNodes[0].model);return t&&t.attributes?{attributes:{POSITION:t.attributes.POSITION},bakeTransform:t.bakeTransform,transform:null}:null}CircleToGeometryData(e){const t=Qn(e.raw.units),n=.1*t,i=this.getCircularCurvePoints(e.raw.plane,e.raw.radius*t,void 0,void 0,n);return{attributes:{POSITION:this.FlattenVector3Array(i)},bakeTransform:null,transform:null}}ArcToGeometryData(e){const t=new T(e.raw.plane.origin.x,e.raw.plane.origin.y,e.raw.plane.origin.z),n=new T(e.raw.startPoint.x,e.raw.startPoint.y,e.raw.startPoint.z),i=new T(e.raw.endPoint.x,e.raw.endPoint.y,e.raw.endPoint.z),r=new T(e.raw.midPoint.x,e.raw.midPoint.y,e.raw.midPoint.z),a=new T().subVectors(n,r).normalize(),o=new T().subVectors(i,r).normalize(),l=a.dot(o)>0,c=new T().subVectors(n,t);c.normalize();const u=new T().subVectors(i,t);u.normalize();const h=new T().crossVectors(c,u);if(h.normalize(),h.length()===0){const C=new T().subVectors(r,t);C.normalize(),h.copy(new T().crossVectors(c,C)),h.normalize()}const d=new T().crossVectors(h,c);d.normalize();const f=Math.min(Math.max(c.dot(u),-1),1),v=Math.acos(f),g=e.raw.radius,m=new Mh(0,0,g,g,0,v,l,0).getPoints(50),x=new Ne,w=Qn(e.raw.plane.units),S=new Ne().makeBasis(c,d,h),b=new Ne().setPosition(t.multiplyScalar(w));x.multiply(b).multiply(S);const E=new Ne().scale(new T(w,w,w));return x.multiply(E),{attributes:{POSITION:this.FlattenVector3Array(m)},bakeTransform:x,transform:null}}EllipseToGeometryData(e){const t=Qn(e.raw.units),n=new T(e.raw.plane.origin.x,e.raw.plane.origin.y,e.raw.plane.origin.z).multiplyScalar(t),i=new T(e.raw.plane.xdir.x,e.raw.plane.xdir.y,e.raw.plane.xdir.z).normalize(),r=new T(e.raw.plane.ydir.x,e.raw.plane.ydir.y,e.raw.plane.ydir.z).normalize();let a=2*Math.PI*e.raw.firstRadius*t*10;a=parseInt(a.toString());const o=[];for(let l=0;l<=a;l++){const c=l*Math.PI*2/a,u=Math.cos(c)*e.raw.firstRadius*t,h=Math.sin(c)*e.raw.secondRadius*t,d=new T(i.x*u,i.y*u,i.z*u),f=new T(r.x*h,r.y*h,r.z*h),v=new T().addVectors(d,f).add(n);o.push(v)}return{attributes:{POSITION:this.FlattenVector3Array(o)},bakeTransform:null,transform:null}}getCircularCurvePoints(e,t,n=0,i=2*Math.PI,r=.1){const a=this.PointToVector3(e.origin),o=this.PointToVector3(e.xdir),l=this.PointToVector3(e.ydir);o.normalize(),l.normalize();let c=(i-n)*t/r;c=parseInt(c.toString());const u=[];for(let h=0;h<=c;h++){const d=n+h*(i-n)/c,f=Math.cos(d)*t,v=Math.sin(d)*t,g=new T(o.x*f,o.y*f,o.z*f),m=new T(l.x*v,l.y*v,l.z*v),x=new T().addVectors(g,m).add(a);u.push(x)}return u}PointToVector3(e,t=!0){const n=t?Qn(e.units):1;let i=null;return i=e.value?new T(e.value[0]*n,e.value[1]*n,e.value[2]*n):new T(e.x*n,e.y*n,e.z*n),i}PointToFloatArray(e){return e.value?[e.value[0],e.value[1],e.value[2]]:[e.x,e.y,e.z]}FlattenVector3Array(e){const t=new Array(3*e.length),n=[];for(let i=0,r=0;i<e.length;i++,r+=3)e[i].toArray(n),t[r]=n[0],t[r+1]=n[1],t[r+2]=n[2]?n[2]:0;return t}unpackColors(e,t=!1){const n=new Array(3*e.length);for(let i=0;i<e.length;i++){const r=e[i],a=r>>16&255,o=r>>8&255,l=255&r;n[3*i]=a/255,n[3*i+1]=o/255,n[3*i+2]=l/255,t&&(n[3*i]=this.srgbToLinear(n[3*i]),n[3*i+1]=this.srgbToLinear(n[3*i+1]),n[3*i+2]=this.srgbToLinear(n[3*i+2]))}return n}srgbToLinear(e){return e<=0?0:e>=1?1:e<.04045?e/12.92:Math.pow((e+.055)/1.055,2.4)}}class Mz extends Az{get resource(){return this._resource}get finished(){return this.isFinished}constructor(e,t,n,i,r){super(t,r),this.isCancelled=!1,this.isFinished=!1,this.tree=e;try{this.loader=this.initObjectLoader(t,n,i,r)}catch(a){return void dt.error(a)}this.converter=new bz(this.loader,this.tree)}initObjectLoader(e,t,n,i){let r;try{r=t||localStorage.getItem("AuthToken")}catch{}r||dt.error("Viewer: no auth token present. Requests to non-public stream objects will fail.");const a=new URL(e),o=a.pathname.split("/");if(o.length<5||a.pathname.indexOf("streams")===-1||a.pathname.indexOf("objects")===-1)throw new Error("Unexpected object url format.");const l=a.origin,c=o[2],u=o[4];return Sv.createFromUrl({serverUrl:l,streamId:c,objectId:u,token:r})}async load(){const e=performance.now();let t=!0,n=0;const i=await this.loader.getTotalObjectCount();let r=0,a=null;dt.warn("Downloading object ",this.resource);for await(const h of this.loader.getObjectIterator()){if(this.isCancelled)return this.emit(Iu.LoadCancelled,this.resource),Promise.resolve(!1);t&&(a=this.converter.traverse(this.resource,h,async()=>{r++}),t=!1),n++,this.emit(Iu.LoadProgress,{progress:n/(i+1),id:this.resource})}if(a&&await a,dt.warn(`Finished converting object ${this.resource} in ${(performance.now()-e)/Oh.second} seconds. Node count: ${this.tree.nodeCount}`),r===0&&(dt.warn(`Viewer: no 3d objects found in object ${this.resource}`),this.emit(Iu.LoadWarning,{message:`No displayable objects found in object ${this.resource}.`})),this.isCancelled)return Promise.resolve(!1);await this.converter.convertInstances(),await this.converter.applyMaterials(),await this.loader.disposeAsync();const o=performance.now(),l=new Ez,c=this.tree.getRenderTree(this.resource);if(!c)return Promise.resolve(!1);const u=c.buildRenderTree(l);return u.then(()=>{dt.log("ASYNC Tree build time -> ",performance.now()-o),dt.log("Node build time -> ",c.buildNodeTime),dt.log("Apply transform time -> ",c.applyTransformTime),dt.log("Geometry build time -> ",c.convertTime),dt.log("Get Node time -> ",c.getNodeTime),dt.log("Other time -> ",c.otherTime),dt.log("Triangulation time -> ",l.meshTriangulationTime),dt.log("ACTUAL Triangulation time -> ",l.actualTriangulateTime),dt.log("Push time -> ",l.pushTime),this.isFinished=!0}),u}cancel(){this.isCancelled=!0,this.isFinished=!1}dispose(){super.dispose(),this.loader.disposeAsync()}}(function(s){s[s.PLAIN=0]="PLAIN",s[s.COLORED=1]="COLORED"})(xS||(xS={}));var Ev;(function(s){s[s.Color=0]="Color",s[s.PackedDepth=1]="PackedDepth",s[s.Normals=2]="Normals",s[s.Passthrough=3]="Passthrough"})(Ev||(Ev={}));Ev.Passthrough;var wS,SS;(function(s){s[s.DEFAULT=0]="DEFAULT",s[s.SOLID=1]="SOLID",s[s.PEN=2]="PEN",s[s.ARCTIC=3]="ARCTIC",s[s.SHADED=4]="SHADED"})(wS||(wS={})),function(s){s.Changed="view-mode-changed"}(SS||(SS={}));new Ne;new Ne;new Ne;const Cz=[-.5,-.5,-.5,.5,-.5,-.5,.5,-.5,-.5,.5,.5,-.5,.5,.5,-.5,-.5,.5,-.5,-.5,.5,-.5,-.5,-.5,-.5,-.5,-.5,.5,.5,-.5,.5,.5,-.5,.5,.5,.5,.5,.5,.5,.5,-.5,.5,.5,-.5,.5,.5,-.5,-.5,.5,-.5,-.5,-.5,-.5,-.5,.5,.5,-.5,.5,.5,-.5,-.5,.5,.5,.5,.5,.5,-.5,-.5,.5,.5,-.5,.5,-.5];new Array(Cz.length);new Array(12);async function bS(s,e){const t={"Content-Type":"application/json",Authorization:""};e&&(t.Authorization=`Bearer ${e}`);const n=await fetch(`${s.origin}/graphql`,{method:"POST",headers:t,body:JSON.stringify({query:`
          query Stream($streamId: String!, $commitId: String!) {
            stream(id: $streamId) {
              commit(id: $commitId) {
                referencedObject
              }
            }
          }
        `,variables:{streamId:s.streamId,commitId:s.commitId}})}),{data:i}=await n.json();return`${s.origin}/streams/${s.streamId}/objects/${i.stream.commit.referencedObject}`}async function Rz(s,e){return Promise.resolve(`${s.origin}/streams/${s.projectId}/objects/${e.toString()}`)}async function Iz(s,e,t){return t.versionId?async function(n,i,r){const a=await fetch(`${i.origin}/graphql`,{method:"POST",headers:n,body:JSON.stringify({query:`
          query ViewerUrlHelperModelVersion($modelId: String!, $projectId: String!, $versionId: String!) {
            project(id: $projectId) {
              model(id: $modelId) {
                version(id: $versionId) {
                  referencedObject
                }
              }
            }
          }
        `,variables:{projectId:i.projectId,modelId:r.modelId,versionId:r.versionId}})});try{const o=await Mv(a);return`${i.origin}/streams/${i.projectId}/objects/${o.project.model.version.referencedObject}`}catch(o){return Promise.reject(new Error(`Could not get object URLs for project ${i.projectId} and model ${r.modelId}. Error: ${o instanceof Error?o.message:o}`))}}(s,e,t):async function(n,i,r){const a=await fetch(`${i.origin}/graphql`,{method:"POST",headers:n,body:JSON.stringify({query:`
          query ViewerUrlHelperModelLastVersion($modelId: String!, $projectId: String!) {
            project(id: $projectId) {
              model(id: $modelId) {
                versions(limit: 1) {
                  items {
                    referencedObject
                  }
                }
              }
            }
          }
        `,variables:{projectId:i.projectId,modelId:r.modelId}})});try{const o=await Mv(a);return`${i.origin}/streams/${i.projectId}/objects/${o.project.model.versions.items[0].referencedObject}`}catch(o){return Promise.reject(new Error(`Could not get object URLs for project ${i.projectId} and model ${r.modelId}. Error: ${o instanceof Error?o.message:o}`))}}(s,e,t)}async function Pz(s,e){return async function(t,n){const i=await fetch(`${n.origin}/graphql`,{method:"POST",headers:t,body:JSON.stringify({query:`
         query ViewerUrlHelperAllModel($projectId: String!) {
          project(id: $projectId) {
            models {
              items {
                versions(limit: 1) {
                  items {
                    referencedObject
                  }
                }
              }
            }
          }
        }
        `,variables:{projectId:n.projectId}})});try{const r=await Mv(i),a=[];return r.project.models.items.forEach(o=>{a.push(`${n.origin}/streams/${n.projectId}/objects/${o.versions.items[0].referencedObject}`)}),a}catch(r){return Promise.reject(new Error(`Could not get object URLs for project ${n.projectId}. Error: ${r instanceof Error?r.message:r}`))}}(s,e)}async function Mv(s){const{data:e}=await s.json();if(!e)throw new Error("Query failed");if(!e.project)throw new Error("Project not found");if(!e.project.model&&!e.project.models)throw new Error("Model(s) not found");return e}var Dz=Object.freeze({__proto__:null,getResourceUrls:async function(s,e){return s.includes("streams")?async function(t,n){var i;const r=new URL(t),a=t.split("/streams/")[1].substring(0,10),o=[];if(t.includes("commits")){const l=t.split("/commits/")[1].substring(0,10),c=await bS({origin:r.origin,streamId:a,commitId:l},n);o.push(c)}if(t.includes("objects")&&o.push(t),t.includes("overlay=")){const l=(i=new URLSearchParams(r.search).get("overlay"))===null||i===void 0?void 0:i.split(",");if(l!==void 0)for(const c of l)c.length===10?o.push(await bS({origin:r.origin,streamId:a,commitId:c},n)):o.push(`${r.origin}/streams/${a}/objects/${c}`)}return o}(s,e):async function(t,n){const i=new URL(decodeURI(t)),r=i.href.match(/[^/]+$/);if(!r)return Promise.reject(new Error("No model or object ids specified"));const a=i.href.split("/projects/")[1].substring(0,10),o={"Content-Type":"application/json",Authorization:""};n&&(o.Authorization=`Bearer ${n}`);const l={origin:i.origin,projectId:a},c=HO(decodeURIComponent(r[0])),u=[];for(let h=0;h<c.length;h++){const d=c[h];jO(d)?u.push(Rz(l,d)):qO(d)?u.push(Iz(o,l,d)):WO(d)&&u.push(Pz(o,l))}try{return(await Promise.all(u)).flatMap(h=>Array.isArray(h)?h:[h])}catch(h){return dt.error(h),[]}}(s,e)}});window.startSpeckleViewer=Lz;async function Lz(s,e=""){const t=document.getElementById("renderer"),n=pA;n.verbose=!0;const i=new FA(t,n);await i.init(),i.createExtension(Zu),i.createExtension(wz);const r=await Dz.getResourceUrls(s,e);for(const a of r){const o=new Mz(i.getWorldTree(),a,e);await i.loadObject(o,!0)}}});export default Bz();
